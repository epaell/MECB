MECB_IO         EQU     $E000
;
; Motorola 6840 PTM (Programmable Timer Module)
;
PTM             EQU     MECB_IO
PTM_CR13        EQU     PTM         ; Write: Timer Control Registers 1 & 3   Read: NOP
PTM_SR          EQU     PTM+1
PTM_CR2         EQU     PTM+1       ; Write: Control Register 2              Read: Status Register (least significant bit selects TCR as TCSR1 or TCSR3)
;
PTM_T1MSB       EQU     PTM+2       ; Write: MSB Buffer Register             Read: Timer 1 Counter
PTM_T1LSB       EQU     PTM+3       ; Write: Timer #1 Latches                Read: LSB Buffer Register
;
PTM_T2MSB       EQU     PTM+4       ; Write: MSB Buffer Register             Read: Timer 1 Counter
PTM_T2LSB       EQU     PTM+5       ; Write: Timer #1 Latches                Read: LSB Buffer Register
;
PTM_T3MSB       EQU     PTM+6       ; Write: MSB Buffer Register             Read: Timer 1 Counter
PTM_T3LSB       EQU     PTM+7       ; Write: Timer #1 Latches                Read: LSB Buffer Register
;
; Motorola 6850 ACIA
;
ACIA            EQU     MECB_IO+$08 ; Location of ACIA
ACIA_STATUS     EQU     ACIA        ; Status
ACIA_CONTROL    EQU     ACIA        ; Control
ACIA_DATA       EQU     ACIA+1      ; Data
;
CR              EQU     $0D         ; Carriage return
LF              EQU     $0A         ; Linefeed
;
; SMON IQR
;
IRQ_LO          EQU     $0314         ; Vector: Hardware IRQ Interrupt Address Lo
IRQ_HI          EQU     $0315         ; Vector: Hardware IRQ Interrupt Address Hi
;
                ORG     $1000
;
start           ldx     #<isr       ; Set up IRQ vector in SMON
                stx     IRQ_LO
                ldx     #>isr
                stx     IRQ_HI
;
                lda     #$03        ; Initialise the ACIA
                sta     ACIA_CONTROL
                lda     #$15
                sta     ACIA_CONTROL
;
                lda     #CR
                jsr     outch       ; Write a newline to indicate program started
                lda     #LF
                jsr     outch
;
                jsr     ptm_init    ; Initialise the PTM
                cli                 ; Enable interrupts
                ldx     seconds
loop            cpx     seconds     ; check for a change
                beq     loop
                ldx     seconds
                lda     #CR         ; go to start of line to over-write updated time
                jsr     outch
                lda     weeks
                jsr     outd
                lda     #' '
                jsr     outch
                lda     dayofweek
                jsr     outd
                lda     #' '
                jsr     outch
                lda     hours
                jsr     out02d
                lda     #':'
                jsr     outch
                lda     minutes
                jsr     out02d
                lda     #':'
                jsr     outch
                lda     seconds
                jsr     out02d
                jmp     loop        ; Infinite loop
;
;
; Subroutine to initialise the PTM for continuous mode with interrupts generated by timer 1
;
ptm_init        lda     timer_MSB   ; Set up the countdown timer for timer 1
                sta     PTM_T1MSB   ; MSB must be written first!
                lda     timer_LSB
                sta     PTM_T1LSB
;
                lda     #10         ; reset the ongoing counter
                sta     ten_ms
                lda     #100
                sta     ticks
                stz     seconds
                stz     minutes
                stz     hours
                stz     dayofweek
                stz     weeks
;
                lda     #$01        ; Preset all timers
                sta     PTM_CR2     ; Write to CR1
                lda     #$42        ; CRX6=1 (interrupt); CRX1=1 (enable clock)
                sta     PTM_CR13
                lda     #$00
                sta     PTM_CR2
;
                lda     PTM_SR      ; Read the interrupt flag from the status register
;
                rts 
;
ten_ms          ds.b    1
ticks           ds.b    1
seconds         ds.b    1
minutes         ds.b    1
hours           ds.b    1
dayofweek       ds.b    1
weeks           ds.b    1
;
;timer_LSB       dc.b    $E7          ; 1 mS at 1 MHz
;timer_MSB       dc.b    $03
timer_LSB       dc.b    $9C           ; 1 mS at 4 Mhz
timer_MSB       dc.b    $0F
;
isr             ;pha                 ; Note: Registers already pushed on stack by SMON
                ;txa
                ;pha
                ;tya
                ;pha
;
isr_timer       lda     PTM_SR      ; Read the interrupt flag from the status register
                bpl     isr_other   ; Something else caused the interrupt
                
                ror                 ; rotate bit 0 to carry flag
                bcs     isr_t1      ; if set, handle timer 1 interrupt
                ror
                bcs     isr_t2      ; handle timer 2 interrupt
                ror
                bcs     isr_t3      ; handle timer 3 interrupt
                bra     isr_other   ; shouldn't really get here
;
isr_t1          dec     ten_ms
                bne     isr_t1done
;
                lda     #10
                sta     ten_ms
                dec     ticks
                bne     isr_t1done
;
                lda     #100
                sta     ticks
                inc     seconds
                lda     seconds
                cmp     #60
                bne     isr_t1done
                stz     seconds
                inc     minutes
                lda     minutes
                cmp     #60
                bne     isr_t1done

                stz     minutes
                inc     hours
                lda     hours
                cmp     #24
                bne     isr_t1done
                
                stz     hours
                inc     dayofweek
                lda     dayofweek
                cmp     #7
                bne     isr_t1done

                stz     dayofweek
                inc     weeks       ; will count up to 4.923 years!
;
isr_t1done      lda     PTM_T1MSB   ; clear interrupt flag for T1
                bra     isr_timer   ; check other timers
;
isr_t2          lda     PTM_T2MSB   ; clear interrupt flag for T2
                bra     isr_timer
;
isr_t3          lda     PTM_T3MSB   ; clear interrupt flag for T3
                bra     isr_done
;
isr_other                           ; If get here something else caused the interrupt (ACIA, PIA, etc)
;
isr_done        pla                 ; Restore registers that were previously pushed on stack by SMON
                tay
                pla
                tax
                pla
                rti
;
; write character to the ACIA, wait until ACIA is ready to transmit
; A, X and Y registers preserved
;
outch           pha                 ; save character
outchw          lda     ACIA_STATUS ; check ACIA status
                and     #$02        ; can write?
                beq     outchw      ; wait if not
                pla                 ; restore character
                sta     ACIA_DATA   ; write character
                rts
;
; output data byte in A as HEX (A is destroyed)
;
out2h           pha                 ; Save A
                lsr                 ; Get upper digit
                lsr
                lsr
                lsr
                jsr     outh        ; Output a hex digit
                pla                 ; Restore A
                and     #$0F
outh            cmp     #$0A        ; Is it a number
                bcc     outnum
                adc     #$06        ; Convert to letter
outnum          adc     #$30        ; Add '0'
                jmp     outch       ; write character
;
; Comnvert binary byte in A as a decimal with leading zeros
;
binary          ds.b    1
hundredsDigit   ds.b    1
tensDigit       ds.b    1
onesDigit       ds.b    1
eotDigit        dc.b    $00
;
outsLSB         ds.b    1
outsMSB         ds.b    1
;
;
; Output binary in A as 3-digit decimal value
;
outd            pha                     ; save A
                jsr     bin2dec         ; convert to decimal
                lda     hundredsDigit
                beq     outd1
                adc     #'0'
                jsr     outch
outd1           lda     tensDigit
                beq     outd2
                adc     #'0'
                jsr     outch
outd2           lda     onesDigit
                adc     #'0'
                jsr     outch
                pla                     ; restore A
                rts
;
; Output binary in A as 2-digit decimal value with leading 0
;
out02d          pha                     ; Save A
                jsr     bin2dec         ; convert to decimal
                lda     tensDigit       ; convert to ASCII
                adc     #'0'
                jsr     outch
                lda     onesDigit
                adc     #'0'
                jsr     outch
                pla
                rts
;
; Convert binary in A into 3-digit decimal value
;
bin2dec         sta     binary
                lda     #$00
                sta     hundredsDigit   ; Reset the result
                sta     tensDigit
                sta     onesDigit
HundredsLoop    lda     binary
                cmp     #100             ; compare binary to 100
                bcc     TensLoop         ; if binary < 100, all done with hundreds digit
                lda     binary
                sec
                sbc     #100
                sta     binary           ; subtract 100, store whats left
                inc     hundredsDigit    ; increment the digital result
                jmp     HundredsLoop     ; run the hundreds loop again
TensLoop        lda     binary
                cmp     #10              ; compare binary to 10
                bcc     OnesLoop         ; if binary < 10, all done with hundreds digit
                lda     binary
                sec
                sbc     #10
                sta     binary           ; subtract 10, store whats left
                inc     tensDigit        ; increment the digital result
                jmp     TensLoop         ; run the tens loop again
OnesLoop        lda     binary
                sta     onesDigit        ; result is already under 10, can copy directly to result
                rts
;
outd8zA         dc.b    128,160,200
outd8zB         ds.b    1
