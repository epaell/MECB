Sections:
00: "seg0" (0-804)
01: "seg200000" (200000-207904)


Source: "src/combo_68k.asm"
                            	     1: * THIS VERSION MODIFIED FOR TEESSIDE X68K PC-2.2 CROSS ASSEMBLER
                            	     2: *     ftp://nyquist.ee.ualberta.ca/pub/motorola/m68k/x68k.zip
                            	     3: *
                            	     4: *     CHANGES FROM ORIGINAL MOTOROLA SOURCE:
                            	     5: *         MANY "MOVE.L" CHANGED TO "MOVEQ"
                            	     6: *             SIMILAR CHANGES ON A FEW OTHER COMMANDS WHERE
                            	     7: *             X68K DOES NOT AUTOMATICALLY MOTOROLA-IZE.
                            	     8: *         X68K HANDLES CHARACTER CONSTANTS DIFFERENTLY
                            	     9: *             DC.W  '1'    -->  $3100  (GOOD)
                            	    10: *             DC.W  '1'+0  -->  $0031  (WHAT!)
                            	    11: *     ONE DIFFERENCE REMAINS IN A "DON'T CARE" BYTE
                            	    12: *         $008FE0 1A3C00FF  MOVE.B  #-1,D5
                            	    13: *                     ^^ $00 INSTEAD OF $FF
                            	    14: * SUBSEQUENTLY MODIFIED FOR USE ON DIGICOOL THING MECB 68008 (EMULATED)
                            	    15: 
                            	    16: *=======================================================================*
                            	    17: * MOTOROLA EDUCATION COMPUTER BOARD ROM PROGRAM "TUTOR"  REVISION # 1.3 *
                            	    18: *=======================================================================*
                            	    19: 
                            	    20: * MACROS
                            	    21: 
                            	    22: 
                            	    23: ADDR2MEM MACRO
                            	    24:          PEA     \1(PC)         MOVE ADDRESS TO MEMORY; POSITION
                            	    25:          MOVE.L  (A7)+,\2       INDEPENDANT = TO "MOVE.L #\1,\2"
                            	    26:          ENDM
                            	    27: 
                            	    28: 
                            	    29: SAVEREGS MACRO
                            	    30:          MOVE.L  A7,REGA7       SAVE STACK POINTER
                            	    31:          LEA     SV\@(PC),A7    A7 = RETURN ADDRESS (FOR CALL TO SAVE)
                            	    32:          MOVE.L  A7,TEMP        TEMP = RETURN ADDRESS
                            	    33:          BRA     SAVE           BSR WITHOUT USING STACK
                            	    34: SV\@     DS      0
                            	    35:          ENDM
                            	    36: 
                            	    37: 
                            	    38: 
                            	    39: 
                            	    40: *-------------------------------------------------------------------------
                            	    41: 
                            	    42: RAM_START EQU   $0000
                            	    43: 
                            	    44: * EQUATES (in alphabetical order)
                            	    45: 
                            	    46: BELL     EQU     $07
                            	    47: BLANK    EQU     $20
                            	    48: BKPOINT  EQU     $4AFB
                            	    49: BUFFSIZE EQU     $80
                            	    50: BUFSIZE  EQU     80
                            	    51: CR       EQU     $0D
                            	    52: CTLD     EQU     $04
                            	    53: CTLH     EQU     $08
                            	    54: CTLW     EQU     $17
                            	    55: CTLX     EQU     $18
                            	    56: DEL      EQU     $7F
                            	    57: DELAYC1  EQU     $1000
                            	    58: EOT      EQU     $04
                            	    59: LF       EQU     $0A
                            	    60: LOCVARSZ EQU     16
                            	    61: RESET    EQU     $03            MASTER RESET FOR ACIA
                            	    62: 
                            	    63: LTIME    SET     205000         LONG TIMER 5 SEC @ 8 MHZ
                            	    64: STIME    SET     41000          SHORT TIMER  100 MLS @ 8 MHZ
                            	    65: 
                            	    66: PDI1     SET     $0F0000        PARALLEL PORT ADDRESS
                            	    67: PITCDDR  SET     $0F0009        PORT C DATA DIRECTION REGISTER
                            	    68: PITPCDR  SET     $0F0019        PORT C DATA REGISTER
                            	    69: PITTCR   SET     $0F0021        TIMER CONTROL REGISTER
                            	    70: PSTATUS  SET     $B             PRINTER STATUS
                            	    71: PBDATA   SET     3              PRINTER CONTROL--BUSY,PAPER,SELECT
                            	    72: PDATA    SET     1              PRINTER DATA
                            	    73: SER1     SET     $3C0008        TERMINAL
                            	    74: SER2     SET     $3C0008        SERIAL PORT2 ADDRESS
                            	    75: 
                            	    76: 
                            	    77: *-------------------------------------------------------------------------
                            	    78: * File ARAM      DATA VARIABLES                                   05/10/82
                            	    79: 
                            	    80: ****************************************************************
                            	    81: *  N O T E:  Ram locations:   starting at zero                 *
                            	    82: ****************************************************************
                            	    83: 
                            	    84:          ORG     RAM_START
                            	    85: 
                            	    86: *                               DEC HEX  DESCRIPTION
00:00000000 00000000        	    87:          DS.L    1              0   $00  AREA OVERLAID BY ROM SR
00:00000004 00000000        	    88:          DS.L    1              1   $01  AND PC
                            	    89: 
                            	    90: 
00:00000008 00000000        	    91: AV2      DS.L    1              2   $02  BUS ERROR            "BUS "
00:0000000C 00000000        	    92: AV3      DS.L    1              3   $03  ADDRESS ERROR        "ADDR"
00:00000010 00000000        	    93: AV4      DS.L    1              4   $04  ILL INSTRUCTION      "OPCO"
00:00000014 00000000        	    94:          DS.L    1              5   $05  DIVIDE BY ZERO       "DIV0"
00:00000018 00000000        	    95:          DS.L    1              6   $06  CHECK TRAP           "CHCK"
00:0000001C 00000000        	    96:          DS.L    1              7   $07  TRAP V               "TP V"
00:00000020 00000000        	    97: AV8      DS.L    1              8   $08  PRIVILEDGE VIOLATION "PRIV"
00:00000024 00000000        	    98: AV9      DS.L    1              9   $09  TRACE
00:00000028 00000000        	    99:          DS.L    1              10  $0A  1010 LINE EMULATION  "1010"
00:0000002C 00000000        	   100: AV11     DS.L    1              11  $0B  1111 LINE EMULATION  "1111"
00:00000030 00000000        	   101: AV12     DS.L    1              12  $0C  USED AS TEMPORARY STORAGE FOR VECTOR MSGS.
00:00000034 00000000        	   102:          DS.L    1              13  $0D  NOT USED
00:00000038 00000000        	   103:          DS.L    1              14  $0E
00:0000003C 00000000        	   104:          DS.L    1              15  $0F
00:00000040 00000000        	   105:          DS.L    1              16  $10
00:00000044 00000000        	   106:          DS.L    1              17  $11
00:00000048 00000000        	   107:          DS.L    1              18  $12
00:0000004C 00000000        	   108:          DS.L    1              19  $13
00:00000050 00000000        	   109:          DS.L    1              20  $14
00:00000054 00000000        	   110:          DS.L    1              21  $15
00:00000058 00000000        	   111:          DS.L    1              22  $16
00:0000005C 00000000        	   112:          DS.L    1              23  $17
00:00000060 00000000        	   113: AV24     DS.L    1              24  $18   0  AUTO VECTORS     "SPUR"
00:00000064 00000000        	   114:          DS.L    1              25  $19   1                   "AV#1"
00:00000068 00000000        	   115:          DS.L    1              26  $1A   2                   "AV#2"   TEST BUTTON
00:0000006C 00000000        	   116:          DS.L    1              27  $1B   3                   "AV#3"
00:00000070 00000000        	   117:          DS.L    1              28  $1C   4                   "AV#4"
00:00000074 00000000        	   118:          DS.L    1              29  $1D   5                   "AV#5"
00:00000078 00000000        	   119:          DS.L    1              30  $1E   6                   "AV#6"
00:0000007C 00000000        	   120: AV31     DS.L    1              31  $1F   7                   "AV#7   [ABORT BUTTON]
00:00000080 00000000        	   121:          DS.L    1              32  $20   TRAP  0             "UT 0"
00:00000084 00000000        	   122:          DS.L    1              33  $21   TRAP  1             "UT 1"
00:00000088 00000000        	   123:          DS.L    1              34  $22   TRAP  2             "UT 2"
00:0000008C 00000000        	   124:          DS.L    1              35  $23   TRAP  3             "UT 3"
00:00000090 00000000        	   125:          DS.L    1              36  $24   TRAP  4             "UT 4"
00:00000094 00000000        	   126:          DS.L    1              37  $25   TRAP  5             "UT 5"
00:00000098 00000000        	   127:          DS.L    1              38  $26   TRAP  6             "UT 6"
00:0000009C 00000000        	   128:          DS.L    1              39  $27   TRAP  7             "UT 7"
00:000000A0 00000000        	   129:          DS.L    1              40  $28   TRAP  8             "UT 8"
00:000000A4 00000000        	   130:          DS.L    1              41  $29   TRAP  9             "UT 9"
00:000000A8 00000000        	   131:          DS.L    1              42  $2A   TRAP 10             "UT A"
00:000000AC 00000000        	   132:          DS.L    1              43  $2B   TRAP 11             "UT B"
00:000000B0 00000000        	   133:          DS.L    1              44  $2C   TRAP 12             "UT C"
00:000000B4 00000000        	   134:          DS.L    1              45  $2D   TRAP 13             "UT D"
00:000000B8 00000000        	   135: AV46     DS.L    1              46  $2E   TRAP 14             "UT E"
00:000000BC 00000000        	   136: AV47     DS.L    1              47  $2F   TRAP 15             "UT F"
00:000000C0 00000000        	   137: AV48     DS.L    1              48  $30
00:000000C4 00000000        	   138:          DS.L    1              49  $31
00:000000C8 00000000        	   139:          DS.L    1              50  $32
00:000000CC 00000000        	   140:          DS.L    1              51  $33
00:000000D0 00000000        	   141:          DS.L    1              52  $34
00:000000D4 00000000        	   142:          DS.L    1              53  $35
00:000000D8 00000000        	   143:          DS.L    1              54  $36
00:000000DC 00000000        	   144:          DS.L    1              55  $37
00:000000E0 00000000        	   145:          DS.L    1              56  $38
00:000000E4 00000000        	   146:          DS.L    1              57  $39
00:000000E8 00000000        	   147:          DS.L    1              58  $3A
00:000000EC 00000000        	   148:          DS.L    1              59  $3B
00:000000F0 00000000        	   149:          DS.L    1              60  $3C
00:000000F4 00000000        	   150:          DS.L    1              61  $3D
00:000000F8 00000000        	   151:          DS.L    1              62  $3E
00:000000FC 00000000        	   152:          DS.L    1              63  $3F
00:00000100 00000000        	   153:          DS.L    1              64  $40
00:00000104 00000000        	   154:          DS.L    1              65  $41
00:00000108 00000000        	   155:          DS.L    1              66  $42
00:0000010C 00000000        	   156:          DS.L    1              67  $43
00:00000110 00000000        	   157:          DS.L    1              68  $44
00:00000114 00000000        	   158:          DS.L    1              69  $45
00:00000118 00000000        	   159:          DS.L    1              70  $46
00:0000011C 00000000        	   160:          DS.L    1              71  $47
00:00000120 00000000        	   161:          DS.L    1              72  $48
00:00000124 00000000        	   162:          DS.L    1              73  $49
00:00000128 00000000        	   163:          DS.L    1              74  $4A
00:0000012C 00000000        	   164:          DS.L    1              75  $4B
00:00000130 00000000        	   165:          DS.L    1              76  $4C
00:00000134 00000000        	   166:          DS.L    1              77  $4D
00:00000138 00000000        	   167:          DS.L    1              78  $4E
00:0000013C 00000000        	   168:          DS.L    1              79  $4F
00:00000140 00000000        	   169:          DS.L    1              80  $50
00:00000144 00000000        	   170:          DS.L    1              81  $51
00:00000148 00000000        	   171:          DS.L    1              82  $52
00:0000014C 00000000        	   172:          DS.L    1              83  $53
00:00000150 00000000        	   173:          DS.L    1              84  $54
00:00000154 00000000        	   174:          DS.L    1              85  $55
00:00000158 00000000        	   175:          DS.L    1              86  $56
00:0000015C 00000000        	   176:          DS.L    1              87  $57
00:00000160 00000000        	   177:          DS.L    1              88  $58
00:00000164 00000000        	   178:          DS.L    1              89  $59
00:00000168 00000000        	   179:          DS.L    1              90  $5A
00:0000016C 00000000        	   180:          DS.L    1              91  $5B
00:00000170 00000000        	   181:          DS.L    1              92  $5C
00:00000174 00000000        	   182:          DS.L    1              93  $5D
00:00000178 00000000        	   183:          DS.L    1              94  $5E
00:0000017C 00000000        	   184:          DS.L    1              95  $5F
00:00000180 00000000        	   185:          DS.L    1              96  $60
00:00000184 00000000        	   186:          DS.L    1              97  $61
00:00000188 00000000        	   187:          DS.L    1              98  $62
00:0000018C 00000000        	   188:          DS.L    1              99  $63
00:00000190 00000000        	   189:          DS.L    1              100  $64
00:00000194 00000000        	   190:          DS.L    1              101  $65
00:00000198 00000000        	   191:          DS.L    1              102  $66
00:0000019C 00000000        	   192:          DS.L    1              103  $67
00:000001A0 00000000        	   193:          DS.L    1              104  $68
00:000001A4 00000000        	   194:          DS.L    1              105  $69
00:000001A8 00000000        	   195:          DS.L    1              106  $6A
00:000001AC 00000000        	   196:          DS.L    1              107  $6B
00:000001B0 00000000        	   197:          DS.L    1              108  $6C
00:000001B4 00000000        	   198:          DS.L    1              109  $6D
00:000001B8 00000000        	   199:          DS.L    1              110  $6E
00:000001BC 00000000        	   200:          DS.L    1              111  $6F
00:000001C0 00000000        	   201:          DS.L    1              112  $70
00:000001C4 00000000        	   202:          DS.L    1              113  $71
00:000001C8 00000000        	   203:          DS.L    1              114  $72
00:000001CC 00000000        	   204:          DS.L    1              115  $73
00:000001D0 00000000        	   205:          DS.L    1              116  $74
00:000001D4 00000000        	   206:          DS.L    1              117  $75
00:000001D8 00000000        	   207:          DS.L    1              118  $76
00:000001DC 00000000        	   208:          DS.L    1              119  $77
00:000001E0 00000000        	   209:          DS.L    1              120  $78
00:000001E4 00000000        	   210:          DS.L    1              121  $79
00:000001E8 00000000        	   211:          DS.L    1              122  $7A
00:000001EC 00000000        	   212:          DS.L    1              123  $7B
00:000001F0 00000000        	   213:          DS.L    1              124  $7C
00:000001F4 00000000        	   214:          DS.L    1              125  $7D
00:000001F8 00000000        	   215:          DS.L    1              126  $7E
00:000001FC 00000000        	   216:          DS.L    1              127  $7F
00:00000200 00000000        	   217:          DS.L    1              128  $80
00:00000204 00000000        	   218:          DS.L    1              129  $81
00:00000208 00000000        	   219:          DS.L    1              130  $82
00:0000020C 00000000        	   220:          DS.L    1              131  $83
00:00000210 00000000        	   221:          DS.L    1              132  $84
00:00000214 00000000        	   222:          DS.L    1              133  $85
00:00000218 00000000        	   223:          DS.L    1              134  $86
00:0000021C 00000000        	   224:          DS.L    1              135  $87
00:00000220 00000000        	   225:          DS.L    1              136  $88
00:00000224 00000000        	   226:          DS.L    1              137  $89
00:00000228 00000000        	   227:          DS.L    1              138  $8A
00:0000022C 00000000        	   228:          DS.L    1              139  $8B
00:00000230 00000000        	   229:          DS.L    1              140  $8C
00:00000234 00000000        	   230:          DS.L    1              141  $8D
00:00000238 00000000        	   231:          DS.L    1              142  $8E
00:0000023C 00000000        	   232:          DS.L    1              143  $8F
00:00000240 00000000        	   233:          DS.L    1              144  $90
00:00000244 00000000        	   234:          DS.L    1              145  $91
00:00000248 00000000        	   235:          DS.L    1              146  $92
00:0000024C 00000000        	   236:          DS.L    1              147  $93
00:00000250 00000000        	   237:          DS.L    1              148  $94
00:00000254 00000000        	   238:          DS.L    1              149  $95
00:00000258 00000000        	   239:          DS.L    1              150  $96
00:0000025C 00000000        	   240:          DS.L    1              151  $97
00:00000260 00000000        	   241:          DS.L    1              152  $98
00:00000264 00000000        	   242:          DS.L    1              153  $99
00:00000268 00000000        	   243:          DS.L    1              154  $9A
00:0000026C 00000000        	   244:          DS.L    1              155  $9B
00:00000270 00000000        	   245:          DS.L    1              156  $9C
00:00000274 00000000        	   246:          DS.L    1              157  $9D
00:00000278 00000000        	   247:          DS.L    1              158  $9E
00:0000027C 00000000        	   248:          DS.L    1              159  $9F
00:00000280 00000000        	   249:          DS.L    1              160  $A0
00:00000284 00000000        	   250:          DS.L    1              161  $A1
00:00000288 00000000        	   251:          DS.L    1              162  $A2
00:0000028C 00000000        	   252:          DS.L    1              163  $A3
00:00000290 00000000        	   253:          DS.L    1              164  $A4
00:00000294 00000000        	   254:          DS.L    1              165  $A5
00:00000298 00000000        	   255:          DS.L    1              166  $A6
00:0000029C 00000000        	   256:          DS.L    1              167  $A7
00:000002A0 00000000        	   257:          DS.L    1              168  $A8
00:000002A4 00000000        	   258:          DS.L    1              169  $A9
00:000002A8 00000000        	   259:          DS.L    1              170  $AA
00:000002AC 00000000        	   260:          DS.L    1              171  $AB
00:000002B0 00000000        	   261:          DS.L    1              172  $AC
00:000002B4 00000000        	   262:          DS.L    1              173  $AD
00:000002B8 00000000        	   263:          DS.L    1              174  $AE
00:000002BC 00000000        	   264:          DS.L    1              175  $AF
00:000002C0 00000000        	   265:          DS.L    1              176  $B0
00:000002C4 00000000        	   266:          DS.L    1              177  $B1
00:000002C8 00000000        	   267:          DS.L    1              178  $B2
00:000002CC 00000000        	   268:          DS.L    1              179  $B3
00:000002D0 00000000        	   269:          DS.L    1              180  $B4
00:000002D4 00000000        	   270:          DS.L    1              181  $B5
00:000002D8 00000000        	   271:          DS.L    1              182  $B6
00:000002DC 00000000        	   272:          DS.L    1              183  $B7
00:000002E0 00000000        	   273:          DS.L    1              184  $B8
00:000002E4 00000000        	   274:          DS.L    1              185  $B9
00:000002E8 00000000        	   275:          DS.L    1              186  $BA
00:000002EC 00000000        	   276:          DS.L    1              187  $BB
00:000002F0 00000000        	   277:          DS.L    1              188  $BC
00:000002F4 00000000        	   278:          DS.L    1              189  $BD
00:000002F8 00000000        	   279:          DS.L    1              190  $BE
00:000002FC 00000000        	   280:          DS.L    1              191  $BF
00:00000300 00000000        	   281:          DS.L    1              192  $C0
00:00000304 00000000        	   282:          DS.L    1              193  $C1
00:00000308 00000000        	   283:          DS.L    1              194  $C2
00:0000030C 00000000        	   284:          DS.L    1              195  $C3
00:00000310 00000000        	   285:          DS.L    1              196  $C4
00:00000314 00000000        	   286:          DS.L    1              197  $C5
00:00000318 00000000        	   287:          DS.L    1              198  $C6
00:0000031C 00000000        	   288:          DS.L    1              199  $C7
00:00000320 00000000        	   289:          DS.L    1              200  $C8
00:00000324 00000000        	   290:          DS.L    1              201  $C9
00:00000328 00000000        	   291:          DS.L    1              202  $CA
00:0000032C 00000000        	   292:          DS.L    1              203  $CB
00:00000330 00000000        	   293:          DS.L    1              204  $CC
00:00000334 00000000        	   294:          DS.L    1              205  $CD
00:00000338 00000000        	   295:          DS.L    1              206  $CE
00:0000033C 00000000        	   296:          DS.L    1              207  $CF
00:00000340 00000000        	   297:          DS.L    1              208  $D0
00:00000344 00000000        	   298:          DS.L    1              209  $D1
00:00000348 00000000        	   299:          DS.L    1              210  $D2
00:0000034C 00000000        	   300:          DS.L    1              211  $D3
00:00000350 00000000        	   301:          DS.L    1              212  $D4
00:00000354 00000000        	   302:          DS.L    1              213  $D5
00:00000358 00000000        	   303:          DS.L    1              214  $D6
00:0000035C 00000000        	   304:          DS.L    1              215  $D7
00:00000360 00000000        	   305:          DS.L    1              216  $D8
00:00000364 00000000        	   306:          DS.L    1              217  $D9
00:00000368 00000000        	   307:          DS.L    1              218  $DA
00:0000036C 00000000        	   308:          DS.L    1              219  $DB
00:00000370 00000000        	   309:          DS.L    1              220  $DC
00:00000374 00000000        	   310:          DS.L    1              221  $DD
00:00000378 00000000        	   311:          DS.L    1              222  $DE
00:0000037C 00000000        	   312:          DS.L    1              223  $DF
00:00000380 00000000        	   313:          DS.L    1              224  $E0
00:00000384 00000000        	   314:          DS.L    1              225  $E1
00:00000388 00000000        	   315:          DS.L    1              226  $E2
00:0000038C 00000000        	   316:          DS.L    1              227  $E3
00:00000390 00000000        	   317:          DS.L    1              228  $E4
00:00000394 00000000        	   318:          DS.L    1              229  $E5
00:00000398 00000000        	   319:          DS.L    1              230  $E6
00:0000039C 00000000        	   320:          DS.L    1              231  $E7
00:000003A0 00000000        	   321:          DS.L    1              232  $E8
00:000003A4 00000000        	   322:          DS.L    1              233  $E9
00:000003A8 00000000        	   323:          DS.L    1              234  $EA
00:000003AC 00000000        	   324:          DS.L    1              235  $EB
00:000003B0 00000000        	   325:          DS.L    1              236  $EC
00:000003B4 00000000        	   326:          DS.L    1              237  $ED
00:000003B8 00000000        	   327:          DS.L    1              238  $EE
00:000003BC 00000000        	   328:          DS.L    1              239  $EF
00:000003C0 00000000        	   329:          DS.L    1              240  $F0
00:000003C4 00000000        	   330:          DS.L    1              241  $F1
00:000003C8 00000000        	   331:          DS.L    1              242  $F2
00:000003CC 00000000        	   332:          DS.L    1              243  $F3
00:000003D0 00000000        	   333:          DS.L    1              244  $F4
00:000003D4 00000000        	   334:          DS.L    1              245  $F5
00:000003D8 00000000        	   335:          DS.L    1              246  $F6
00:000003DC 00000000        	   336:          DS.L    1              247  $F7
00:000003E0 00000000        	   337:          DS.L    1              248  $F8
00:000003E4 00000000        	   338:          DS.L    1              249  $F9
00:000003E8 00000000        	   339:          DS.L    1              250  $FA
00:000003EC 00000000        	   340:          DS.L    1              251  $FB
00:000003F0 00000000        	   341:          DS.L    1              252  $FC
00:000003F4 00000000        	   342:          DS.L    1              253  $FD            3RD
00:000003F8 00000000        	   343:          DS.L    1              254  $FE            2ND
00:000003FC 00000000        	   344:          DS.L    1              255  $FF VECTOR FOR 1ST IPC DISK CONTROLLER
                            	   345: 
                            	   346: 
                            	   347: *  PSEUDO REGISTERS
                            	   348: 
00:00000400 00000000        	   349: REGPC    DS.L    1              USERS PROGRAM COUNTER
00:00000404 00000000        	   350: REGSR    DS.L    1              USERS CONDITION CODES
00:00000408 00000000        	   351: REGS     DS.L    8              D REGISTERS
00:0000040C *
00:00000428 00000000        	   352:          DS.L    7              A0 THROUGH A6 REGISTERS
00:0000042C *
00:00000444 00000000        	   353: REGA7    DS.L    1              A7 REGISTER
00:00000448 00000000        	   354: REGUS    DS.L    1              USER STACK
                            	   355: 
                            	   356: 
                            	   357: 
                            	   358: ****************************************************************
                            	   359: *              WORKING STORAGE                                 *
                            	   360: *  NOTE: SUBROUTINE "INITHRAM" ZEROES RAM...                   *
                            	   361: *        FROM "BEGHRAM" THROUGH "ENDHRAM" WHEN IT IS EXECUTED  *
                            	   362: ****************************************************************
                            	   363: 
                            	   364: BEGHRAM  DS      0              INITIALIZE STARTS HERE
                            	   365: 
00:0000044C 00000000        	   366: OFFSET   DS.L    8              ASSUMED OFFSETS (VIA "R@" FORMAT)
00:00000450 *
00:0000046C 00000000        	   367: MEMSIZE  DS.L    1              MEMORY SIZE IN BYTES
00:00000470 00000000        	   368: BPADD    DS.L    8              BREAKPOINT ADDRESSES
00:00000474 *
00:00000490 00000000        	   369: BPTILL   DS.L    1              TEMPORARY BREAKPOINT
00:00000494 00000000        	   370: BPCNT    DS.L    9              BREAKPOINT COUNTS
00:00000498 *
00:000004B8 0000            	   371: BPDATA   DS.W    9              HOLD USER WORDS REPLACED BY TRAP IN SET BP
00:000004BA *
00:000004CA 00000000        	   372: BERRD    DS.L    2              SPECIAL DATA FOR BUS AND ADDR ERROR EXCEPTIONS
00:000004CE *
00:000004D2 00000000        	   373: SAVEAV4  DS.L    1              HOLDS USER'S AV4 VECTOR (WE USE FOR BP)
00:000004D6 00000000        	   374: TEMP     DS.L    1              TEMP
00:000004DA 00000000        	   375: TRACECNT DS.L    1              TRACE COUNTER (-1=TRACE 1 & RUN)
00:000004DE 0000            	   376: TRACEON  DS.W    1              FLAG FOR TRACE ON
00:000004E0 0000            	   377: BPSTATUS DS.W    1              1=PB ARE IN  0=ARE OUT OF MEMORY
00:000004E2 00000000        	   378: ECHOPT1  DS.L    1              ECHO FLAG TO PORT ONE
                            	   379: 
                            	   380: 
                            	   381: 
                            	   382: * THE FOLLOWING MUST REMAIN AS IS
                            	   383: *  User documentation DEPENDS upon it!
                            	   384: *
                            	   385: OPTIONS  DS.W    0              FORCE WORD BOUNDRY
00:000004E6 00              	   386:          DS.B    1              X-ON CHARACTER
00:000004E7 00              	   387:          DS.B    1              X-OFF CHARACTER
00:000004E8 00              	   388:          DS.B    1              NO NO-AUTO LINEFEED
00:000004E9 00              	   389:          DS.B    1              SHORT FORM REGISTER DISPLAY
00:000004EA 00              	   390:          DS.B    1              TM  trailing character
00:000004EB 00              	   391:          DS.B    1              TM  exit character
                            	   392: 
                            	   393: XONOFF   EQU     OPTIONS
                            	   394: TMCHARS  EQU     OPTIONS+4
                            	   395: 
                            	   396: * END of as is section
                            	   397: 
                            	   398: 
                            	   399: ***************************
                            	   400: * TARGET SUPERVISOR STACK *
                            	   401: ***************************
                            	   402: 
00:000004EC 00000000        	   403:          DS.L    20
00:000004F0 *
00:0000053C 00000000        	   404: SSA7     DS.L    1
                            	   405: 
                            	   406: 
                            	   407: 
                            	   408: **************
                            	   409: * I/O BUFFER *
                            	   410: **************
                            	   411: 
00:00000540 00              	   412: BUFFER   DS.B    BUFFSIZE
00:00000541 *
                            	   413: 
00:000005C0 00              	   414: DUMPTEMP DS.B    80             HEADER TEMP BUFFER
00:000005C1 *
                            	   415: 
00:00000610 00000000        	   416: SCREEN1  DS.L    1              PRINT THIS BEFORE TRACE DISPLAY
00:00000614 00000000        	   417: SCREEN2  DS.L    1              PRINT THIS AFTER TRACE DISPLAY
                            	   418: 
00:00000618 00              	   419: NULLPADS DS.B    2              CHARACTER NULL PADS
00:00000619 *
00:0000061A 00              	   420: CRPADS   DS.B    2              CARRIAGE RETURN NULL PADS
00:0000061B *
                            	   421: 
00:0000061C 00000000        	   422: OUTTO    DS.L    1              HOLDS ADDRESS OF OUTPUT ROUTINE
00:00000620 00000000        	   423: INFROM   DS.L    1              HOLDS ADDRESS OF INPUT ROUTINE
00:00000624 00000000        	   424: ALTSER1  DS.L    1              ALTERNATE SERIAL PORT#1
00:00000628 00000000        	   425: ALTSER2  DS.L    1              ALTERNATE SERIAL PORT#2
00:0000062C 00000000        	   426: INPORT1  DS.L    1              INPUT ROUTINE ADDRESS
00:00000630 00000000        	   427: OUTPORT1 DS.L    1              ADDRESS FOR OUPUT ROUTINE
00:00000634 00000000        	   428: INPORT2  DS.L    1              ADDRESS FOR INPUT ROUTINE
00:00000638 00000000        	   429: OUTPORT2 DS.L    1              FOR OUTPURT ROUTINE
00:0000063C 00000000        	   430: INPORT3  DS.L    1              THIS MIGHT BE FOR TAPE
00:00000640 00000000        	   431: OUTPORT3 DS.L    1              THIS MIGHT BE FOR PRINTER
00:00000644 00000000        	   432: INPORT4  DS.L    1              CASSETTE
00:00000648 00000000        	   433: OUTPORT4 DS.L    1              CASSETTE
00:0000064C 0000            	   434: MD1CON   DS.W    1              ACIA PROFILE (PORT1/PORT2)
00:0000064E 00000000        	   435: PDIPORT  DS.L    1              PDIPORT ADDRESS
00:00000652 0000            	   436: CRTPNT   DS.W    1              OUTPUT TO PRINTER AND CRT
00:00000654 00              	   437: TAPENULS DS.B    1              NULLS FOR CASSETTE
                            	   438: 
00:00000655 00              	   439:          DS.B    1              PAD BYTE
                            	   440: 
00:00000656 00000000        	   441: CTLINK   DS.L    1              POINTER TO FIRST TABLE
                            	   442: 
                            	   443: 
                            	   444: 
                            	   445: ENDHRAM  DS.W    0              MUST START ON WORD BOUNDRY
                            	   446: 
                            	   447: 
                            	   448: 
                            	   449: *********************
                            	   450: * SYSTEM STACK AREA *
                            	   451: *********************
                            	   452: 
                            	   453:          DS.W    0              FORCE ON WORD BOUNDRY
00:0000065A 00              	   454:          DS.B    300            ROOM FOR STACK
00:0000065B *
00:00000786 0000            	   455: SYSTACK  DS.W    1              START OF STACK (ADDRESS DECREASES)
00:00000788 00              	   456:          DS.B    4              STRETCHED STACK (USED BY 'SAVE')
00:00000789 *
                            	   457: 
00:0000078C 00              	   458:          DS.B    120            EXTENDED AREA USED IF DISASSEMBLER
00:0000078D *
                            	   459: 
                            	   460:          DS.B    0              LAST LOW MEMORY LOCATION USED + 1
                            	   461: 
                            	   462: 
                            	   463: *-------------------------------------------------------------------------
                            	   464: 
                            	   465: *CODE68K
                            	   466: *                               OFFSET  0
                            	   467: ESKB     EQU     $00000000      DS      0
                            	   468: TDATA    EQU     $00000000      DS.B    10
                            	   469: TNB      EQU     $0000000A      DS.B    1
                            	   470: TLSPEC   EQU     $0000000B      DS.B    1
                            	   471: TLENGTH  EQU     $0000000C      DS.W    1
                            	   472: PCOUNTER EQU     $0000000E      DS.L    1
                            	   473: PTROP    EQU     $00000012      DS.L    1              POINTER TO OPERAND
                            	   474: PENDOP   EQU     $00000016      DS.L    1              POINTER END OF OPERAND
                            	   475: PTRBUFE  EQU     $0000001A      DS.L    1              POINTER TO END OF FORMATED SOURCE
                            	   476: LINK     EQU     $0000001E      DS.L    1              SAVE FOR UNLINK
                            	   477: ESKE     EQU     $00000022      DS.B    0
                            	   478: 
                            	   479: 
                            	   480: *DCODE68K
                            	   481: *                               OFFSET  -LOCVARSZ
                            	   482: DDATA    EQU     $FFFFFFF0      DS.L    3
                            	   483: HISPC    EQU     $FFFFFFFC      DS.L    1
                            	   484: 
                            	   485: 
                            	   486: *LOAD
                            	   487: *                               OFFSET  -((BUFFSIZE/2)+4)
                            	   488: CC       EQU     $FFFFFFBC      DS.L    1              CC (BYTE COUNT)
                            	   489: ADDRESS  EQU     $FFFFFFC0      DS.L    1              ADDRESS + OFFSET
                            	   490: LDATA    EQU     $FFFFFFC4      DS.B    1
                            	   491: 
                            	   492: 
                            	   493: 
                            	   494: 
                            	   495: *-------------------------------------------------------------------------
                            	   496: * File B         Init Vectors+Ram                                 05/29/82
                            	   497: 
                            	   498:          ORG     $200000
                            	   499: 
01:00200000 00000444        	   500: FIRST    DC.L    REGA7              ; 0   $00  SR
01:00200004 0020053A        	   501:          DC.L    START              ; 1   $01  RESET
01:00200008 00200428        	   502:          DC.L    BERRMSG            ; 2   $02  BUS ERROR            "BUS "
01:0020000C 00200432        	   503:          DC.L    ADDRMSG            ; 3   $03  ADDRESS ERROR        "ADDR"
01:00200010 002011E0        	   504:          DC.L    CHKBP              ; 4   $04  ILL INSTRUCTION      "OPCO"
01:00200014 002007A8        	   505:          DC.L    VECT5              ; 5   $05  DIVIDE BY ZERO       "DIV0"
01:00200018 002007B2        	   506:          DC.L    VECT6              ; 6   $06  CHECK TRAP           "CHCK"
01:0020001C 002007BC        	   507:          DC.L    VECT7              ; 7   $07  TRAP V               "TP V"
01:00200020 002007C6        	   508:          DC.L    VECT8              ; 8   $08  PRIVILEDGE VIOLATION "PRIV"
01:00200024 002010B6        	   509:          DC.L    TRACE              ; 9   $09  TRACE
01:00200028 002007DA        	   510:          DC.L    VECT10             ; 10  $0A  1010 LINE EMULATION  "1010"
01:0020002C 002007E4        	   511:          DC.L    VECT11             ; 11  $0B  1111 LINE EMULATION  "1111"
01:00200030 00000000        	   512:          DS.L    1              12  $0C  UNASSIGNED
01:00200034 00000000        	   513:          DS.L    1              13  $0D  UNASSIGNED
01:00200038 00000000        	   514:          DS.L    1              14  $0E  UNASSIGNED
01:0020003C 00000000        	   515:          DS.L    1              15  $0F  UNINITIALIZED INTERRUPT VECTOR
01:00200040 00000000        	   516:          DS.L    1              16  $10  UNASSIGNED
01:00200044 00000000        	   517:          DS.L    1              17  $11  UNASSIGNED
01:00200048 00000000        	   518:          DS.L    1              18  $12  UNASSIGNED
01:0020004C 00000000        	   519:          DS.L    1              19  $13  UNASSIGNED
01:00200050 00000000        	   520:          DS.L    1              20  $14  UNASSIGNED
01:00200054 00000000        	   521:          DS.L    1              21  $15  UNASSIGNED
01:00200058 00000000        	   522:          DS.L    1              22  $16  UNASSIGNED
01:0020005C 00000000        	   523:          DS.L    1              23  $17  UNASSIGNED
01:00200060 002007EE        	   524:          DC.L    VECT24         24  $18  SPURIOUS INTERRUPT
01:00200064 002007F8        	   525:          DC.L    VECT25         25  $19  LEVEL 1 INTERRUPT
01:00200068 00200802        	   526:          DC.L    VECT26         26  $1A  LEVEL 2 INTERRUPT
01:0020006C 0020080C        	   527:          DC.L    VECT27         27  $1B  LEVEL 3 INTERRUPT
01:00200070 00200816        	   528:          DC.L    VECT28         28  $1C  LEVEL 4 INTERRUPT
01:00200074 00200820        	   529:          DC.L    VECT29         29  $1D  LEVEL 5 INTERRUPT
01:00200078 0020082A        	   530:          DC.L    VECT30         30  $1E  LEVEL 6 INTERRUPT
01:0020007C 00201D18        	   531:          DC.L    ABORTB         31  $1F  LEVEL 7 INTERRUPT
01:00200080 0020083E        	   532:          DC.L    VECT32         32  $20   TRAP  0
01:00200084 00200848        	   533:          DC.L    VECT33         33  $21   TRAP  1
01:00200088 00200852        	   534:          DC.L    VECT34         34  $22   TRAP  2
01:0020008C 0020085C        	   535:          DC.L    VECT35         35  $23   TRAP  3
01:00200090 00200866        	   536:          DC.L    VECT36         36  $24   TRAP  4
01:00200094 00200870        	   537:          DC.L    VECT37         37  $25   TRAP  5
01:00200098 0020087A        	   538:          DC.L    VECT38         38  $26   TRAP  6
01:0020009C 00200884        	   539:          DC.L    VECT39         39  $27   TRAP  7
01:002000A0 0020088E        	   540:          DC.L    VECT40         40  $28   TRAP  8
01:002000A4 00200898        	   541:          DC.L    VECT41         41  $29   TRAP  9
01:002000A8 002008A2        	   542:          DC.L    VECT42         42  $2A   TRAP 10
01:002000AC 002008AC        	   543:          DC.L    VECT43         43  $2B   TRAP 11
01:002000B0 002008B6        	   544:          DC.L    VECT44         44  $2C   TRAP 12
01:002000B4 002008C0        	   545:          DC.L    VECT45         45  $2D   TRAP 13
01:002000B8 00204258        	   546:          DC.L    TRAP14         46  $2E   TRAP 14
01:002000BC 002008D4        	   547:          DC.L    VECT47         47  $2F   TRAP 15
01:002000C0 00000000        	   548:          DS.L    1              48  $30   UNASSIGNED
01:002000C4 00000000        	   549:          DS.L    1              49  $31   UNASSIGNED
01:002000C8 00000000        	   550:          DS.L    1              50  $32   UNASSIGNED
01:002000CC 00000000        	   551:          DS.L    1              51  $33   UNASSIGNED
01:002000D0 00000000        	   552:          DS.L    1              52  $34   UNASSIGNED
01:002000D4 00000000        	   553:          DS.L    1              53  $35   UNASSIGNED
01:002000D8 00000000        	   554:          DS.L    1              54  $36   UNASSIGNED
01:002000DC 00000000        	   555:          DS.L    1              55  $37   UNASSIGNED
01:002000E0 00000000        	   556:          DS.L    1              56  $38   UNASSIGNED
01:002000E4 00000000        	   557:          DS.L    1              57  $39   UNASSIGNED
01:002000E8 00000000        	   558:          DS.L    1              58  $3A   UNASSIGNED
01:002000EC 00000000        	   559:          DS.L    1              59  $3B   UNASSIGNED
01:002000F0 00000000        	   560:          DS.L    1              60  $3C   UNASSIGNED
01:002000F4 00000000        	   561:          DS.L    1              61  $3D   UNASSIGNED
01:002000F8 00000000        	   562:          DS.L    1              62  $3E   UNASSIGNED
01:002000FC 00000000        	   563:          DS.L    1              63  $3F   UNASSIGNED
01:00200100 00000000        	   564:          DS.L    1              64  $40   USER INTERRUPT
01:00200104 00000000        	   565:          DS.L    1              65  $41   USER INTERRUPT
01:00200108 00000000        	   566:          DS.L    1              66  $42   USER INTERRUPT
01:0020010C 00000000        	   567:          DS.L    1              67  $43   USER INTERRUPT
01:00200110 00000000        	   568:          DS.L    1              68  $44   USER INTERRUPT
01:00200114 00000000        	   569:          DS.L    1              69  $45   USER INTERRUPT
01:00200118 00000000        	   570:          DS.L    1              70  $46   USER INTERRUPT
01:0020011C 00000000        	   571:          DS.L    1              71  $47   USER INTERRUPT
01:00200120 00000000        	   572:          DS.L    1              72  $48   USER INTERRUPT
01:00200124 00000000        	   573:          DS.L    1              73  $49   USER INTERRUPT
01:00200128 00000000        	   574:          DS.L    1              74  $4A   USER INTERRUPT
01:0020012C 00000000        	   575:          DS.L    1              75  $4B   USER INTERRUPT
01:00200130 00000000        	   576:          DS.L    1              76  $4C   USER INTERRUPT
01:00200134 00000000        	   577:          DS.L    1              77  $4D   USER INTERRUPT
01:00200138 00000000        	   578:          DS.L    1              78  $4E   USER INTERRUPT
01:0020013C 00000000        	   579:          DS.L    1              79  $4F   USER INTERRUPT
01:00200140 00000000        	   580:          DS.L    1              80  $50   USER INTERRUPT
01:00200144 00000000        	   581:          DS.L    1              81  $51   USER INTERRUPT
01:00200148 00000000        	   582:          DS.L    1              82  $52   USER INTERRUPT
01:0020014C 00000000        	   583:          DS.L    1              83  $53   USER INTERRUPT
01:00200150 00000000        	   584:          DS.L    1              84  $54   USER INTERRUPT
01:00200154 00000000        	   585:          DS.L    1              85  $55   USER INTERRUPT
01:00200158 00000000        	   586:          DS.L    1              86  $56   USER INTERRUPT
01:0020015C 00000000        	   587:          DS.L    1              87  $57   USER INTERRUPT
01:00200160 00000000        	   588:          DS.L    1              88  $58   USER INTERRUPT
01:00200164 00000000        	   589:          DS.L    1              89  $59   USER INTERRUPT
01:00200168 00000000        	   590:          DS.L    1              90  $5A   USER INTERRUPT
01:0020016C 00000000        	   591:          DS.L    1              91  $5B   USER INTERRUPT
01:00200170 00000000        	   592:          DS.L    1              92  $5C   USER INTERRUPT
01:00200174 00000000        	   593:          DS.L    1              93  $5D   USER INTERRUPT
01:00200178 00000000        	   594:          DS.L    1              94  $5E   USER INTERRUPT
01:0020017C 00000000        	   595:          DS.L    1              95  $5F   USER INTERRUPT
01:00200180 00000000        	   596:          DS.L    1              96  $60   USER INTERRUPT
01:00200184 00000000        	   597:          DS.L    1              97  $61   USER INTERRUPT
01:00200188 00000000        	   598:          DS.L    1              98  $62   USER INTERRUPT
01:0020018C 00000000        	   599:          DS.L    1              99  $63   USER INTERRUPT
01:00200190 00000000        	   600:          DS.L    1              100  $64  USER INTERRUPT
01:00200194 00000000        	   601:          DS.L    1              101  $65  USER INTERRUPT
01:00200198 00000000        	   602:          DS.L    1              102  $66  USER INTERRUPT
01:0020019C 00000000        	   603:          DS.L    1              103  $67  USER INTERRUPT
01:002001A0 00000000        	   604:          DS.L    1              104  $68  USER INTERRUPT
01:002001A4 00000000        	   605:          DS.L    1              105  $69  USER INTERRUPT
01:002001A8 00000000        	   606:          DS.L    1              106  $6A  USER INTERRUPT
01:002001AC 00000000        	   607:          DS.L    1              107  $6B  USER INTERRUPT
01:002001B0 00000000        	   608:          DS.L    1              108  $6C  USER INTERRUPT
01:002001B4 00000000        	   609:          DS.L    1              109  $6D  USER INTERRUPT
01:002001B8 00000000        	   610:          DS.L    1              110  $6E  USER INTERRUPT
01:002001BC 00000000        	   611:          DS.L    1              111  $6F  USER INTERRUPT
01:002001C0 00000000        	   612:          DS.L    1              112  $70  USER INTERRUPT
01:002001C4 00000000        	   613:          DS.L    1              113  $71  USER INTERRUPT
01:002001C8 00000000        	   614:          DS.L    1              114  $72  USER INTERRUPT
01:002001CC 00000000        	   615:          DS.L    1              115  $73  USER INTERRUPT
01:002001D0 00000000        	   616:          DS.L    1              116  $74  USER INTERRUPT
01:002001D4 00000000        	   617:          DS.L    1              117  $75  USER INTERRUPT
01:002001D8 00000000        	   618:          DS.L    1              118  $76  USER INTERRUPT
01:002001DC 00000000        	   619:          DS.L    1              119  $77  USER INTERRUPT
01:002001E0 00000000        	   620:          DS.L    1              120  $78  USER INTERRUPT
01:002001E4 00000000        	   621:          DS.L    1              121  $79  USER INTERRUPT
01:002001E8 00000000        	   622:          DS.L    1              122  $7A  USER INTERRUPT
01:002001EC 00000000        	   623:          DS.L    1              123  $7B  USER INTERRUPT
01:002001F0 00000000        	   624:          DS.L    1              124  $7C  USER INTERRUPT
01:002001F4 00000000        	   625:          DS.L    1              125  $7D  USER INTERRUPT
01:002001F8 00000000        	   626:          DS.L    1              126  $7E  USER INTERRUPT
01:002001FC 00000000        	   627:          DS.L    1              127  $7F  USER INTERRUPT
01:00200200 00000000        	   628:          DS.L    1              128  $80  USER INTERRUPT
01:00200204 00000000        	   629:          DS.L    1              129  $81  USER INTERRUPT
01:00200208 00000000        	   630:          DS.L    1              130  $82  USER INTERRUPT
01:0020020C 00000000        	   631:          DS.L    1              131  $83  USER INTERRUPT
01:00200210 00000000        	   632:          DS.L    1              132  $84  USER INTERRUPT
01:00200214 00000000        	   633:          DS.L    1              133  $85  USER INTERRUPT
01:00200218 00000000        	   634:          DS.L    1              134  $86  USER INTERRUPT
01:0020021C 00000000        	   635:          DS.L    1              135  $87  USER INTERRUPT
01:00200220 00000000        	   636:          DS.L    1              136  $88  USER INTERRUPT
01:00200224 00000000        	   637:          DS.L    1              137  $89  USER INTERRUPT
01:00200228 00000000        	   638:          DS.L    1              138  $8A  USER INTERRUPT
01:0020022C 00000000        	   639:          DS.L    1              139  $8B  USER INTERRUPT
01:00200230 00000000        	   640:          DS.L    1              140  $8C  USER INTERRUPT
01:00200234 00000000        	   641:          DS.L    1              141  $8D  USER INTERRUPT
01:00200238 00000000        	   642:          DS.L    1              142  $8E  USER INTERRUPT
01:0020023C 00000000        	   643:          DS.L    1              143  $8F  USER INTERRUPT
01:00200240 00000000        	   644:          DS.L    1              144  $90  USER INTERRUPT
01:00200244 00000000        	   645:          DS.L    1              145  $91  USER INTERRUPT
01:00200248 00000000        	   646:          DS.L    1              146  $92  USER INTERRUPT
01:0020024C 00000000        	   647:          DS.L    1              147  $93  USER INTERRUPT
01:00200250 00000000        	   648:          DS.L    1              148  $94  USER INTERRUPT
01:00200254 00000000        	   649:          DS.L    1              149  $95  USER INTERRUPT
01:00200258 00000000        	   650:          DS.L    1              150  $96  USER INTERRUPT
01:0020025C 00000000        	   651:          DS.L    1              151  $97  USER INTERRUPT
01:00200260 00000000        	   652:          DS.L    1              152  $98  USER INTERRUPT
01:00200264 00000000        	   653:          DS.L    1              153  $99  USER INTERRUPT
01:00200268 00000000        	   654:          DS.L    1              154  $9A  USER INTERRUPT
01:0020026C 00000000        	   655:          DS.L    1              155  $9B  USER INTERRUPT
01:00200270 00000000        	   656:          DS.L    1              156  $9C  USER INTERRUPT
01:00200274 00000000        	   657:          DS.L    1              157  $9D  USER INTERRUPT
01:00200278 00000000        	   658:          DS.L    1              158  $9E  USER INTERRUPT
01:0020027C 00000000        	   659:          DS.L    1              159  $9F  USER INTERRUPT
01:00200280 00000000        	   660:          DS.L    1              160  $A0  USER INTERRUPT
01:00200284 00000000        	   661:          DS.L    1              161  $A1  USER INTERRUPT
01:00200288 00000000        	   662:          DS.L    1              162  $A2  USER INTERRUPT
01:0020028C 00000000        	   663:          DS.L    1              163  $A3  USER INTERRUPT
01:00200290 00000000        	   664:          DS.L    1              164  $A4  USER INTERRUPT
01:00200294 00000000        	   665:          DS.L    1              165  $A5  USER INTERRUPT
01:00200298 00000000        	   666:          DS.L    1              166  $A6  USER INTERRUPT
01:0020029C 00000000        	   667:          DS.L    1              167  $A7  USER INTERRUPT
01:002002A0 00000000        	   668:          DS.L    1              168  $A8  USER INTERRUPT
01:002002A4 00000000        	   669:          DS.L    1              169  $A9  USER INTERRUPT
01:002002A8 00000000        	   670:          DS.L    1              170  $AA  USER INTERRUPT
01:002002AC 00000000        	   671:          DS.L    1              171  $AB  USER INTERRUPT
01:002002B0 00000000        	   672:          DS.L    1              172  $AC  USER INTERRUPT
01:002002B4 00000000        	   673:          DS.L    1              173  $AD  USER INTERRUPT
01:002002B8 00000000        	   674:          DS.L    1              174  $AE  USER INTERRUPT
01:002002BC 00000000        	   675:          DS.L    1              175  $AF  USER INTERRUPT
01:002002C0 00000000        	   676:          DS.L    1              176  $B0  USER INTERRUPT
01:002002C4 00000000        	   677:          DS.L    1              177  $B1  USER INTERRUPT
01:002002C8 00000000        	   678:          DS.L    1              178  $B2  USER INTERRUPT
01:002002CC 00000000        	   679:          DS.L    1              179  $B3  USER INTERRUPT
01:002002D0 00000000        	   680:          DS.L    1              180  $B4  USER INTERRUPT
01:002002D4 00000000        	   681:          DS.L    1              181  $B5  USER INTERRUPT
01:002002D8 00000000        	   682:          DS.L    1              182  $B6  USER INTERRUPT
01:002002DC 00000000        	   683:          DS.L    1              183  $B7  USER INTERRUPT
01:002002E0 00000000        	   684:          DS.L    1              184  $B8  USER INTERRUPT
01:002002E4 00000000        	   685:          DS.L    1              185  $B9  USER INTERRUPT
01:002002E8 00000000        	   686:          DS.L    1              186  $BA  USER INTERRUPT
01:002002EC 00000000        	   687:          DS.L    1              187  $BB  USER INTERRUPT
01:002002F0 00000000        	   688:          DS.L    1              188  $BC  USER INTERRUPT
01:002002F4 00000000        	   689:          DS.L    1              189  $BD  USER INTERRUPT
01:002002F8 00000000        	   690:          DS.L    1              190  $BE  USER INTERRUPT
01:002002FC 00000000        	   691:          DS.L    1              191  $BF  USER INTERRUPT
01:00200300 00000000        	   692:          DS.L    1              192  $C0  USER INTERRUPT
01:00200304 00000000        	   693:          DS.L    1              193  $C1  USER INTERRUPT
01:00200308 00000000        	   694:          DS.L    1              194  $C2  USER INTERRUPT
01:0020030C 00000000        	   695:          DS.L    1              195  $C3  USER INTERRUPT
01:00200310 00000000        	   696:          DS.L    1              196  $C4  USER INTERRUPT
01:00200314 00000000        	   697:          DS.L    1              197  $C5  USER INTERRUPT
01:00200318 00000000        	   698:          DS.L    1              198  $C6  USER INTERRUPT
01:0020031C 00000000        	   699:          DS.L    1              199  $C7  USER INTERRUPT
01:00200320 00000000        	   700:          DS.L    1              200  $C8  USER INTERRUPT
01:00200324 00000000        	   701:          DS.L    1              201  $C9  USER INTERRUPT
01:00200328 00000000        	   702:          DS.L    1              202  $CA  USER INTERRUPT
01:0020032C 00000000        	   703:          DS.L    1              203  $CB  USER INTERRUPT
01:00200330 00000000        	   704:          DS.L    1              204  $CC  USER INTERRUPT
01:00200334 00000000        	   705:          DS.L    1              205  $CD  USER INTERRUPT
01:00200338 00000000        	   706:          DS.L    1              206  $CE  USER INTERRUPT
01:0020033C 00000000        	   707:          DS.L    1              207  $CF  USER INTERRUPT
01:00200340 00000000        	   708:          DS.L    1              208  $D0  USER INTERRUPT
01:00200344 00000000        	   709:          DS.L    1              209  $D1  USER INTERRUPT
01:00200348 00000000        	   710:          DS.L    1              210  $D2  USER INTERRUPT
01:0020034C 00000000        	   711:          DS.L    1              211  $D3  USER INTERRUPT
01:00200350 00000000        	   712:          DS.L    1              212  $D4  USER INTERRUPT
01:00200354 00000000        	   713:          DS.L    1              213  $D5  USER INTERRUPT
01:00200358 00000000        	   714:          DS.L    1              214  $D6  USER INTERRUPT
01:0020035C 00000000        	   715:          DS.L    1              215  $D7  USER INTERRUPT
01:00200360 00000000        	   716:          DS.L    1              216  $D8  USER INTERRUPT
01:00200364 00000000        	   717:          DS.L    1              217  $D9  USER INTERRUPT
01:00200368 00000000        	   718:          DS.L    1              218  $DA  USER INTERRUPT
01:0020036C 00000000        	   719:          DS.L    1              219  $DB  USER INTERRUPT
01:00200370 00000000        	   720:          DS.L    1              220  $DC  USER INTERRUPT
01:00200374 00000000        	   721:          DS.L    1              221  $DD  USER INTERRUPT
01:00200378 00000000        	   722:          DS.L    1              222  $DE  USER INTERRUPT
01:0020037C 00000000        	   723:          DS.L    1              223  $DF  USER INTERRUPT
01:00200380 00000000        	   724:          DS.L    1              224  $E0  USER INTERRUPT
01:00200384 00000000        	   725:          DS.L    1              225  $E1  USER INTERRUPT
01:00200388 00000000        	   726:          DS.L    1              226  $E2  USER INTERRUPT
01:0020038C 00000000        	   727:          DS.L    1              227  $E3  USER INTERRUPT
01:00200390 00000000        	   728:          DS.L    1              228  $E4  USER INTERRUPT
01:00200394 00000000        	   729:          DS.L    1              229  $E5  USER INTERRUPT
01:00200398 00000000        	   730:          DS.L    1              230  $E6  USER INTERRUPT
01:0020039C 00000000        	   731:          DS.L    1              231  $E7  USER INTERRUPT
01:002003A0 00000000        	   732:          DS.L    1              232  $E8  USER INTERRUPT
01:002003A4 00000000        	   733:          DS.L    1              233  $E9  USER INTERRUPT
01:002003A8 00000000        	   734:          DS.L    1              234  $EA  USER INTERRUPT
01:002003AC 00000000        	   735:          DS.L    1              235  $EB  USER INTERRUPT
01:002003B0 00000000        	   736:          DS.L    1              236  $EC  USER INTERRUPT
01:002003B4 00000000        	   737:          DS.L    1              237  $ED  USER INTERRUPT
01:002003B8 00000000        	   738:          DS.L    1              238  $EE  USER INTERRUPT
01:002003BC 00000000        	   739:          DS.L    1              239  $EF  USER INTERRUPT
01:002003C0 00000000        	   740:          DS.L    1              240  $F0  USER INTERRUPT
01:002003C4 00000000        	   741:          DS.L    1              241  $F1  USER INTERRUPT
01:002003C8 00000000        	   742:          DS.L    1              242  $F2  USER INTERRUPT
01:002003CC 00000000        	   743:          DS.L    1              243  $F3  USER INTERRUPT
01:002003D0 00000000        	   744:          DS.L    1              244  $F4  USER INTERRUPT
01:002003D4 00000000        	   745:          DS.L    1              245  $F5  USER INTERRUPT
01:002003D8 00000000        	   746:          DS.L    1              246  $F6  USER INTERRUPT
01:002003DC 00000000        	   747:          DS.L    1              247  $F7  USER INTERRUPT
01:002003E0 00000000        	   748:          DS.L    1              248  $F8  USER INTERRUPT
01:002003E4 00000000        	   749:          DS.L    1              249  $F9  USER INTERRUPT
01:002003E8 00000000        	   750:          DS.L    1              250  $FA  USER INTERRUPT
01:002003EC 00000000        	   751:          DS.L    1              251  $FB  USER INTERRUPT
01:002003F0 00000000        	   752:          DS.L    1              252  $FC  USER INTERRUPT
01:002003F4 00000000        	   753:          DS.L    1              253  $FD  USER INTERRUPT
01:002003F8 00000000        	   754:          DS.L    1              254  $FE  USER INTERRUPT
01:002003FC 00000000        	   755:          DS.L    1              255  $FF  USER INTERRUPT
                            	   756: 
01:00200400 60000CB4        	   757: V2       BRA     TRACE
                            	   758: 
                            	   759: 
                            	   760: **********************************
                            	   761: * INITIALIZE HIGH RAM SUBROUTINE *
                            	   762: **********************************
                            	   763: 
01:00200404 41F8044C        	   764: INITHRAM LEA     BEGHRAM,A0     START OF WORK RAM (PAST REGISTERS)
01:00200408 203C0000020E    	   765:          MOVE.L  #(ENDHRAM-BEGHRAM),D0  BYTES TO ZERO
01:0020040E 7200            	   766:          CLR.L   D1
01:00200410 10C1            	   767: INIT     MOVE.B  D1,(A0)+       ZERO MEMORY
01:00200412 5380            	   768:          SUBQ.L  #1,D0
01:00200414 66FA            	   769:          BNE     INIT
                            	   770: 
                            	   771:          ADDR2MEM BERRMSG,AV2   POINT AT BUS TRAP ERROR MESSAGE ROUTINE
01:00200416 487A0010        	     1M          PEA     BERRMSG(PC)         MOVE ADDRESS TO MEMORY; POSITION
01:0020041A 21DF0008        	     2M          MOVE.L  (A7)+,AV2       INDEPENDANT = TO "MOVE.L #BERRMSG,AV2"
                            	   772: 
                            	   773:          ADDR2MEM ADDRMSG,AV3   POINT AT ADDRESS TRAP ERROR MESSAGE ROUTINE
01:0020041E 487A0012        	     1M          PEA     ADDRMSG(PC)         MOVE ADDRESS TO MEMORY; POSITION
01:00200422 21DF000C        	     2M          MOVE.L  (A7)+,AV3       INDEPENDANT = TO "MOVE.L #ADDRMSG,AV3"
                            	   774: 
01:00200426 4E75            	   775:          RTS
                            	   776: 
                            	   777: 
                            	   778: ****************************************************
                            	   779: * SPECIAL HANDLING FOR BUS ERROR AND ADDRESS ERROR *
                            	   780: ****************************************************
                            	   781: 
01:00200428 21FC425553200030	   782: BERRMSG  MOVE.L  #'BUS ',$30
                            	   783: 
01:00200430 6008            	   784:          BRA.S   VECTBE
                            	   785: 
01:00200432 21FC414444520030	   786: ADDRMSG  MOVE.L  #'ADDR',$30
                            	   787: 
                            	   788: 
01:0020043A 21DF04CA        	   789: VECTBE   MOVE.L  (A7)+,BERRD
01:0020043E 21DF04CE        	   790:          MOVE.L  (A7)+,BERRD+4
                            	   791: 
                            	   792:          SAVEREGS
01:00200442 21CF0444        	     1M          MOVE.L  A7,REGA7       SAVE STACK POINTER
01:00200446 4FFA000A        	     2M          LEA     SV_000003(PC),A7    A7 = RETURN ADDRESS (FOR CALL TO SAVE)
01:0020044A 21CF04D6        	     3M          MOVE.L  A7,TEMP        TEMP = RETURN ADDRESS
01:0020044E 60000C38        	     4M          BRA     SAVE           BSR WITHOUT USING STACK
                            	     5M SV_000003     DS      0
01:00200452 61001C3C        	   793:          BSR     FIXBUF
01:00200456 3CFC0D0A        	   794:          MOVE.W  #$D0A,(A6)+
01:0020045A 303804CA        	   795:          MOVE.W  BERRD,D0
01:0020045E 6100194A        	   796:          BSR     PNT4HX         FORMAT FUNCTION CODE
                            	   797: 
01:00200462 1CFC0020        	   798:          MOVE.B  #BLANK,(A6)+   SPACE
01:00200466 203804CC        	   799:          MOVE.L  BERRD+2,D0
01:0020046A 61001930        	   800:          BSR     PNT8HX         FORMAT ACCESS ADDRESS
                            	   801: 
01:0020046E 1CFC0020        	   802:          MOVE.B  #BLANK,(A6)+   SPACE
01:00200472 303804D0        	   803:          MOVE.W  BERRD+6,D0
01:00200476 61001932        	   804:          BSR     PNT4HX         FORMAT INSTRUCTION REGISTER
                            	   805: 
01:0020047A 61001B88        	   806:          BSR     OUTPUT
01:0020047E 600018F8        	   807:          BRA     EVECT2         GO DISPLAY REGISTERS & PROMPT
                            	   808: 
01:00200482 53594E54415820  	   809: MSG008   DC.B    'SYNTAX '
                            	   810: 
01:00200489 4552524F5220    	   811: MSG008E  DC.B    'ERROR '
                            	   812: 
01:0020048F 04              	   813: MSGEOT   DC.B    EOT
                            	   814: 
01:00200490 57484154        	   815: MSG021   DC.B    'WHAT',EOT
01:00200494 04
                            	   816: 
01:00200495 00              	   817:          DC.B    0              PAD BYTE
                            	   818: 
                            	   819: 
                            	   820: * PRINT WHAT
                            	   821: 
01:00200496 4BFAFFF8        	   822: WHAT     LEA     MSG021(PC),A5  PRINT 'WHAT' AND ENTER MACSBUG
01:0020049A 614E            	   823: WHAT93   BSR.S   FIXDATA
01:0020049C 427804DE        	   824:          CLR.W   TRACEON
01:002004A0 61001B48        	   825: MSG      BSR     OUT1CR
01:002004A4 60000188        	   826:          BRA     MACSBUG
                            	   827: 
                            	   828: 
                            	   829: * PRINT ERROR
                            	   830: 
01:002004A8 4BFAFFDF        	   831: ERROR    LEA     MSG008E(PC),A5
01:002004AC 60EC            	   832:          BRA     WHAT93
                            	   833: 
01:002004AE 4BFAFFD2        	   834: SYNTAX   LEA     MSG008(PC),A5  'SYNTAX ERROR'
01:002004B2 60E6            	   835:          BRA     WHAT93
                            	   836: 
                            	   837: * FORMAT PHYSICAL ADDRESS FROM (D0)
01:002004B4 4BFA0022        	   838: PPHY     LEA     MSG019(PC),A5
01:002004B8 6130            	   839:          BSR.S   FIXDATA
01:002004BA 6012            	   840:          BRA.S   P2PHY2
                            	   841: 
                            	   842: * FORMAT TWO PHYSICAL ADDRESSES FROM (A0) & (A1)
01:002004BC 4BFA001A        	   843: P2PHY    LEA     MSG019(PC),A5  'PHYSICAL ADDRESS='
01:002004C0 6128            	   844:          BSR.S   FIXDATA
01:002004C2 2008            	   845:          MOVE.L  A0,D0
01:002004C4 610018D6        	   846:          BSR     PNT8HX         FORMAT ADDR1
01:002004C8 1CFC0020        	   847:          MOVE.B  #BLANK,(A6)+   SPACE FOR FORMATING
01:002004CC 2009            	   848:          MOVE.L  A1,D0
01:002004CE 610018CC        	   849: P2PHY2   BSR     PNT8HX         FORMAT ADDR2
01:002004D2 61001B16        	   850:          BSR     OUT1CR         DISPLAY IT
01:002004D6 4E75            	   851:          RTS
                            	   852: 
01:002004D8 504859534943414C	   853: MSG019   DC.B    'PHYSICAL ADDRESS=',EOT
01:002004E0 2041444452455353
01:002004E8 3D
01:002004E9 04
                            	   854: 
                            	   855: 
                            	   856: 
                            	   857: 
                            	   858: 
                            	   859: *************************************************************
                            	   860: * -FIXDATA- SUBROUTINE...  MOVES MESSAGE POINTED TO BY (A5) *
                            	   861: *                          INTO "BUFFER". EOT, ($04), ENDS  *
                            	   862: *                          THE MOVE. AT COMPLETION (A5) IS  *
                            	   863: *                          POINTING AT THE BEGINNING, (A6)  *
                            	   864: *                          POINTS AT END.                   *
                            	   865: *************************************************************
                            	   866: 
01:002004EA 4DF80540        	   867: FIXDATA  LEA     BUFFER,A6
01:002004EE 0C150004        	   868: FIXDADD  CMPI.B  #EOT,(A5)
01:002004F2 6704            	   869:          BEQ.S   FIXD2
01:002004F4 1CDD            	   870:          MOVE.B  (A5)+,(A6)+
01:002004F6 60F6            	   871:          BRA     FIXDADD
01:002004F8 4BF80540        	   872: FIXD2    LEA     BUFFER,A5
01:002004FC 4E75            	   873:          RTS
                            	   874: 
                            	   875: 
                            	   876: ************************************************************
                            	   877: * -FIXDCRLF- SUBROUTINE INSERTS A CARRIAGE RETURN AND LINE *
                            	   878: *                       FEED IN FRONT OF THE TEXT, THEN    *
                            	   879: *                       USES THE REMAINING PORTION OF THE  *
                            	   880: *                       FIXDATA.                           *
                            	   881: ************************************************************
                            	   882: 
01:002004FE 4DF80540        	   883: FIXDCRLF LEA     BUFFER,A6
01:00200502 3CFC0D0A        	   884:          MOVE.W  #$0D0A,(A6)+   CR,LF
01:00200506 60E6            	   885:          BRA     FIXDADD
                            	   886: 
                            	   887: 
                            	   888: 
                            	   889: 
                            	   890: *-------------------------------------------------------------------------
                            	   891: * File E         VERSAbug entry point                             01/08/81
                            	   892: 
                            	   893: **********************
                            	   894: * INITIALIZE VECTORS *
                            	   895: **********************
                            	   896: *                               Set most vectors to point at "????" routine
01:00200508 41F80008        	   897: INITVECT LEA     8,A0           Skip (Restart) STACK & ADDRESS vectors
01:0020050C 43FA184E        	   898:          LEA     ABORTE(PC),A1  A1 = "Default" TRAP ERROR routine address
                            	   899: 
01:00200510 20C9            	   900: INIT0    MOVE.L  A1,(A0)+       INITIALIZE VECTOR
01:00200512 B0FC0400        	   901:          CMPA.L  #$400,A0       Done?
01:00200516 6BF8            	   902:          BMI.S   INIT0          *
01:00200518 4E75            	   903:          RTS
                            	   904: 
                            	   905: 
                            	   906: * SPECIAL ENTRY THAT DOES NOT CHANGE VECTORS
                            	   907: 
01:0020051A 48B800010406    	   908: START1S  MOVEM.W D0,REGSR+2     Assure good parity.
01:00200520 40F80406        	   909:          MOVE.W  SR,REGSR+2     SAVE TARGET'S STATUS REGISTER
01:00200524 21CF0444        	   910:          MOVE.L  A7,REGA7       SAVE TARGET'S STACK
01:00200528 21D70400        	   911:          MOVE.L  (A7),REGPC     .PROGRAM COUNTER
01:0020052C 4FF80444        	   912:          LEA     REGA7,A7
01:00200530 48E7FFFE        	   913:          MOVEM.L D0-D7/A0-A6,-(A7) .REGISTERS
01:00200534 4FF80786        	   914:          LEA     SYSTACK,A7
01:00200538 6026            	   915:          BRA     START11
                            	   916: 
                            	   917: 
                            	   918: ************************
                            	   919: *    INITIALIZATION    *
                            	   920: ************************
                            	   921: 
                            	   922: * SAVE PROCESSOR REGISTERS (EXCEPT A7 & PC)
                            	   923: 
01:0020053A 48B800010406    	   924: START    MOVEM.W D0,REGSR+2     Assure good parity
01:00200540 40F80406        	   925:          MOVE.W  SR,REGSR+2     SAVE STATUS REGISTER
01:00200544 48E7FFFE        	   926:          MOVEM.L D0-D7/A0-A6,-(A7)
                            	   927: 
01:00200548 33FC000000040000	   928:          MOVE.W  #$0000,$040000               ; Get out of BOOT mode so read from RAM works as normal
                            	   929: 
01:00200550 4FF80786        	   930:          LEA     SYSTACK,A7     SET UP STACK
01:00200554 21CF0444        	   931:          MOVE.L  A7,REGA7
                            	   932: 
01:00200558 7200            	   933:          CLR.L   D1
01:0020055A 21C10400        	   934:          MOVE.L  D1,REGPC       PC = 000000
                            	   935: 
01:0020055E 61A8            	   936:          BSR     INITVECT
                            	   937: 
                            	   938: 
01:00200560 46FC2700        	   939: START11  MOVE.W  #$2700,SR      MASK OFF INTERRUPTS
                            	   940: 
01:00200564 4E68            	   941:          MOVE.L  USP,A0
01:00200566 21C80448        	   942:          MOVE.L  A0,REGUS       USER STACK
                            	   943: 
01:0020056A 6100FE98        	   944:          BSR     INITHRAM       ZERO (INITIALIZE) HIGH RAM
                            	   945: 
                            	   946: 
                            	   947: * VECTMSG.SA
01:0020056E 6100020A        	   948:          BSR     INITVMSG
                            	   949: 
                            	   950: 
                            	   951: * H.SA
                            	   952:          ADDR2MEM CHKBP,AV4     ILLEGAL INSTRUCTION
01:00200572 487A0C6C        	     1M          PEA     CHKBP(PC)         MOVE ADDRESS TO MEMORY; POSITION
01:00200576 21DF0010        	     2M          MOVE.L  (A7)+,AV4       INDEPENDANT = TO "MOVE.L #CHKBP,AV4"
                            	   953: 
                            	   954: 
                            	   955: * TM.SA
01:0020057A 31FC180104EA    	   956:          MOVE.W  #$1801,TMCHARS CNTLX,CNTL/A
                            	   957: 
                            	   958: 
                            	   959: * W.SA
                            	   960:          ADDR2MEM  ABORTB,AV31  ABORT
01:00200580 487A1796        	     1M          PEA     ABORTB(PC)         MOVE ADDRESS TO MEMORY; POSITION
01:00200584 21DF007C        	     2M          MOVE.L  (A7)+,AV31       INDEPENDANT = TO "MOVE.L #ABORTB,AV31"
                            	   961: 
                            	   962: 
                            	   963: * Y.SA
                            	   964:          ADDR2MEM  OUT1CR0,OUTPORT1 INITIALIZE I/O ROUTINES
01:00200588 487A1A7A        	     1M          PEA     OUT1CR0(PC)         MOVE ADDRESS TO MEMORY; POSITION
01:0020058C 21DF0630        	     2M          MOVE.L  (A7)+,OUTPORT1       INDEPENDANT = TO "MOVE.L #OUT1CR0,OUTPORT1"
                            	   965:          ADDR2MEM  OUTPUT20,OUTPORT2
01:00200590 487A1A92        	     1M          PEA     OUTPUT20(PC)         MOVE ADDRESS TO MEMORY; POSITION
01:00200594 21DF0638        	     2M          MOVE.L  (A7)+,OUTPORT2       INDEPENDANT = TO "MOVE.L #OUTPUT20,OUTPORT2"
                            	   966:          ADDR2MEM  PRCRLF,OUTPORT3     PRINTER DRIVER
01:00200598 487A1BC6        	     1M          PEA     PRCRLF(PC)         MOVE ADDRESS TO MEMORY; POSITION
01:0020059C 21DF0640        	     2M          MOVE.L  (A7)+,OUTPORT3       INDEPENDANT = TO "MOVE.L #PRCRLF,OUTPORT3"
                            	   967:          ADDR2MEM  TAPEOUT,OUTPORT4    CASSETTE
01:002005A0 487A1CF4        	     1M          PEA     TAPEOUT(PC)         MOVE ADDRESS TO MEMORY; POSITION
01:002005A4 21DF0648        	     2M          MOVE.L  (A7)+,OUTPORT4       INDEPENDANT = TO "MOVE.L #TAPEOUT,OUTPORT4"
                            	   968:          ADDR2MEM  PORTIN10,INPORT1
01:002005A8 487A1B0E        	     1M          PEA     PORTIN10(PC)         MOVE ADDRESS TO MEMORY; POSITION
01:002005AC 21DF062C        	     2M          MOVE.L  (A7)+,INPORT1       INDEPENDANT = TO "MOVE.L #PORTIN10,INPORT1"
                            	   969:          ADDR2MEM  PORTIN20,INPORT2
01:002005B0 487A1E1C        	     1M          PEA     PORTIN20(PC)         MOVE ADDRESS TO MEMORY; POSITION
01:002005B4 21DF0634        	     2M          MOVE.L  (A7)+,INPORT2       INDEPENDANT = TO "MOVE.L #PORTIN20,INPORT2"
                            	   970:          ADDR2MEM  PORTIN10,INPORT3
01:002005B8 487A1AFE        	     1M          PEA     PORTIN10(PC)         MOVE ADDRESS TO MEMORY; POSITION
01:002005BC 21DF063C        	     2M          MOVE.L  (A7)+,INPORT3       INDEPENDANT = TO "MOVE.L #PORTIN10,INPORT3"
                            	   971:          ADDR2MEM  TAPEIN,INPORT4      CASSETTE
01:002005C0 487A1ED4        	     1M          PEA     TAPEIN(PC)         MOVE ADDRESS TO MEMORY; POSITION
01:002005C4 21DF0644        	     2M          MOVE.L  (A7)+,INPORT4       INDEPENDANT = TO "MOVE.L #TAPEIN,INPORT4"
                            	   972: 
01:002005C8 11FC00080654    	   973:          MOVE.B  #8,TAPENULS    NULLS FOR CASSETTE
01:002005CE 21FC000F0000064E	   974:          MOVE.L  #PDI1,PDIPORT  PRINTER
                            	   975: 
                            	   976: 
                            	   977: *        INITIALIZE MC68230 PI/T
01:002005D6 207C000F0000    	   978:          MOVE.L  #PDI1,A0       BASE ADDRESS OF PI/T
01:002005DC 203C0000FF00    	   979:          MOVE.L  #$0000FF00,D0
01:002005E2 01C80001        	   980:          MOVEP.L D0,1(A0)
                            	   981: 
                            	   982: *        SELECT MODE 0
                            	   983: *        IRQ'S INACTIVATED
                            	   984: *        PORT A--ALL BITS OUTPUTS
                            	   985: *        PORT B--ALL BITS INPUTS
                            	   986: 
01:002005E6 117C0060000D    	   987:          MOVE.B  #$60,13(A0)    SUBMODE 01 FOR PORT A; INTERLOCKED HANDS
01:002005EC 117C00A0000F    	   988:          MOVE.B  #$A0,15(A0)    SUBMODE 1X FOR PORT B
01:002005F2 117C00300001    	   989:          MOVE.B  #$30,1(A0)     ENABLE HANDSHAKE LINES
01:002005F8 117C00A8000F    	   990:          MOVE.B  #$A8,15(A0)    RESET AND INIT PRINTER
01:002005FE 21FC000F0010064E	   991:          MOVE.L  #PDI1+$10,PDIPORT
                            	   992: 
01:00200606 117C00A0000F    	   993:          MOVE.B  #$A0,15(A0)    CLEAR INIT
                            	   994: 
                            	   995: * INITIALIZE THE PDI'S
                            	   996: 
01:0020060C 31FC5151064C    	   997:          MOVE.W  #$5151,MD1CON
01:00200612 61001D60        	   998:          BSR     INITSER        RESET & PROGRAM PDI
                            	   999: 
                            	  1000: * INITIALIZE XON/XOFF (READER ON / READER OFF)
                            	  1001: *            AUTO-LINE FEED OVERRIDE
                            	  1002: 
01:00200616 21FC0000000004E6	  1003:          MOVE.L  #$00000000,XONOFF
                            	  1004: 
                            	  1005: 
                            	  1006: 
                            	  1007: * TRAP14.SA
                            	  1008:          ADDR2MEM  TRAP14,AV46
01:0020061E 487A3C38        	     1M          PEA     TRAP14(PC)         MOVE ADDRESS TO MEMORY; POSITION
01:00200622 21DF00B8        	     2M          MOVE.L  (A7)+,AV46       INDEPENDANT = TO "MOVE.L #TRAP14,AV46"
01:00200626 21FCFE2042FC0656	  1009:          MOVE.L  #(254<<24)+CT,CTLINK
                            	  1010: 
                            	  1011: 
                            	  1012: 
                            	  1013: 
                            	  1014: 
                            	  1015: ************************************************************************
                            	  1016: *                    V E R S I O N   N U M B E R   A N D   P R O M P T *
                            	  1017: ************************************************************************
                            	  1018: 
01:0020062E 46FC2700        	  1019: MACSBUG  MOVE.W  #$2700,SR      MASK OFF INTERRUPTS
01:00200632 4FF80786        	  1020:          LEA     SYSTACK,A7     RESTORE SYSTEM STACK
01:00200636 61000B60        	  1021:          BSR     SWAPOUT        GET BP OUT OF USER MEMORY
                            	  1022: 
01:0020063A 42B80490        	  1023:          CLR.L   BPTILL         GET RID OF 'TILL' BREAKPOINT
01:0020063E 42B8061C        	  1024:          CLR.L   OUTTO          INITIALIZE I/O TO DEFAULT
01:00200642 42B80620        	  1025:          CLR.L   INFROM         INITIALIZE I/O TO DEFAULT
01:00200646 423804E2        	  1026:          CLR.B   ECHOPT1        NO ECHO TO PORT1
                            	  1027: 
01:0020064A 4BFA00AA        	  1028:          LEA     MSG001(PC),A5  > (Prompt)
01:0020064E 6100FE9A        	  1029:          BSR     FIXDATA
                            	  1030: 
01:00200652 4A7804DE        	  1031:          TST.W   TRACEON        SEE IF IN TRACE MODE
01:00200656 6704            	  1032:          BEQ.S   MACSBUG1
01:00200658 1CFC003A        	  1033:          MOVE.B  #':',(A6)+     IN TRACE MODE
01:0020065C 1CFC003E        	  1034: MACSBUG1 MOVE.B  #'>',(A6)+     PROMPT
01:00200660 1CFC0020        	  1035:          MOVE.B  #BLANK,(A6)+   .. SPACE
01:00200664 6100199E        	  1036:          BSR     OUTPUT         GO PRINT IT
                            	  1037: 
                            	  1038: * INPUT LINE
01:00200668 61001A26        	  1039:          BSR     FIXBUF         GET READY FOR INPUT
01:0020066C 61001A2A        	  1040:          BSR     PORTIN1        GET A COMMAND
01:00200670 1CBC0020        	  1041: DECODE6  MOVE.B  #BLANK,(A6)    BLANK OUT END+1
                            	  1042: 
                            	  1043: *  DECODE A COMMAND
                            	  1044: *
                            	  1045: *  DECODE SPECIAL CHARACTER USAGE:
                            	  1046: *    LEADING SPACES IGNORED
                            	  1047: *    LEADING NULLS IGNORED
                            	  1048: *    IF SECOND CHAR  *  CHAR CAN BE ANY CHAR
                            	  1049: 
01:00200674 BBCE            	  1050:          CMP.L   A6,A5          SEE IF ANYTHING ENTERED
01:00200676 6B08            	  1051:          BMI.S   DECODE1
01:00200678 4A7804DE        	  1052:          TST.W   TRACEON        SEE IF IN TRACE MODE
01:0020067C 6600031A        	  1053:          BNE     TCMDHOT        DIRECT TO TRACE 1 COMMAND
                            	  1054: 
01:00200680 BBCE            	  1055: DECODE1  CMP.L   A6,A5          SEE IF AT END OF BUFFER
01:00200682 6200FE12        	  1056:          BHI     WHAT           GO TO 'WHAT' IF CONFUSED
01:00200686 1015            	  1057:          MOVE.B  (A5),D0        GRAB FIRST CHARACTER
01:00200688 0C00002A        	  1058:          CMPI.B  #'*',D0        SEND LINE COMMAND
01:0020068C 6608            	  1059:          BNE.S   DECODE10
01:0020068E 528D            	  1060:          ADDQ.L  #1,A5          GET PAST PHOENY PROMPT
01:00200690 6100197C        	  1061:          BSR     OUTPUT2        SEND LINE+CR (NO LF) TO PORT2
01:00200694 6098            	  1062:          BRA     MACSBUG        REENTER COMMAND MODE
                            	  1063: 
01:00200696 0C000020        	  1064: DECODE10 CMPI.B  #$20,D0        IGNORE LEADING SPACES
01:0020069A 6604            	  1065:          BNE.S   DECODE2        WHERE TO GO IF NOT A SPACE
01:0020069C 528D            	  1066:          ADDQ.L  #1,A5          BUMP START OF BUFFER
01:0020069E 60E0            	  1067:          BRA.S   DECODE1        TRY NEXT CHARACTER
                            	  1068: *
01:002006A0 1215            	  1069: DECODE2  MOVE.B  (A5),D1        GET 2 LETTERS OF COMMAND
01:002006A2 E149            	  1070:          LSL.W   #8,D1          MAKE ROOM FOR SECOND CHAR
01:002006A4 122D0001        	  1071:          MOVE.B  1(A5),D1       GET SECOND CHAR
01:002006A8 7600            	  1072:          CLR.L   D3             D3 = CLEAR "NO" SWITCH
                            	  1073: 
01:002006AA 43FA0058        	  1074: DECODE21 LEA     SOLIST(PC),A1  A1 = COMMAND LIST ADDRESS
01:002006AE 3419            	  1075: DECODE4  MOVE.W  (A1)+,D2       D2 = 2 CHAR COMMAND FROM LIST
01:002006B0 7000            	  1076:          CLR.L   D0             CLEAR HIGH BITS
01:002006B2 3019            	  1077:          MOVE.W  (A1)+,D0       D0 = OFFSET FROM START OF ROM
                            	  1078: 
01:002006B4 4A83            	  1079:          TST.L   D3
01:002006B6 6704            	  1080:          BEQ.S   DECODE41       NOT A "NO"
01:002006B8 4A02            	  1081:          TST.B   D2             IS "NO" OPTION SUPPORTED THIS COMMAND?
01:002006BA 6AF2            	  1082:          BPL     DECODE4        NO...THEN RUN OUT OF COMMANDS
                            	  1083: 
01:002006BC 02427F7F        	  1084: DECODE41 ANDI.W  #$7F7F,D2      CLEAR "INVISABLE" & "NO" BITS
01:002006C0 0C427F7F        	  1085:          CMPI.W  #$7F7F,D2      END OF LIST?
01:002006C4 6700FDD0        	  1086:          BEQ     WHAT           Command not found
                            	  1087: 
01:002006C8 0C02002A        	  1088:          CMPI.B  #'*',D2        SEE IF DON'T CARE CHARACTER
01:002006CC 6602            	  1089:          BNE.S   DECODE3
01:002006CE 1401            	  1090:          MOVE.B  D1,D2          DEFAULT
                            	  1091: 
01:002006D0 B441            	  1092: DECODE3  CMP.W   D1,D2          Command from table = the input?
01:002006D2 66DA            	  1093:          BNE     DECODE4        COMMAND NOT FOUND
                            	  1094: 
01:002006D4 427804DE        	  1095:          CLR.W   TRACEON        TURN OFF TRACE MODE
                            	  1096: 
01:002006D8 548D            	  1097:          ADDQ.L  #2,A5          POINT A5 PAST 2 DIGIT COMMAND
                            	  1098: 
01:002006DA 487AF924        	  1099:          PEA     FIRST(PC)      BUILD GO TO ADDRESS
01:002006DE D197            	  1100:          ADD.L   D0,(A7)        ON STACK.
01:002006E0 D797            	  1101:          ADD.L   D3,(A7)
                            	  1102: 
01:002006E2 205F            	  1103:          MOVE.L  (A7)+,A0       GO TO COMMAND
01:002006E4 4E90            	  1104:          JSR     (A0)           * SAVE MARK FOR RETURN
01:002006E6 6000FF46        	  1105:          BRA     MACSBUG        *  RETURN HERE
                            	  1106: 
                            	  1107: *
                            	  1108: *    NO COMMAND
                            	  1109: *
01:002006EA 76FC            	  1110: NOCMD    MOVEQ   #-4,D3         SET "NO" SWITCH
01:002006EC 1215            	  1111:          MOVE.B  (A5),D1        MOVE CHAR #3
01:002006EE E141            	  1112:          ASL.W   #8,D1          MOVE OVER 1 CHAR
01:002006F0 122D0001        	  1113:          MOVE.B  1(A5),D1       MOVE CHAR #4
01:002006F4 60B4            	  1114:          BRA     DECODE21       WHICH "NO" COMMAND?
                            	  1115: 
                            	  1116: 
                            	  1117: *-------------------------------------------------------------------------
                            	  1118: * File COMMANDS  Command list                                     06/20/82
                            	  1119: 
                            	  1120: 
01:002006F6 0D              	  1121: MSG001   DC.B    CR,LF,'TUTOR  1.3 ',EOT    "PROMPT"
01:002006F7 0A
01:002006F8 5455544F52202031
01:00200700 2E3320
01:00200703 04
                            	  1122: 
                            	  1123: 
                            	  1124: 
                            	  1125: 
                            	  1126: *******************************************************
                            	  1127: * C O P Y R I G H T . 1 9 8 1 . B Y . M O T O R O L A *
                            	  1128: *******************************************************
                            	  1129: 
                            	  1130: * VERSAbug command generation macro
                            	  1131: CMD      MACRO
                            	  1132: FLAG     SET     0              *
                            	  1133:          IFC     '\2','HELP=NO'
                            	  1134: FLAG     SET     FLAG+$8000     * "Help" will not display this command
                            	  1135:          ENDC
                            	  1136:          IFC     '\3','HELP=NO'
                            	  1137: FLAG     SET     FLAG+$8000     * "Help" will not display this command
                            	  1138:          ENDC
                            	  1139:          IFC     '\2','NORTN=YES'
                            	  1140: FLAG     SET     FLAG+$80       * "NO\1".Command
                            	  1141:          ENDC
                            	  1142:          IFC     '\3','NORTN=YES'
                            	  1143: FLAG     SET     FLAG+$80       * "NO\1".Command
                            	  1144:          ENDC
                            	  1145:          IFC     '\1','PER'     Check for the "PER" command
                            	  1146:          DC.W    '.*'+FLAG      * Reg commands (.A2 .D6 .PC .R0 etc.)
                            	  1147:          DC.W    \1CMD-FIRST    *************************************
                            	  1148:          ENDC
                            	  1149:          IFNC    '\1','PER'     If not PERCMD...
                            	  1150:          IFEQ    '\1'&($FF00)   If 1 digit code, 2nd will be a blank.
                            	  1151:          DC.W    '\1 '+FLAG     * "\1"....Command  -  -  (Single Digit)
                            	  1152:          ENDC
                            	  1153:          IFNE    '\1'&($FF00)   If 2 digit code, leave as is.
                            	  1154:          DC.W    '\1'+FLAG      * "\1"...Command
                            	  1155:          ENDC
                            	  1156:          DC.W    \1CMD-FIRST    *************************************
                            	  1157:          ENDC
                            	  1158:          ENDM
                            	  1159: 
                            	  1160: 
                            	  1161: SOLIST   DS      0              Start Of LIST
                            	  1162: 
                            	  1163:          CMD     PER,HELP=NO,X,X
                            	     1M FLAG     SET     0              *
                            	     2M          IFC     'HELP=NO','HELP=NO'
                            	     3M FLAG     SET     FLAG+$8000     * "Help" will not display this command
                            	     4M          ENDC
                            	     5M          IFC     'X','HELP=NO'
                            	     6M FLAG     SET     FLAG+$8000     * "Help" will not display this command
                            	     7M          ENDC
                            	     8M          IFC     'HELP=NO','NORTN=YES'
                            	     9M FLAG     SET     FLAG+$80       * "NOPER".Command
                            	    10M          ENDC
                            	    11M          IFC     'X','NORTN=YES'
                            	    12M FLAG     SET     FLAG+$80       * "NOPER".Command
                            	    13M          ENDC
                            	    14M          IFC     'PER','PER'     Check for the "PER" command
01:00200704 AE2A            	    15M          DC.W    '.*'+FLAG      * Reg commands (.A2 .D6 .PC .R0 etc.)
01:00200706 198A            	    16M          DC.W    PERCMD-FIRST    *************************************
                            	    17M          ENDC
                            	    18M          IFNC    'PER','PER'     If not PERCMD...
                            	    19M          IFEQ    'PER'&($FF00)   If 1 digit code, 2nd will be a blank.
                            	    20M          DC.W    'PER '+FLAG     * "PER"....Command  -  -  (Single Digit)
                            	    21M          ENDC
                            	    22M          IFNE    'PER'&($FF00)   If 2 digit code, leave as is.
                            	    23M          DC.W    'PER'+FLAG      * "PER"...Command
                            	    24M          ENDC
                            	    25M          DC.W    PERCMD-FIRST    *************************************
                            	    26M          ENDC
                            	  1164: 
                            	  1165:          CMD     NO,HELP=NO,X,X
                            	     1M FLAG     SET     0              *
                            	     2M          IFC     'HELP=NO','HELP=NO'
                            	     3M FLAG     SET     FLAG+$8000     * "Help" will not display this command
                            	     4M          ENDC
                            	     5M          IFC     'X','HELP=NO'
                            	     6M FLAG     SET     FLAG+$8000     * "Help" will not display this command
                            	     7M          ENDC
                            	     8M          IFC     'HELP=NO','NORTN=YES'
                            	     9M FLAG     SET     FLAG+$80       * "NONO".Command
                            	    10M          ENDC
                            	    11M          IFC     'X','NORTN=YES'
                            	    12M FLAG     SET     FLAG+$80       * "NONO".Command
                            	    13M          ENDC
                            	    14M          IFC     'NO','PER'     Check for the "PER" command
                            	    15M          DC.W    '.*'+FLAG      * Reg commands (.A2 .D6 .PC .R0 etc.)
                            	    16M          DC.W    NOCMD-FIRST    *************************************
                            	    17M          ENDC
                            	    18M          IFNC    'NO','PER'     If not PERCMD...
                            	    19M          IFEQ    'NO'&($FF00)   If 1 digit code, 2nd will be a blank.
                            	    20M          DC.W    'NO '+FLAG     * "NO"....Command  -  -  (Single Digit)
                            	    21M          ENDC
                            	    22M          IFNE    'NO'&($FF00)   If 2 digit code, leave as is.
01:00200708 CE4F            	    23M          DC.W    'NO'+FLAG      * "NO"...Command
                            	    24M          ENDC
01:0020070A 06EA            	    25M          DC.W    NOCMD-FIRST    *************************************
                            	    26M          ENDC
                            	  1166: 
                            	  1167:          CMD     BA,X,X
                            	     1M FLAG     SET     0              *
                            	     2M          IFC     'X','HELP=NO'
                            	     3M FLAG     SET     FLAG+$8000     * "Help" will not display this command
                            	     4M          ENDC
                            	     5M          IFC     'X','HELP=NO'
                            	     6M FLAG     SET     FLAG+$8000     * "Help" will not display this command
                            	     7M          ENDC
                            	     8M          IFC     'X','NORTN=YES'
                            	     9M FLAG     SET     FLAG+$80       * "NOBA".Command
                            	    10M          ENDC
                            	    11M          IFC     'X','NORTN=YES'
                            	    12M FLAG     SET     FLAG+$80       * "NOBA".Command
                            	    13M          ENDC
                            	    14M          IFC     'BA','PER'     Check for the "PER" command
                            	    15M          DC.W    '.*'+FLAG      * Reg commands (.A2 .D6 .PC .R0 etc.)
                            	    16M          DC.W    BACMD-FIRST    *************************************
                            	    17M          ENDC
                            	    18M          IFNC    'BA','PER'     If not PERCMD...
                            	    19M          IFEQ    'BA'&($FF00)   If 1 digit code, 2nd will be a blank.
                            	    20M          DC.W    'BA '+FLAG     * "BA"....Command  -  -  (Single Digit)
                            	    21M          ENDC
                            	    22M          IFNE    'BA'&($FF00)   If 2 digit code, leave as is.
01:0020070C 4241            	    23M          DC.W    'BA'+FLAG      * "BA"...Command
                            	    24M          ENDC
01:0020070E 127E            	    25M          DC.W    BACMD-FIRST    *************************************
                            	    26M          ENDC
                            	  1168: 
                            	  1169:          CMD     BF,X,X
                            	     1M FLAG     SET     0              *
                            	     2M          IFC     'X','HELP=NO'
                            	     3M FLAG     SET     FLAG+$8000     * "Help" will not display this command
                            	     4M          ENDC
                            	     5M          IFC     'X','HELP=NO'
                            	     6M FLAG     SET     FLAG+$8000     * "Help" will not display this command
                            	     7M          ENDC
                            	     8M          IFC     'X','NORTN=YES'
                            	     9M FLAG     SET     FLAG+$80       * "NOBF".Command
                            	    10M          ENDC
                            	    11M          IFC     'X','NORTN=YES'
                            	    12M FLAG     SET     FLAG+$80       * "NOBF".Command
                            	    13M          ENDC
                            	    14M          IFC     'BF','PER'     Check for the "PER" command
                            	    15M          DC.W    '.*'+FLAG      * Reg commands (.A2 .D6 .PC .R0 etc.)
                            	    16M          DC.W    BFCMD-FIRST    *************************************
                            	    17M          ENDC
                            	    18M          IFNC    'BF','PER'     If not PERCMD...
                            	    19M          IFEQ    'BF'&($FF00)   If 1 digit code, 2nd will be a blank.
                            	    20M          DC.W    'BF '+FLAG     * "BF"....Command  -  -  (Single Digit)
                            	    21M          ENDC
                            	    22M          IFNE    'BF'&($FF00)   If 2 digit code, leave as is.
01:00200710 4246            	    23M          DC.W    'BF'+FLAG      * "BF"...Command
                            	    24M          ENDC
01:00200712 08E0            	    25M          DC.W    BFCMD-FIRST    *************************************
                            	    26M          ENDC
                            	  1170: 
                            	  1171:          CMD     BM,X,X
                            	     1M FLAG     SET     0              *
                            	     2M          IFC     'X','HELP=NO'
                            	     3M FLAG     SET     FLAG+$8000     * "Help" will not display this command
                            	     4M          ENDC
                            	     5M          IFC     'X','HELP=NO'
                            	     6M FLAG     SET     FLAG+$8000     * "Help" will not display this command
                            	     7M          ENDC
                            	     8M          IFC     'X','NORTN=YES'
                            	     9M FLAG     SET     FLAG+$80       * "NOBM".Command
                            	    10M          ENDC
                            	    11M          IFC     'X','NORTN=YES'
                            	    12M FLAG     SET     FLAG+$80       * "NOBM".Command
                            	    13M          ENDC
                            	    14M          IFC     'BM','PER'     Check for the "PER" command
                            	    15M          DC.W    '.*'+FLAG      * Reg commands (.A2 .D6 .PC .R0 etc.)
                            	    16M          DC.W    BMCMD-FIRST    *************************************
                            	    17M          ENDC
                            	    18M          IFNC    'BM','PER'     If not PERCMD...
                            	    19M          IFEQ    'BM'&($FF00)   If 1 digit code, 2nd will be a blank.
                            	    20M          DC.W    'BM '+FLAG     * "BM"....Command  -  -  (Single Digit)
                            	    21M          ENDC
                            	    22M          IFNE    'BM'&($FF00)   If 2 digit code, leave as is.
01:00200714 424D            	    23M          DC.W    'BM'+FLAG      * "BM"...Command
                            	    24M          ENDC
01:00200716 0932            	    25M          DC.W    BMCMD-FIRST    *************************************
                            	    26M          ENDC
                            	  1172: 
                            	  1173: 
                            	  1174: 
                            	  1175:          CMD     BR,NORTN=YES,X,X
                            	     1M FLAG     SET     0              *
                            	     2M          IFC     'NORTN=YES','HELP=NO'
                            	     3M FLAG     SET     FLAG+$8000     * "Help" will not display this command
                            	     4M          ENDC
                            	     5M          IFC     'X','HELP=NO'
                            	     6M FLAG     SET     FLAG+$8000     * "Help" will not display this command
                            	     7M          ENDC
                            	     8M          IFC     'NORTN=YES','NORTN=YES'
                            	     9M FLAG     SET     FLAG+$80       * "NOBR".Command
                            	    10M          ENDC
                            	    11M          IFC     'X','NORTN=YES'
                            	    12M FLAG     SET     FLAG+$80       * "NOBR".Command
                            	    13M          ENDC
                            	    14M          IFC     'BR','PER'     Check for the "PER" command
                            	    15M          DC.W    '.*'+FLAG      * Reg commands (.A2 .D6 .PC .R0 etc.)
                            	    16M          DC.W    BRCMD-FIRST    *************************************
                            	    17M          ENDC
                            	    18M          IFNC    'BR','PER'     If not PERCMD...
                            	    19M          IFEQ    'BR'&($FF00)   If 1 digit code, 2nd will be a blank.
                            	    20M          DC.W    'BR '+FLAG     * "BR"....Command  -  -  (Single Digit)
                            	    21M          ENDC
                            	    22M          IFNE    'BR'&($FF00)   If 2 digit code, leave as is.
01:00200718 42D2            	    23M          DC.W    'BR'+FLAG      * "BR"...Command
                            	    24M          ENDC
01:0020071A 0A4E            	    25M          DC.W    BRCMD-FIRST    *************************************
                            	    26M          ENDC
                            	  1176: 
                            	  1177:          CMD     BS,X,X
                            	     1M FLAG     SET     0              *
                            	     2M          IFC     'X','HELP=NO'
                            	     3M FLAG     SET     FLAG+$8000     * "Help" will not display this command
                            	     4M          ENDC
                            	     5M          IFC     'X','HELP=NO'
                            	     6M FLAG     SET     FLAG+$8000     * "Help" will not display this command
                            	     7M          ENDC
                            	     8M          IFC     'X','NORTN=YES'
                            	     9M FLAG     SET     FLAG+$80       * "NOBS".Command
                            	    10M          ENDC
                            	    11M          IFC     'X','NORTN=YES'
                            	    12M FLAG     SET     FLAG+$80       * "NOBS".Command
                            	    13M          ENDC
                            	    14M          IFC     'BS','PER'     Check for the "PER" command
                            	    15M          DC.W    '.*'+FLAG      * Reg commands (.A2 .D6 .PC .R0 etc.)
                            	    16M          DC.W    BSCMD-FIRST    *************************************
                            	    17M          ENDC
                            	    18M          IFNC    'BS','PER'     If not PERCMD...
                            	    19M          IFEQ    'BS'&($FF00)   If 1 digit code, 2nd will be a blank.
                            	    20M          DC.W    'BS '+FLAG     * "BS"....Command  -  -  (Single Digit)
                            	    21M          ENDC
                            	    22M          IFNE    'BS'&($FF00)   If 2 digit code, leave as is.
01:0020071C 4253            	    23M          DC.W    'BS'+FLAG      * "BS"...Command
                            	    24M          ENDC
01:0020071E 0B14            	    25M          DC.W    BSCMD-FIRST    *************************************
                            	    26M          ENDC
                            	  1178: 
                            	  1179:          CMD     BT,X,X
                            	     1M FLAG     SET     0              *
                            	     2M          IFC     'X','HELP=NO'
                            	     3M FLAG     SET     FLAG+$8000     * "Help" will not display this command
                            	     4M          ENDC
                            	     5M          IFC     'X','HELP=NO'
                            	     6M FLAG     SET     FLAG+$8000     * "Help" will not display this command
                            	     7M          ENDC
                            	     8M          IFC     'X','NORTN=YES'
                            	     9M FLAG     SET     FLAG+$80       * "NOBT".Command
                            	    10M          ENDC
                            	    11M          IFC     'X','NORTN=YES'
                            	    12M FLAG     SET     FLAG+$80       * "NOBT".Command
                            	    13M          ENDC
                            	    14M          IFC     'BT','PER'     Check for the "PER" command
                            	    15M          DC.W    '.*'+FLAG      * Reg commands (.A2 .D6 .PC .R0 etc.)
                            	    16M          DC.W    BTCMD-FIRST    *************************************
                            	    17M          ENDC
                            	    18M          IFNC    'BT','PER'     If not PERCMD...
                            	    19M          IFEQ    'BT'&($FF00)   If 1 digit code, 2nd will be a blank.
                            	    20M          DC.W    'BT '+FLAG     * "BT"....Command  -  -  (Single Digit)
                            	    21M          ENDC
                            	    22M          IFNE    'BT'&($FF00)   If 2 digit code, leave as is.
01:00200720 4254            	    23M          DC.W    'BT'+FLAG      * "BT"...Command
                            	    24M          ENDC
01:00200722 0C4E            	    25M          DC.W    BTCMD-FIRST    *************************************
                            	    26M          ENDC
                            	  1180: 
                            	  1181:          CMD     DC,X,X
                            	     1M FLAG     SET     0              *
                            	     2M          IFC     'X','HELP=NO'
                            	     3M FLAG     SET     FLAG+$8000     * "Help" will not display this command
                            	     4M          ENDC
                            	     5M          IFC     'X','HELP=NO'
                            	     6M FLAG     SET     FLAG+$8000     * "Help" will not display this command
                            	     7M          ENDC
                            	     8M          IFC     'X','NORTN=YES'
                            	     9M FLAG     SET     FLAG+$80       * "NODC".Command
                            	    10M          ENDC
                            	    11M          IFC     'X','NORTN=YES'
                            	    12M FLAG     SET     FLAG+$80       * "NODC".Command
                            	    13M          ENDC
                            	    14M          IFC     'DC','PER'     Check for the "PER" command
                            	    15M          DC.W    '.*'+FLAG      * Reg commands (.A2 .D6 .PC .R0 etc.)
                            	    16M          DC.W    DCCMD-FIRST    *************************************
                            	    17M          ENDC
                            	    18M          IFNC    'DC','PER'     If not PERCMD...
                            	    19M          IFEQ    'DC'&($FF00)   If 1 digit code, 2nd will be a blank.
                            	    20M          DC.W    'DC '+FLAG     * "DC"....Command  -  -  (Single Digit)
                            	    21M          ENDC
                            	    22M          IFNE    'DC'&($FF00)   If 2 digit code, leave as is.
01:00200724 4443            	    23M          DC.W    'DC'+FLAG      * "DC"...Command
                            	    24M          ENDC
01:00200726 0CA0            	    25M          DC.W    DCCMD-FIRST    *************************************
                            	    26M          ENDC
                            	  1182: 
                            	  1183:          CMD     DF,X,X
                            	     1M FLAG     SET     0              *
                            	     2M          IFC     'X','HELP=NO'
                            	     3M FLAG     SET     FLAG+$8000     * "Help" will not display this command
                            	     4M          ENDC
                            	     5M          IFC     'X','HELP=NO'
                            	     6M FLAG     SET     FLAG+$8000     * "Help" will not display this command
                            	     7M          ENDC
                            	     8M          IFC     'X','NORTN=YES'
                            	     9M FLAG     SET     FLAG+$80       * "NODF".Command
                            	    10M          ENDC
                            	    11M          IFC     'X','NORTN=YES'
                            	    12M FLAG     SET     FLAG+$80       * "NODF".Command
                            	    13M          ENDC
                            	    14M          IFC     'DF','PER'     Check for the "PER" command
                            	    15M          DC.W    '.*'+FLAG      * Reg commands (.A2 .D6 .PC .R0 etc.)
                            	    16M          DC.W    DFCMD-FIRST    *************************************
                            	    17M          ENDC
                            	    18M          IFNC    'DF','PER'     If not PERCMD...
                            	    19M          IFEQ    'DF'&($FF00)   If 1 digit code, 2nd will be a blank.
                            	    20M          DC.W    'DF '+FLAG     * "DF"....Command  -  -  (Single Digit)
                            	    21M          ENDC
                            	    22M          IFNE    'DF'&($FF00)   If 2 digit code, leave as is.
01:00200728 4446            	    23M          DC.W    'DF'+FLAG      * "DF"...Command
                            	    24M          ENDC
01:0020072A 0CFE            	    25M          DC.W    DFCMD-FIRST    *************************************
                            	    26M          ENDC
                            	  1184: 
                            	  1185:          CMD     DU,X,X
                            	     1M FLAG     SET     0              *
                            	     2M          IFC     'X','HELP=NO'
                            	     3M FLAG     SET     FLAG+$8000     * "Help" will not display this command
                            	     4M          ENDC
                            	     5M          IFC     'X','HELP=NO'
                            	     6M FLAG     SET     FLAG+$8000     * "Help" will not display this command
                            	     7M          ENDC
                            	     8M          IFC     'X','NORTN=YES'
                            	     9M FLAG     SET     FLAG+$80       * "NODU".Command
                            	    10M          ENDC
                            	    11M          IFC     'X','NORTN=YES'
                            	    12M FLAG     SET     FLAG+$80       * "NODU".Command
                            	    13M          ENDC
                            	    14M          IFC     'DU','PER'     Check for the "PER" command
                            	    15M          DC.W    '.*'+FLAG      * Reg commands (.A2 .D6 .PC .R0 etc.)
                            	    16M          DC.W    DUCMD-FIRST    *************************************
                            	    17M          ENDC
                            	    18M          IFNC    'DU','PER'     If not PERCMD...
                            	    19M          IFEQ    'DU'&($FF00)   If 1 digit code, 2nd will be a blank.
                            	    20M          DC.W    'DU '+FLAG     * "DU"....Command  -  -  (Single Digit)
                            	    21M          ENDC
                            	    22M          IFNE    'DU'&($FF00)   If 2 digit code, leave as is.
01:0020072C 4455            	    23M          DC.W    'DU'+FLAG      * "DU"...Command
                            	    24M          ENDC
01:0020072E 0E1C            	    25M          DC.W    DUCMD-FIRST    *************************************
                            	    26M          ENDC
                            	  1186: 
                            	  1187: 
                            	  1188: 
                            	  1189:          CMD     G,X,X
                            	     1M FLAG     SET     0              *
                            	     2M          IFC     'X','HELP=NO'
                            	     3M FLAG     SET     FLAG+$8000     * "Help" will not display this command
                            	     4M          ENDC
                            	     5M          IFC     'X','HELP=NO'
                            	     6M FLAG     SET     FLAG+$8000     * "Help" will not display this command
                            	     7M          ENDC
                            	     8M          IFC     'X','NORTN=YES'
                            	     9M FLAG     SET     FLAG+$80       * "NOG".Command
                            	    10M          ENDC
                            	    11M          IFC     'X','NORTN=YES'
                            	    12M FLAG     SET     FLAG+$80       * "NOG".Command
                            	    13M          ENDC
                            	    14M          IFC     'G','PER'     Check for the "PER" command
                            	    15M          DC.W    '.*'+FLAG      * Reg commands (.A2 .D6 .PC .R0 etc.)
                            	    16M          DC.W    GCMD-FIRST    *************************************
                            	    17M          ENDC
                            	    18M          IFNC    'G','PER'     If not PERCMD...
                            	    19M          IFEQ    'G'&($FF00)   If 1 digit code, 2nd will be a blank.
01:00200730 4720            	    20M          DC.W    'G '+FLAG     * "G"....Command  -  -  (Single Digit)
                            	    21M          ENDC
                            	    22M          IFNE    'G'&($FF00)   If 2 digit code, leave as is.
                            	    23M          DC.W    'G'+FLAG      * "G"...Command
                            	    24M          ENDC
01:00200732 0A20            	    25M          DC.W    GCMD-FIRST    *************************************
                            	    26M          ENDC
                            	  1190: 
                            	  1191:          CMD     GD,X,X
                            	     1M FLAG     SET     0              *
                            	     2M          IFC     'X','HELP=NO'
                            	     3M FLAG     SET     FLAG+$8000     * "Help" will not display this command
                            	     4M          ENDC
                            	     5M          IFC     'X','HELP=NO'
                            	     6M FLAG     SET     FLAG+$8000     * "Help" will not display this command
                            	     7M          ENDC
                            	     8M          IFC     'X','NORTN=YES'
                            	     9M FLAG     SET     FLAG+$80       * "NOGD".Command
                            	    10M          ENDC
                            	    11M          IFC     'X','NORTN=YES'
                            	    12M FLAG     SET     FLAG+$80       * "NOGD".Command
                            	    13M          ENDC
                            	    14M          IFC     'GD','PER'     Check for the "PER" command
                            	    15M          DC.W    '.*'+FLAG      * Reg commands (.A2 .D6 .PC .R0 etc.)
                            	    16M          DC.W    GDCMD-FIRST    *************************************
                            	    17M          ENDC
                            	    18M          IFNC    'GD','PER'     If not PERCMD...
                            	    19M          IFEQ    'GD'&($FF00)   If 1 digit code, 2nd will be a blank.
                            	    20M          DC.W    'GD '+FLAG     * "GD"....Command  -  -  (Single Digit)
                            	    21M          ENDC
                            	    22M          IFNE    'GD'&($FF00)   If 2 digit code, leave as is.
01:00200734 4744            	    23M          DC.W    'GD'+FLAG      * "GD"...Command
                            	    24M          ENDC
01:00200736 0A2E            	    25M          DC.W    GDCMD-FIRST    *************************************
                            	    26M          ENDC
                            	  1192: 
                            	  1193:          CMD     GO,X,X
                            	     1M FLAG     SET     0              *
                            	     2M          IFC     'X','HELP=NO'
                            	     3M FLAG     SET     FLAG+$8000     * "Help" will not display this command
                            	     4M          ENDC
                            	     5M          IFC     'X','HELP=NO'
                            	     6M FLAG     SET     FLAG+$8000     * "Help" will not display this command
                            	     7M          ENDC
                            	     8M          IFC     'X','NORTN=YES'
                            	     9M FLAG     SET     FLAG+$80       * "NOGO".Command
                            	    10M          ENDC
                            	    11M          IFC     'X','NORTN=YES'
                            	    12M FLAG     SET     FLAG+$80       * "NOGO".Command
                            	    13M          ENDC
                            	    14M          IFC     'GO','PER'     Check for the "PER" command
                            	    15M          DC.W    '.*'+FLAG      * Reg commands (.A2 .D6 .PC .R0 etc.)
                            	    16M          DC.W    GOCMD-FIRST    *************************************
                            	    17M          ENDC
                            	    18M          IFNC    'GO','PER'     If not PERCMD...
                            	    19M          IFEQ    'GO'&($FF00)   If 1 digit code, 2nd will be a blank.
                            	    20M          DC.W    'GO '+FLAG     * "GO"....Command  -  -  (Single Digit)
                            	    21M          ENDC
                            	    22M          IFNE    'GO'&($FF00)   If 2 digit code, leave as is.
01:00200738 474F            	    23M          DC.W    'GO'+FLAG      * "GO"...Command
                            	    24M          ENDC
01:0020073A 0A20            	    25M          DC.W    GOCMD-FIRST    *************************************
                            	    26M          ENDC
                            	  1194: 
                            	  1195:          CMD     GT,X,X
                            	     1M FLAG     SET     0              *
                            	     2M          IFC     'X','HELP=NO'
                            	     3M FLAG     SET     FLAG+$8000     * "Help" will not display this command
                            	     4M          ENDC
                            	     5M          IFC     'X','HELP=NO'
                            	     6M FLAG     SET     FLAG+$8000     * "Help" will not display this command
                            	     7M          ENDC
                            	     8M          IFC     'X','NORTN=YES'
                            	     9M FLAG     SET     FLAG+$80       * "NOGT".Command
                            	    10M          ENDC
                            	    11M          IFC     'X','NORTN=YES'
                            	    12M FLAG     SET     FLAG+$80       * "NOGT".Command
                            	    13M          ENDC
                            	    14M          IFC     'GT','PER'     Check for the "PER" command
                            	    15M          DC.W    '.*'+FLAG      * Reg commands (.A2 .D6 .PC .R0 etc.)
                            	    16M          DC.W    GTCMD-FIRST    *************************************
                            	    17M          ENDC
                            	    18M          IFNC    'GT','PER'     If not PERCMD...
                            	    19M          IFEQ    'GT'&($FF00)   If 1 digit code, 2nd will be a blank.
                            	    20M          DC.W    'GT '+FLAG     * "GT"....Command  -  -  (Single Digit)
                            	    21M          ENDC
                            	    22M          IFNE    'GT'&($FF00)   If 2 digit code, leave as is.
01:0020073C 4754            	    23M          DC.W    'GT'+FLAG      * "GT"...Command
                            	    24M          ENDC
01:0020073E 09D4            	    25M          DC.W    GTCMD-FIRST    *************************************
                            	    26M          ENDC
                            	  1196: 
                            	  1197:          CMD     HE,X,X
                            	     1M FLAG     SET     0              *
                            	     2M          IFC     'X','HELP=NO'
                            	     3M FLAG     SET     FLAG+$8000     * "Help" will not display this command
                            	     4M          ENDC
                            	     5M          IFC     'X','HELP=NO'
                            	     6M FLAG     SET     FLAG+$8000     * "Help" will not display this command
                            	     7M          ENDC
                            	     8M          IFC     'X','NORTN=YES'
                            	     9M FLAG     SET     FLAG+$80       * "NOHE".Command
                            	    10M          ENDC
                            	    11M          IFC     'X','NORTN=YES'
                            	    12M FLAG     SET     FLAG+$80       * "NOHE".Command
                            	    13M          ENDC
                            	    14M          IFC     'HE','PER'     Check for the "PER" command
                            	    15M          DC.W    '.*'+FLAG      * Reg commands (.A2 .D6 .PC .R0 etc.)
                            	    16M          DC.W    HECMD-FIRST    *************************************
                            	    17M          ENDC
                            	    18M          IFNC    'HE','PER'     If not PERCMD...
                            	    19M          IFEQ    'HE'&($FF00)   If 1 digit code, 2nd will be a blank.
                            	    20M          DC.W    'HE '+FLAG     * "HE"....Command  -  -  (Single Digit)
                            	    21M          ENDC
                            	    22M          IFNE    'HE'&($FF00)   If 2 digit code, leave as is.
01:00200740 4845            	    23M          DC.W    'HE'+FLAG      * "HE"...Command
                            	    24M          ENDC
01:00200742 1282            	    25M          DC.W    HECMD-FIRST    *************************************
                            	    26M          ENDC
                            	  1198: 
                            	  1199:          CMD     LO,X,X
                            	     1M FLAG     SET     0              *
                            	     2M          IFC     'X','HELP=NO'
                            	     3M FLAG     SET     FLAG+$8000     * "Help" will not display this command
                            	     4M          ENDC
                            	     5M          IFC     'X','HELP=NO'
                            	     6M FLAG     SET     FLAG+$8000     * "Help" will not display this command
                            	     7M          ENDC
                            	     8M          IFC     'X','NORTN=YES'
                            	     9M FLAG     SET     FLAG+$80       * "NOLO".Command
                            	    10M          ENDC
                            	    11M          IFC     'X','NORTN=YES'
                            	    12M FLAG     SET     FLAG+$80       * "NOLO".Command
                            	    13M          ENDC
                            	    14M          IFC     'LO','PER'     Check for the "PER" command
                            	    15M          DC.W    '.*'+FLAG      * Reg commands (.A2 .D6 .PC .R0 etc.)
                            	    16M          DC.W    LOCMD-FIRST    *************************************
                            	    17M          ENDC
                            	    18M          IFNC    'LO','PER'     If not PERCMD...
                            	    19M          IFEQ    'LO'&($FF00)   If 1 digit code, 2nd will be a blank.
                            	    20M          DC.W    'LO '+FLAG     * "LO"....Command  -  -  (Single Digit)
                            	    21M          ENDC
                            	    22M          IFNE    'LO'&($FF00)   If 2 digit code, leave as is.
01:00200744 4C4F            	    23M          DC.W    'LO'+FLAG      * "LO"...Command
                            	    24M          ENDC
01:00200746 13C6            	    25M          DC.W    LOCMD-FIRST    *************************************
                            	    26M          ENDC
                            	  1200: 
                            	  1201:          CMD     M,X,X
                            	     1M FLAG     SET     0              *
                            	     2M          IFC     'X','HELP=NO'
                            	     3M FLAG     SET     FLAG+$8000     * "Help" will not display this command
                            	     4M          ENDC
                            	     5M          IFC     'X','HELP=NO'
                            	     6M FLAG     SET     FLAG+$8000     * "Help" will not display this command
                            	     7M          ENDC
                            	     8M          IFC     'X','NORTN=YES'
                            	     9M FLAG     SET     FLAG+$80       * "NOM".Command
                            	    10M          ENDC
                            	    11M          IFC     'X','NORTN=YES'
                            	    12M FLAG     SET     FLAG+$80       * "NOM".Command
                            	    13M          ENDC
                            	    14M          IFC     'M','PER'     Check for the "PER" command
                            	    15M          DC.W    '.*'+FLAG      * Reg commands (.A2 .D6 .PC .R0 etc.)
                            	    16M          DC.W    MCMD-FIRST    *************************************
                            	    17M          ENDC
                            	    18M          IFNC    'M','PER'     If not PERCMD...
                            	    19M          IFEQ    'M'&($FF00)   If 1 digit code, 2nd will be a blank.
01:00200748 4D20            	    20M          DC.W    'M '+FLAG     * "M"....Command  -  -  (Single Digit)
                            	    21M          ENDC
                            	    22M          IFNE    'M'&($FF00)   If 2 digit code, leave as is.
                            	    23M          DC.W    'M'+FLAG      * "M"...Command
                            	    24M          ENDC
01:0020074A 1712            	    25M          DC.W    MCMD-FIRST    *************************************
                            	    26M          ENDC
                            	  1202: 
                            	  1203: 
                            	  1204: 
                            	  1205:          CMD     MD,X,X
                            	     1M FLAG     SET     0              *
                            	     2M          IFC     'X','HELP=NO'
                            	     3M FLAG     SET     FLAG+$8000     * "Help" will not display this command
                            	     4M          ENDC
                            	     5M          IFC     'X','HELP=NO'
                            	     6M FLAG     SET     FLAG+$8000     * "Help" will not display this command
                            	     7M          ENDC
                            	     8M          IFC     'X','NORTN=YES'
                            	     9M FLAG     SET     FLAG+$80       * "NOMD".Command
                            	    10M          ENDC
                            	    11M          IFC     'X','NORTN=YES'
                            	    12M FLAG     SET     FLAG+$80       * "NOMD".Command
                            	    13M          ENDC
                            	    14M          IFC     'MD','PER'     Check for the "PER" command
                            	    15M          DC.W    '.*'+FLAG      * Reg commands (.A2 .D6 .PC .R0 etc.)
                            	    16M          DC.W    MDCMD-FIRST    *************************************
                            	    17M          ENDC
                            	    18M          IFNC    'MD','PER'     If not PERCMD...
                            	    19M          IFEQ    'MD'&($FF00)   If 1 digit code, 2nd will be a blank.
                            	    20M          DC.W    'MD '+FLAG     * "MD"....Command  -  -  (Single Digit)
                            	    21M          ENDC
                            	    22M          IFNE    'MD'&($FF00)   If 2 digit code, leave as is.
01:0020074C 4D44            	    23M          DC.W    'MD'+FLAG      * "MD"...Command
                            	    24M          ENDC
01:0020074E 1564            	    25M          DC.W    MDCMD-FIRST    *************************************
                            	    26M          ENDC
                            	  1206: 
                            	  1207:          CMD     MM,X,X
                            	     1M FLAG     SET     0              *
                            	     2M          IFC     'X','HELP=NO'
                            	     3M FLAG     SET     FLAG+$8000     * "Help" will not display this command
                            	     4M          ENDC
                            	     5M          IFC     'X','HELP=NO'
                            	     6M FLAG     SET     FLAG+$8000     * "Help" will not display this command
                            	     7M          ENDC
                            	     8M          IFC     'X','NORTN=YES'
                            	     9M FLAG     SET     FLAG+$80       * "NOMM".Command
                            	    10M          ENDC
                            	    11M          IFC     'X','NORTN=YES'
                            	    12M FLAG     SET     FLAG+$80       * "NOMM".Command
                            	    13M          ENDC
                            	    14M          IFC     'MM','PER'     Check for the "PER" command
                            	    15M          DC.W    '.*'+FLAG      * Reg commands (.A2 .D6 .PC .R0 etc.)
                            	    16M          DC.W    MMCMD-FIRST    *************************************
                            	    17M          ENDC
                            	    18M          IFNC    'MM','PER'     If not PERCMD...
                            	    19M          IFEQ    'MM'&($FF00)   If 1 digit code, 2nd will be a blank.
                            	    20M          DC.W    'MM '+FLAG     * "MM"....Command  -  -  (Single Digit)
                            	    21M          ENDC
                            	    22M          IFNE    'MM'&($FF00)   If 2 digit code, leave as is.
01:00200750 4D4D            	    23M          DC.W    'MM'+FLAG      * "MM"...Command
                            	    24M          ENDC
01:00200752 1712            	    25M          DC.W    MMCMD-FIRST    *************************************
                            	    26M          ENDC
                            	  1208: 
                            	  1209:          CMD     MS,X,X
                            	     1M FLAG     SET     0              *
                            	     2M          IFC     'X','HELP=NO'
                            	     3M FLAG     SET     FLAG+$8000     * "Help" will not display this command
                            	     4M          ENDC
                            	     5M          IFC     'X','HELP=NO'
                            	     6M FLAG     SET     FLAG+$8000     * "Help" will not display this command
                            	     7M          ENDC
                            	     8M          IFC     'X','NORTN=YES'
                            	     9M FLAG     SET     FLAG+$80       * "NOMS".Command
                            	    10M          ENDC
                            	    11M          IFC     'X','NORTN=YES'
                            	    12M FLAG     SET     FLAG+$80       * "NOMS".Command
                            	    13M          ENDC
                            	    14M          IFC     'MS','PER'     Check for the "PER" command
                            	    15M          DC.W    '.*'+FLAG      * Reg commands (.A2 .D6 .PC .R0 etc.)
                            	    16M          DC.W    MSCMD-FIRST    *************************************
                            	    17M          ENDC
                            	    18M          IFNC    'MS','PER'     If not PERCMD...
                            	    19M          IFEQ    'MS'&($FF00)   If 1 digit code, 2nd will be a blank.
                            	    20M          DC.W    'MS '+FLAG     * "MS"....Command  -  -  (Single Digit)
                            	    21M          ENDC
                            	    22M          IFNE    'MS'&($FF00)   If 2 digit code, leave as is.
01:00200754 4D53            	    23M          DC.W    'MS'+FLAG      * "MS"...Command
                            	    24M          ENDC
01:00200756 1896            	    25M          DC.W    MSCMD-FIRST    *************************************
                            	    26M          ENDC
                            	  1210: 
                            	  1211:          CMD     OF,X,X
                            	     1M FLAG     SET     0              *
                            	     2M          IFC     'X','HELP=NO'
                            	     3M FLAG     SET     FLAG+$8000     * "Help" will not display this command
                            	     4M          ENDC
                            	     5M          IFC     'X','HELP=NO'
                            	     6M FLAG     SET     FLAG+$8000     * "Help" will not display this command
                            	     7M          ENDC
                            	     8M          IFC     'X','NORTN=YES'
                            	     9M FLAG     SET     FLAG+$80       * "NOOF".Command
                            	    10M          ENDC
                            	    11M          IFC     'X','NORTN=YES'
                            	    12M FLAG     SET     FLAG+$80       * "NOOF".Command
                            	    13M          ENDC
                            	    14M          IFC     'OF','PER'     Check for the "PER" command
                            	    15M          DC.W    '.*'+FLAG      * Reg commands (.A2 .D6 .PC .R0 etc.)
                            	    16M          DC.W    OFCMD-FIRST    *************************************
                            	    17M          ENDC
                            	    18M          IFNC    'OF','PER'     If not PERCMD...
                            	    19M          IFEQ    'OF'&($FF00)   If 1 digit code, 2nd will be a blank.
                            	    20M          DC.W    'OF '+FLAG     * "OF"....Command  -  -  (Single Digit)
                            	    21M          ENDC
                            	    22M          IFNE    'OF'&($FF00)   If 2 digit code, leave as is.
01:00200758 4F46            	    23M          DC.W    'OF'+FLAG      * "OF"...Command
                            	    24M          ENDC
01:0020075A 1AB8            	    25M          DC.W    OFCMD-FIRST    *************************************
                            	    26M          ENDC
                            	  1212: 
                            	  1213:          CMD     PA,NORTN=YES,X,X
                            	     1M FLAG     SET     0              *
                            	     2M          IFC     'NORTN=YES','HELP=NO'
                            	     3M FLAG     SET     FLAG+$8000     * "Help" will not display this command
                            	     4M          ENDC
                            	     5M          IFC     'X','HELP=NO'
                            	     6M FLAG     SET     FLAG+$8000     * "Help" will not display this command
                            	     7M          ENDC
                            	     8M          IFC     'NORTN=YES','NORTN=YES'
                            	     9M FLAG     SET     FLAG+$80       * "NOPA".Command
                            	    10M          ENDC
                            	    11M          IFC     'X','NORTN=YES'
                            	    12M FLAG     SET     FLAG+$80       * "NOPA".Command
                            	    13M          ENDC
                            	    14M          IFC     'PA','PER'     Check for the "PER" command
                            	    15M          DC.W    '.*'+FLAG      * Reg commands (.A2 .D6 .PC .R0 etc.)
                            	    16M          DC.W    PACMD-FIRST    *************************************
                            	    17M          ENDC
                            	    18M          IFNC    'PA','PER'     If not PERCMD...
                            	    19M          IFEQ    'PA'&($FF00)   If 1 digit code, 2nd will be a blank.
                            	    20M          DC.W    'PA '+FLAG     * "PA"....Command  -  -  (Single Digit)
                            	    21M          ENDC
                            	    22M          IFNE    'PA'&($FF00)   If 2 digit code, leave as is.
01:0020075C 50C1            	    23M          DC.W    'PA'+FLAG      * "PA"...Command
                            	    24M          ENDC
01:0020075E 25B4            	    25M          DC.W    PACMD-FIRST    *************************************
                            	    26M          ENDC
                            	  1214: 
                            	  1215:          CMD     PF,X,X
                            	     1M FLAG     SET     0              *
                            	     2M          IFC     'X','HELP=NO'
                            	     3M FLAG     SET     FLAG+$8000     * "Help" will not display this command
                            	     4M          ENDC
                            	     5M          IFC     'X','HELP=NO'
                            	     6M FLAG     SET     FLAG+$8000     * "Help" will not display this command
                            	     7M          ENDC
                            	     8M          IFC     'X','NORTN=YES'
                            	     9M FLAG     SET     FLAG+$80       * "NOPF".Command
                            	    10M          ENDC
                            	    11M          IFC     'X','NORTN=YES'
                            	    12M FLAG     SET     FLAG+$80       * "NOPF".Command
                            	    13M          ENDC
                            	    14M          IFC     'PF','PER'     Check for the "PER" command
                            	    15M          DC.W    '.*'+FLAG      * Reg commands (.A2 .D6 .PC .R0 etc.)
                            	    16M          DC.W    PFCMD-FIRST    *************************************
                            	    17M          ENDC
                            	    18M          IFNC    'PF','PER'     If not PERCMD...
                            	    19M          IFEQ    'PF'&($FF00)   If 1 digit code, 2nd will be a blank.
                            	    20M          DC.W    'PF '+FLAG     * "PF"....Command  -  -  (Single Digit)
                            	    21M          ENDC
                            	    22M          IFNE    'PF'&($FF00)   If 2 digit code, leave as is.
01:00200760 5046            	    23M          DC.W    'PF'+FLAG      * "PF"...Command
                            	    24M          ENDC
01:00200762 1B34            	    25M          DC.W    PFCMD-FIRST    *************************************
                            	    26M          ENDC
                            	  1216: 
                            	  1217: 
                            	  1218: 
                            	  1219:          CMD     T,X,X
                            	     1M FLAG     SET     0              *
                            	     2M          IFC     'X','HELP=NO'
                            	     3M FLAG     SET     FLAG+$8000     * "Help" will not display this command
                            	     4M          ENDC
                            	     5M          IFC     'X','HELP=NO'
                            	     6M FLAG     SET     FLAG+$8000     * "Help" will not display this command
                            	     7M          ENDC
                            	     8M          IFC     'X','NORTN=YES'
                            	     9M FLAG     SET     FLAG+$80       * "NOT".Command
                            	    10M          ENDC
                            	    11M          IFC     'X','NORTN=YES'
                            	    12M FLAG     SET     FLAG+$80       * "NOT".Command
                            	    13M          ENDC
                            	    14M          IFC     'T','PER'     Check for the "PER" command
                            	    15M          DC.W    '.*'+FLAG      * Reg commands (.A2 .D6 .PC .R0 etc.)
                            	    16M          DC.W    TCMD-FIRST    *************************************
                            	    17M          ENDC
                            	    18M          IFNC    'T','PER'     If not PERCMD...
                            	    19M          IFEQ    'T'&($FF00)   If 1 digit code, 2nd will be a blank.
01:00200764 5420            	    20M          DC.W    'T '+FLAG     * "T"....Command  -  -  (Single Digit)
                            	    21M          ENDC
                            	    22M          IFNE    'T'&($FF00)   If 2 digit code, leave as is.
                            	    23M          DC.W    'T'+FLAG      * "T"...Command
                            	    24M          ENDC
01:00200766 0984            	    25M          DC.W    TCMD-FIRST    *************************************
                            	    26M          ENDC
                            	  1220: 
                            	  1221:          CMD     TM,X,X
                            	     1M FLAG     SET     0              *
                            	     2M          IFC     'X','HELP=NO'
                            	     3M FLAG     SET     FLAG+$8000     * "Help" will not display this command
                            	     4M          ENDC
                            	     5M          IFC     'X','HELP=NO'
                            	     6M FLAG     SET     FLAG+$8000     * "Help" will not display this command
                            	     7M          ENDC
                            	     8M          IFC     'X','NORTN=YES'
                            	     9M FLAG     SET     FLAG+$80       * "NOTM".Command
                            	    10M          ENDC
                            	    11M          IFC     'X','NORTN=YES'
                            	    12M FLAG     SET     FLAG+$80       * "NOTM".Command
                            	    13M          ENDC
                            	    14M          IFC     'TM','PER'     Check for the "PER" command
                            	    15M          DC.W    '.*'+FLAG      * Reg commands (.A2 .D6 .PC .R0 etc.)
                            	    16M          DC.W    TMCMD-FIRST    *************************************
                            	    17M          ENDC
                            	    18M          IFNC    'TM','PER'     If not PERCMD...
                            	    19M          IFEQ    'TM'&($FF00)   If 1 digit code, 2nd will be a blank.
                            	    20M          DC.W    'TM '+FLAG     * "TM"....Command  -  -  (Single Digit)
                            	    21M          ENDC
                            	    22M          IFNE    'TM'&($FF00)   If 2 digit code, leave as is.
01:00200768 544D            	    23M          DC.W    'TM'+FLAG      * "TM"...Command
                            	    24M          ENDC
01:0020076A 1C6A            	    25M          DC.W    TMCMD-FIRST    *************************************
                            	    26M          ENDC
                            	  1222: 
                            	  1223:          CMD     TR,X,X
                            	     1M FLAG     SET     0              *
                            	     2M          IFC     'X','HELP=NO'
                            	     3M FLAG     SET     FLAG+$8000     * "Help" will not display this command
                            	     4M          ENDC
                            	     5M          IFC     'X','HELP=NO'
                            	     6M FLAG     SET     FLAG+$8000     * "Help" will not display this command
                            	     7M          ENDC
                            	     8M          IFC     'X','NORTN=YES'
                            	     9M FLAG     SET     FLAG+$80       * "NOTR".Command
                            	    10M          ENDC
                            	    11M          IFC     'X','NORTN=YES'
                            	    12M FLAG     SET     FLAG+$80       * "NOTR".Command
                            	    13M          ENDC
                            	    14M          IFC     'TR','PER'     Check for the "PER" command
                            	    15M          DC.W    '.*'+FLAG      * Reg commands (.A2 .D6 .PC .R0 etc.)
                            	    16M          DC.W    TRCMD-FIRST    *************************************
                            	    17M          ENDC
                            	    18M          IFNC    'TR','PER'     If not PERCMD...
                            	    19M          IFEQ    'TR'&($FF00)   If 1 digit code, 2nd will be a blank.
                            	    20M          DC.W    'TR '+FLAG     * "TR"....Command  -  -  (Single Digit)
                            	    21M          ENDC
                            	    22M          IFNE    'TR'&($FF00)   If 2 digit code, leave as is.
01:0020076C 5452            	    23M          DC.W    'TR'+FLAG      * "TR"...Command
                            	    24M          ENDC
01:0020076E 0984            	    25M          DC.W    TRCMD-FIRST    *************************************
                            	    26M          ENDC
                            	  1224: 
                            	  1225:          CMD     TT,X,X
                            	     1M FLAG     SET     0              *
                            	     2M          IFC     'X','HELP=NO'
                            	     3M FLAG     SET     FLAG+$8000     * "Help" will not display this command
                            	     4M          ENDC
                            	     5M          IFC     'X','HELP=NO'
                            	     6M FLAG     SET     FLAG+$8000     * "Help" will not display this command
                            	     7M          ENDC
                            	     8M          IFC     'X','NORTN=YES'
                            	     9M FLAG     SET     FLAG+$80       * "NOTT".Command
                            	    10M          ENDC
                            	    11M          IFC     'X','NORTN=YES'
                            	    12M FLAG     SET     FLAG+$80       * "NOTT".Command
                            	    13M          ENDC
                            	    14M          IFC     'TT','PER'     Check for the "PER" command
                            	    15M          DC.W    '.*'+FLAG      * Reg commands (.A2 .D6 .PC .R0 etc.)
                            	    16M          DC.W    TTCMD-FIRST    *************************************
                            	    17M          ENDC
                            	    18M          IFNC    'TT','PER'     If not PERCMD...
                            	    19M          IFEQ    'TT'&($FF00)   If 1 digit code, 2nd will be a blank.
                            	    20M          DC.W    'TT '+FLAG     * "TT"....Command  -  -  (Single Digit)
                            	    21M          ENDC
                            	    22M          IFNE    'TT'&($FF00)   If 2 digit code, leave as is.
01:00200770 5454            	    23M          DC.W    'TT'+FLAG      * "TT"...Command
                            	    24M          ENDC
01:00200772 09A0            	    25M          DC.W    TTCMD-FIRST    *************************************
                            	    26M          ENDC
                            	  1226: 
                            	  1227:          CMD     VE,X,X
                            	     1M FLAG     SET     0              *
                            	     2M          IFC     'X','HELP=NO'
                            	     3M FLAG     SET     FLAG+$8000     * "Help" will not display this command
                            	     4M          ENDC
                            	     5M          IFC     'X','HELP=NO'
                            	     6M FLAG     SET     FLAG+$8000     * "Help" will not display this command
                            	     7M          ENDC
                            	     8M          IFC     'X','NORTN=YES'
                            	     9M FLAG     SET     FLAG+$80       * "NOVE".Command
                            	    10M          ENDC
                            	    11M          IFC     'X','NORTN=YES'
                            	    12M FLAG     SET     FLAG+$80       * "NOVE".Command
                            	    13M          ENDC
                            	    14M          IFC     'VE','PER'     Check for the "PER" command
                            	    15M          DC.W    '.*'+FLAG      * Reg commands (.A2 .D6 .PC .R0 etc.)
                            	    16M          DC.W    VECMD-FIRST    *************************************
                            	    17M          ENDC
                            	    18M          IFNC    'VE','PER'     If not PERCMD...
                            	    19M          IFEQ    'VE'&($FF00)   If 1 digit code, 2nd will be a blank.
                            	    20M          DC.W    'VE '+FLAG     * "VE"....Command  -  -  (Single Digit)
                            	    21M          ENDC
                            	    22M          IFNE    'VE'&($FF00)   If 2 digit code, leave as is.
01:00200774 5645            	    23M          DC.W    'VE'+FLAG      * "VE"...Command
                            	    24M          ENDC
01:00200776 13C0            	    25M          DC.W    VECMD-FIRST    *************************************
                            	    26M          ENDC
                            	  1228: 
01:00200778 FFFF            	  1229:          DC.W      $FFFF     End of list indicator
                            	  1230: 
                            	  1231: 
                            	  1232: 
                            	  1233: 
                            	  1234: *-------------------------------------------------------------------------
                            	  1235: * File VECTMSG   Messages for vectors                             05/29/82
                            	  1236: 
                            	  1237: ************************************************************
                            	  1238: *Reprogram some VECTORS to specific ERROR handler routines *
                            	  1239: ************************************************************
                            	  1240: 
01:0020077A 41FA0022        	  1241: INITVMSG LEA     VECT(PC),A0    A0 = START OF VECTOR TABLE
01:0020077E 43F80010        	  1242:          LEA     AV4,A1         A1 = FIRST VECTOR TO INITIALIZE
01:00200782 700A            	  1243:          MOVEQ   #10,D0         D0 = COUNT
01:00200784 22C8            	  1244: VECTI    MOVE.L  A0,(A1)+       MOVE ADDRESS TO VECTOR
01:00200786 D1C0            	  1245:          ADD.L   D0,A0          BUMP ADDRESS
01:00200788 B2FC0030        	  1246:          CMPA.L  #AV11+4,A1
01:0020078C 66F6            	  1247:          BNE     VECTI
                            	  1248: 
01:0020078E 43F80060        	  1249:          LEA     AV24,A1        A1 = NEXT VECTOR TO INITIALIZE
01:00200792 22C8            	  1250: VECTI2   MOVE.L  A0,(A1)+       MOVE ADDRESS TO VECTOR
01:00200794 D1C0            	  1251:          ADD.L   D0,A0          BUMP ADDRESS
01:00200796 B2FC00C0        	  1252:          CMPA.L  #AV48,A1
01:0020079A 66F6            	  1253:          BNE     VECTI2
01:0020079C 4E75            	  1254:          RTS
                            	  1255: 
                            	  1256: 
                            	  1257: *************************************************************************
                            	  1258: * STANDARD VECTOR "MESSAGE" HANDLING ROUTINE ($30 IS TEMP STORAGE AREA) *
                            	  1259: *************************************************************************
                            	  1260: 
01:0020079E 21FC4F50434F0030	  1261: VECT     MOVE.L  #'OPCO',$30    MOVE TO $30, USE SHORT BRANCHES AND PRINT IT
                            	  1262: 
01:002007A6 604E            	  1263:          BRA.S   EVECT5
01:002007A8 21FC444956300030	  1264: VECT5    MOVE.L  #'DIV0',$30    MOVE TO $30, USE SHORT BRANCHES AND PRINT IT
                            	  1265: 
01:002007B0 6044            	  1266:          BRA.S   EVECT5
01:002007B2 21FC4348434B0030	  1267: VECT6    MOVE.L  #'CHCK',$30    MOVE TO $30, USE SHORT BRANCHES AND PRINT IT
                            	  1268: 
01:002007BA 603A            	  1269:          BRA.S   EVECT5
01:002007BC 21FC545020560030	  1270: VECT7    MOVE.L  #'TP V',$30    MOVE TO $30, USE SHORT BRANCHES AND PRINT IT
                            	  1271: 
01:002007C4 6030            	  1272:          BRA.S   EVECT5
01:002007C6 21FC505249560030	  1273: VECT8    MOVE.L  #'PRIV',$30    MOVE TO $30, USE SHORT BRANCHES AND PRINT IT
                            	  1274: 
01:002007CE 6026            	  1275:          BRA.S   EVECT5
01:002007D0 21FC545241430030	  1276: VECT9    MOVE.L  #'TRAC',$30    MOVE TO $30, USE SHORT BRANCHES AND PRINT IT
                            	  1277: 
01:002007D8 601C            	  1278:          BRA.S   EVECT5
01:002007DA 21FC313031300030	  1279: VECT10   MOVE.L  #'1010',$30    MOVE TO $30, USE SHORT BRANCHES AND PRINT IT
                            	  1280: 
01:002007E2 6012            	  1281:          BRA.S   EVECT5
01:002007E4 21FC313131310030	  1282: VECT11   MOVE.L  #'1111',$30    MOVE TO $30, USE SHORT BRANCHES AND PRINT IT
                            	  1283: 
01:002007EC 6008            	  1284:          BRA.S   EVECT5
01:002007EE 21FC535055520030	  1285: VECT24   MOVE.L  #'SPUR',$30    MOVE TO $30, USE SHORT BRANCHES AND PRINT IT
                            	  1286: 
01:002007F6 6044            	  1287: EVECT5   BRA.S   EVECT6
01:002007F8 21FC415623310030	  1288: VECT25   MOVE.L  #'AV#1',$30    MOVE TO $30, USE SHORT BRANCHES AND PRINT IT
                            	  1289: 
01:00200800 603A            	  1290:          BRA.S   EVECT6
01:00200802 21FC415623320030	  1291: VECT26   MOVE.L  #'AV#2',$30    MOVE TO $30, USE SHORT BRANCHES AND PRINT IT
                            	  1292: 
01:0020080A 6030            	  1293:          BRA.S   EVECT6
01:0020080C 21FC415623330030	  1294: VECT27   MOVE.L  #'AV#3',$30    MOVE TO $30, USE SHORT BRANCHES AND PRINT IT
                            	  1295: 
01:00200814 6026            	  1296:          BRA.S   EVECT6
01:00200816 21FC415623340030	  1297: VECT28   MOVE.L  #'AV#4',$30    MOVE TO $30, USE SHORT BRANCHES AND PRINT IT
                            	  1298: 
01:0020081E 601C            	  1299:          BRA.S   EVECT6
01:00200820 21FC415623350030	  1300: VECT29   MOVE.L  #'AV#5',$30    MOVE TO $30, USE SHORT BRANCHES AND PRINT IT
                            	  1301: 
01:00200828 6012            	  1302:          BRA.S   EVECT6
01:0020082A 21FC415623360030	  1303: VECT30   MOVE.L  #'AV#6',$30    MOVE TO $30, USE SHORT BRANCHES AND PRINT IT
                            	  1304: 
01:00200832 6008            	  1305:          BRA.S   EVECT6
01:00200834 21FC415623370030	  1306: VECT31   MOVE.L  #'AV#7',$30    MOVE TO $30, USE SHORT BRANCHES AND PRINT IT
                            	  1307: 
01:0020083C 604E            	  1308: EVECT6   BRA.S   EVECT7
01:0020083E 21FC555420300030	  1309: VECT32   MOVE.L  #'UT 0',$30    MOVE TO $30, USE SHORT BRANCHES AND PRINT IT
                            	  1310: 
01:00200846 6044            	  1311:          BRA.S   EVECT7
01:00200848 21FC555420310030	  1312: VECT33   MOVE.L  #'UT 1',$30    MOVE TO $30, USE SHORT BRANCHES AND PRINT IT
                            	  1313: 
01:00200850 603A            	  1314:          BRA.S   EVECT7
01:00200852 21FC555420320030	  1315: VECT34   MOVE.L  #'UT 2',$30    MOVE TO $30, USE SHORT BRANCHES AND PRINT IT
                            	  1316: 
01:0020085A 6030            	  1317:          BRA.S   EVECT7
01:0020085C 21FC555420330030	  1318: VECT35   MOVE.L  #'UT 3',$30    MOVE TO $30, USE SHORT BRANCHES AND PRINT IT
                            	  1319: 
01:00200864 6026            	  1320:          BRA.S   EVECT7
01:00200866 21FC555420340030	  1321: VECT36   MOVE.L  #'UT 4',$30    MOVE TO $30, USE SHORT BRANCHES AND PRINT IT
                            	  1322: 
01:0020086E 601C            	  1323:          BRA.S   EVECT7
01:00200870 21FC555420350030	  1324: VECT37   MOVE.L  #'UT 5',$30    MOVE TO $30, USE SHORT BRANCHES AND PRINT IT
                            	  1325: 
01:00200878 6012            	  1326:          BRA.S   EVECT7
01:0020087A 21FC555420360030	  1327: VECT38   MOVE.L  #'UT 6',$30    MOVE TO $30, USE SHORT BRANCHES AND PRINT IT
                            	  1328: 
01:00200882 6008            	  1329:          BRA.S   EVECT7
01:00200884 21FC555420370030	  1330: VECT39   MOVE.L  #'UT 7',$30    MOVE TO $30, USE SHORT BRANCHES AND PRINT IT
                            	  1331: 
01:0020088C 604E            	  1332: EVECT7   BRA.S   EVECT
01:0020088E 21FC555420380030	  1333: VECT40   MOVE.L  #'UT 8',$30    MOVE TO $30, USE SHORT BRANCHES AND PRINT IT
                            	  1334: 
01:00200896 6044            	  1335:          BRA.S   EVECT
01:00200898 21FC555420390030	  1336: VECT41   MOVE.L  #'UT 9',$30    MOVE TO $30, USE SHORT BRANCHES AND PRINT IT
                            	  1337: 
01:002008A0 603A            	  1338:          BRA.S   EVECT
01:002008A2 21FC555420410030	  1339: VECT42   MOVE.L  #'UT A',$30    MOVE TO $30, USE SHORT BRANCHES AND PRINT IT
                            	  1340: 
01:002008AA 6030            	  1341:          BRA.S   EVECT
01:002008AC 21FC555420420030	  1342: VECT43   MOVE.L  #'UT B',$30    MOVE TO $30, USE SHORT BRANCHES AND PRINT IT
                            	  1343: 
01:002008B4 6026            	  1344:          BRA.S   EVECT
01:002008B6 21FC555420430030	  1345: VECT44   MOVE.L  #'UT C',$30    MOVE TO $30, USE SHORT BRANCHES AND PRINT IT
                            	  1346: 
01:002008BE 601C            	  1347:          BRA.S   EVECT
01:002008C0 21FC555420440030	  1348: VECT45   MOVE.L  #'UT D',$30    MOVE TO $30, USE SHORT BRANCHES AND PRINT IT
                            	  1349: 
01:002008C8 6012            	  1350:          BRA.S   EVECT
01:002008CA 21FC555420450030	  1351: VECT46   MOVE.L  #'UT E',$30    MOVE TO $30, USE SHORT BRANCHES AND PRINT IT
                            	  1352: 
01:002008D2 6108            	  1353:          BSR.S   EVECT
01:002008D4 21FC555420460030	  1354: VECT47   MOVE.L  #'UT F',$30    MOVE TO $30, USE SHORT BRANCHES AND PRINT IT
                            	  1355: 
                            	  1356: 
                            	  1357: *
                            	  1358: *    SAVE REGISTERS AND PRINT VECTOR MSG
                            	  1359: *
01:002008DC 60001486        	  1360: EVECT    BRA     EVECTL
                            	  1361: 
                            	  1362: 
                            	  1363: 
                            	  1364: 
                            	  1365: *-------------------------------------------------------------------------
                            	  1366: * File BF        Block Fill command                               06/16/82
                            	  1367: 
                            	  1368: *  BLOCK FILL    ADDRESS1 ADDRESS2 WORD-DATA
                            	  1369: 
01:002008E0 41FAFBCC        	  1370: BFCMD    LEA     SYNTAX(PC),A0
01:002008E4 61001588        	  1371:          BSR     FNEXTF
01:002008E8 6100064C        	  1372:          BSR     GETA
01:002008EC 6100159E        	  1373:          BSR     CKWADR         CHECK WORD BOUNDRY ADDRESS
01:002008F0 2C00            	  1374:          MOVE.L  D0,D6          D6 = FROM BEGIN ADDRESS
                            	  1375: 
01:002008F2 6100157A        	  1376:          BSR     FNEXTF
01:002008F6 6100063E        	  1377:          BSR     GETA
01:002008FA 61001590        	  1378:          BSR     CKWADR         CHECK WORD BOUNDRY ADDRESS
01:002008FE 2240            	  1379:          MOVE.L  D0,A1          A1 = FROM END ADDRESS
                            	  1380: 
01:00200900 6100156C        	  1381:          BSR     FNEXTF         FIND NEXT FIELD
01:00200904 610015EA        	  1382:          BSR     GETNUMA        D0 = VALUE
01:00200908 2E00            	  1383:          MOVE.L  D0,D7
                            	  1384: 
01:0020090A 2046            	  1385:          MOVE.L  D6,A0          A0 = FROM BEGIN ADDRESS
01:0020090C 6100FBAE        	  1386:          BSR     P2PHY          DISPLAY ADDRESSES
01:00200910 B3C8            	  1387:          CMP.L   A0,A1
01:00200912 6500FB9A        	  1388:          BCS     SYNTAX         END ADDR TOO SMALL
                            	  1389: 
01:00200916 0C8700010000    	  1390:          CMPI.L  #$10000,D7
01:0020091C 6400FB90        	  1391:          BCC     SYNTAX         WORD OVERFLOW
                            	  1392: 
                            	  1393: BFCMD11
01:00200920 3087            	  1394:          MOVE.W  D7,(A0)        STORE DATA
01:00200922 3218            	  1395:          MOVE.W  (A0)+,D1
01:00200924 B247            	  1396:          CMP.W   D7,D1          VERIFY DATA
01:00200926 66000F5C        	  1397:          BNE     MM90           'DATA DID NOT STORE'
                            	  1398: 
01:0020092A B3C8            	  1399:          CMP.L   A0,A1
01:0020092C 64F2            	  1400:          BCC     BFCMD11
01:0020092E 6000FCFE        	  1401:          BRA     MACSBUG
                            	  1402: 
                            	  1403: 
                            	  1404: 
                            	  1405: 
                            	  1406: *-------------------------------------------------------------------------
                            	  1407: * File BM        BM (Block Move) Command                          11/27/81
                            	  1408: 
                            	  1409: *  BLOCK MOVE
                            	  1410: 
01:00200932 41FAFB7A        	  1411: BMCMD    LEA     SYNTAX(PC),A0
01:00200936 61001536        	  1412:          BSR     FNEXTF
01:0020093A 610005FA        	  1413:          BSR     GETA
01:0020093E 2640            	  1414:          MOVE.L  D0,A3          A3 = FROM BEGIN ADDRESS
                            	  1415: 
01:00200940 6100152C        	  1416:          BSR     FNEXTF
01:00200944 610005F0        	  1417:          BSR     GETA
01:00200948 2240            	  1418:          MOVE.L  D0,A1          A1 = FROM END ADDRESS
                            	  1419: 
01:0020094A 61001522        	  1420:          BSR     FNEXTF
01:0020094E 610005E6        	  1421:          BSR     GETA
01:00200952 2440            	  1422:          MOVE.L  D0,A2          A2 = TO BEGIN ADDRESS
                            	  1423: 
01:00200954 204B            	  1424:          MOVE.L  A3,A0
01:00200956 6100FB64        	  1425:          BSR     P2PHY          PRINT ADDRESSES (A0) & (A1)
01:0020095A 200A            	  1426:          MOVE.L  A2,D0
01:0020095C 6100FB56        	  1427:          BSR     PPHY           PRINT TO ADDRESS
                            	  1428: 
01:00200960 2209            	  1429:          MOVE.L  A1,D1
01:00200962 928B            	  1430:          SUB.L   A3,D1          D1 =  SIZE - 1
01:00200964 6500FB48        	  1431:          BCS     SYNTAX         END LESS THAN BEGIN
01:00200968 5281            	  1432:          ADDQ.L  #1,D1          D1 = COUNT (SIZE)
                            	  1433: 
01:0020096A B5CB            	  1434:          CMP.L   A3,A2
01:0020096C 6408            	  1435:          BCC.S   BM122          MOVING LOW TO HIGH
                            	  1436: 
01:0020096E 14DB            	  1437: BM112    MOVE.B  (A3)+,(A2)+    MOVING HIGH TO LOW
01:00200970 5381            	  1438:          SUBQ.L  #1,D1          COUNT
01:00200972 66FA            	  1439:          BNE     BM112
01:00200974 600A            	  1440:          BRA.S   BM142
                            	  1441: 
01:00200976 D7C1            	  1442: BM122    ADD.L   D1,A3          MOVING LOW TO HIGH
01:00200978 D5C1            	  1443:          ADD.L   D1,A2
01:0020097A 1523            	  1444: BM132    MOVE.B  -(A3),-(A2)
01:0020097C 5381            	  1445:          SUBQ.L  #1,D1
01:0020097E 66FA            	  1446:          BNE     BM132
01:00200980 6000FCAC        	  1447: BM142    BRA     MACSBUG
                            	  1448: 
                            	  1449: 
                            	  1450: 
                            	  1451: 
                            	  1452: *-------------------------------------------------------------------------
                            	  1453: * File BR        BR, GD, GT, TR, TT, PER Commands                 12/04/81
                            	  1454: 
                            	  1455: *   ***T***   TRACE COMMAND
                            	  1456: 
                            	  1457: TCMD     DS      0              "T" Alias for "TR" command
01:00200984 41FA0012        	  1458: TRCMD    LEA     TCMDHOT(PC),A0 IF NO PARAMTERS
01:00200988 610014E4        	  1459:          BSR     FNEXTF         FIND NEXT FIELD
01:0020098C 61001562        	  1460:          BSR     GETNUMA        FIND NUMBER OF INST TO TRACE
01:00200990 61001500        	  1461:          BSR     CKADDR         INSURE 24 BITS OR LESS
01:00200994 4A80            	  1462:          TST.L   D0
01:00200996 6602            	  1463:          BNE.S   TCMD15
                            	  1464: 
                            	  1465: TCMDHOT  DS      0              SPECIAL ENTRY FROM DECODE
01:00200998 7001            	  1466:          MOVEQ   #1,D0          ZERO; MAKE TRACE ONE
01:0020099A 21C004DA        	  1467: TCMD15   MOVE.L  D0,TRACECNT
01:0020099E 6022            	  1468:          BRA.S   TRACE2
                            	  1469: 
                            	  1470: 
                            	  1471: *
                            	  1472: ** TT ** "TRACE TILL" COMMAND
                            	  1473: *
                            	  1474: 
01:002009A0 41FAFB0C        	  1475: TTCMD    LEA     SYNTAX(PC),A0
01:002009A4 610014C8        	  1476:          BSR     FNEXTF         FIND NEXT FIELD
01:002009A8 6100058C        	  1477:          BSR     GETA           GET ADDRESS
01:002009AC 610014DE        	  1478:          BSR     CKWADR         CHECK WORD BOUNDRY ADDRESS
                            	  1479: 
01:002009B0 2C00            	  1480:          MOVE.L  D0,D6
01:002009B2 6100FB00        	  1481:          BSR     PPHY           DISPLAY TILL ADDRESS
                            	  1482: 
01:002009B6 21C60490        	  1483:          MOVE.L  D6,BPTILL      9TH BP
01:002009BA 21FC0000FFFF04DA	  1484:          MOVE.L  #$FFFF,TRACECNT  SET FOR A VERY LONG TIME
                            	  1485: 
                            	  1486: 
01:002009C2 31FCFFFF04DE    	  1487: TRACE2   MOVE.W  #-1,TRACEON    FOR DECODE OF NEXT COMMAND
                            	  1488: 
01:002009C8 20380400        	  1489:          MOVE.L  REGPC,D0
01:002009CC 6100FAE6        	  1490:          BSR     PPHY           DISPLAY START (PC) ADDRESS
01:002009D0 60000778        	  1491:          BRA     UNTRACE
                            	  1492: 
                            	  1493: 
                            	  1494: *
                            	  1495: *   ***GT***  RUN PROGRAM TO TEMP BREAKPOINT
                            	  1496: *
                            	  1497: 
01:002009D4 41FAFAD8        	  1498: GTCMD    LEA     SYNTAX(PC),A0  GET NUMBER ELSE PRINT "WHAT"
01:002009D8 61001494        	  1499:          BSR     FNEXTF         FIND NEXT FIELD
01:002009DC 61000558        	  1500:          BSR     GETA           GET ADDRESS
01:002009E0 610014AA        	  1501:          BSR     CKWADR         CHECK WORD BOUNDRY ADDRESS
01:002009E4 2C00            	  1502:          MOVE.L  D0,D6          D6 = UNTIL ADDRESS
01:002009E6 6100FACC        	  1503:          BSR     PPHY           PRINT PHYSICAL ADDRESS
                            	  1504: 
                            	  1505: * IF TILL ADDRESS IN BREAKPOINT TABLE; DISPLAY WHAT
                            	  1506: 
01:002009EA 41F80470        	  1507:          LEA     BPADD,A0       A0 = POINTER TO BP ADDRESSES
01:002009EE 7E08            	  1508:          MOVEQ   #8,D7          D7 = # OF ADDRESS ALLOWED
01:002009F0 BC98            	  1509: GT21     CMP.L   (A0)+,D6
01:002009F2 670000A0        	  1510:          BEQ     BCMD55         ALREADY IN TABLE -SHOW TABLE-
01:002009F6 5387            	  1511:          SUBQ.L  #1,D7
01:002009F8 66F6            	  1512:          BNE     GT21
                            	  1513: 
01:002009FA 21C60490        	  1514:          MOVE.L  D6,BPTILL      9TH BREAKPOINT
01:002009FE 6116            	  1515:          BSR.S   GOCMD1A        NORMAL STARTUP
01:00200A00 6020            	  1516:          BRA.S   GOCMD1
                            	  1517: 
01:00200A02 41FA0012        	  1518: GOSET1   LEA     GOCMD1A(PC),A0 WHERE TO GO IF NO PARAMERS
01:00200A06 61001466        	  1519:          BSR     FNEXTF         FIND NEXT FIELD
01:00200A0A 6100052A        	  1520:          BSR     GETA           GET ADDRESS
01:00200A0E 6100147C        	  1521:          BSR     CKWADR         CHECK WORD BOUNDRY ADDRESS
01:00200A12 21C00400        	  1522:          MOVE.L  D0,REGPC
                            	  1523: 
01:00200A16 20380400        	  1524: GOCMD1A  MOVE.L  REGPC,D0       (ALSO SUBROUTINE ENTRY)
01:00200A1A 6100FA98        	  1525:          BSR     PPHY           PRINT ".PC" PHYSICAL ADDRESS
01:00200A1E 4E75            	  1526:          RTS
                            	  1527: 
                            	  1528: GCMD     DS      0              "G" ALIAS FOR "GO"
01:00200A20 61E0            	  1529: GOCMD    BSR     GOSET1         "GO" (AFTER TRACING ONE INST)
01:00200A22 21FCFFFFFFFF04DA	  1530: GOCMD1   MOVE.L  #-1,TRACECNT   "FLAG" COUNTER AS SPECIAL
                            	  1531: 
01:00200A2A 6000071E        	  1532:          BRA     UNTRACE
                            	  1533: 
01:00200A2E 61D2            	  1534: GDCMD    BSR     GOSET1         "GO DIRECT" Command
01:00200A30 60000726        	  1535:          BRA     UNSTACK
                            	  1536: 
                            	  1537: 
                            	  1538: *   ***BR***  SET AND PRINT BREAKPOINTS
                            	  1539: 
                            	  1540: *                   DELETE ALL BREAKPOINTS
                            	  1541: 
01:00200A34 6108            	  1542: NOBRCMD  BSR.S   FIXBP          GET POINTERS
01:00200A36 4298            	  1543: BCMD01   CLR.L   (A0)+          CLEAR THE ADDRESS TABLE
01:00200A38 5387            	  1544:          SUBQ.L  #1,D7          DO IT 8 TIMES
01:00200A3A 66FA            	  1545:          BNE     BCMD01
01:00200A3C 6060            	  1546:          BRA.S   BCMD7          DISPLAY EMPTY TABLE
                            	  1547: 
01:00200A3E 41F80470        	  1548: FIXBP    LEA     BPADD,A0       SET UP ADDRESS & COUNTER
01:00200A42 7E08            	  1549:          MOVEQ   #8,D7          COUNTER
01:00200A44 45F80494        	  1550:          LEA     BPCNT,A2       COUNTS
01:00200A48 4E75            	  1551:          RTS
                            	  1552: 
                            	  1553: ************************************************************
                            	  1554: * THIS COMMAND SUPPORTS THE "NO" OPTION. COMMANDS THAT ALLOW
                            	  1555: * THE "NO" OPTION PROVIDE A HARD BRANCH 4 BYTES BEFORE THE
                            	  1556: * REGULAR COMMAND.
                            	  1557: ************************************************************
                            	  1558: 
01:00200A4A 6000009A        	  1559:          BRA     NOBR0          ENTRY FOR "NOBR" (IT LOOKS FOR PARMS OR NOT)
01:00200A4E 41FA004E        	  1560: BRCMD    LEA     BCMD7(PC),A0   WHERE TO GO IF NO PARMS
01:00200A52 6100141A        	  1561: BCMD0    BSR     FNEXTF         FIND NEXT FIELD
01:00200A56 610004DE        	  1562:          BSR     GETA           GET ADDRESS
01:00200A5A 61001430        	  1563:          BSR     CKWADR         CHECK WORD BOUNDRY ADDRESS
                            	  1564: 
01:00200A5E 61DE            	  1565:          BSR     FIXBP          SET UP COUNTER & ADDRESS
01:00200A60 B090            	  1566: BCMD00   CMP.L   (A0),D0        SEE IF ALREADY IN TABLE
01:00200A62 6710            	  1567:          BEQ.S   BCMD33         GO CHECK FOR COUNT
01:00200A64 588A            	  1568:          ADDQ.L  #4,A2          BUMP OTHER POINTER
01:00200A66 5888            	  1569:          ADDQ.L  #4,A0          BUMP MAIN POINTER
01:00200A68 5387            	  1570:          SUBQ.L  #1,D7
01:00200A6A 66F4            	  1571:          BNE     BCMD00
                            	  1572: 
01:00200A6C 61D0            	  1573:          BSR     FIXBP          GET ADDRESS & POINTERS
01:00200A6E 4A90            	  1574: BCMD3    TST.L   (A0)           FIND AN EMPTY STOP
01:00200A70 661A            	  1575:          BNE.S   BCMD5
01:00200A72 2080            	  1576:          MOVE.L  D0,(A0)        PUT NEW ADDRESS IN TABLE
01:00200A74 4292            	  1577: BCMD33   CLR.L   (A2)           CLEAR CURRENT COUNT
01:00200A76 1215            	  1578:          MOVE.B  (A5),D1        CHECK INPUT FOR COUNT
01:00200A78 0C01003B        	  1579:          CMPI.B  #';',D1
01:00200A7C 6608            	  1580:          BNE.S   BCMD6          NO COUNT
01:00200A7E 528D            	  1581:          ADDQ.L  #1,A5          BUMP THE BUFFER SCANNER
01:00200A80 6100146E        	  1582:          BSR     GETNUMA        GO GET THE COUNT
01:00200A84 2480            	  1583:          MOVE.L  D0,(A2)        MOVE TO TABLE
                            	  1584: 
01:00200A86 41FA0016        	  1585: BCMD6    LEA     BCMD7(PC),A0   WHERE TO GO IF NO MORE PARAMETERS
01:00200A8A 60C6            	  1586:          BRA     BCMD0
                            	  1587: 
01:00200A8C 5888            	  1588: BCMD5    ADDQ.L  #4,A0          BUMP TABLE POINTER
01:00200A8E 588A            	  1589:          ADDQ.L  #4,A2          BUMP POINTER TO COUNTS
01:00200A90 5387            	  1590:          SUBQ.L  #1,D7          LOOP AROUND
01:00200A92 66DA            	  1591:          BNE     BCMD3
                            	  1592: 
01:00200A94 4BFAF9F3        	  1593: BCMD55   LEA     MSG008E(PC),A5 TABLE FULL; ERROR MESSAGE
01:00200A98 6100FA50        	  1594:          BSR     FIXDATA
01:00200A9C 6008            	  1595:          BRA.S   BCMD77
                            	  1596: 
01:00200A9E 4BFA003A        	  1597: BCMD7    LEA     MSGBR(PC),A5   "BREAKPOINTS"
01:00200AA2 6100FA5A        	  1598:          BSR     FIXDCRLF
01:00200AA6 61001542        	  1599: BCMD77   BSR     OUT1CR
                            	  1600: 
01:00200AAA 6192            	  1601:          BSR     FIXBP          SET ADDRESS & COUNTER
01:00200AAC 2C1A            	  1602: BCMD8    MOVE.L  (A2)+,D6       D6 = COUNT
01:00200AAE 2010            	  1603:          MOVE.L  (A0),D0        D0 = ADDRESS
01:00200AB0 671E            	  1604:          BEQ.S   BCMD9          ZERO ADDRESS
01:00200AB2 6100131A        	  1605:          BSR     FRELADDR       FORMAT RELATIVE ADDRESS
01:00200AB6 1CFC0020        	  1606:          MOVE.B  #BLANK,(A6)+
                            	  1607: 
01:00200ABA 2010            	  1608:          MOVE.L  (A0),D0        FORMAT ABSOLUTE ADDRESS
01:00200ABC 610012E6        	  1609:          BSR     PNT6HX
01:00200AC0 2006            	  1610:          MOVE.L  D6,D0
01:00200AC2 6708            	  1611:          BEQ.S   BCMD81         DON'T PRINT ZERO COUNT
01:00200AC4 1CFC003B        	  1612:          MOVE.B  #';',(A6)+
01:00200AC8 6100135E        	  1613:          BSR     PNTZHX         PRINT WITH ZERO SURPRESS
                            	  1614: 
01:00200ACC 6100151C        	  1615: BCMD81   BSR     OUT1CR
01:00200AD0 5888            	  1616: BCMD9    ADDQ.L  #4,A0
01:00200AD2 5387            	  1617:          SUBQ.L  #1,D7          LOOP AROUND
01:00200AD4 66D6            	  1618:          BNE     BCMD8
01:00200AD6 6000FB56        	  1619:          BRA     MACSBUG
                            	  1620: 
01:00200ADA 425245414B504F49	  1621: MSGBR    DC.B    'BREAKPOINTS',EOT
01:00200AE2 4E5453
01:00200AE5 04
                            	  1622: 
                            	  1623: 
                            	  1624: 
                            	  1625: * NOBR COMMAND
                            	  1626: 
01:00200AE6 41FAFF4C        	  1627: NOBR0    LEA     NOBRCMD(PC),A0 WHERE TO GO IF NO PARAMETERS
01:00200AEA 61001382        	  1628: NOBR1    BSR     FNEXTF         FIND NEXT FIELD
01:00200AEE 61000446        	  1629:          BSR     GETA           GO DECODE NUMBER/ADDRESS
01:00200AF2 4A80            	  1630:          TST.L   D0
01:00200AF4 679E            	  1631:          BEQ     BCMD55         ZERO NOT VALID BREAKPOINT
01:00200AF6 61001394        	  1632:          BSR     CKWADR         CHECK WORD BOUNDRY ADDRESS
                            	  1633: 
01:00200AFA 41F80470        	  1634:          LEA     BPADD,A0       SET UP TABLE POINTER
01:00200AFE 7E08            	  1635:          MOVEQ   #8,D7          COUNTER
01:00200B00 2210            	  1636: NOBR3    MOVE.L  (A0),D1        GET BREAKPOINT IN TABLE
01:00200B02 B081            	  1637:          CMP.L   D1,D0          SEE IF SAME
01:00200B04 6706            	  1638:          BEQ.S   NOBR4
01:00200B06 5888            	  1639:          ADDQ.L  #4,A0
01:00200B08 5387            	  1640:          SUBQ.L  #1,D7
01:00200B0A 66F4            	  1641:          BNE     NOBR3
01:00200B0C 4290            	  1642: NOBR4    CLR.L   (A0)           CLEAR THIS BREAKPOINT
01:00200B0E 41FAFF8E        	  1643:          LEA     BCMD7(PC),A0   WHERE TO GO IF NO PARAMETER
01:00200B12 60D6            	  1644:          BRA     NOBR1
                            	  1645: 
                            	  1646: 
                            	  1647: 
                            	  1648: 
                            	  1649: *-------------------------------------------------------------------------
                            	  1650: * File BS        BS (Block Search) Command                        11/27/81
                            	  1651: 
                            	  1652: *
                            	  1653: *  BLOCK SEARCH   BS <ADDR1> <ADDR2> 'LITERAL STRING'
                            	  1654: *                 BS <ADDR1> <ADDR2> <DATA> [<MASK>] [;<OPTION>]
                            	  1655: 
01:00200B14 41FAF998        	  1656: BSCMD    LEA     SYNTAX(PC),A0
01:00200B18 61001354        	  1657:          BSR     FNEXTF
01:00200B1C 61000418        	  1658:          BSR     GETA
01:00200B20 2640            	  1659:          MOVE.L  D0,A3          A3 = FROM BEGIN ADDRESS
                            	  1660: 
01:00200B22 6100134A        	  1661:          BSR     FNEXTF
01:00200B26 6100040E        	  1662:          BSR     GETA
01:00200B2A 2240            	  1663:          MOVE.L  D0,A1          A1 = FROM END ADDRESS
                            	  1664: 
01:00200B2C 61001340        	  1665:          BSR     FNEXTF
01:00200B30 1015            	  1666:          MOVE.B  (A5),D0
01:00200B32 0C000027        	  1667:          CMPI.B  #$27,D0
01:00200B36 670000B0        	  1668:          BEQ     BS311          LITERAL STRING SEARCH
                            	  1669: 
01:00200B3A 610013B4        	  1670:          BSR     GETNUMA
01:00200B3E 2E00            	  1671:          MOVE.L  D0,D7          D7 = DATA WE ARE LOOKING FOR
01:00200B40 7A00            	  1672:          CLR.L   D5             SCAN FOR OPTIONS
01:00200B42 204D            	  1673:          MOVE.L  A5,A0
01:00200B44 B1CE            	  1674: BS91     CMP.L   A6,A0
01:00200B46 6426            	  1675:          BCC.S   BS97           AT END OF BUFFER
                            	  1676: 
01:00200B48 1018            	  1677:          MOVE.B  (A0)+,D0
01:00200B4A 0C00003B        	  1678:          CMPI.B  #';',D0
01:00200B4E 66F4            	  1679:          BNE     BS91           NOT SEMICOLON
                            	  1680: 
01:00200B50 2C48            	  1681:          MOVE.L  A0,A6
01:00200B52 538E            	  1682:          SUBQ.L  #1,A6          ADJUST END OF BUFFER POINTER
                            	  1683: 
01:00200B54 1010            	  1684:          MOVE.B  (A0),D0        D0 = OPTION CHARACTER
01:00200B56 0C000042        	  1685:          CMPI.B  #'B',D0
01:00200B5A 6712            	  1686:          BEQ.S   BS97           BYTE  D5 = 0
                            	  1687: 
01:00200B5C 7A01            	  1688:          MOVEQ   #1,D5
01:00200B5E 0C000057        	  1689:          CMPI.B  #'W',D0
01:00200B62 670A            	  1690:          BEQ.S   BS97                WORD  D5 = +
                            	  1691: 
01:00200B64 7AFF            	  1692:          MOVEQ   #-1,D5         LONG WORD  D5 = -
01:00200B66 0C00004C        	  1693:          CMPI.B  #'L',D0
01:00200B6A 6600F942        	  1694:          BNE     SYNTAX
                            	  1695: BS97     DS      0
                            	  1696: 
01:00200B6E 78FF            	  1697:          MOVEQ   #-1,D4         D4 = DEFAULT SEARCH MASK
01:00200B70 41FA000C        	  1698:          LEA     BS101(PC),A0
01:00200B74 610012F8        	  1699:          BSR     FNEXTF         FIND NEXT FIELD
01:00200B78 61001376        	  1700:          BSR     GETNUMA
01:00200B7C 2800            	  1701:          MOVE.L  D0,D4          D4 = MASK
                            	  1702: BS101    DS      0
                            	  1703: 
01:00200B7E 204B            	  1704:          MOVE.L  A3,A0
01:00200B80 6100F93A        	  1705:          BSR     P2PHY          PRINT ADDRESSES (A0) & (A1)
                            	  1706: 
01:00200B84 B3CB            	  1707:          CMP.L   A3,A1
01:00200B86 6500F926        	  1708:          BCS     SYNTAX         END LESS THAN BEGIN
                            	  1709: 
01:00200B8A B7C9            	  1710: BS200    CMP.L   A1,A3
01:00200B8C 6400FAA0        	  1711:          BCC     MACSBUG        DONE
                            	  1712: 
01:00200B90 610014FE        	  1713:          BSR     FIXBUF
01:00200B94 200B            	  1714:          MOVE.L  A3,D0
01:00200B96 6100120C        	  1715:          BSR     PNT6HX         FORMAT ADDRESS
01:00200B9A 1CFC0020        	  1716:          MOVE.B  #BLANK,(A6)+   SPACE INTO BUFFER
                            	  1717: 
01:00200B9E 4A85            	  1718:          TST.L   D5
01:00200BA0 6734            	  1719:          BEQ.S   BS225          BYTE SIZE
                            	  1720: 
01:00200BA2 200B            	  1721:          MOVE.L  A3,D0
01:00200BA4 610012E6        	  1722:          BSR     CKWADR         INSURE WORD BOUNDRY
01:00200BA8 4A85            	  1723:          TST.L   D5
01:00200BAA 6A18            	  1724:          BPL.S   BS219          WORD SIZE (2 BYTES)
                            	  1725: 
01:00200BAC 7C02            	  1726:          MOVEQ   #2,D6          D6 =  SIZE (LONG WORD)
01:00200BAE 2013            	  1727:          MOVE.L  (A3),D0        FETCH
01:00200BB0 C084            	  1728:          AND.L   D4,D0          MASK
01:00200BB2 B087            	  1729:          CMP.L   D7,D0          COMPARE
01:00200BB4 660A            	  1730:          BNE.S   BS215
                            	  1731: 
01:00200BB6 2013            	  1732:          MOVE.L  (A3),D0        DISPLAY NON-MASKED DATA
01:00200BB8 610011E2        	  1733:          BSR     PNT8HX
                            	  1734: 
01:00200BBC 6100142C        	  1735: BS213    BSR     OUT1CR
                            	  1736: 
01:00200BC0 D7C6            	  1737: BS215    ADD.L   D6,A3          BUMP FETCH ADDRESS  (D6 = SIZE)
01:00200BC2 60C6            	  1738:          BRA     BS200
                            	  1739: 
01:00200BC4 7C02            	  1740: BS219    MOVEQ   #2,D6          SIZE = WORD
01:00200BC6 3013            	  1741:          MOVE.W  (A3),D0
01:00200BC8 C044            	  1742:          AND.W   D4,D0
01:00200BCA B047            	  1743:          CMP.W   D7,D0
01:00200BCC 66F2            	  1744:          BNE     BS215
                            	  1745: 
01:00200BCE 3013            	  1746:          MOVE.W  (A3),D0
01:00200BD0 610011D8        	  1747:          BSR     PNT4HX         DISPLAY
01:00200BD4 60E6            	  1748:          BRA     BS213
                            	  1749: 
01:00200BD6 7C01            	  1750: BS225    MOVEQ   #1,D6          SIZE = BYTE
01:00200BD8 1013            	  1751:          MOVE.B  (A3),D0
01:00200BDA C004            	  1752:          AND.B   D4,D0
01:00200BDC B007            	  1753:          CMP.B   D7,D0
01:00200BDE 66E0            	  1754:          BNE     BS215
                            	  1755: 
01:00200BE0 1013            	  1756:          MOVE.B  (A3),D0
01:00200BE2 610011CE        	  1757:          BSR     PNT2HX         DISPLAY
01:00200BE6 60D4            	  1758:          BRA     BS213
                            	  1759: 
                            	  1760: * LITERAL STRING SEARCH
                            	  1761: *   SAVE STRING
                            	  1762: 
01:00200BE8 45F805C0        	  1763: BS311    LEA     DUMPTEMP,A2
01:00200BEC 528D            	  1764: BS313    ADDQ.L  #1,A5
01:00200BEE BBCE            	  1765:          CMP.L   A6,A5
01:00200BF0 6400F8BC        	  1766:          BCC     SYNTAX         ADDR1 GREATER THAN ADDR2
01:00200BF4 14D5            	  1767:          MOVE.B  (A5),(A2)+
01:00200BF6 1015            	  1768:          MOVE.B  (A5),D0
01:00200BF8 0C000027        	  1769:          CMPI.B  #$27,D0
01:00200BFC 66EE            	  1770:          BNE     BS313
01:00200BFE 538A            	  1771:          SUBQ.L  #1,A2          A2 = END OF STRING + 1
                            	  1772: 
01:00200C00 204B            	  1773:          MOVE.L  A3,A0
01:00200C02 6100F8B8        	  1774:          BSR     P2PHY          DISPLAY ADDRESSES
                            	  1775: 
01:00200C06 B3CB            	  1776:          CMP.L   A3,A1
01:00200C08 6500F8A4        	  1777:          BCS     SYNTAX
                            	  1778: 
                            	  1779: * LOOK FOR STRING MATCH
                            	  1780: 
01:00200C0C 49F805C0        	  1781: BS323    LEA     DUMPTEMP,A4    A4 = BEGIN OF STRING
01:00200C10 204B            	  1782:          MOVE.L  A3,A0          A0 = BEGIN OF MEMORY
01:00200C12 1010            	  1783: BS325    MOVE.B  (A0),D0
01:00200C14 B01C            	  1784:          CMP.B   (A4)+,D0       DATA COMPARE
01:00200C16 662C            	  1785:          BNE.S   BS365          MIS-MATCH
                            	  1786: 
01:00200C18 B3C8            	  1787:          CMP.L   A0,A1          ADDRESS CHECK
01:00200C1A 6500FA12        	  1788:          BCS     MACSBUG        OUT OF MEMORY
                            	  1789: 
01:00200C1E 5288            	  1790:          ADDQ.L  #1,A0
01:00200C20 B9CA            	  1791:          CMP.L   A2,A4
01:00200C22 65EE            	  1792:          BCS     BS325          MORE STRING TO CHECK
                            	  1793: 
01:00200C24 6100146A        	  1794:          BSR     FIXBUF         HAVE MATCH
01:00200C28 200B            	  1795:          MOVE.L  A3,D0          FORMAT ADDRESS
01:00200C2A 61001178        	  1796:          BSR     PNT6HX
01:00200C2E 1CFC0020        	  1797:          MOVE.B  #BLANK,(A6)+   SPACE
                            	  1798: 
01:00200C32 1CFC0027        	  1799:          MOVE.B  #$27,(A6)+     LEADING QUOTE
01:00200C36 49F805C0        	  1800:          LEA     DUMPTEMP,A4    MOVE STRING TO BUFFER
01:00200C3A 1CDC            	  1801: BS355    MOVE.B  (A4)+,(A6)+
01:00200C3C B5CC            	  1802:          CMP.L   A4,A2
01:00200C3E 64FA            	  1803:          BCC     BS355
                            	  1804: 
01:00200C40 610013A8        	  1805:          BSR     OUT1CR         DISPLAY
                            	  1806: 
01:00200C44 528B            	  1807: BS365    ADDQ.L  #1,A3
01:00200C46 B3CB            	  1808:          CMP.L   A3,A1
01:00200C48 6500F9E4        	  1809:          BCS     MACSBUG        DONE
01:00200C4C 60BE            	  1810:          BRA     BS323
                            	  1811: 
                            	  1812: 
                            	  1813: 
                            	  1814: 
                            	  1815: *-------------------------------------------------------------------------
                            	  1816: * File BT        BT (Block Test) command                          11/30/81
                            	  1817: 
                            	  1818: * BT   BLOCK OF MEMORY TEST
                            	  1819: 
01:00200C4E 61000D02        	  1820: BTCMD    BSR     MTSETUP        PREPARE PARMS (FROM,TO/COUNT)
01:00200C52 61000FC2        	  1821:          BSR     RAMTEST        EXEC MEMORY TEST SUBROUTINE
01:00200C56 6700F9D6        	  1822:          BEQ     MACSBUG        NO ERRORS, RETURN TO MACSBUG
01:00200C5A 2F01            	  1823:          MOVE.L  D1,-(A7)       SAVE DATA READ
01:00200C5C 2F00            	  1824:          MOVE.L  D0,-(A7)       SAVE DATA WRITTEN CAUSING ERROR
                            	  1825: 
01:00200C5E 61001430        	  1826:          BSR     FIXBUF         SET UP TO PRINT
01:00200C62 2CFC4641494C    	  1827:          MOVE.L  #'FAIL',(A6)+
01:00200C68 2CFC45442041    	  1828:          MOVE.L  #'ED A',(A6)+
01:00200C6E 3CFC5420        	  1829:          MOVE.W  #'T ',(A6)+
01:00200C72 200A            	  1830:          MOVE.L  A2,D0          ADDRESS WHERE IT FAILED
01:00200C74 6100112E        	  1831:          BSR     PNT6HX
                            	  1832: 
01:00200C78 2CFC20205752    	  1833:          MOVE.L  #'  WR',(A6)+
01:00200C7E 2CFC4F54453D    	  1834:          MOVE.L  #'OTE=',(A6)+
01:00200C84 201F            	  1835:          MOVE.L  (A7)+,D0       WHAT WAS WRITTEN
01:00200C86 61001122        	  1836:          BSR     PNT4HX
                            	  1837: 
01:00200C8A 2CFC20202052    	  1838:          MOVE.L  #'   R',(A6)+
01:00200C90 2CFC4541443D    	  1839:          MOVE.L  #'EAD=',(A6)+
01:00200C96 201F            	  1840:          MOVE.L  (A7)+,D0       WHAT WAS READ
01:00200C98 61001110        	  1841:          BSR     PNT4HX
                            	  1842: 
01:00200C9C 6000F802        	  1843:          BRA     MSG            PRINT IT
                            	  1844: 
                            	  1845: 
                            	  1846: 
                            	  1847: 
                            	  1848: *-------------------------------------------------------------------------
                            	  1849: * File DC        DC (Data Conversion) Command                     12/10/81
                            	  1850: 
                            	  1851: *
                            	  1852: *
                            	  1853: *  ***DC***  NUMBER CONVERSIONS
                            	  1854: *
                            	  1855: DCCMD    DS      0              -DATA CONVERT COMMAND-
01:00200CA0 41FAF80C        	  1856: NUMCON0  LEA     SYNTAX(PC),A0  IF NO PARAMETERS
01:00200CA4 610011C8        	  1857:          BSR     FNEXTF         POINT TO NEXT PARAMETER
01:00200CA8 6100028C        	  1858:          BSR     GETA           EVALUATE EXPRESSION
                            	  1859: 
01:00200CAC 610013E2        	  1860:          BSR     FIXBUF         SET UP FOR PRINT
01:00200CB0 2E00            	  1861:          MOVE.L  D0,D7          D7=VALUE
01:00200CB2 4A87            	  1862:          TST.L   D7             SEE IF NEGATIVE
01:00200CB4 6A0E            	  1863:          BPL.S   NUMCON1
01:00200CB6 1CFC0024        	  1864:          MOVE.B  #'$',(A6)+
01:00200CBA 2007            	  1865:          MOVE.L  D7,D0          MOVE NEGATIVE RESULT TO D0
01:00200CBC 610010DE        	  1866:          BSR     PNT8HX
01:00200CC0 1CFC003D        	  1867:          MOVE.B  #'=',(A6)+
01:00200CC4 2007            	  1868: NUMCON1  MOVE.L  D7,D0          RESTORE
01:00200CC6 6A08            	  1869:          BPL.S   NUMCON2
01:00200CC8 4480            	  1870:          NEG.L   D0
01:00200CCA 6B04            	  1871:          BMI.S   NUMCON2        SPECIAL CASE (-0)
01:00200CCC 1CFC002D        	  1872:          MOVE.B  #'-',(A6)+
01:00200CD0 1CFC0024        	  1873: NUMCON2  MOVE.B  #'$',(A6)+
01:00200CD4 61001152        	  1874:          BSR     PNTZHX
01:00200CD8 1CFC003D        	  1875:          MOVE.B  #'=',(A6)+     NOW PRINT DECIMAL VALUE
01:00200CDC 2007            	  1876:          MOVE.L  D7,D0
01:00200CDE 6A08            	  1877:          BPL.S   NUMCON3
01:00200CE0 4480            	  1878:          NEG.L   D0
01:00200CE2 6B04            	  1879:          BMI.S   NUMCON3        SPECIAL CASE (-0)
01:00200CE4 1CFC002D        	  1880:          MOVE.B  #'-',(A6)+
01:00200CE8 1CFC0026        	  1881: NUMCON3  MOVE.B  #'&',(A6)+
01:00200CEC 6100066E        	  1882:          BSR     HEX2DEC        PUT VALUE IN BUFFER
01:00200CF0 6000F7AE        	  1883:          BRA     MSG            GO PRINT IT
                            	  1884: 
                            	  1885: 
                            	  1886: 
                            	  1887: 
                            	  1888: *-------------------------------------------------------------------------
                            	  1889: * File DFDI      DF (Display registers) WITH disassembler         05/27/82
                            	  1890: 
01:00200CF4 50435352        	  1891: REGNAMES DC.L    'PCSR'         TABLE OF NAMES OF REGISTERS
01:00200CF8 55535353        	  1892:          DC.L    'USSS'
01:00200CFC 3F3F            	  1893:          DC.W    '??'           END OF TABLE
                            	  1894: 
                            	  1895: DFCMD    DS      0              DF COMMAND  ENTRY
01:00200CFE 600A            	  1896:          BRA.S   TD07
                            	  1897: 
01:00200D00 6100138E        	  1898: TDISPLY  BSR     FIXBUF         PRINT TRACE DISPLAY SUBROUTINE
01:00200D04 4A3804E9        	  1899:          TST.B   XONOFF+3
01:00200D08 6652            	  1900:          BNE.S   TD25           SHORT DISPLAY
                            	  1901: 
01:00200D0A 61001384        	  1902: TD07     BSR     FIXBUF         PRINT PRELUDE
01:00200D0E 42B8061C        	  1903:          CLR.L   OUTTO          FORCE DISPLAY TO OPERATORS CONSOLE
01:00200D12 2CF80610        	  1904:          MOVE.L  SCREEN1,(A6)+
01:00200D16 6704            	  1905:          BEQ.S   TD09           SKIP PRELUDE
01:00200D18 610012EA        	  1906:          BSR     OUTPUT
                            	  1907: TD09
                            	  1908: 
01:00200D1C 49FAFFD6        	  1909:          LEA     REGNAMES(PC),A4 REGISTER NAMES
01:00200D20 45F80400        	  1910:          LEA     REGPC,A2       REGISTER DATA
01:00200D24 6100136A        	  1911:          BSR     FIXBUF         SET UP I/O BUFFER
                            	  1912: 
01:00200D28 301C            	  1913: TD1      MOVE.W  (A4)+,D0       GET REG NAME
01:00200D2A 2E1A            	  1914:          MOVE.L  (A2)+,D7       GET REG CONTENT
01:00200D2C 0C403F3F        	  1915:          CMPI.W  #'??',D0       SEE IF AT END OF REGS
01:00200D30 6650            	  1916:          BNE.S   TD4
01:00200D32 610012B6        	  1917:          BSR     OUT1CR         PRINT BUFFER
                            	  1918: 
01:00200D36 1E3C0044        	  1919:          MOVE.B  #'D',D7        CLASS=DATA
01:00200D3A 47F80408        	  1920:          LEA     REGS,A3        OFFSET
01:00200D3E 61000D9A        	  1921:          BSR     PNTCLS         GO PRINT THE BLOCK
                            	  1922: 
01:00200D42 1E3C0041        	  1923:          MOVE.B  #'A',D7        CLASS=ADDRESS
01:00200D46 47F80428        	  1924:          LEA     REGS+32,A3     OFFSET
01:00200D4A 61000D8E        	  1925:          BSR     PNTCLS         GO PRINT THE BLOCK
                            	  1926: 
01:00200D4E 61001340        	  1927:          BSR     FIXBUF
01:00200D52 7214            	  1928:          MOVEQ   #20,D1         LOOP COUNTER
01:00200D54 1CFC002D        	  1929: TD27     MOVE.B  #'-',(A6)+     FILL BUFFER WITH BOARDER
01:00200D58 5381            	  1930:          SUBQ.L  #1,D1
01:00200D5A 66F8            	  1931:          BNE TD27
                            	  1932: 
01:00200D5C 28780400        	  1933: TD25     MOVE.L  REGPC,A4       DISASSEMBLE
01:00200D60 4CD40007        	  1934:          MOVEM.L (A4),D0-D2
01:00200D64 2A4E            	  1935:          MOVE.L  A6,A5
01:00200D66 610030F8        	  1936:          BSR     DCODE68K
01:00200D6A 4BF80540        	  1937:          LEA     BUFFER,A5
                            	  1938: 
01:00200D6E 6100127A        	  1939:          BSR     OUT1CR         PRINT
                            	  1940: 
01:00200D72 6100131C        	  1941:          BSR     FIXBUF         PRINT END STUFF FOR SCREEN CONTROL
01:00200D76 2CF80614        	  1942:          MOVE.L  SCREEN2,(A6)+
01:00200D7A 6704            	  1943:          BEQ.S   TD39           SKIP END STUFF
01:00200D7C 61001286        	  1944:          BSR     OUTPUT
01:00200D80 4E75            	  1945: TD39     RTS     RETURN FOR MORE WORK
                            	  1946: 
01:00200D82 3400            	  1947: TD4      MOVE.W  D0,D2          PRINT REG NAME IN BUFFER
01:00200D84 E040            	  1948:          ASR.W   #8,D0          MOVE IT OVER
01:00200D86 1600            	  1949:          MOVE.B  D0,D3          SAVE REGISTER TYPE A,D,W,M ETC
01:00200D88 1CC0            	  1950:          MOVE.B  D0,(A6)+       SAVE FIRST LETTER
01:00200D8A 1CC2            	  1951:          MOVE.B  D2,(A6)+       SAVE NEXT LETTER
01:00200D8C 1CFC003D        	  1952:          MOVE.B  #'=',(A6)+     EQUAL SIGN
01:00200D90 0C425553        	  1953:          CMPI.W  #'US',D2
01:00200D94 6606            	  1954:          BNE.S   T44
01:00200D96 20380448        	  1955:          MOVE.L  REGUS,D0       USER STACK
01:00200D9A 6014            	  1956:          BRA.S   T449
                            	  1957: 
01:00200D9C 0C425353        	  1958: T44      CMPI.W  #'SS',D2       SUPER STACK IS SPECIAL
01:00200DA0 6606            	  1959:          BNE.S   T448
01:00200DA2 20380444        	  1960:          MOVE.L  REGA7,D0       GET A7
01:00200DA6 6008            	  1961:          BRA.S   T449
                            	  1962: 
01:00200DA8 2007            	  1963: T448     MOVE.L  D7,D0          REGISTER VALUE
01:00200DAA 0C425352        	  1964:          CMPI.W  #'SR',D2       SEE IF STATUS REGISTER
01:00200DAE 670C            	  1965:          BEQ.S   TDCC
01:00200DB0 61000FEA        	  1966: T449     BSR     PNT8HX         FORMAT 8 HEX CHAR
01:00200DB4 1CFC0020        	  1967: TD9      MOVE.B  #BLANK,(A6)+   SPACE BETWEEN REGS
01:00200DB8 6000FF6E        	  1968:          BRA TD1
                            	  1969: 
                            	  1970: *   CONDITION CODE FORMAT
                            	  1971: *
01:00200DBC 3600            	  1972: TDCC     MOVE.W  D0,D3          SAVE FOR A MOMENT
01:00200DBE 61000FEA        	  1973:          BSR     PNT4HX
01:00200DC2 1CFC003D        	  1974:          MOVE.B  #'=',(A6)+
01:00200DC6 2E3C80000054    	  1975:          MOVE.L  #$80000054,D7  TRACE BIT
01:00200DCC 613E            	  1976:          BSR.S   TDCC9
01:00200DCE 2E3C20000053    	  1977:          MOVE.L  #$20000053,D7  SUPERVISOR BIT
01:00200DD4 6136            	  1978:          BSR.S   TDCC9
01:00200DD6 3003            	  1979:          MOVE.W  D3,D0          INTERRUPT LEVEL
01:00200DD8 E048            	  1980:          LSR.W   #8,D0
01:00200DDA 02000007        	  1981:          ANDI.B  #$07,D0        "7" MAX IN SR FOR LEVEL
01:00200DDE 61000FDA        	  1982:          BSR     PUTHEX
01:00200DE2 2E3C00100058    	  1983:          MOVE.L  #$100058,D7    X BIT
01:00200DE8 6122            	  1984:          BSR.S   TDCC9
01:00200DEA 2E3C0008004E    	  1985:          MOVE.L  #$8004E,D7     N BIT
01:00200DF0 611A            	  1986:          BSR.S   TDCC9
01:00200DF2 2E3C0004005A    	  1987:          MOVE.L  #$4005A,D7     Z BIT
01:00200DF8 6112            	  1988:          BSR.S   TDCC9
01:00200DFA 2E3C00020056    	  1989:          MOVE.L  #$20056,D7     V BIT
01:00200E00 610A            	  1990:          BSR.S   TDCC9
01:00200E02 2E3C00010043    	  1991:          MOVE.L  #$10043,D7     C BIT
01:00200E08 6102            	  1992:          BSR.S   TDCC9
01:00200E0A 60A8            	  1993:          BRA     TD9
                            	  1994: *
01:00200E0C 2C07            	  1995: TDCC9    MOVE.L  D7,D6          DUPLICATE STUFF
01:00200E0E 4846            	  1996:          SWAP    D6             GET BIT POSITION
01:00200E10 CC43            	  1997:          AND.W   D3,D6          SEE IF ON
01:00200E12 6604            	  1998:          BNE.S   TDCC91
01:00200E14 1E3C002E        	  1999:          MOVE.B  #'.',D7        PUT IN PERIOD IF OFF
01:00200E18 1CC7            	  2000: TDCC91   MOVE.B  D7,(A6)+       PUT IN LETTER IF ON
01:00200E1A 4E75            	  2001:          RTS
                            	  2002: 
                            	  2003: 
                            	  2004: 
                            	  2005: 
                            	  2006: *-------------------------------------------------------------------------
                            	  2007: * File DUMP      DU     Dump "S-Records"                          05/10/82
                            	  2008: 
                            	  2009: *   ***DUMP***  DUMP  'S' RECORDS
                            	  2010: *    FORMAT:  DU  ADDRESS1 ADDRESS2  [TEXT....]
                            	  2011: *
                            	  2012: DUCMD    DS      0
01:00200E1C 61001732        	  2013:          BSR     SCANPORT       SEE WHERE TO SEND OUTPUT (DUMMY CALL)
01:00200E20 2C38061C        	  2014:          MOVE.L  OUTTO,D6       SAVE OUTTO FOR ACTUAL S-RECORD DUMP
01:00200E24 42B8061C        	  2015:          CLR.L   OUTTO          OVERRIDE SCANPORT CALL
                            	  2016: 
01:00200E28 41FAF684        	  2017:          LEA     SYNTAX(PC),A0  WHERE TO GO IF NO PARAMTERS
01:00200E2C 61001040        	  2018:          BSR     FNEXTF         FIND NEXT FIELD
01:00200E30 61000104        	  2019:          BSR     GETA           GET ADDRESS1
01:00200E34 2640            	  2020:          MOVE.L  D0,A3          A3 = BEGIN ADDRESS
                            	  2021: 
01:00200E36 61001036        	  2022:          BSR     FNEXTF
01:00200E3A 610000FA        	  2023:          BSR     GETA           GET ADDRESS2
01:00200E3E 2840            	  2024:          MOVE.L  D0,A4          A4 = END ADDRESS
                            	  2025: 
                            	  2026: * PROCESS HEADER
01:00200E40 41FA0006        	  2027:          LEA     PUNCH5(PC),A0  WHERE TO GO IF NO HEADER
01:00200E44 61001028        	  2028:          BSR     FNEXTF         LOOK FOR HEADER
                            	  2029: PUNCH5   DS      0
                            	  2030: 
                            	  2031: * MOVE TEXT TO 'TEMP STORAGE'
01:00200E48 45F805C0        	  2032:          LEA     DUMPTEMP,A2
01:00200E4C 2A0A            	  2033:          MOVE.L  A2,D5          D5 = START OF TEXT
01:00200E4E BDCD            	  2034: PUM11    CMP.L   A5,A6
01:00200E50 6704            	  2035:          BEQ.S   PUM13
01:00200E52 14DD            	  2036:          MOVE.B  (A5)+,(A2)+    MOVE
01:00200E54 60F8            	  2037:          BRA     PUM11
01:00200E56 CB8A            	  2038: PUM13    EXG     A2,D5          D5 = END OF TEXT +1
                            	  2039: 
                            	  2040: * DISPLAY ADDRESSES
01:00200E58 204B            	  2041:          MOVE.L  A3,A0
01:00200E5A 224C            	  2042:          MOVE.L  A4,A1
01:00200E5C 6100F65E        	  2043:          BSR     P2PHY          DISPLAY TWO ADDRESSES
                            	  2044: 
                            	  2045: * INSURE END EQUAL GREATER THAN BEG
01:00200E60 B9CB            	  2046:          CMP.L   A3,A4
01:00200E62 6500F64A        	  2047:          BCS     SYNTAX
                            	  2048: 
01:00200E66 21C6061C        	  2049:          MOVE.L  D6,OUTTO       RESTORE OPTIONAL DESTINATION OF DUMP
                            	  2050: 
                            	  2051: * FINISH PROCESSING HEADER
                            	  2052: *  A2 = START OF TEXT
01:00200E6A 61001224        	  2053:          BSR     FIXBUF         A5,A6=#BUFFER
01:00200E6E 7C02            	  2054:          MOVEQ   #2,D6          THE BYTE COUNT
01:00200E70 7800            	  2055:          CLR.L   D4             CLEAR THE CHECKSUM
01:00200E72 2CFC53303F3F    	  2056:          MOVE.L  #'S0??',(A6)+  START OF S RECORD
01:00200E78 2CFC30303030    	  2057:          MOVE.L  #'0000',(A6)+  DUMMY ADDRESS
01:00200E7E B5C5            	  2058: MORES0   CMP.L   D5,A2          SEE IF AT END OF TEXT
01:00200E80 6C0C            	  2059:          BGE.S   ENDS0          WHERE TO GO WHEN ALL CHARACTERS USED
01:00200E82 5286            	  2060:          ADDQ.L  #1,D6          ANOTHER BYTE
                            	  2061: 
01:00200E84 101A            	  2062:          MOVE.B  (A2)+,D0       GET ANOTHER BYTE OF TEXT
                            	  2063: 
01:00200E86 D880            	  2064:          ADD.L   D0,D4          FOR CHECKSUM
01:00200E88 61000F28        	  2065:          BSR     PNT2HX         PUT IT IN BUFFER
01:00200E8C 60F0            	  2066:          BRA     MORES0
                            	  2067: ENDS0    DS      0
                            	  2068: 
01:00200E8E 61000084        	  2069:          BSR     PNTSREC        GO PRINT THE 'S' RECORD
01:00200E92 344B            	  2070:          MOVE    A3,A2          A2 WILL SCAN BETWEEN A3-A4
                            	  2071: 
                            	  2072: * DO ANOTHER 'S' RECORD
01:00200E94 610011FA        	  2073: MORESP   BSR     FIXBUF         A5,A6=#BUFFER
01:00200E98 7800            	  2074:          CLR.L   D4             CLEAR CHECKSUM REGISTER
01:00200E9A 200B            	  2075:          MOVE.L  A3,D0          READY TO PRINT ADDRESS
01:00200E9C 220B            	  2076:          MOVE.L  A3,D1          GET READY TO AND ADDRESS
01:00200E9E 7610            	  2077:          MOVEQ   #$10,D3        MAXIMUM BYTES ON S REC LINE
01:00200EA0 D283            	  2078:          ADD.L   D3,D1          INSURE END OF LINE ADDRESS IS MAX
01:00200EA2 028100FF0000    	  2079:          ANDI.L  #$FF0000,D1    SEE IF 3 BYTE ADDRESS
01:00200EA8 6618            	  2080:          BNE.S   S2REC          WHERE TO GO IF 3 BYTES NEEDED
01:00200EAA 2CFC53313F3F    	  2081:          MOVE.L  #'S1??',(A6)+  PUSH
01:00200EB0 300B            	  2082:          MOVE    A3,D0          SET UP TO PRINT 2 BYTE ADDRESS
01:00200EB2 61000EF6        	  2083:          BSR     PNT4HX         PRINT 4 HEX CHAR ADDRESS
01:00200EB6 7C02            	  2084:          MOVEQ   #2,D6          BYTE COUNT
01:00200EB8 300B            	  2085:          MOVE.W  A3,D0          FIX UP CHECKSUM
01:00200EBA D800            	  2086:          ADD.B   D0,D4          LOW BYTE
01:00200EBC E040            	  2087:          ASR     #8,D0          SHIFT IT OVER
01:00200EBE D800            	  2088:          ADD.B   D0,D4          HIGH BYTE OF ADDRESS
01:00200EC0 6018            	  2089:          BRA.S   PNCA3          GO PUNCH A LINE
                            	  2090: 
01:00200EC2 2CFC53323F3F    	  2091: S2REC    MOVE.L  #'S2??',(A6)+  PUSH
01:00200EC8 61000EDA        	  2092:          BSR     PNT6HX         PRINT 6 HEX CHAR ADDRESS
01:00200ECC 7C03            	  2093:          MOVEQ   #3,D6          BYTE COUNT
01:00200ECE 200B            	  2094:          MOVE.L  A3,D0          FIX UP CHECKSUM
01:00200ED0 D800            	  2095:          ADD.B   D0,D4          LOW BYTE
01:00200ED2 E040            	  2096:          ASR     #8,D0          SHIFT IT OVER
01:00200ED4 D800            	  2097:          ADD.B   D0,D4          MIDDLE BYTE
01:00200ED6 4840            	  2098:          SWAP    D0             SET UP FOR HIGH BYTE
01:00200ED8 D800            	  2099:          ADD.B   D0,D4          ADD HIGH BYTE
01:00200EDA B7CC            	  2100: PNCA3    CMP.L   A4,A3          SEE IF AT ENDING ADDRESS
                            	  2101: 
                            	  2102: * END OF FILE
01:00200EDC 6F1C            	  2103:          BLE.S   A3OUT          WHERE TO GO IF BELOW OR AT END ADDRESS
01:00200EDE 612E            	  2104:          BSR.S   PNTSRECX       END IT BY PRINTING LAST RECORD
01:00200EE0 610011AE        	  2105:          BSR     FIXBUF         A5,A6=#BUFFER
01:00200EE4 7800            	  2106:          CLR.L   D4             CLEAR THE CHECKSUM
01:00200EE6 2CFC53393F3F    	  2107:          MOVE.L  #'S9??',(A6)+  MOVE TO PRINT BUFFER
01:00200EEC 2CFC30303030    	  2108:          MOVE.L  #'0000',(A6)+  MOVE '0000' TO PRIT BUFFER
01:00200EF2 7C02            	  2109:          MOVEQ   #2,D6          BYTE COUNT
01:00200EF4 611E            	  2110:          BSR.S   PNTSREC        PRINT 'S9' END-OF-FILE RECORD
01:00200EF6 6000F736        	  2111:          BRA     MACSBUG        REENTER MACSBUG
                            	  2112: 
01:00200EFA 101B            	  2113: A3OUT    MOVE.B  (A3)+,D0       GRAB THE BYTE FROM MEMORY
01:00200EFC D840            	  2114:          ADD.W   D0,D4          ADD TO CHECKSUM
01:00200EFE 5246            	  2115:          ADDQ.W  #1,D6          BUMP THE BYTE COUNT
01:00200F00 5289            	  2116:          ADDQ.L  #1,A1          ADD TO COUNT OF BYTES PROCESSED
01:00200F02 61000EAE        	  2117:          BSR     PNT2HX         PUT THE HEX IN THE PRINT BUFFER
01:00200F06 5383            	  2118:          SUBQ.L  #1,D3          COUNT DOWN CHAR TO GO IN LINE
01:00200F08 66D0            	  2119:          BNE     PNCA3
01:00200F0A 6108            	  2120:          BSR.S   PNTSREC        END OF LINE-PUNCH IT
01:00200F0C 6086            	  2121:          BRA     MORESP         GO FIX UP NEXT LINE
                            	  2122: 
                            	  2123: * FIX UP & PRINT THE 'S' RECORD/LINE
                            	  2124: 
01:00200F0E B2FC0000        	  2125: PNTSRECX CMP.W   #0,A1          SEE IF ANY CHAR MOVED
01:00200F12 6720            	  2126:          BEQ.S   PNTSRTS        NO CHAR MOVED
                            	  2127: 
01:00200F14 5246            	  2128: PNTSREC  ADD     #1,D6          ONE MORE BYTE (CHECKSUM)
01:00200F16 D846            	  2129:          ADD.W   D6,D4          ADD BYTE COUNT TO CHECKSUM
01:00200F18 4604            	  2130:          NOT.B   D4             COMPLIMENT THE CHECKSUM
01:00200F1A 2004            	  2131:          MOVE.L  D4,D0          READY FOR PRINT-HEX
01:00200F1C 61000E94        	  2132:          BSR     PNT2HX         PUT CHECKSUM IN RECORD
01:00200F20 2E0E            	  2133:          MOVE.L  A6,D7          SAVE FOR THE MOMENT
01:00200F22 2C4D            	  2134:          MOVE.L  A5,A6          START OF BUFFER
01:00200F24 548E            	  2135:          ADDQ.L  #2,A6          BYPASS RECORD TYPE (4 CHAR)
01:00200F26 1006            	  2136:          MOVE.B  D6,D0          SET UP BYTE COUNT FOR PNTHEX ROUTINE
01:00200F28 61000E88        	  2137:          BSR     PNT2HX         PUT THE BYTE COUNT IN THE PRINT BUFFER
01:00200F2C 2C47            	  2138:          MOVE.L  D7,A6          RESTORE REAL END OF BUFFER
01:00200F2E 610010BA        	  2139:          BSR     OUT1CR         DO THE ACTUAL DISPLAY/PUNCH
01:00200F32 93C9            	  2140:          SUB.L   A1,A1          CLEAR COUNTER OF BYTES PROCESSED
01:00200F34 4E75            	  2141: PNTSRTS  RTS
                            	  2142: 
                            	  2143: 
                            	  2144: 
                            	  2145: 
                            	  2146: *-------------------------------------------------------------------------
                            	  2147: * File GETA      GET ADDRESS Subroutine                           12/01/81
                            	  2148: 
                            	  2149: * GET ADDRESS
                            	  2150: *  ENTER (A5) POINTER START OF BUFFER
                            	  2151: *        (A6) POINTER END OF BUFFER
                            	  2152: *
                            	  2153: *  RETURN:  D0 = ADDRESS
                            	  2154: 
                            	  2155: *        (A6) POINTER END OF BUFFER
                            	  2156: *
                            	  2157: *  RETURN:  D0 = ADDRESS
                            	  2158: 
                            	  2159: 
                            	  2160: * FORMATS HANDLED:
                            	  2161: *  1.  NUMBER        DEFAULTS TO HEX
                            	  2162: *  2.  $NUMBER       HEX
                            	  2163: *  3.  &NUMBER       DECIMAL
                            	  2164: *  4.  (A@)
                            	  2165: *  5.  NUMBER(A@)
                            	  2166: *  6.  (A@,D@)
                            	  2167: *  7.  NUMBER(A@,D@)
                            	  2168: *  8.  [NUMBER]      MEMORY INDIRECT
                            	  2169: *
                            	  2170: *   FORMATS 1,2,3,8  ADD OFFSET R0 UNLESS R1 - R7 SPECIFIED
                            	  2171: 
                            	  2172: 
                            	  2173: * WORK REGISTERS
                            	  2174: *  D4    VALUE BEING BUILT
                            	  2175: *
                            	  2176: *  D5    FLAG REGISTER
                            	  2177: *     = 8000XXXX  R@ GIVEN (GARO)
                            	  2178: *     = XXXX80XX  [  GIVEN (GALB)
                            	  2179: *     = XXXXXX80  (  GIVEN (GALP)
                            	  2180: *
                            	  2181: *  D6    FLAG REGISTER
                            	  2182: *     = 8000XXXX  A@ GIVEN           (GAAVF)
                            	  2183: *     = XXXX80XX  NEED PLUS OR MINUS (GANPM)
                            	  2184: *     = XXXXXX2B  +  PLUS GIVEN      (GAPMS)
                            	  2185: *             2D  -  MINUS GIVEN
                            	  2186: 
01:00200F36 48E70E80        	  2187: GETA     MOVEM.L D4-D6/A0,-(A7) SAVE SOME REGISTERS
01:00200F3A 7800            	  2188:          CLR.L   D4             VALUE BEING BUILT
01:00200F3C 7A00            	  2189:          CLR.L   D5             FLAG REG
01:00200F3E 7C00            	  2190:          CLR.L   D6             FLAG REG
                            	  2191: 
01:00200F40 101D            	  2192:          MOVE.B  (A5)+,D0       GET BYTE
01:00200F42 BDCD            	  2193:          CMP.L   A5,A6
01:00200F44 6500010C        	  2194:          BCS     GAP191         END OF BUFFER
                            	  2195: 
01:00200F48 0C00005B        	  2196:          CMPI.B  #'[',D0
01:00200F4C 660C            	  2197:          BNE.S   GAP113
                            	  2198: 
                            	  2199: *  [  SET INDIRECT
                            	  2200: 
01:00200F4E 00458000        	  2201:          ORI.W   #$8000,D5      SET LEFT BRACKET (GALB)
                            	  2202: 
01:00200F52 101D            	  2203: GAP111   MOVE.B  (A5)+,D0       GET BYTE
01:00200F54 BDCD            	  2204:          CMP.L   A5,A6
01:00200F56 650000FA        	  2205:          BCS     GAP191         END OF BUFFER
                            	  2206: GAP113   DS      0
                            	  2207: 
01:00200F5A 0C00002B        	  2208:          CMPI.B  #'+',D0
01:00200F5E 675E            	  2209:          BEQ.S   GAP121         PLUS SIGN
                            	  2210: 
01:00200F60 0C00002D        	  2211:          CMPI.B  #'-',D0
01:00200F64 6758            	  2212:          BEQ.S   GAP121         MINUS SIGN
                            	  2213: 
01:00200F66 0C00005D        	  2214:          CMPI.B  #']',D0
01:00200F6A 675E            	  2215:          BEQ.S   GAP131         RIGHT BRACKET (INDIRECT)
                            	  2216: 
01:00200F6C 0C000028        	  2217:          CMPI.B  #'(',D0
01:00200F70 676C            	  2218:          BEQ.S   GAP141         LEFT PARIN
                            	  2219: 
01:00200F72 0C00002C        	  2220:          CMPI.B  #',',D0
01:00200F76 67000092        	  2221:          BEQ     GAP161         COMMA
                            	  2222: 
01:00200F7A 0C000029        	  2223:          CMPI.B  #')',D0
01:00200F7E 670000CC        	  2224:          BEQ     GAP181         RIGHT PARIN
                            	  2225: 
01:00200F82 0C00003B        	  2226:          CMPI.B  #';',D0        "SEMI-COLON"
01:00200F86 670000CA        	  2227:          BEQ     GAP191         TERMINATE
                            	  2228: 
01:00200F8A 0C000020        	  2229:          CMPI.B  #BLANK,D0      "SPACE"
01:00200F8E 670000C2        	  2230:          BEQ     GAP191         TERMINATE
                            	  2231: 
01:00200F92 4A46            	  2232:          TST.W   D6             (GANPM)
01:00200F94 6B70            	  2233:          BMI.S   GAE            NEEDS PLUS OR MINUS
                            	  2234: 
01:00200F96 0C000052        	  2235:          CMPI.B  #'R',D0
01:00200F9A 67000094        	  2236:          BEQ     GAP171         RELATIVE OFFSET
                            	  2237: 
01:00200F9E 4A06            	  2238:          TST.B   D6             (GALP)
01:00200FA0 6B64            	  2239:          BMI.S   GAE            (...   NUMBER NOT ALLOWED
                            	  2240: 
                            	  2241: * NONE OF ABOVE ASSUME NUMERIC VALUE
01:00200FA2 538D            	  2242:          SUBQ.L  #1,A5          ADJUST (A5) TO FIRST CHAR
01:00200FA4 7000            	  2243:          CLR.L   D0
01:00200FA6 61000F48        	  2244:          BSR     GETNUMA
                            	  2245: 
01:00200FAA 0C06002D        	  2246:          CMPI.B  #'-',D6        (GAPMS)
01:00200FAE 6704            	  2247:          BEQ.S   GAP118         MINUS SIGN
                            	  2248: 
01:00200FB0 D880            	  2249:          ADD.L   D0,D4          PLUS SIGN
01:00200FB2 6002            	  2250:          BRA.S   GAP119
                            	  2251: 
01:00200FB4 9880            	  2252: GAP118   SUB.L   D0,D4
                            	  2253: 
01:00200FB6 4206            	  2254: GAP119   CLR.B   D6             (GAPMS)  RESET PLUS MINUS FLAG
01:00200FB8 00468000        	  2255:          ORI.W   #$8000,D6      (GANPM)  SET NEED PLUS MINUS
01:00200FBC 6094            	  2256: GAP111S  BRA     GAP111
                            	  2257: 
                            	  2258: * (*) (-) SET ARITHMETIC OPERATOR
                            	  2259: 
01:00200FBE 4A06            	  2260: GAP121   TST.B   D6             (GAPMS)
01:00200FC0 6644            	  2261:          BNE.S   GAE            MULTI OPERATORS
01:00200FC2 1C00            	  2262:          MOVE.B  D0,D6          (GAPMS)
01:00200FC4 024600FF        	  2263:          ANDI.W  #$00FF,D6      RESET (GANPM) NEED PLUS MINUS
01:00200FC8 60F2            	  2264:          BRA     GAP111S
                            	  2265: 
                            	  2266: *  ]  CLOSE INDIRECT
                            	  2267: 
01:00200FCA 4A45            	  2268: GAP131   TST.W   D5             (GALB)
01:00200FCC 6A38            	  2269:          BPL.S   GAE            [ MISSING
                            	  2270: 
                            	  2271: * IF NO R@ GIVEN ADD R0
01:00200FCE 4A85            	  2272:          TST.L   D5             (GARO)
01:00200FD0 6B04            	  2273:          BMI.S   GAP135         R@ GIVEN
01:00200FD2 D8B8044C        	  2274:          ADD.L   OFFSET,D4      NO R@ GIVEN; ADD R0
                            	  2275: GAP135   DS      0
                            	  2276: 
01:00200FD6 2044            	  2277:          MOVE.L  D4,A0
01:00200FD8 2010            	  2278:          MOVE.L  (A0),D0
01:00200FDA 6000008A        	  2279:          BRA     GAP199
                            	  2280: 
                            	  2281: *  (  DO PARIN PAIR
                            	  2282: 
01:00200FDE 4A05            	  2283: GAP141   TST.B   D5             (GALP)
01:00200FE0 6B24            	  2284:          BMI.S   GAE            MULTI (
01:00200FE2 4A85            	  2285:          TST.L   D5             (GARO)
01:00200FE4 6B20            	  2286:          BMI.S   GAE            R@ NOT ALLOWED WITH (..)
01:00200FE6 00050080        	  2287:          ORI.B   #$80,D5        (GALP) SET LEFT PAREN
                            	  2288: 
                            	  2289: * LEFT PARIN SET; MUST BE A@ NEXT
01:00200FEA 101D            	  2290:          MOVE.B  (A5)+,D0       GET BYTE
01:00200FEC BDCD            	  2291:          CMP.L   A5,A6
01:00200FEE 6516            	  2292:          BCS.S   GAE
01:00200FF0 0C000041        	  2293:          CMPI.B  #'A',D0
01:00200FF4 6610            	  2294:          BNE.S   GAE            NOT A-REG
01:00200FF6 41F80428        	  2295:          LEA     REGS+32,A0
01:00200FFA 6170            	  2296:          BSR.S   GASRGN         GET VALUE IN A@
01:00200FFC D881            	  2297:          ADD.L   D1,D4
01:00200FFE 008680000000    	  2298:          ORI.L   #$80000000,D6  (GAAVF) A-REG VALUE FLAG
01:00201004 60B6            	  2299:          BRA     GAP111S
                            	  2300: 
01:00201006 6000F4A6        	  2301: GAE      BRA     SYNTAX
                            	  2302: 
                            	  2303: *  COMMA  A-REG or
                            	  2304: *  COMMA  D-REG REQUIRED
                            	  2305: 
01:0020100A 4A86            	  2306: GAP161   TST.L   D6             (GAAVF)
01:0020100C 6AF8            	  2307:          BPL     GAE            NO A-REG SPECIFIED
01:0020100E 101D            	  2308:          MOVE.B  (A5)+,D0       GET BYTE
01:00201010 BDCD            	  2309:          CMP.L   A5,A6
01:00201012 65F2            	  2310:          BCS     GAE
01:00201014 0C000041        	  2311:          CMPI.B  #'A',D0
01:00201018 6606            	  2312:          BNE.S   GAP163
01:0020101A 41F80428        	  2313:          LEA     REGS+32,A0     GET VALUE IN A@
01:0020101E 600A            	  2314:          BRA.S   GAP165
01:00201020 0C000044        	  2315: GAP163   CMPI.B  #'D',D0
01:00201024 66E0            	  2316:          BNE     GAE            NOT D-REG
01:00201026 41F80408        	  2317:          LEA     REGS,A0        GET VALUE IN D@
01:0020102A 6140            	  2318: GAP165   BSR.S   GASRGN
01:0020102C D881            	  2319:          ADD.L   D1,D4
01:0020102E 608C            	  2320:          BRA     GAP111S
                            	  2321: 
                            	  2322: *  R@  OFFSET
                            	  2323: 
01:00201030 0C06002B        	  2324: GAP171   CMPI.B  #'+',D6        (GAPMS)
01:00201034 66D0            	  2325:          BNE     GAE            ONLY + ALLOWED
                            	  2326: 
                            	  2327: * ONLY ONE R@ ALLOWED
                            	  2328: 
01:00201036 4A85            	  2329:          TST.L   D5             (GARO)
01:00201038 6BCC            	  2330:          BMI     GAE            MULIT R@
01:0020103A 008580000000    	  2331:          ORI.L   #$80000000,D5  SET R@ GIVEN (GARO)
                            	  2332: 
01:00201040 41F8044C        	  2333:          LEA     OFFSET,A0
01:00201044 6126            	  2334:          BSR.S   GASRGN         GET VALUE IN R@
01:00201046 D881            	  2335:          ADD.L   D1,D4
01:00201048 6000FF6C        	  2336:          BRA     GAP119
                            	  2337: 
                            	  2338: *  )  CLOSE THE WORLD
                            	  2339: 
01:0020104C 4A86            	  2340: GAP181   TST.L   D6             (GAAVF)
01:0020104E 6AB6            	  2341:          BPL     GAE            NO (
01:00201050 6012            	  2342:          BRA.S   GAP197
                            	  2343: 
                            	  2344: *  SPACE  TERMINATOR
                            	  2345: 
01:00201052 4A45            	  2346: GAP191   TST.W   D5             (GALB)
01:00201054 6BB0            	  2347:          BMI     GAE            [ WITHOUT ]
01:00201056 4A05            	  2348:          TST.B   D5             (GALP)
01:00201058 6BAC            	  2349:          BMI     GAE            ( WITHOUT )
01:0020105A 538D            	  2350:          SUBQ.L  #1,A5          ADJUST CHAR POINTER
                            	  2351: 
                            	  2352: * IF NO R@ GIVEN ADD R0
                            	  2353: 
01:0020105C 4A85            	  2354:          TST.L   D5             (GARO)
01:0020105E 6B04            	  2355:          BMI.S   GAP197         R@ GIVEN
01:00201060 D8B8044C        	  2356:          ADD.L   OFFSET,D4
01:00201064 2004            	  2357: GAP197   MOVE.L  D4,D0
                            	  2358: 
01:00201066 4CDF0170        	  2359: GAP199   MOVEM.L (A7)+,D4-D6/A0
01:0020106A 4E75            	  2360:          RTS
                            	  2361: 
                            	  2362: * GET NEXT NUMBER
                            	  2363: *  A0 = POINTER TO TABLE OF VALUES
                            	  2364: *  D1 = VALUE ON RETURN
                            	  2365: 
01:0020106C 7000            	  2366: GASRGN   CLR.L   D0
01:0020106E 101D            	  2367:          MOVE.B  (A5)+,D0       GET BYTE
01:00201070 BDCD            	  2368:          CMP.L   A5,A6
01:00201072 6592            	  2369:          BCS     GAE
01:00201074 04000030        	  2370:          SUBI.B  #'0',D0        ADJUST TO ZERO
01:00201078 0C000007        	  2371:          CMPI.B  #7,D0
01:0020107C 6288            	  2372:          BHI     GAE            NOT 0 - 7
01:0020107E C0FC0004        	  2373:          MULU    #4,D0          4 * OFFSET
01:00201082 22300000        	  2374:          MOVE.L  (A0,D0),D1
01:00201086 4E75            	  2375:          RTS
                            	  2376: 
                            	  2377: 
                            	  2378: 
                            	  2379: 
                            	  2380: *-------------------------------------------------------------------------
                            	  2381: * File H         Register save,Trace, Breakpoint                  03/03/82
                            	  2382: 
                            	  2383: *       SAVE ALL REGISTERS ROUTINE-JMP [TEMP] BACK
                            	  2384: *          USUALLY CALLED BY THE MACRO "SAVEREGS"
                            	  2385: 
                            	  2386: SAVE     DS      0
01:00201088 4FF80444        	  2387:          LEA     REGA7,A7       WHERE TO START STORING
01:0020108C 48E7FFFE        	  2388:          MOVEM.L D0-D7/A0-A6,-(A7)  SAVE REGISTERS
                            	  2389: 
01:00201090 4FF8078A        	  2390:          LEA     SYSTACK+4,A7   SET UP STRETCHED VERSAUG STACK
                            	  2391: 
01:00201094 20780444        	  2392:          MOVE.L  REGA7,A0       A0 = TARGETS SUPERVISOR STACK POINTER
01:00201098 31D80406        	  2393:          MOVE.W  (A0)+,REGSR+2  GET TARGETS SR
                            	  2394: 
01:0020109C 21D80400        	  2395:          MOVE.L  (A0)+,REGPC    GET TARGETS PC
                            	  2396: 
01:002010A0 21C80444        	  2397:          MOVE.L  A0,REGA7       WHERE TARGET STACK REALLY POINTS
                            	  2398: 
01:002010A4 4E69            	  2399:          MOVE.L  USP,A1         GET USERS STACK POINTER
01:002010A6 21C90448        	  2400:          MOVE.L  A1,REGUS       SAVE IT FOR DISPLAY ETC
                            	  2401: 
01:002010AA 20380400        	  2402:          MOVE.L  REGPC,D0       GET PROGRAM COUNTER
01:002010AE 598F            	  2403:          SUBQ.L  #4,A7          SET REAL MACSBUG STACK
01:002010B0 2F3804D6        	  2404:          MOVE.L  TEMP,-(A7)     PUT RETURN ADDRESS ON STACK
01:002010B4 4E75            	  2405:          RTS                    RETURN TO SENDER
                            	  2406: 
                            	  2407: *
                            	  2408: *     ***TRACE***  TRACE ENTRY POINT
                            	  2409: *       ENTER FROM VECTOR 9  (LOCATION 24) FOR
                            	  2410: *
                            	  2411: 
                            	  2412: * REGISTER USAGE
                            	  2413: *  A0 = ADDRESS OF BREAKPOINT ADDRESS
                            	  2414: *  A2 = ADDRESS OF BREAKPOINT COUNTS
                            	  2415: *  D1 = PC
                            	  2416: *  D5 = TRACECNT
                            	  2417: *  D7 = BKPT COUNT
                            	  2418: 
01:002010B6 46FC2700        	  2419: TRACE    MOVE.W  #$2700,SR      MASK OFF INTERRUPTS
                            	  2420:          SAVEREGS
01:002010BA 21CF0444        	     1M          MOVE.L  A7,REGA7       SAVE STACK POINTER
01:002010BE 4FFA0008        	     2M          LEA     SV_000044(PC),A7    A7 = RETURN ADDRESS (FOR CALL TO SAVE)
01:002010C2 21CF04D6        	     3M          MOVE.L  A7,TEMP        TEMP = RETURN ADDRESS
01:002010C6 60C0            	     4M          BRA     SAVE           BSR WITHOUT USING STACK
                            	     5M SV_000044     DS      0
                            	  2421: 
                            	  2422: * IF PC POINTS TO 'TRACE'; DOUBLE EVENT OCCURED
                            	  2423: *  CLEAR LAST EVENT BY IGNORING
                            	  2424: 
01:002010C8 0CB8002004000400	  2425:          CMPI.L  #V2,REGPC
                            	  2426: 
01:002010D0 6610            	  2427:          BNE.S   TRACE16
                            	  2428: 
01:002010D2 2A780444        	  2429:          MOVE.L  REGA7,A5       TRIM LAST EVENT FROM STACK
01:002010D6 31DD0406        	  2430:          MOVE.W  (A5)+,REGSR+2  *MOVE VALUES FROM STACK TO
01:002010DA 21DD0400        	  2431:          MOVE.L  (A5)+,REGPC    *PSUEDO SR, PC,
01:002010DE 21CD0444        	  2432:          MOVE.L  A5,REGA7       *REFLECT ADJUSTMENTS IN PSUEDO STACK
01:002010E2 02787FFF0406    	  2433: TRACE16  ANDI.W  #$7FFF,REGSR+2 RESET "T" (TRACE) BIT
                            	  2434: 
                            	  2435: 
01:002010E8 2A3804DA        	  2436:          MOVE.L  TRACECNT,D5
01:002010EC 6B54            	  2437:          BMI.S   TRACE39        EXECUTING ONE-INSTRUCTION
01:002010EE 67000C50        	  2438:          BEQ     ABORT335       NOT TRACEING
                            	  2439: 
                            	  2440: *   MAKE SURE WE ARE NOT TRACING OURSELVES
01:002010F2 22380400        	  2441:          MOVE.L  REGPC,D1       GET PC
01:002010F6 41FAEF08        	  2442:          LEA.L   FIRST(PC),A0
01:002010FA B288            	  2443:          CMP.L   A0,D1
01:002010FC 6B10            	  2444:          BMI.S   TISOK          TRACING BELOW OURSELVES
01:002010FE 41FA32E8        	  2445:          LEA     LAST(PC),A0
01:00201102 B288            	  2446:          CMP.L   A0,D1
01:00201104 6208            	  2447:          BHI.S   TISOK          TRACING ABOVE OURSELVES
01:00201106 4BFA015E        	  2448:          LEA     MSG020(PC),A5  TRACING OURSELVES
01:0020110A 60000128        	  2449:          BRA     CHKBP4
                            	  2450: TISOK
                            	  2451: 
01:0020110E 41F80470        	  2452:          LEA     BPADD,A0
01:00201112 45F80494        	  2453:          LEA     BPCNT,A2
01:00201116 7E09            	  2454:          MOVEQ   #9,D7          9TH BP IS "UNTILL" FEATURE
                            	  2455: 
01:00201118 B290            	  2456: TRACE01  CMP.L   (A0),D1        SEE IF PC MATCHES ADDRESS IN TABLE
01:0020111A 6610            	  2457:          BNE.S   TRACE08
01:0020111C 2012            	  2458:          MOVE.L  (A2),D0        GET COUNT
01:0020111E 67000110        	  2459:          BEQ     CHKBP3         COUNT ZERO
01:00201122 5380            	  2460:          SUBQ.L  #1,D0          COUNT DOWN
01:00201124 2480            	  2461:          MOVE.L  D0,(A2)        SAVE IT
01:00201126 67000108        	  2462:          BEQ     CHKBP3         COUNT WENT TO ZERO
01:0020112A 6008            	  2463:          BRA.S   TRACE03
                            	  2464: 
01:0020112C 5888            	  2465: TRACE08  ADDQ.L  #4,A0          BUMP TABLE POINTER
01:0020112E 588A            	  2466:          ADDQ.L  #4,A2          BUMP COUNT TABLE POINTER
01:00201130 5387            	  2467:          SUBQ.L  #1,D7          LOOP AROUND
01:00201132 66E4            	  2468:          BNE     TRACE01
                            	  2469: 
01:00201134 6100FBCA        	  2470: TRACE03  BSR     TDISPLY        DO TRACE DISPLAY
01:00201138 53B804DA        	  2471:          SUBQ.L  #1,TRACECNT    TRACE COUNT
01:0020113C 6700F4F0        	  2472:          BEQ     MACSBUG        STOP WHEN ZERO
01:00201140 6008            	  2473:          BRA.S   UNTRACE        CONTINUE WITH TRACE
                            	  2474: 
                            	  2475: 
                            	  2476: * END UP HERE AFTER BREAKPOINTING ONE INSTRUCTION
                            	  2477: * -- PUT BP BACK IN AND CONTINUE TO RUN
                            	  2478: 
01:00201142 42B804DA        	  2479: TRACE39  CLR.L   TRACECNT
01:00201146 613A            	  2480:          BSR.S   SWAPIN         PUT BP INTO USER'S MEMORY
01:00201148 600E            	  2481:          BRA.S   UNSTACK        CONTINUE TO RUN
                            	  2482: 
                            	  2483: 
01:0020114A 007880000406    	  2484: UNTRACE  ORI.W   #$8000,REGSR+2 SET UP TRACE BIT!
                            	  2485:          ADDR2MEM TRACE,AV9     TAKE TRACE VECTOR
01:00201150 487AFF64        	     1M          PEA     TRACE(PC)         MOVE ADDRESS TO MEMORY; POSITION
01:00201154 21DF0024        	     2M          MOVE.L  (A7)+,AV9       INDEPENDANT = TO "MOVE.L #TRACE,AV9"
                            	  2486: 
01:00201158 22780448        	  2487: UNSTACK  MOVE.L  REGUS,A1
01:0020115C 4E61            	  2488:          MOVE.L  A1,USP         US = TARGET'S USER STACK
01:0020115E 24780400        	  2489:          MOVE.L  REGPC,A2       A2 = TARGET'S PC
                            	  2490: 
                            	  2491: 
                            	  2492:          DS      0              INSURE MEMORY AT LOCATION OF PC
01:00201162 3012            	  2493:          MOVE.W  (A2),D0        * ADDR TRAP ERROR * IF NO MEMORY
                            	  2494: 
01:00201164 22780444        	  2495:          MOVE.L  REGA7,A1       A1 = TARGET SYSTEM STACK (SS)
                            	  2496: 
                            	  2497:          DS      0              INSURE MEMORY AT TARGET'S STACK
01:00201168 230A            	  2498:          MOVE.L  A2,-(A1)       MOVE PC ONTO TARGET'S STACK
                            	  2499: 
01:0020116A 30380406        	  2500:          MOVE.W  REGSR+2,D0
01:0020116E 3300            	  2501:          MOVE.W  D0,-(A1)       SR ONTO TARGET'S STACK
                            	  2502: 
01:00201170 21C904D6        	  2503:          MOVE.L  A1,TEMP        TEMP = TARGETS SS
                            	  2504: 
01:00201174 4FF80408        	  2505:          LEA     REGS,A7        A7 = POINTER TO PSUEDO REGISTERS
01:00201178 4CDF7FFF        	  2506:          MOVEM.L (A7)+,D0-D7/A0-A6  ARM MOST OF TARGET REGISTERS
01:0020117C 2E7804D6        	  2507:          MOVE.L  TEMP,A7        SS = TARGET'S
                            	  2508: 
01:00201180 4E73            	  2509:          RTE                    GO BACK TO THE USER
                            	  2510: 
                            	  2511: 
01:00201182 6114            	  2512: SWAPIN   BSR.S   SWAPOUT        MAKE SURE THEY ARE ALL OUT
                            	  2513: 
01:00201184 21F8001004D2    	  2514:          MOVE.L  AV4,SAVEAV4    SAVE VECTOR (WHOM EVER'S IT WAS)
01:0020118A 4DFA0054        	  2515:          LEA     CHKBP(PC),A6
01:0020118E 21CE0010        	  2516:          MOVE.L  A6,AV4         REPLACE IT WITH THE "CHKBP" RTN
01:00201192 4DFA002A        	  2517:          LEA     SWAPIN1(PC),A6 A6 = ROUTINE ADDRESS
01:00201196 6010            	  2518:          BRA.S   SWAP
                            	  2519: 
01:00201198 4A7804E0        	  2520: SWAPOUT  TST.W   BPSTATUS        SEE IF OUT ALREADY
01:0020119C 6740            	  2521:          BEQ.S   SWAPEND         YES...DONE
01:0020119E 21F804D20010    	  2522:          MOVE.L  SAVEAV4,AV4     NO....REPLACE THE VECTOR
                            	  2523: 
01:002011A4 4DFA0028        	  2524:          LEA     SWAPOUT1(PC),A6 A6 = ROUTINE ADDRESS
01:002011A8 41F80470        	  2525: SWAP     LEA     BPADD,A0       A0 = ADDRESS OF TABLE
01:002011AC 45F80494        	  2526:          LEA     BPCNT,A2       A2 = ADDRESS OF COUNTS
01:002011B0 7E09            	  2527:          MOVEQ   #9,D7          DO 9 BP
01:002011B2 47F804B8        	  2528:          LEA     BPDATA,A3      CONTENT TABLE
                            	  2529: 
01:002011B6 2850            	  2530: SWAP1    MOVE.L  (A0),A4        GET POSSIBLE ADDDRESS
01:002011B8 4A90            	  2531:          TST.L   (A0)           IS POSSIBLE ADDRESS ZERO
01:002011BA 671A            	  2532:          BEQ.S   SWAP99         ZERO MEANS NO BP DEFINED
01:002011BC 4ED6            	  2533:          JMP     (A6)           GO TO RIGHT ROUTINE
                            	  2534: 
                            	  2535: SWAPIN1
01:002011BE 3014            	  2536:          MOVE.W  (A4),D0        USER'S PROGRAM GOES INTO TABLE
                            	  2537: 
01:002011C0 3680            	  2538:          MOVE.W  D0,(A3)
01:002011C2 38BC4AFB        	  2539:          MOVE.W  #BKPOINT,(A4)  PUT BREAKPOINT IN
                            	  2540: 
01:002011C6 31FC000104E0    	  2541:          MOVE.W  #1,BPSTATUS    FLAG AS BP IN
01:002011CC 6008            	  2542:          BRA.S   SWAP99
                            	  2543: 
01:002011CE 3013            	  2544: SWAPOUT1 MOVE.W  (A3),D0        GET CONTENTS FROM TABLE
01:002011D0 3880            	  2545:          MOVE.W  D0,(A4)        PUT CONTENTS BACK INTO PROGRAM
                            	  2546: 
01:002011D2 427804E0        	  2547:          CLR.W   BPSTATUS       FLAG AS BREAKPOINTS OUT
01:002011D6 5888            	  2548: SWAP99   ADDQ.L  #4,A0          BUMP ADDRESS TABLE POINTER
01:002011D8 548B            	  2549:          ADDQ.L  #2,A3          BUMP CONTENT TABLE POINTER
01:002011DA 5387            	  2550:          SUBQ.L  #1,D7
01:002011DC 66D8            	  2551:          BNE     SWAP1
01:002011DE 4E75            	  2552: SWAPEND  RTS
                            	  2553: 
                            	  2554: *  ILLEGAL INSTRUCTION ENTRY POINT
                            	  2555: *   BREAKPOINT TEST
                            	  2556: *
01:002011E0 46FC2700        	  2557: CHKBP    MOVE.W  #$2700,SR      MASK OF INT.
                            	  2558:          SAVEREGS
01:002011E4 21CF0444        	     1M          MOVE.L  A7,REGA7       SAVE STACK POINTER
01:002011E8 4FFA000A        	     2M          LEA     SV_000046(PC),A7    A7 = RETURN ADDRESS (FOR CALL TO SAVE)
01:002011EC 21CF04D6        	     3M          MOVE.L  A7,TEMP        TEMP = RETURN ADDRESS
01:002011F0 6000FE96        	     4M          BRA     SAVE           BSR WITHOUT USING STACK
                            	     5M SV_000046     DS      0
01:002011F4 20380400        	  2559:          MOVE.L  REGPC,D0       GET PROGRAM COUNTER TO COMPARE
01:002011F8 2A40            	  2560:          MOVE.L  D0,A5          A5 = TARGET PC
01:002011FA 3215            	  2561:          MOVE.W  (A5),D1        SEE WHAT OP CODE WAS XEQ
                            	  2562: 
01:002011FC 619A            	  2563:          BSR     SWAPOUT        TAKE BREAKPOINTS OUT
                            	  2564: 
01:002011FE 0C414AFB        	  2565:          CMPI.W  #BKPOINT,D1    USED FOR BP
01:00201202 6616            	  2566:          BNE.S   CHKBP11        NOT AT BREAKPOINT
                            	  2567: 
01:00201204 41F80470        	  2568:          LEA     BPADD,A0       A0 = ADDRESS OF BP ADDRESSES
01:00201208 45F80494        	  2569:          LEA     BPCNT,A2       A2 = ADDRESS OF BP COUNTS
01:0020120C 7E09            	  2570:          MOVEQ   #9,D7          D7 = LOOP COUNT
                            	  2571: 
01:0020120E BBD0            	  2572: CHKBP1   CMP.L   (A0),A5        SEE IF WE ARE THERE
01:00201210 6712            	  2573:          BEQ.S   CHKBP2         AT BREAKPOINT; AT AN ADDRESS
                            	  2574: 
01:00201212 5888            	  2575:          ADDQ.L  #4,A0          BUMP BOTH POINTERS
01:00201214 588A            	  2576:          ADDQ.L  #4,A2
01:00201216 5387            	  2577:          SUBQ.L  #1,D7
01:00201218 66F4            	  2578:          BNE     CHKBP1
                            	  2579: 
                            	  2580: * IS NOT A BREAKPOINT; ASSUME ILLEGAL INSTRUCTION
01:0020121A 4BFA0028        	  2581: CHKBP11  LEA     MSG009(PC),A5  'ILLEGAL INSTRUCTION'
01:0020121E 427804DE        	  2582:          CLR.W   TRACEON        RESET TRACE MODE
01:00201222 6010            	  2583:          BRA.S   CHKBP4
                            	  2584: 
                            	  2585: * AT BREAKPOINT...CHECK COUNT
01:00201224 2012            	  2586: CHKBP2   MOVE.L  (A2),D0        GET COUNT
01:00201226 6708            	  2587:          BEQ.S   CHKBP3         COUNT ZERO
01:00201228 5380            	  2588:          SUBQ.L  #1,D0          DECREMENT
01:0020122A 2480            	  2589:          MOVE.L  D0,(A2)        PUT COUNT BACK
01:0020122C 6600F7F4        	  2590:          BNE     GOCMD1         COUNT NOT ZERO; KEEP GOING
                            	  2591: 
01:00201230 4BFA0026        	  2592: CHKBP3   LEA     MSG014(PC),A5  "AT BREAKPOINT"
                            	  2593: 
01:00201234 6100F2C8        	  2594: CHKBP4   BSR     FIXDCRLF
01:00201238 61000DB0        	  2595:          BSR     OUT1CR
01:0020123C 6100FAC2        	  2596:          BSR     TDISPLY        PRINT TRACE DISPLAY
01:00201240 6000F3EC        	  2597:          BRA     MACSBUG
                            	  2598: 
01:00201244 494C4C4547414C20	  2599: MSG009   DC.B    'ILLEGAL INSTRUCTION',EOT
01:0020124C 494E535452554354
01:00201254 494F4E
01:00201257 04
                            	  2600: 
                            	  2601: 
                            	  2602: 
                            	  2603: 
01:00201258 415420425245414B	  2604: MSG014   DC.B    'AT BREAKPOINT',EOT
01:00201260 504F494E54
01:00201265 04
                            	  2605: 
                            	  2606: 
                            	  2607: 
01:00201266 2E50432077697468	  2608: MSG020   DC.B    '.PC within "DEBUGGER"',BELL,EOT
01:0020126E 696E202244454255
01:00201276 4747455222
01:0020127B 07
01:0020127C 04
                            	  2609: 
                            	  2610: 
                            	  2611: 
                            	  2612: 
                            	  2613: 
01:0020127D 00              	  2614:          DC.B    0              PAD BYTE
                            	  2615: 
                            	  2616: 
                            	  2617: *-------------------------------------------------------------------------
                            	  2618: * File BA        BASIC Command                                     12/01/81
                            	  2619: 
                            	  2620: * BASIC  COMMAND
                            	  2621: *  START ENHANCED BASIC
01:0020127E 600031BA        	  2622: BACMD    BRA     code_start        Run BASIC
                            	  2623: 
                            	  2624: 
                            	  2625: 
                            	  2626: *-------------------------------------------------------------------------
                            	  2627: * File HE        HELP Command                                     12/01/81
                            	  2628: 
                            	  2629: * HELP  COMMAND
                            	  2630: *  PRINT: REGISTERS AND COMMANDS IN TABLES
                            	  2631: 
01:00201282 4BFA0066        	  2632: HECMD    LEA     MSG002(PC),A5
01:00201286 6100F262        	  2633:          BSR     FIXDATA
01:0020128A 61000D5E        	  2634:          BSR     OUT1CR         PRINT
                            	  2635: 
01:0020128E 49FAF474        	  2636:          LEA     SOLIST(PC),A4  A4 = POINTER TO COMMAND LIST
                            	  2637: 
01:00201292 61000DFC        	  2638:          BSR     FIXBUF
01:00201296 143C0008        	  2639:          MOVE.B  #8,D2          D2 = # CMDS PER LINE
01:0020129A 321C            	  2640: HELP4    MOVE.W  (A4)+,D1       GET 2 BYTE COMMAND
01:0020129C 0C41FFFF        	  2641:          CMPI.W  #$FFFF,D1
01:002012A0 6740            	  2642:          BEQ.S   HELP6          DONE PRINT LAST BUFFER
01:002012A2 548C            	  2643:          ADDQ.L  #2,A4          BUMP POINTER UP BY 2
01:002012A4 4A41            	  2644:          TST.W   D1             IS THE INVISIBLE INDICATOR ON?
01:002012A6 6BF2            	  2645:          BMI     HELP4          YES... THEN BYPASS THIS ONE
01:002012A8 3601            	  2646:          MOVE.W  D1,D3          SAVE XX FOR "XX" AND "NOXX" IN HELP
01:002012AA 02417F7F        	  2647:          ANDI.W  #$7F7F,D1      REMOVE CONTROL BITS
01:002012AE 3CC1            	  2648:          MOVE.W  D1,(A6)+       NO.... MOVE THIS COMMAND TO "PRINT" LINE
01:002012B0 2CFC20202020    	  2649:          MOVE.L  #'    ',(A6)+  MOVE BLANKS FOR SPACING
01:002012B6 6118            	  2650:          BSR.S   HELP81         PRINT THE LINE IF FULL
01:002012B8 08030007        	  2651:          BTST    #7,D3          IS "NO" OPTION SUPPORTED?
01:002012BC 6710            	  2652:          BEQ.S   EOHLOOP        NO...BYPASS THIS COMMAND, ELSE...
01:002012BE 3CFC4E4F        	  2653:          MOVE.W  #'NO',(A6)+    "NO  "   IN MSG
01:002012C2 02437F7F        	  2654:          ANDI.W  #$7F7F,D3      RESET CONTROL BITS
01:002012C6 3CC3            	  2655:          MOVE.W  D3,(A6)+       "NOCC"   IN MSG (WHERE CC=COMMAND CODE)
01:002012C8 3CFC2020        	  2656:          MOVE.W  #'  ',(A6)+    "NOCC  " IN MSG    "    "    "      "
01:002012CC 6102            	  2657:          BSR.S   HELP81         PRINT THE LINE IF FULL
01:002012CE 60CA            	  2658: EOHLOOP  BRA     HELP4          NEXT COMMAND.
                            	  2659: 
                            	  2660: *        DISPLAY LINE OF COMMANDS (IF FULL)
                            	  2661: 
01:002012D0 5302            	  2662: HELP81   SUBQ.B  #1,D2          D2 = COUNT OF COMMANDS PER LINE
01:002012D2 660C            	  2663:          BNE.S   HELP85         NOT FULL, JUST RETURN FOR MORE
01:002012D4 61000D14        	  2664:          BSR     OUT1CR         YES, THEN WRITE IT
01:002012D8 61000DB6        	  2665:          BSR     FIXBUF         SET-UP LINE FOR NEXT COMMANDS
01:002012DC 143C0008        	  2666:          MOVE.B  #8,D2          D2 = MAX NUMBER CAN BE PLACED IN LINE
01:002012E0 4E75            	  2667: HELP85   RTS
                            	  2668: 
01:002012E2 61000D06        	  2669: HELP6    BSR     OUT1CR         PRINT ANY REMAINING PORTION
                            	  2670: *        BRA     HELP1          SEE IF COMPLETE
01:002012E6 6000F346        	  2671:          BRA     MACSBUG        HELP IS COMPLETE SO RETURN
                            	  2672: 
01:002012EA 2E5043202E535220	  2673: MSG002   DC.B    '.PC .SR .US .SS',CR,LF
01:002012F2 2E5553202E5353
01:002012F9 0D
01:002012FA 0A
                            	  2674: 
                            	  2675: 
                            	  2676: 
01:002012FB 2E4430202E443120	  2677:          DC.B    '.D0 .D1 .D2 .D3 .D4 .D5 .D6 .D7',CR,LF
01:00201303 2E4432202E443320
01:0020130B 2E4434202E443520
01:00201313 2E4436202E4437
01:0020131A 0D
01:0020131B 0A
                            	  2678: 
                            	  2679: 
                            	  2680: 
                            	  2681: 
                            	  2682: 
                            	  2683: 
01:0020131C 2E4130202E413120	  2684:          DC.B    '.A0 .A1 .A2 .A3 .A4 .A5 .A6 .A7',CR,LF
01:00201324 2E4132202E413320
01:0020132C 2E4134202E413520
01:00201334 2E4136202E4137
01:0020133B 0D
01:0020133C 0A
                            	  2685: 
                            	  2686: 
                            	  2687: 
                            	  2688: 
                            	  2689: 
                            	  2690: 
01:0020133D 2E5230202E523120	  2691:          DC.B    '.R0 .R1 .R2 .R3 .R4 .R5 .R6',CR,LF,EOT
01:00201345 2E5232202E523320
01:0020134D 2E5234202E523520
01:00201355 2E5236
01:00201358 0D
01:00201359 0A
01:0020135A 04
                            	  2692: 
                            	  2693: 
                            	  2694: 
                            	  2695: 
                            	  2696: 
                            	  2697: 
01:0020135B 00              	  2698:          DC.B    0              PAD BYTE
                            	  2699: 
                            	  2700: 
                            	  2701: 
                            	  2702: *-------------------------------------------------------------------------
                            	  2703: * File HEX2DEC   HEX2DEC convert hex to decimal                   11/02/81
                            	  2704: 
                            	  2705: 
                            	  2706: *    CONVERT BINARY TO DECIMAL  REG D0 PUT IN (A6) BUFFER AS ASCII
                            	  2707: 
01:0020135C 48E77B00        	  2708: HEX2DEC  MOVEM.L D1-D4/D6-D7,-(A7)   SAVE REGISTERS
01:00201360 2E00            	  2709:          MOVE.L  D0,D7          SAVE IT HERE
01:00201362 6A08            	  2710:          BPL.S   HX2DC
01:00201364 4487            	  2711:          NEG.L   D7             CHANGE TO POSITIVE
01:00201366 6B4E            	  2712:          BMI.S   HX2DC57        SPECIAL CASE (-0)
01:00201368 1CFC002D        	  2713:          MOVE.B  #'-',(A6)+     PUT IN NEG SIGN
01:0020136C 4244            	  2714: HX2DC    CLR.W   D4             FOR ZERO SURPRESS
01:0020136E 7C0A            	  2715:          MOVEQ   #10,D6         COUNTER
01:00201370 7401            	  2716: HX2DC0   MOVEQ   #1,D2          VALUE TO SUB
01:00201372 2206            	  2717:          MOVE.L  D6,D1          COUNTER
01:00201374 5381            	  2718:          SUBQ.L  #1,D1          ADJUST - FORM POWER OF TEN
01:00201376 671A            	  2719:          BEQ.S   HX2DC2         IF POWER IS ZERO
01:00201378 3602            	  2720: HX2DC1   MOVE.W  D2,D3          D3=LOWER WORD
01:0020137A C6FC000A        	  2721:          MULU    #10,D3
01:0020137E 4842            	  2722:          SWAP    D2             D2=UPPER WORD
01:00201380 C4FC000A        	  2723:          MULU    #10,D2
01:00201384 4843            	  2724:          SWAP    D3             ADD UPPER TO UPPER
01:00201386 D443            	  2725:          ADD.W   D3,D2
01:00201388 4842            	  2726:          SWAP    D2             PUT UPPER IN UPPER
01:0020138A 4843            	  2727:          SWAP    D3             PUT LOWER IN LOWER
01:0020138C 3403            	  2728:          MOVE.W  D3,D2          D2=UPPER & LOWER
01:0020138E 5381            	  2729:          SUBQ.L  #1,D1
01:00201390 66E6            	  2730:          BNE     HX2DC1
01:00201392 7000            	  2731: HX2DC2   CLR.L   D0             HOLDS SUB AMT
01:00201394 BE82            	  2732: HX2DC22  CMP.L   D2,D7
01:00201396 6D06            	  2733:          BLT.S   HX2DC3         IF NO MORE SUB POSSIBLE
01:00201398 5280            	  2734:          ADDQ.L  #1,D0          BUMP SUBS
01:0020139A 9E82            	  2735:          SUB.L   D2,D7          COUNT DOWN BY POWERS OF TEN
01:0020139C 60F6            	  2736:          BRA.S   HX2DC22        DO MORE
01:0020139E 4A00            	  2737: HX2DC3   TST.B   D0             ANY VALUE?
01:002013A0 6604            	  2738:          BNE.S   HX2DC4
01:002013A2 4A44            	  2739:          TST.W   D4             ZERO SURPRESS
01:002013A4 6708            	  2740:          BEQ.S   HX2DC5
01:002013A6 06000030        	  2741: HX2DC4   ADDI.B  #$30,D0        BINARY TO ASCII
01:002013AA 1CC0            	  2742:          MOVE.B  D0,(A6)+       PUT IN BUFFER
01:002013AC 1800            	  2743:          MOVE.B  D0,D4          MARK AS NON ZERO SURPRESS
01:002013AE 5386            	  2744: HX2DC5   SUBQ.L  #1,D6          NEXT POWER
01:002013B0 66BE            	  2745:          BNE     HX2DC0
01:002013B2 4A44            	  2746:          TST.W   D4             SEE IF ANYTHING PRINTED
01:002013B4 6604            	  2747:          BNE.S   HX2DC6
01:002013B6 1CFC0030        	  2748: HX2DC57  MOVE.B  #'0',(A6)+     PRINT AT LEST A ZERO
01:002013BA 4CDF00DE        	  2749: HX2DC6   MOVEM.L (A7)+,D1-D4/D6-D7   RESTORE REGISTERS
01:002013BE 4E75            	  2750:          RTS                    END OF ROUTINE
                            	  2751: 
                            	  2752: 
                            	  2753: 
                            	  2754: 
                            	  2755: *-------------------------------------------------------------------------
                            	  2756: * File LOAD      LO & VE (Load & Verify) Commands.                02/22/82
                            	  2757: 
                            	  2758: * THIS FUNCTION
                            	  2759: *   1.) READS A "S-RECORD"
                            	  2760: *   2.) FORMATS THE DATA ON THE STACK
                            	  2761: *   3.) CALCULATES THE CHECKSUM
                            	  2762: *   4.) THEN STORES (VERIFIES) THE DATA TO MEMORY
                            	  2763: *
                            	  2764: * WHEN VERIFYING RECORDS MAKE BE SKIPPED WHILE DISPLAYING THE MISS-MATCHED
                            	  2765: *  RECORDS.  DISPLAY FORMAT
                            	  2766: *   S1CCAAAA.-.-.-33.-
                            	  2767: *     CC                     BYTE COUNT
                            	  2768: *       AAAA                 ADDRESS
                            	  2769: *           .-.-.-  .-       DATA FIELDS THAT MATCHED
                            	  2770: *                 33         DATA MISS MATCH (DISPLAY DATA FROM S-RECORD)
                            	  2771: 
                            	  2772: *   ***LOAD*** AND ***VERIFY***  'S' RECORDS
                            	  2773: *
                            	  2774: *        D4 = ERROR FLAG
                            	  2775: *
                            	  2776: *        D5 = V000I0CC
                            	  2777: *             0.......  = LOAD
                            	  2778: *             8.......  = VERIFY
                            	  2779: *             ....0...  = CALCULATE CHECKSUM
                            	  2780: *             ....8...  = IGNORE CHECKSUM
                            	  2781: *             ......CC  = CHECKSUM
                            	  2782: 
01:002013C0 7A01            	  2783: VECMD    MOVEQ   #1,D5          MARK THE MODE
01:002013C2 E29D            	  2784:          ROR.L   #1,D5          D5 = $80000000
01:002013C4 6002            	  2785:          BRA.S   CHKCHKS        GO CHECK CHECKSUM OPTION
                            	  2786: 
01:002013C6 7A00            	  2787: LOCMD    CLR.L   D5             READ MODE
01:002013C8 7800            	  2788: CHKCHKS  CLR.L   D4             RESET ERROR FLAG
01:002013CA 61001184        	  2789:          BSR     SCANPORT       SET UP OUTPUT P1,P2,P3 ETC
                            	  2790: 
                            	  2791: * SEE IF CHECKSUM -C OPTION AND =SEND THIS OPTION
                            	  2792: 
01:002013CE BBCE            	  2793: READ01   CMP.L   A6,A5          SEE IF AT END OF BUFFER
01:002013D0 643C            	  2794:          BCC.S   READ09
01:002013D2 101D            	  2795:          MOVE.B  (A5)+,D0       GET A CHARACTER
01:002013D4 0C00003D        	  2796: READ03   CMPI.B  #'=',D0        SEE IF EQUAL SIGN
01:002013D8 6730            	  2797:          BEQ.S   READ08
                            	  2798: 
01:002013DA 0C000058        	  2799:          CMPI.B  #'X',D0        SEE IF ECHO
01:002013DE 6606            	  2800:          BNE.S   READ021
01:002013E0 1A3C00FF        	  2801:          MOVE.B  #-1,D5         D5.B = ECHO TO PORT ONE
01:002013E4 60E8            	  2802:          BRA     READ01
                            	  2803: 
01:002013E6 0C00002D        	  2804: READ021  CMPI.B  #'-',D0        SEE IF MINUS SIGN
01:002013EA 66E2            	  2805:          BNE.S   READ01
01:002013EC BBCE            	  2806:          CMP.L   A6,A5          SEE IF AT END OF BUFFER
01:002013EE 671E            	  2807:          BEQ.S   READ09
01:002013F0 101D            	  2808:          MOVE.B  (A5)+,D0       GRAB SECOND CHARACTER
01:002013F2 0C000043        	  2809:          CMPI.B  #'C',D0        SEE IF LETTER C AS IN -C
01:002013F6 66DC            	  2810:          BNE     READ03
01:002013F8 00458000        	  2811:          ORI.W   #$8000,D5      MARK AS IGNORE CHECKSUM
01:002013FC 60D0            	  2812:          BRA     READ01
                            	  2813: 
01:002013FE 7C00            	  2814: READS1   CLR.L   D6             D6 = TYPE "S1"
01:00201400 5983            	  2815:          SUBQ.L  #4,D3          BYTE COUNT
                            	  2816: 
01:00201402 7000            	  2817:          CLR.L   D0
01:00201404 6100013C        	  2818:          BSR     READHEX4       FORM ADDRESS
01:00201408 6066            	  2819:          BRA.S   READS202
                            	  2820: 
01:0020140A 61000C02        	  2821: READ08   BSR     OUTPUT2        SEND REST OF LINE(+CR) TO PORT
                            	  2822: 
01:0020140E 11C504E2        	  2823: READ09   MOVE.B  D5,ECHOPT1     MOVE ECHO FLAG
01:00201412 21F80630061C    	  2824:          MOVE.L  OUTPORT1,OUTTO SEND OUTPUT TO CONSOLE
                            	  2825: 
                            	  2826: 
01:00201418 4FF80786        	  2827: READ0    LEA     SYSTACK,A7     FORCE STACK (FOR ERROR RECOVERY)
                            	  2828: 
01:0020141C 4E54FFBC        	  2829:          LINK    A4,#-((BUFFSIZE/2)+4)  CREATE BUFFER ON STACK
                            	  2830: 
01:00201420 4205            	  2831:          CLR.B   D5             ZERO CHECKSUM
                            	  2832: 
01:00201422 61000C6C        	  2833:          BSR     FIXBUF         START OF INPUT BUFFER
01:00201426 61000F94        	  2834:          BSR     PORTIN2        GET A RECORD FROM PORT
                            	  2835: 
01:0020142A 264D            	  2836:          MOVE.L  A5,A3 SAVE     START ADDRESS OF BUFFER
01:0020142C 101B            	  2837: READ00   MOVE.B  (A3)+,D0       GET FIRST CHARACTER
01:0020142E BDCB            	  2838:          CMP.L   A3,A6
01:00201430 65E6            	  2839:          BCS     READ0          END OF BUFFER WITHOUT "S"
                            	  2840: 
01:00201432 0C000053        	  2841: READ005  CMPI.B  #'S',D0        SEE IF IT IS AN S
01:00201436 66F4            	  2842:          BNE     READ00         GET ANOTHER CHARACTER
01:00201438 610000C4        	  2843:          BSR     GETCHR         GET RECORD TYPE
01:0020143C 2C00            	  2844:          MOVE.L  D0,D6
                            	  2845: 
01:0020143E 610000B0        	  2846:          BSR     READHEX        GET CHAR COUNT
01:00201442 7600            	  2847:          CLR.L   D3
01:00201444 1600            	  2848:          MOVE.B  D0,D3
                            	  2849: 
01:00201446 0C060030        	  2850:          CMPI.B  #'0',D6        'S0'???
01:0020144A 67CC            	  2851:          BEQ     READ0          JUST IGNORE
01:0020144C 0C060031        	  2852:          CMPI.B  #'1',D6
01:00201450 67AC            	  2853:          BEQ.S   READS1         S1 RECORD TYPE (2 BYTE ADDRESS)
01:00201452 0C060038        	  2854:          CMPI.B  #'8',D6
01:00201456 670000F6        	  2855:          BEQ     READS8         S8 RECORD TYPE
01:0020145A 0C060039        	  2856:          CMPI.B  #'9',D6
01:0020145E 670000FE        	  2857:          BEQ     READS9         S9 RECORD TYPE
01:00201462 0C060032        	  2858:          CMPI.B  #'2',D6
01:00201466 66CA            	  2859:          BNE.S   READ005        KEEP LOOKING FOR "Sn"
                            	  2860: 
01:00201468 7C02            	  2861: READS2   MOVEQ   #2,D6          D6 = TYPE = S2 (3 BYTE ADDRESS)
01:0020146A 610000D0        	  2862:          BSR     READHEX6
01:0020146E 5B83            	  2863:          SUBQ.L  #5,D3          BYTE COUNT
01:00201470 2943FFBC        	  2864: READS202 MOVE.L  D3,CC(A4)
                            	  2865: 
01:00201474 2940FFC0        	  2866:          MOVE.L  D0,ADDRESS(A4) ADDRESS + OFFSET
01:00201478 45ECFFC4        	  2867:          LEA     LDATA(A4),A2   A2 = STORE TO STACK POINTER
                            	  2868: 
01:0020147C 6172            	  2869: READ100  BSR.S   READHEX        GET DATA BYTE
01:0020147E 14C0            	  2870:          MOVE.B  D0,(A2)+       MOVE DATA TO STACK
01:00201480 51CBFFFA        	  2871:          DBRA    D3,READ100
                            	  2872: 
01:00201484 4A45            	  2873:          TST.W   D5
01:00201486 6B0A            	  2874:          BMI.S   READ120        IGNORE CHECKSUM
                            	  2875: 
01:00201488 1E05            	  2876:          MOVE.B  D5,D7
01:0020148A 6164            	  2877:          BSR.S   READHEX        GET CHECKSUM FROM DATA
01:0020148C 4607            	  2878:          NOT.B   D7             CALCULATED CHECKSUM
01:0020148E B007            	  2879:          CMP.B   D7,D0
01:00201490 664C            	  2880:          BNE.S   READCKSM       ERROR
                            	  2881: READ120
                            	  2882: 
                            	  2883: 
                            	  2884: * STORE DATA (VERIFY) TO MEMORY
                            	  2885: 
01:00201492 262CFFBC        	  2886:          MOVE.L  CC(A4),D3      BYTE COUNT
01:00201496 266CFFC0        	  2887:          MOVE.L  ADDRESS(A4),A3 MEMORY STORE ADDRESS
01:0020149A 45ECFFC4        	  2888:          LEA     LDATA(A4),A2   DATA ADDRESS ON STACK
                            	  2889: 
01:0020149E 4A85            	  2890:          TST.L   D5
01:002014A0 6B10            	  2891:          BMI.S   READ400        VERIFY
                            	  2892: 
01:002014A2 1692            	  2893: READ130  MOVE.B  (A2),(A3)      STORE DATA
01:002014A4 B70A            	  2894:          CMP.B   (A2)+,(A3)+    VERIFY DATA STORED
01:002014A6 6600045A        	  2895:          BNE     SETME          DATA DID NOT STORE
01:002014AA 51CBFFF6        	  2896:          DBRA    D3,READ130
01:002014AE 6000FF68        	  2897: READ135  BRA     READ0
                            	  2898: 
                            	  2899: 
                            	  2900: ***     VERIFY
                            	  2901: 
01:002014B2 43ED0008        	  2902: READ400  LEA     8(A5),A1       A1 = PTR TO INPUT STRING
01:002014B6 D3C6            	  2903:          ADD.L   D6,A1
                            	  2904: 
01:002014B8 7E00            	  2905:          CLR.L   D7             D7 = MISS-MATCH FLAG
                            	  2906: 
01:002014BA B70A            	  2907: READ410  CMP.B   (A2)+,(A3)+    VERIFY DATA
01:002014BC 6618            	  2908:          BNE.S   READ440        MISS-MATCH
01:002014BE 12FC002E        	  2909:          MOVE.B  #'.',(A1)+     OVERLAY INPUT STRING IF OK
01:002014C2 12FC002D        	  2910:          MOVE.B  #'-',(A1)+
01:002014C6 51CBFFF2        	  2911: READ420  DBRA    D3,READ410
                            	  2912: 
01:002014CA 4A87            	  2913:          TST.L   D7
01:002014CC 67E0            	  2914:          BEQ     READ135        RECORD OK
                            	  2915: 
01:002014CE 2C49            	  2916:          MOVE.L  A1,A6          DONOT DISPLAY CHECKSUM
01:002014D0 61000B18        	  2917: READ430  BSR     OUT1CR         DISPLAY IT
01:002014D4 60D8            	  2918:          BRA     READ135        READ NEXT RECORD
                            	  2919: 
01:002014D6 7EFF            	  2920: READ440  MOVEQ   #-1,D7         D7 = Set miss-match flag
01:002014D8 78FF            	  2921:          MOVEQ   #-1,D4         D4 = Set Summary error flag
01:002014DA 5489            	  2922:          ADDQ.L  #2,A1
01:002014DC 60E8            	  2923:          BRA     READ420
                            	  2924: 
01:002014DE 78FF            	  2925: READCKSM MOVEQ   #-1,D4         D4 = Set summary error flag
01:002014E0 4BFA0051        	  2926:          LEA     MSGLOAD2(PC),A5
01:002014E4 6100F008        	  2927:          BSR     FIXDADD
01:002014E8 2007            	  2928:          MOVE.L  D7,D0
01:002014EA 610008C6        	  2929:          BSR     PNT2HX         CALCULATED CHECKSUM
01:002014EE 60E0            	  2930:          BRA     READ430
                            	  2931: 
01:002014F0 6114            	  2932: READHEX  BSR.S   GETHEXC        FORM BYTE
01:002014F2 E900            	  2933:          ASL.B   #4,D0
01:002014F4 1200            	  2934:          MOVE.B  D0,D1
01:002014F6 610E            	  2935:          BSR.S   GETHEXC
01:002014F8 8001            	  2936:          OR.B    D1,D0          D0 = BYTE FORMED
01:002014FA DA00            	  2937:          ADD.B   D0,D5          UPDATE CHECKSUM
01:002014FC 4E75            	  2938:          RTS
                            	  2939: 
01:002014FE 101B            	  2940: GETCHR   MOVE.B  (A3)+,D0
01:00201500 BDCB            	  2941:          CMP.L   A3,A6
01:00201502 65DA            	  2942:          BCS     READCKSM       OVERFLOW
01:00201504 4E75            	  2943:          RTS
                            	  2944: 
01:00201506 61F6            	  2945: GETHEXC  BSR     GETCHR
01:00201508 04000030        	  2946:          SUBI.B  #$30,D0        SEE IF LESS THAN ZERO
01:0020150C 6D10            	  2947:          BLT.S   RHEX3
01:0020150E 0C000009        	  2948:          CMPI.B  #$09,D0        SEE IF GT 9
01:00201512 6F08            	  2949:          BLE.S   RHEX2
01:00201514 5F00            	  2950:          SUBQ.B  #7,D0          NORMALIZE $A TO 10
01:00201516 0C000010        	  2951:          CMPI.B  #$10,D0        SEE IF TOO LARGE
01:0020151A 6402            	  2952:          BCC.S   RHEX3
01:0020151C 4E75            	  2953: RHEX2    RTS
                            	  2954: 
01:0020151E 4BFA000A        	  2955: RHEX3    LEA     MSGLOAD1(PC),A5 'NOT HEX=X?'  MESSAGE
01:00201522 6100EFCA        	  2956:          BSR     FIXDADD
01:00201526 1CE3            	  2957:          MOVE.B  -(A3),(A6)+    BAD CHARACTER
01:00201528 60A6            	  2958:          BRA     READ430        GO TRY NEXT RECORD
                            	  2959: 
01:0020152A 4E4F54204845583D	  2960: MSGLOAD1 DC.B    'NOT HEX=',EOT
01:00201532 04
                            	  2961: 
                            	  2962: 
01:00201533 2043484B53554D3D	  2963: MSGLOAD2 DC.B    ' CHKSUM=',EOT
01:0020153B 04
                            	  2964: 
                            	  2965: 
01:0020153C 7000            	  2966: READHEX6 CLR.L   D0             FORM ADDRESS (3 BYTE)
01:0020153E 61B0            	  2967:          BSR     READHEX
01:00201540 E180            	  2968:          ASL.L   #8,D0
01:00201542 61AC            	  2969: READHEX4 BSR     READHEX        FORM ADDRESS (2 BYTE)
01:00201544 E180            	  2970:          ASL.L   #8,D0
01:00201546 61A8            	  2971:          BSR     READHEX
01:00201548 D0B8044C        	  2972:          ADD.L   OFFSET,D0
01:0020154C 4E75            	  2973:          RTS
                            	  2974: 
01:0020154E 61EC            	  2975: READS8   BSR     READHEX6
01:00201550 21C00400        	  2976: READS800 MOVE.L  D0,REGPC       SAVE IT IN THE USER PREG
                            	  2977: 
01:00201554 4A84            	  2978:          TST.L   D4
01:00201556 6600EF50        	  2979:          BNE     ERROR          DISPLAY "ERROR"
01:0020155A 6000F0D2        	  2980:          BRA     MACSBUG        END OF ROUTINE
                            	  2981: 
01:0020155E 7000            	  2982: READS9   CLR.L   D0
01:00201560 61E0            	  2983:          BSR     READHEX4       GET ADDRESS
01:00201562 60EC            	  2984:          BRA     READS800
                            	  2985: 
                            	  2986: 
                            	  2987: *-------------------------------------------------------------------------
                            	  2988: * File MDDI      MD[S] (Memory Display) Command                   06/16/82
                            	  2989: 
                            	  2990: *   ***MD***   MEMORY DISPLAY         ENTRY POINT
                            	  2991: *     FORMAT:  MD[S] <ADDRESS> [<COUNT>] [;DI]
                            	  2992: * 1.  IF 'S' USED IN COMMAND THEN IT WILL DUMP 16 LINES, (1 Screen), AND
                            	  2993: *     PROMPT-ENTER CR FOR 16 MORE LINES ETC OR ANY MACSBUG COMMAND.
                            	  2994: *
                            	  2995: 
                            	  2996: MDCMD    DS      0
01:00201564 61000FEA        	  2997:          BSR     SCANPORT       WHERE TO SEND OUTPUT
01:00201568 21F90000062C0620	  2998:          MOVE.L  INPORT1.L,INFROM ONLY ALLOW INPUT FROM PORT1
                            	  2999: 
01:00201570 7CFF            	  3000:          MOVEQ   #-1,D6         D6 = HOW MANY LINES PER PAGE
                            	  3001: 
01:00201572 97CB            	  3002:          SUB.L   A3,A3          A4 = DEFAULT ZERO  START
01:00201574 284B            	  3003:          MOVE.L  A3,A4          A3 = END ADDR
                            	  3004: 
01:00201576 7E00            	  3005:          CLR.L   D7             D7 = DO NOT DISASSEMBLE
01:00201578 244D            	  3006:          MOVE.L  A5,A2
01:0020157A BDCA            	  3007: PRINT8   CMP.L   A2,A6          LOOK FOR OPTIONS
01:0020157C 651A            	  3008:          BCS.S   PRINTDI        NO  OPTIONS
01:0020157E 0C1A003B        	  3009:          CMPI.B  #';',(A2)+
01:00201582 66F6            	  3010:          BNE     PRINT8
                            	  3011: 
01:00201584 2C4A            	  3012:          MOVE.L  A2,A6
01:00201586 538E            	  3013:          SUBQ.L  #1,A6          A6 = POINTER TO ;
                            	  3014: 
01:00201588 0C1A0044        	  3015:          CMPI.B  #'D',(A2)+
01:0020158C 6600EF20        	  3016: PRINTMB  BNE     SYNTAX         COMMAND SYNTAX ERROR
01:00201590 0C1A0049        	  3017:          CMPI.B  #'I',(A2)+
01:00201594 66F6            	  3018:          BNE     PRINTMB
01:00201596 7EFF            	  3019:          MOVEQ   #-1,D7         DISASSEMBLE OPTION
                            	  3020: PRINTDI
                            	  3021: 
                            	  3022: 
                            	  3023: * LOOK FOR "S" IN COMMAND
01:00201598 1015            	  3024:          MOVE.B  (A5),D0
01:0020159A 0C000053        	  3025:          CMPI.B  #'S',D0
01:0020159E 6608            	  3026:          BNE.S   PRINT5         NO "S" IN COMMAND
01:002015A0 528D            	  3027:          ADDQ.L  #1,A5          MOVE PAST "S"
                            	  3028: 
01:002015A2 7C10            	  3029:          MOVEQ   #16,D6         DO 16 LINES AT A TIME
01:002015A4 97CB            	  3030:          SUB.L   A3,A3
01:002015A6 538B            	  3031:          SUBQ.L  #1,A3          MAX END ADDRESS
                            	  3032: 
01:002015A8 41FA001A        	  3033: PRINT5   LEA     PRINT7(PC),A0  WHERE TO GO IF NO PARAMETERS
01:002015AC 610008C0        	  3034:          BSR     FNEXTF         FIND NEXT FIELD
01:002015B0 6100F984        	  3035:          BSR     GETA
01:002015B4 2840            	  3036:          MOVE.L  D0,A4          A4 = GET ADDRESS
                            	  3037: 
01:002015B6 610008B6        	  3038:          BSR     FNEXTF
01:002015BA 61000906        	  3039:          BSR     GETEXP         D0 = GET COUNT
01:002015BE D08C            	  3040:          ADD.L   A4,D0          END=START+COUNT-1
01:002015C0 5380            	  3041:          SUBQ.L  #1,D0          BACK OFF ONE
01:002015C2 2640            	  3042:          MOVE.L  D0,A3          A3 = END ADDRESS
                            	  3043: 
01:002015C4 4A87            	  3044: PRINT7   TST.L   D7
01:002015C6 672A            	  3045:          BEQ.S   PUTADR         NOT DISASSEMBLE
                            	  3046: 
01:002015C8 61000AC6        	  3047: PRINTDI5 BSR     FIXBUF         ;DI OPTION
01:002015CC 48E70310        	  3048:          MOVEM.L A3/D6-D7,-(A7)
01:002015D0 4CD40007        	  3049:          MOVEM.L (A4),D0-D2     D0-D2 = DATA TO DISASSEMBLE
01:002015D4 6100288A        	  3050:          BSR     DCODE68K       DISASSEMBLE
01:002015D8 61000A10        	  3051:          BSR     OUT1CR
01:002015DC 4CDF08C0        	  3052:          MOVEM.L (A7)+,A3/D6-D7
                            	  3053: 
01:002015E0 5386            	  3054:          SUBQ.L  #1,D6
01:002015E2 676C            	  3055:          BEQ.S   PRINT9         'MDS' COMMAND
                            	  3056: 
01:002015E4 B7CC            	  3057:          CMP.L   A4,A3          END CHECK
01:002015E6 64E0            	  3058:          BCC     PRINTDI5
01:002015E8 6066            	  3059:          BRA.S   PRINT9
                            	  3060: 
01:002015EA 7C10            	  3061: PRINT3   MOVEQ   #16,D6         D6 = LINE BLOCK COUNT
01:002015EC 97CB            	  3062:          SUB.L   A3,A3
01:002015EE 538B            	  3063:          SUBQ.L  #1,A3          A3 = MAX END ADDRESS
01:002015F0 60D2            	  3064:          BRA     PRINT7
                            	  3065: 
                            	  3066: * START A NEW  LINE
                            	  3067: *
01:002015F2 61000A9C        	  3068: PUTADR   BSR     FIXBUF         SET UP OUTPUT BUFFER
01:002015F6 200C            	  3069:          MOVE.L  A4,D0          CURRENT LINE ADDRESS
01:002015F8 610007D4        	  3070:          BSR     FRELADDR       FORM RELATIVE ADDRESS
01:002015FC 1CFC0020        	  3071:          MOVE.B  #$20,(A6)+     FORMAT  SPACE
01:00201600 204C            	  3072:          MOVE.L  A4,A0          A0 IS SCANNING ADDRESS
01:00201602 7610            	  3073:          MOVEQ   #$10,D3        SET UP COUNTER FOR LOOP
                            	  3074: 
01:00201604 1018            	  3075: NXTBP    MOVE.B  (A0)+,D0       GET BYTE TO PRINT
01:00201606 610007AA        	  3076:          BSR     PNT2HX         PRINT IT
01:0020160A 1CFC0020        	  3077:          MOVE.B  #$20,(A6)+     SPACE BETWEEN EACH HEX
                            	  3078: 
01:0020160E 0C030009        	  3079:          CMPI.B  #9,D3          HALF LINE SPACING
01:00201612 6604            	  3080:          BNE.S   NXTBP3
01:00201614 1CFC0020        	  3081:          MOVE.B  #$20,(A6)+
                            	  3082: NXTBP3
                            	  3083: 
01:00201618 5383            	  3084:          SUBQ.L  #1,D3
01:0020161A 66E8            	  3085:          BNE     NXTBP          LOOP TILL D3 IS ZERO
                            	  3086: 
01:0020161C 1CFC0020        	  3087:          MOVE.B  #$20,(A6)+     MOVE A SPACE
01:00201620 204C            	  3088:          MOVE.L  A4,A0          RELOAD SCANNER FOR ASCII PRINTS
01:00201622 7610            	  3089:          MOVEQ   #$10,D3        RELOAD COUNTER
                            	  3090: 
01:00201624 1018            	  3091: NXTCHR   MOVE.B  (A0)+,D0       FETCH BYTE
01:00201626 0200007F        	  3092:          ANDI.B  #$7F,D0        REMOVE HIGH ORDER BIT, (ASCII ONLY USES 7 BITS)
01:0020162A 0C000020        	  3093:          CMPI.B  #$20,D0        SEE IF IT IS CONTROL CHAR
01:0020162E 6D06            	  3094:          BLT.S   NOTCHR         BYPASS IF IT IS... ELSE
01:00201630 0C00007F        	  3095:          CMPI.B  #$7F,D0        IS IT A "7F"?    (CAUSES PRINTER PROBLEM)
01:00201634 6D04            	  3096:          BLT.S   PUTCHR         NO... THEN PRINT IT, ELSE SUBSTITUTE "."
01:00201636 103C002E        	  3097: NOTCHR   MOVE.B  #$2E,D0        CHANGE UNPRINTABLE TO PERIOD
                            	  3098: 
01:0020163A 1CC0            	  3099: PUTCHR   MOVE.B  D0,(A6)+       MOVE "EDITTED" CHARACTER TO PRINT LINE
01:0020163C 5383            	  3100:          SUBQ.L  #1,D3          LOOP AROUND FOR NEXT CHAR
01:0020163E 66E4            	  3101:          BNE     NXTCHR         ANY LEFT?
01:00201640 610009A8        	  3102:          BSR     OUT1CR         NO... THEN PRINT THE COMPLETE LINE
01:00201644 508C            	  3103:          ADDQ.L  #$08,A4        UPDATE STARTING ADDRESS OF NEXT ADDRESS
01:00201646 508C            	  3104:          ADDQ.L  #$08,A4        ........
01:00201648 B7CC            	  3105:          CMP.L   A4,A3          DOES NEW LINE START PAST END
01:0020164A 6504            	  3106:          BCS.S   PRINT9         SEE IF STILL GOING
01:0020164C 5386            	  3107:          SUBQ.L  #1,D6          DECR THE COUNTER
01:0020164E 66A2            	  3108:          BNE     PUTADR         DO ANOTHER LINE
                            	  3109: 
01:00201650 4BFAF0A4        	  3110: PRINT9   LEA     MSG001(PC),A5  SET UP FOR PROMPT
01:00201654 6100EE94        	  3111:          BSR     FIXDATA
01:00201658 1CFC003E        	  3112:          MOVE.B  #'>',(A6)+     PROMPT SAME AS MACSBUG
01:0020165C 1CFC0020        	  3113:          MOVE.B  #BLANK,(A6)+
01:00201660 610009A2        	  3114:          BSR     OUTPUT         PRINT IT
                            	  3115: 
01:00201664 61000A2A        	  3116:          BSR     FIXBUF         RESET BUFFER
01:00201668 61000A2E        	  3117:          BSR     PORTIN1        TAKE IN INPUT
01:0020166C BBCE            	  3118:          CMP.L   A6,A5          SEE IF ANYTHING ENTERED
01:0020166E 6700FF7A        	  3119:          BEQ     PRINT3         NOTHING ENTERED; DO 16 MORE LINES
01:00201672 42B8061C        	  3120:          CLR.L   OUTTO          *
01:00201676 6000EFF8        	  3121:          BRA     DECODE6        GO MAKE SURE 2ND DIGIT IS BLANK
                            	  3122: 
                            	  3123: 
                            	  3124: 
                            	  3125: 
                            	  3126: *-------------------------------------------------------------------------
                            	  3127: * File MMDI      Modify Memory command WITH asm/disasm            11/27/81
                            	  3128: 
                            	  3129: * MODIFY MEMORY
                            	  3130: *  COMMON REGISTER USAGE
                            	  3131: *   A6  IO BUFFER POINTER  END
                            	  3132: *   A5  IO BUFFER POINTER  START
                            	  3133: *   A4  ADDRESS TO MODIFY
                            	  3134: *   A3
                            	  3135: *   A2
                            	  3136: *   A1
                            	  3137: *   A0
                            	  3138: *   D7  DATA READ (DATA STORED)
                            	  3139: *   D6  SIZE  1/2/4 BYTES  (ASM/DISASM 2 - 10 BYTES)
                            	  3140: *   D5  OVERRIDE BYTE (80XX=NON VERIFY)  (XX80=BYTE SIZE)
                            	  3141: *
                            	  3142: * ;OPTIONS
                            	  3143: *   ;W  WORD
                            	  3144: *   ;L  LONG WORD (4 BYTES)
                            	  3145: *   ;DI DISASSEMBLE
                            	  3146: *     ;O  ODD ADDRESSES ONLY
                            	  3147: *     ;V  EVEN ADDRESSES ONLY
                            	  3148: *       ;N  NON-VERIFY
                            	  3149: *
                            	  3150: 
01:0020167A 61000810        	  3151: MMDI     BSR     CKWADR
01:0020167E 61000812        	  3152:          BSR     CKADDR
01:00201682 7C00            	  3153:          CLR.L   D6             SIZE = 0
01:00201684 D9C6            	  3154: MMDI22   ADD.L   D6,A4          PC = PC + SIZE
01:00201686 61000A08        	  3155: MMDI23   BSR     FIXBUF         A5 & A6 = POINTER TO BUFFER
                            	  3156: 
                            	  3157: *                  ENTRY
                            	  3158: *                   A4 = PROGRAM COUNTER
                            	  3159: *                   A5 = POINTER TO STORE DISASSEMBLED LINE
01:0020168A 4CD40007        	  3160:          MOVEM.L   (A4),D0-D2          DATA TO DISASSEMBLE
01:0020168E 610027D0        	  3161:          BSR       DCODE68K
                            	  3162: *                  RETURN
                            	  3163: *                   A4 = NEW PROGRAM COUNTER
                            	  3164: *                   A5 = PTR START BUFFER
                            	  3165: *                   A6 = PRT END BUFFER
                            	  3166: *                   D6 = NUMBER OF BYTES DISASSEMBLED
                            	  3167: 
01:00201692 1CFC003F        	  3168:          MOVE.B  #'?',(A6)+
01:00201696 6100096C        	  3169:          BSR     OUTPUT
                            	  3170: 
01:0020169A 610009F4        	  3171: MMDI31   BSR     FIXBUF
01:0020169E 61000A0A        	  3172:          BSR     PORTIN1N       INPUT ASSEMBLY SOURCE (NO LINE FEED)
01:002016A2 BDCD            	  3173:          CMP.L   A5,A6
01:002016A4 6606            	  3174:          BNE.S   MMDI34
01:002016A6 61000942        	  3175:          BSR     OUT1CR         NOTHING INPUT; OUTPUT LINE FEED
01:002016AA 60DA            	  3176:          BRA     MMDI23
                            	  3177: 
01:002016AC 99C6            	  3178: MMDI34   SUB.L   D6,A4          BACKUP PC
                            	  3179: 
01:002016AE 0C15002E        	  3180:          CMPI.B  #'.',(A5)
01:002016B2 670001DC        	  3181:          BEQ     MM905          CLOSE
                            	  3182: 
01:002016B6 47F80797        	  3183:          LEA     SYSTACK+17,A3  STORE BUFFER
                            	  3184: 
                            	  3185: *                  A3 = STORE POINTER
                            	  3186: *                  A4 = PROGRAM COUNTER
                            	  3187: *                  A5 = POINTER TO DATA TO ASSEMBLE
                            	  3188: *                  A6 = POINTER TO END OF SOURCE DATA
                            	  3189: 
01:002016BA 610015CA        	  3190:          BSR     CODE68K        ASSEMBLE
                            	  3191: 
                            	  3192: *                  A3 = POINTER TO LINE ASSEMBLED
                            	  3193: *                  A4 = PROGRAM COUNTER
                            	  3194: *                  A6 = POINTER END OF LINE ASSEMBLED
                            	  3195: *                  D0-D2 = DATA ASSEMBLED
                            	  3196: *                  D6 = NUMBER OF BYTES ASSEMBLED
                            	  3197: *                  D7 = ERROR FLAG & POSITION OF ERROR
                            	  3198: 
01:002016BE 2A4B            	  3199:          MOVE.L  A3,A5
01:002016C0 47EB004E        	  3200:          ADD.L   #78,A3         A3 = MAX LINE
01:002016C4 B7CE            	  3201: MMDI26   CMP.L   A6,A3
01:002016C6 6506            	  3202:          BCS.S   MMDI27
01:002016C8 1CFC0020        	  3203:          MOVE.B  #BLANK,(A6)+   SPACE FILL LINE
01:002016CC 60F6            	  3204:          BRA     MMDI26
01:002016CE 6100091A        	  3205: MMDI27   BSR     OUT1CR         PRINT LINE JUST ENTERED
                            	  3206: 
01:002016D2 4A07            	  3207:          TST.B   D7
01:002016D4 6620            	  3208:          BNE.S   MMDI30         ERROR; DON'T STORE DATA
                            	  3209: 
01:002016D6 45F8078A        	  3210:          LEA     SYSTACK+4,A2   A2 = TEMP AREA
01:002016DA 48E2E000        	  3211:          MOVEM.L D0/D1/D2,-(A2) STORE DATA
01:002016DE 2206            	  3212:          MOVE.L  D6,D1          D1 = NUMBER OF BYTES TO STORE
01:002016E0 5381            	  3213:          SUBQ.L  #1,D1
01:002016E2 224C            	  3214:          MOVE.L  A4,A1          A1 = DATA STORE POINTER
01:002016E4 101A            	  3215: MMDI29   MOVE.B  (A2)+,D0
01:002016E6 1280            	  3216:          MOVE.B  D0,(A1)
01:002016E8 1419            	  3217:          MOVE.B  (A1)+,D2       INSURE DATA STORED
01:002016EA B400            	  3218:          CMP.B   D0,D2
01:002016EC 66000196        	  3219:          BNE     MM90
01:002016F0 51C9FFF2        	  3220:          DBRA    D1,MMDI29
01:002016F4 608E            	  3221:          BRA     MMDI22
                            	  3222: 
01:002016F6 61000998        	  3223: MMDI30   BSR     FIXBUF
01:002016FA 1CFC0020        	  3224: MMDI44   MOVE.B  #BLANK,(A6)+   SPACES
01:002016FE 51CFFFFA        	  3225:          DBRA    D7,MMDI44
                            	  3226: 
01:00201702 1D7C0058FFFF    	  3227:          MOVE.B  #'X',-1(A6)    X UNDER ERROR
01:00201708 1CFC003F        	  3228:          MOVE.B  #'?',(A6)+     ? ALLOW REINPUT
01:0020170C 610008F6        	  3229:          BSR     OUTPUT
01:00201710 6088            	  3230:          BRA     MMDI31
                            	  3231: 
                            	  3232: 
                            	  3233: MCMD     DS      0              "M" Alias for "MM" Command
                            	  3234: MMCMD    DS      0              "MM" Command -Memory Modify-
01:00201712 41FAED9A        	  3235:          LEA     SYNTAX(PC),A0  A0=ERROR RETURN
01:00201716 61000756        	  3236:          BSR     FNEXTF
01:0020171A 6100F81A        	  3237:          BSR     GETA
01:0020171E 2840            	  3238:          MOVE.L  D0,A4          A4= ADDRESS OF DATA
01:00201720 7C01            	  3239:          MOVEQ   #1,D6          SIZE = BYTE
01:00201722 7A00            	  3240:          CLR.L   D5             NO OVERRIDE
                            	  3241: 
01:00201724 BDCD            	  3242: MM05     CMP.L   A5,A6
01:00201726 6566            	  3243:          BCS.S   MM10           AT END OF BUFFER
                            	  3244: 
                            	  3245: * LOOK FOR ;OPTIONS
01:00201728 101D            	  3246:          MOVE.B  (A5)+,D0
01:0020172A 0C00003B        	  3247:          CMPI.B  #';',D0
01:0020172E 66F4            	  3248:          BNE     MM05           IGNORE NOT ;
                            	  3249: 
01:00201730 101D            	  3250:          MOVE.B  (A5)+,D0       GET NEXT CHAR
01:00201732 0C000044        	  3251:          CMPI.B  #'D',D0
01:00201736 660A            	  3252:          BNE.S   MM045
                            	  3253: 
01:00201738 0C1D0049        	  3254:          CMPI.B  #'I',(A5)+     DISSAMBLY OPTION
01:0020173C 66E6            	  3255:          BNE     MM05
01:0020173E 6000FF3A        	  3256:          BRA     MMDI
                            	  3257: 
01:00201742 0C000057        	  3258: MM045    CMPI.B  #'W',D0
01:00201746 6742            	  3259:          BEQ.S   MM065          ;W   D6=2
                            	  3260: 
01:00201748 0C00004C        	  3261:          CMPI.B  #'L',D0
01:0020174C 6608            	  3262:          BNE.S   MM054
01:0020174E 1C3C0004        	  3263:          MOVE.B  #4,D6          ;L   D6=4
01:00201752 4205            	  3264:          CLR.B   D5             RESET BYTE OVERRIDE
01:00201754 60CE            	  3265:          BRA     MM05
                            	  3266: 
01:00201756 0C00004E        	  3267: MM054    CMPI.B  #'N',D0
01:0020175A 6606            	  3268:          BNE.S   MM056
01:0020175C 00458000        	  3269:          ORI.W   #$8000,D5      ;N  D5=$8000
01:00201760 60C2            	  3270:          BRA     MM05
                            	  3271: 
01:00201762 0C00004F        	  3272: MM056    CMPI.B  #'O',D0
01:00201766 6608            	  3273:          BNE.S   MM058
01:00201768 200C            	  3274:          MOVE.L  A4,D0          ;O
01:0020176A 00000001        	  3275:          ORI.B   #1,D0          FORCE ODD ADDRESS
01:0020176E 600E            	  3276:          BRA.S   MM060
                            	  3277: 
01:00201770 0C000056        	  3278: MM058    CMPI.B  #'V',D0
01:00201774 6600ED38        	  3279:          BNE     SYNTAX         ERROR
01:00201778 200C            	  3280:          MOVE.L  A4,D0          ;V
01:0020177A 020000FE        	  3281:          ANDI.B  #$FE,D0        FORCE EVEN ADDRESS
01:0020177E 2840            	  3282: MM060    MOVE.L  D0,A4
01:00201780 00050080        	  3283:          ORI.B   #$80,D5        BYTE OVERRIDE
01:00201784 1C3C0002        	  3284: MM064    MOVE.B  #2,D6          SIZE = WORD (2 BYTES)
01:00201788 609A            	  3285:          BRA     MM05
                            	  3286: 
01:0020178A 4205            	  3287: MM065    CLR.B   D5             RESET BYTE OVERRIDE
01:0020178C 60F6            	  3288:          BRA     MM064
                            	  3289: 
                            	  3290: * FORMAT ADDRESS FOR PRINTING
01:0020178E 200C            	  3291: MM10     MOVE.L  A4,D0
01:00201790 0C060001        	  3292:          CMPI.B  #1,D6
01:00201794 6708            	  3293:          BEQ.S   MM11           "BYTE"
01:00201796 4A05            	  3294:          TST.B   D5
01:00201798 6B04            	  3295:          BMI.S   MM11           BYTE OVERRIDE
01:0020179A 610006F0        	  3296:          BSR     CKWADR         CHK ALLIGNMENT
01:0020179E 610006F2        	  3297: MM11     BSR     CKADDR         *
01:002017A2 610008EC        	  3298:          BSR     FIXBUF
01:002017A6 61000626        	  3299:          BSR     FRELADDR       FORM RELATIVE ADDRESS
01:002017AA 1CFC0020        	  3300:          MOVE.B  #BLANK,(A6)+   SPACE
                            	  3301: 
01:002017AE 4A45            	  3302:          TST.W   D5
01:002017B0 6B2C            	  3303:          BMI.S   MM18           NON-VERIFY (DON'T READ MEMORY)
                            	  3304: 
                            	  3305: * READ DATA FROM MEMORY & FORMAT IT
01:002017B2 4A05            	  3306:          TST.B   D5
01:002017B4 6B0C            	  3307:          BMI.S   MM12           BYTE OVERRIDE
                            	  3308: 
01:002017B6 0C060002        	  3309:          CMPI.B  #2,D6
01:002017BA 6710            	  3310:          BEQ.S   MM14           WORD
01:002017BC 0C060004        	  3311:          CMPI.B  #4,D6
01:002017C0 6714            	  3312:          BEQ.S   MM16           LONG WORD
                            	  3313: 
                            	  3314: * BYTE
                            	  3315: MM12
01:002017C2 1E14            	  3316:          MOVE.B  (A4),D7        D7 = DATA READ
01:002017C4 2007            	  3317:          MOVE.L  D7,D0
01:002017C6 610005EA        	  3318:          BSR     PNT2HX         FORMAT BYTE
01:002017CA 6012            	  3319:          BRA.S   MM18
                            	  3320: 
                            	  3321: * WORD
                            	  3322: MM14
01:002017CC 3E14            	  3323:          MOVE.W  (A4),D7
01:002017CE 2007            	  3324:          MOVE.L  D7,D0
01:002017D0 610005D8        	  3325:          BSR     PNT4HX         FORMAT WORD
01:002017D4 6008            	  3326:          BRA.S   MM18
                            	  3327: 
                            	  3328: * LONG WORD
                            	  3329: MM16
01:002017D6 2E14            	  3330:          MOVE.L  (A4),D7
01:002017D8 2007            	  3331:          MOVE.L  D7,D0
01:002017DA 610005C0        	  3332:          BSR     PNT8HX         FORMAT LONG WORD
                            	  3333: 
01:002017DE 1CFC0020        	  3334: MM18     MOVE.B  #BLANK,(A6)+   SPACE
01:002017E2 1CFC003F        	  3335:          MOVE.B  #'?',(A6)+
01:002017E6 6100081C        	  3336:          BSR     OUTPUT
                            	  3337: 
                            	  3338: * READ USER INPUT
                            	  3339: *  [DATA] (CR)   NEXT
                            	  3340: *           ^    LAST
                            	  3341: *           =    SAME
                            	  3342: *           .    EXIT
                            	  3343: 
01:002017EA 610008A4        	  3344:          BSR     FIXBUF
01:002017EE 610008A8        	  3345:          BSR     PORTIN1
01:002017F2 BDCD            	  3346:          CMP.L   A5,A6
01:002017F4 67000082        	  3347:          BEQ     MM50           NO DATA (CR ONLY)
                            	  3348: 
01:002017F8 41FA005A        	  3349:          LEA     MM40(PC),A0    A0 = NO PARAMETER RETURN
01:002017FC 61000670        	  3350:          BSR     FNEXTF         FIND NEXT FIELD
                            	  3351: 
                            	  3352: * IF = ^ OR .  TAKE ACTION
01:00201800 1015            	  3353:          MOVE.B  (A5),D0
01:00201802 0C00003D        	  3354:          CMPI.B  #'=',D0
01:00201806 6786            	  3355:          BEQ     MM10
01:00201808 0C00002E        	  3356:          CMPI.B  #'.',D0
01:0020180C 6700EE20        	  3357:          BEQ     MACSBUG
01:00201810 0C00005E        	  3358:          CMPI.B  #'^',D0
01:00201814 6768            	  3359:          BEQ.S   MM60
                            	  3360: 
01:00201816 610006AA        	  3361:          BSR     GETEXP         GET DATA
01:0020181A 2E00            	  3362:          MOVE.L  D0,D7          D7=DATA STORED
                            	  3363: 
                            	  3364: * WE HAVE DATA; STORE IT
01:0020181C 4A05            	  3365:          TST.B   D5
01:0020181E 6B0C            	  3366:          BMI.S   MM22           BYTE OVERRIDE
                            	  3367: 
01:00201820 0C060002        	  3368:          CMPI.B  #2,D6
01:00201824 6714            	  3369:          BEQ.S   MM24           WORD
01:00201826 0C060004        	  3370:          CMPI.B  #4,D6
01:0020182A 671C            	  3371:          BEQ.S   MM26           LONG WORD
                            	  3372: 
                            	  3373: * BYTE
                            	  3374: MM22
01:0020182C 1880            	  3375:          MOVE.B  D0,(A4)        STORE DATA
01:0020182E 4A45            	  3376:          TST.W   D5
01:00201830 6B22            	  3377:          BMI.S   MM40           NO-VERIFY
01:00201832 1014            	  3378:          MOVE.B  (A4),D0
01:00201834 B007            	  3379:          CMP.B   D7,D0
01:00201836 664C            	  3380:          BNE.S   MM90           NO MATCH
01:00201838 601A            	  3381:          BRA.S   MM40
                            	  3382: 
                            	  3383: * WORD
                            	  3384: MM24
01:0020183A 3880            	  3385:          MOVE.W  D0,(A4)        STORE
01:0020183C 4A45            	  3386:          TST.W   D5
01:0020183E 6B14            	  3387:          BMI.S   MM40           DO NOT VERIFY
01:00201840 3014            	  3388:          MOVE.W  (A4),D0
01:00201842 B047            	  3389:          CMP.W   D7,D0
01:00201844 663E            	  3390:          BNE.S   MM90           NO MATCH
01:00201846 600C            	  3391:          BRA.S   MM40
                            	  3392: 
                            	  3393: * LONG WORD
                            	  3394: MM26
01:00201848 2880            	  3395:          MOVE.L  D0,(A4)
01:0020184A 4A45            	  3396:          TST.W   D5
01:0020184C 6B06            	  3397:          BMI.S   MM40           DO NOT VERIFY
01:0020184E 2014            	  3398:          MOVE.L  (A4),D0
01:00201850 B087            	  3399:          CMP.L   D7,D0
01:00201852 6630            	  3400:          BNE.S   MM90           NO MATCH
                            	  3401: 
                            	  3402: * LOOK FOR  . = ^
01:00201854 1015            	  3403: MM40     MOVE.B  (A5),D0
01:00201856 0C00002E        	  3404:          CMPI.B  #'.',D0
01:0020185A 6700EDD2        	  3405:          BEQ     MACSBUG        DONE
01:0020185E 0C00005E        	  3406:          CMPI.B  #'^',D0
01:00201862 671A            	  3407:          BEQ.S   MM60           BACKUP ADDRESS
01:00201864 0C00003D        	  3408:          CMPI.B  #'=',D0
01:00201868 6700FF24        	  3409:          BEQ     MM10           ADDRESS STAYS THE SAME
01:0020186C 0C000020        	  3410:          CMPI.B  #BLANK,D0
01:00201870 6706            	  3411:          BEQ.S   MM50
01:00201872 BDCD            	  3412:          CMP.L   A5,A6
01:00201874 6600EC38        	  3413:          BNE     SYNTAX         ERROR
                            	  3414: 
                            	  3415: * ADDRESS LOW TO HIGH
01:00201878 D9C6            	  3416: MM50     ADD.L   D6,A4
01:0020187A 6000FF12        	  3417:          BRA     MM10
                            	  3418: 
                            	  3419: * ADDRESS HIGH TO LOW
01:0020187E 99C6            	  3420: MM60     SUB.L   D6,A4
01:00201880 6000FF0C        	  3421:          BRA     MM10
                            	  3422: 
01:00201884 4BFA00B6        	  3423: MM90     LEA     MSG017(PC),A5  'DATA DID NOT STORE'
01:00201888 6100EC74        	  3424: MM95     BSR     FIXDCRLF
01:0020188C 6000EC12        	  3425:          BRA     MSG
                            	  3426: 
01:00201890 4BFAEBFD        	  3427: MM905    LEA     MSGEOT(PC),A5
01:00201894 60F2            	  3428:          BRA     MM95
                            	  3429: 
                            	  3430: 
                            	  3431: 
                            	  3432: 
                            	  3433: *-------------------------------------------------------------------------
                            	  3434: * File MS        Memory set command                               11/02/81
                            	  3435: 
                            	  3436: *    ***MS***   MEMORY SET
                            	  3437: *     FORMAT: MS  ADDRESS HEX HEX,HEX,'ASCII'  ETC.
                            	  3438: *     COMMAS OR SPACES BETWEEN FIELDS
                            	  3439: *     FIELDS ARE SIZE ADJUSTED (STORES UP TO 4 BYTES)
                            	  3440: *     ASCII ENCLOSED IN SINGLE QUOTES-ANY LENGTH
                            	  3441: 
01:00201896 41FAEC16        	  3442: MSCMD    LEA     SYNTAX(PC),A0  IF NO PARAMETERS
01:0020189A 610005D2        	  3443:          BSR     FNEXTF         FIND NEXT FIELD
01:0020189E 6100F696        	  3444:          BSR     GETA           GET ADDRESS
01:002018A2 610005EE        	  3445:          BSR     CKADDR         CHECK VALID ADDRESS
                            	  3446: 
01:002018A6 2240            	  3447:          MOVE.L  D0,A1          A1=START (OPEN) ADDRESS
01:002018A8 41FAED84        	  3448: SETM1    LEA     MACSBUG(PC),A0 IF NO PARAMTER
01:002018AC 610005C0        	  3449:          BSR     FNEXTF         FIND NEXT FIELD
01:002018B0 284D            	  3450:          MOVE.L  A5,A4          SAVE ADDRESS OF PARAMTER
01:002018B2 1015            	  3451:          MOVE.B  (A5),D0        CHECK OUT NEXT CHARACTER
01:002018B4 0C000027        	  3452:          CMPI.B  #$27,D0        SEE IF IT IS QUOTE MARK
01:002018B8 6730            	  3453:          BEQ.S   SETM5          SPECIAL ROUTINE
01:002018BA 0C00004E        	  3454:          CMPI.B  #'N',D0        SEE IF NEXT LINE FEATURE
01:002018BE 674E            	  3455:          BEQ.S   SETM7
01:002018C0 6100062E        	  3456:          BSR     GETNUMA        GET THE DATA
01:002018C4 2649            	  3457:          MOVE.L  A1,A3          ADDRESS
01:002018C6 220D            	  3458:          MOVE.L  A5,D1          COMPUTE BYTES OF DATA
01:002018C8 928C            	  3459:          SUB.L   A4,D1          LEN=END-START
01:002018CA E281            	  3460:          ASR.L   #1,D1          BYTES=CHAR/2
01:002018CC 6402            	  3461:          BCC.S   SETM3          TAKE CARE OF ODD CHARACTER
01:002018CE 5281            	  3462:          ADDQ.L  #1,D1          WHOLE NUMBER OF BYTES
01:002018D0 2401            	  3463: SETM3    MOVE.L  D1,D2          D1 SCANS DOWN
01:002018D2 5382            	  3464:          SUBQ.L  #1,D2          KNOCK IT DOWN TO INDEX
01:002018D4 17802000        	  3465:          MOVE.B  D0,0(A3,D2)    INDEXED BECAUSE BACKWARD
                            	  3466: 
01:002018D8 16332000        	  3467:          MOVE.B  0(A3,D2),D3    REREAD TO CHECK IF STORED OK
                            	  3468: 
01:002018DC B600            	  3469:          CMP.B   D0,D3          ARE SAME?
01:002018DE 6622            	  3470:          BNE.S   SETME          'DATA DID NOT STORE'
                            	  3471: 
01:002018E0 E080            	  3472:          ASR.L   #8,D0          SHIFT ONE BYTE
01:002018E2 5289            	  3473:          ADDQ.L  #1,A1          BUMP ADDRESS
01:002018E4 5381            	  3474:          SUBQ.L  #1,D1
01:002018E6 66E8            	  3475:          BNE     SETM3
01:002018E8 60BE            	  3476:          BRA.S   SETM1          GO DO NEXT DATA
                            	  3477: 
                            	  3478: *  DATA IN IN ASCII STRING
01:002018EA 528D            	  3479: SETM5    ADDQ.L  #1,A5          GET PAST QUOTE MARK
01:002018EC BBCE            	  3480: SETM6    CMP.L   A6,A5          SEE IF END OF BUFFER
01:002018EE 6C00ED3E        	  3481:          BGE     MACSBUG
01:002018F2 101D            	  3482:          MOVE.B  (A5)+,D0       GRAB CHARACTER
01:002018F4 0C000027        	  3483:          CMPI.B  #$27,D0        SEE IF QUOTE MARK
01:002018F8 67AE            	  3484:          BEQ.S   SETM1          IF SO-END OF STRING
01:002018FA 1280            	  3485:          MOVE.B  D0,(A1)        SAVE DATA
                            	  3486: 
01:002018FC 1219            	  3487:          MOVE.B  (A1)+,D1       REREAD FOR CHECK
                            	  3488: 
01:002018FE B001            	  3489:          CMP.B   D1,D0          SEE IF SAME
01:00201900 67EA            	  3490:          BEQ     SETM6
01:00201902 4BFA0038        	  3491: SETME    LEA     MSG017(PC),A5  'DATA DID NOT STORE'
01:00201906 6100EBF6        	  3492:          BSR     FIXDCRLF
01:0020190A 6000EB94        	  3493:          BRA     MSG
                            	  3494: 
01:0020190E 61000780        	  3495: SETM7    BSR     FIXBUF         DISPLAY CURRENT ADDRESS
01:00201912 2009            	  3496:          MOVE.L  A1,D0
01:00201914 61000486        	  3497:          BSR     PNT8HX         PUT ADDRESS IN BUFFER
01:00201918 2CFC20203F20    	  3498:          MOVE.L  #'  ? ',(A6)+  PROMPT
01:0020191E 610006E4        	  3499:          BSR     OUTPUT         DUMP BUFFER WITH NO LF CR
01:00201922 6100076C        	  3500:          BSR     FIXBUF         GET READY FOR INPUT
01:00201926 1AFC0020        	  3501:          MOVE.B  #BLANK,(A5)+   ADVANCE IN BUFFER
01:0020192A 2C4D            	  3502:          MOVE.L  A5,A6          BECAUSE OF SNAFU IN FINDNP
01:0020192C 6100076A        	  3503:          BSR     PORTIN1        INPUT FROM CONSOLE
01:00201930 1025            	  3504:          MOVE.B  -(A5),D0       JUST BACK UP IN BUFFER
01:00201932 BBCE            	  3505:          CMP.L   A6,A5
01:00201934 6700ECF8        	  3506:          BEQ     MACSBUG
01:00201938 6000FF6E        	  3507:          BRA     SETM1          DO DECODE IT
                            	  3508: 
01:0020193C 4441544120444944	  3509: MSG017   DC.B    'DATA DID NOT STORE',CR,LF,EOT
01:00201944 204E4F542053544F
01:0020194C 5245
01:0020194E 0D
01:0020194F 0A
01:00201950 04
                            	  3510: 
                            	  3511: 
                            	  3512: 
                            	  3513: 
                            	  3514: 
01:00201951 00              	  3515:          DC.B    0              PAD BYTE
                            	  3516: 
                            	  3517: 
                            	  3518: 
                            	  3519: 
                            	  3520: *-------------------------------------------------------------------------
                            	  3521: * File MTSETUP   MTSETUP memory test setup                        11/02/81
                            	  3522: 
                            	  3523: *
                            	  3524: * SET UP PARMS FOR BLOCK TEST AND BLOCK INITIALIZE
                            	  3525: *
                            	  3526: 
                            	  3527: MTSETUP  DS      0
01:00201952 21CF04D6        	  3528:          MOVE.L  A7,TEMP        STACK FOR EXCEPTION RETURN
01:00201956 41FAEB56        	  3529:          LEA     SYNTAX(PC),A0  WHERE TO GO IF NO PARAMETERS
01:0020195A 61000512        	  3530:          BSR     FNEXTF         FIND NEXT FIELD
01:0020195E 6100F5D6        	  3531:          BSR     GETA           GET ADDR1
01:00201962 61000528        	  3532:          BSR     CKWADR         CHECK WORD BOUNDRY ADDRESS
01:00201966 2640            	  3533:          MOVE.L  D0,A3          SAVE STARTING ADDRESS
                            	  3534: 
01:00201968 41FAEB44        	  3535:          LEA     SYNTAX(PC),A0  SET UP TO TRY "TO" ADDRESS
01:0020196C 61000500        	  3536:          BSR     FNEXTF         *
01:00201970 6100F5C4        	  3537:          BSR     GETA           GET ADDR2
01:00201974 61000516        	  3538:          BSR     CKWADR
01:00201978 2240            	  3539:          MOVE.L  D0,A1          A1 = END ADDRESS?
01:0020197A 204B            	  3540:          MOVE.L  A3,A0          A0 = STARTING ADDRESS
01:0020197C 6100EB3E        	  3541:          BSR     P2PHY          DISPLAY TWO ADDRESSES
01:00201980 B3C8            	  3542:          CMP.L   A0,A1
01:00201982 6500EB2A        	  3543:          BCS     SYNTAX         END ADDR TOO SMALL
01:00201986 5489            	  3544:          ADDQ.L  #2,A1          ADJUST END ADDR
01:00201988 4E75            	  3545:          RTS
                            	  3546: 
                            	  3547: 
                            	  3548: 
                            	  3549: 
                            	  3550: *-------------------------------------------------------------------------
                            	  3551: * File OF        OF & PERIOD Command                              12/18/81
                            	  3552: 
                            	  3553: * .*  HANDLER
                            	  3554: *   GET TWO CHARACTERS FOLLOWING PERIOD
                            	  3555: 
01:0020198A E149            	  3556: PERCMD   LSL.W   #8,D1
01:0020198C 1215            	  3557:          MOVE.B  (A5),D1        D1 = 2ND,3RD CHARACTERS
01:0020198E 538D            	  3558:          SUBQ.L  #1,A5          A5 = POINTER TO 2ND CHAR  (1ST REAL CHARACTER)
                            	  3559: 
01:00201990 41FA0030        	  3560:          LEA     REGTBL(PC),A0
01:00201994 7E00            	  3561: PER4     CLR.L   D7
01:00201996 3E18            	  3562:          MOVE.W  (A0)+,D7       SAVE FIRST WORD FOR END OF TABLE TEST
01:00201998 3018            	  3563:          MOVE.W  (A0)+,D0       GET REAL REGISTER ID INTO D0
01:0020199A 0C47FFFF        	  3564:          CMPI.W  #$FFFF,D7      ARE WE AT THE END OF THE TABLE?
01:0020199E 6700EAF6        	  3565:          BEQ     WHAT           YES...THEN WE DIDNT FIND IT
                            	  3566: 
01:002019A2 0C000040        	  3567:          CMPI.B  #'@',D0
01:002019A6 660E            	  3568:          BNE.S   PER3           NOT @
                            	  3569: 
                            	  3570: * THIRD CHAR MUST BE NUMERIC 0 - 7
01:002019A8 1001            	  3571:          MOVE.B  D1,D0          ALLEGED DIGIT
01:002019AA 0C000030        	  3572:          CMPI.B  #'0',D0
01:002019AE 6BE4            	  3573:          BMI     PER4           NOT A DIGIT
01:002019B0 0C000038        	  3574:          CMPI.B  #'8',D0
01:002019B4 6ADE            	  3575:          BPL     PER4           NOT A DIGIT
                            	  3576: 
01:002019B6 B041            	  3577: PER3     CMP.W   D1,D0
01:002019B8 66DA            	  3578:          BNE     PER4           MISS-MATCH
                            	  3579: 
                            	  3580: *******************************************************************
                            	  3581: *        AT THIS TIME WE HAVE FOUND THE ENTRY IN THE "REG TABLE"  *
                            	  3582: *        WE NOW NEED TO EXTRACT AND USE THE OFFSET                *
                            	  3583: *******************************************************************
                            	  3584: 
01:002019BA 41FAE644        	  3585:          LEA     FIRST(PC),A0   A0 = Start of VERSAbug RO
01:002019BE D1C7            	  3586:          ADD.L   D7,A0          Add offset
01:002019C0 4ED0            	  3587:          JMP     (A0)           Now go to the calculated location
                            	  3588: 
                            	  3589: 
                            	  3590: ***************
                            	  3591: REGTBL   EQU  *
                            	  3592: ***************
                            	  3593: 
01:002019C2 1A04            	  3594:          DC.W    SETA7-FIRST    Stack Register Routine
01:002019C4 4137            	  3595:          DC.W    'A7'           *
                            	  3596: 
01:002019C6 19F8            	  3597:          DC.W    SETPC-FIRST    Program Counter Routine
01:002019C8 5043            	  3598:          DC.W    'PC'           *
                            	  3599: 
01:002019CA 19FE            	  3600:          DC.W    SETSR-FIRST    Status Register Routine
01:002019CC 5352            	  3601:          DC.W    'SR'           *
                            	  3602: 
01:002019CE 1A14            	  3603:          DC.W    SETUS-FIRST    User Stack Routine
01:002019D0 5553            	  3604:          DC.W    'US'           *
                            	  3605: 
01:002019D2 1A0E            	  3606:          DC.W    SETSS-FIRST    System Stack Routine
01:002019D4 5353            	  3607:          DC.W    'SS'           *
                            	  3608: 
01:002019D6 19EC            	  3609:          DC.W    SETD-FIRST     Data Register Routine
01:002019D8 4440            	  3610:          DC.W    'D@'           *
                            	  3611: 
01:002019DA 19F2            	  3612:          DC.W    SETA-FIRST     Address Register Routine
01:002019DC 4140            	  3613:          DC.W    'A@'           *
                            	  3614: 
01:002019DE 1ACC            	  3615:          DC.W    PNTCLSA-FIRST  All Address Registers Routine
01:002019E0 4120            	  3616:          DC.W    'A '           *
                            	  3617: 
01:002019E2 1AC2            	  3618:          DC.W    PNTCLSD-FIRST  All Data Registers Routine
01:002019E4 4420            	  3619:          DC.W    'D '           *
                            	  3620: 
01:002019E6 1A1A            	  3621:          DC.W    SETRN-FIRST    All Registers Routine
01:002019E8 5240            	  3622:          DC.W    'R@'           *
                            	  3623: 
01:002019EA FFFF            	  3624:          DC.W    $FFFF          END OF TABLE
                            	  3625: 
                            	  3626: *    PRINT & INPUT REGISTER ROUTINES
                            	  3627: 
01:002019EC 49F80408        	  3628: SETD     LEA     REGS,A4        START OF REGISTERS
01:002019F0 6034            	  3629:          BRA.S   SETR
                            	  3630: 
01:002019F2 49F80428        	  3631: SETA     LEA     REGS+32,A4     OFFSET IN REGISTER TABLE
01:002019F6 602E            	  3632:          BRA.S   SETR
                            	  3633: 
01:002019F8 49F80400        	  3634: SETPC    LEA     REGPC,A4       WHERE PC IS
01:002019FC 6030            	  3635:          BRA.S   SETR0
                            	  3636: 
01:002019FE 49F80404        	  3637: SETSR    LEA     REGSR,A4       WHERE SR IS
01:00201A02 602A            	  3638:          BRA.S   SETR0
                            	  3639: 
01:00201A04 22380404        	  3640: SETA7    MOVE.L  REGSR,D1       GET CONDITION CODES
01:00201A08 02412000        	  3641:          ANDI.W  #$2000,D1      CHECK SUPERVISOR BIT
01:00201A0C 6706            	  3642:          BEQ.S   SETUS
01:00201A0E 49F80444        	  3643: SETSS    LEA     REGA7,A4       WHERE SUPERVISOR STACK IS
01:00201A12 601A            	  3644:          BRA.S   SETR0
                            	  3645: 
01:00201A14 49F80448        	  3646: SETUS    LEA     REGUS,A4       USER STACK
01:00201A18 6014            	  3647:          BRA.S   SETR0
                            	  3648: 
01:00201A1A 49F8044C        	  3649: SETRN    LEA     OFFSET,A4      SET OFFSET
01:00201A1E 0C010037        	  3650:          CMPI.B  #'7',D1
01:00201A22 6700EA8A        	  3651:          BEQ     SYNTAX         NOT ALLOWED TO CHANGE A7
                            	  3652: 
                            	  3653: 
                            	  3654: *  ROUTINE TO ENTER DATA FOR A SINGLE REGISTER
                            	  3655: *   A5-A6 ARE COMMAND BUFFER
                            	  3656: *   D0 HAS REGISTER DIGIT A4 HAS CLASS OFFSET
                            	  3657: 
01:00201A26 61000578        	  3658: SETR     BSR     GETHEX         GET REG NUMBER
01:00201A2A E588            	  3659:          LSL.L   #2,D0          SHIFT LEFT...MULT BY 4
01:00201A2C D9C0            	  3660:          ADD.L   D0,A4          A4 NOW HAS EXACT ADDRESS
01:00201A2E 548D            	  3661: SETR0    ADDQ.L  #2,A5          NOW FIND PARAMETERS
01:00201A30 103C003A        	  3662:          MOVE.B  #':',D0        SEE IF COLON IN COMMAND
01:00201A34 6154            	  3663:          BSR.S   SCAN
01:00201A36 671E            	  3664:          BEQ.S   SETR5
                            	  3665: *SEE IF ANY PARAMER (HEX)
01:00201A38 41FA0016        	  3666:          LEA     SETR4(PC),A0   WHERE TO GO IF NO PARAMETERS
01:00201A3C 61000430        	  3667:          BSR     FNEXTF         FIND NEXT FIELD
                            	  3668: 
01:00201A40 0C00002E        	  3669:          CMPI.B  #'.',D0
01:00201A44 6706            	  3670:          BEQ.S   SEMACS         PERIOD; GET OUT
                            	  3671: 
01:00201A46 6100F4EE        	  3672:          BSR     GETA           GET ADDRESS VALUE
01:00201A4A 2880            	  3673:          MOVE.L  D0,(A4)        SAVE NEW VALUE
01:00201A4C 6000EBE0        	  3674: SEMACS   BRA     MACSBUG
                            	  3675: 
                            	  3676: *JUST PRINT IT
                            	  3677: 
01:00201A50 6148            	  3678: SETR4    BSR.S   PRINTR         FIX UP TO PRINT
01:00201A52 6000EA4C        	  3679:          BRA     MSG            GO PRINT MESSAGE-GO TO MACSBUG
                            	  3680: 
01:00201A56 6102            	  3681: SETR5    BSR.S   SETSR1
01:00201A58 60F2            	  3682:          BRA     SEMACS
                            	  3683: 
01:00201A5A 613E            	  3684: SETSR1   BSR.S   PRINTR         FIX UP TO PRINT
01:00201A5C 1CFC0020        	  3685:          MOVE.B  #BLANK,(A6)+   SPACE
01:00201A60 1CFC003F        	  3686:          MOVE.B  #'?',(A6)+     PROMPT
01:00201A64 1CFC0020        	  3687:          MOVE.B  #BLANK,(A6)+   SPACE
01:00201A68 6100059A        	  3688:          BSR     OUTPUT         PRINT IT
                            	  3689: 
01:00201A6C 61000622        	  3690:          BSR     FIXBUF
01:00201A70 61000626        	  3691:          BSR     PORTIN1
                            	  3692: 
01:00201A74 41FA0012        	  3693:          LEA     SETSR15(PC),A0 A0=DEFAULT (NO PARM) ADDRESS
01:00201A78 610003F4        	  3694:          BSR     FNEXTF         FIND FIELD
                            	  3695: 
01:00201A7C 0C00002E        	  3696:          CMPI.B  #'.',D0
01:00201A80 67CA            	  3697:          BEQ     SEMACS         PERIOD; GET OUT
                            	  3698: 
01:00201A82 6100F4B2        	  3699:          BSR     GETA           CONVERT IT
01:00201A86 2880            	  3700:          MOVE.L  D0,(A4)        STORE NEW DATA
                            	  3701: 
                            	  3702: SETSR15  DS      0
01:00201A88 4E75            	  3703:          RTS
                            	  3704: 
                            	  3705: 
                            	  3706: * SEE IF CHARACTER IS IN BUFFER
                            	  3707: 
01:00201A8A 204D            	  3708: SCAN     MOVE.L  A5,A0          A0 IS WORKING SCANNER
01:00201A8C B1CE            	  3709: SCAN2    CMP.L   A6,A0          SEE IF AT END OF BUFFER
01:00201A8E 6208            	  3710:          BHI.S   RETURN5
01:00201A90 B010            	  3711:          CMP.B   (A0),D0        LOOK AT CHARACTER
01:00201A92 6704            	  3712:          BEQ.S   RETURN5
01:00201A94 5288            	  3713:          ADDQ.L  #1,A0          GET PAST CHARACTER
01:00201A96 60F4            	  3714:          BRA.S   SCAN2
01:00201A98 4E75            	  3715: RETURN5  RTS
                            	  3716: 
                            	  3717: * ROUTINE TO SET UP TO PRINT REG
                            	  3718: 
01:00201A9A 610005F4        	  3719: PRINTR   BSR     FIXBUF
                            	  3720: 
01:00201A9E 568E            	  3721:          ADDQ.L  #3,A6          GET PAST REG NAME (.XX)
01:00201AA0 1CFC003D        	  3722:          MOVE.B  #'=',(A6)+     PUT IN EQUAL SIGN
01:00201AA4 2014            	  3723:          MOVE.L  (A4),D0        GET VALUE
01:00201AA6 B8FC0404        	  3724:          CMPA.L  #REGSR,A4      SEE IF THIS IS CONDITION CODES
01:00201AAA 6606            	  3725:          BNE.S   PRINTR2
01:00201AAC 610002FC        	  3726:          BSR     PNT4HX         JUST PRINT WORD
01:00201AB0 4E75            	  3727:          RTS
                            	  3728: 
01:00201AB2 610002E8        	  3729: PRINTR2  BSR     PNT8HX         PRINT THE VALUE
01:00201AB6 4E75            	  3730:          RTS
                            	  3731: 
                            	  3732: *
                            	  3733: *   PRINT ALL REGISTERS IN A CLASS (A OR D OR R)
                            	  3734: *
                            	  3735: 
                            	  3736: OFCMD    DS      0              "OF" Command -Display Offset registers-
01:00201AB8 1E3C0052        	  3737: SETO     MOVE.B  #'R',D7
01:00201ABC 47F8044C        	  3738:          LEA     OFFSET,A3
01:00201AC0 6012            	  3739:          BRA.S   PNTCLSB
                            	  3740: 
01:00201AC2 1E3C0044        	  3741: PNTCLSD  MOVE.B  #'D',D7        CLASS=DATA
01:00201AC6 47F80408        	  3742:          LEA     REGS,A3        OFFSET
01:00201ACA 6008            	  3743:          BRA.S   PNTCLSB
                            	  3744: 
01:00201ACC 1E3C0041        	  3745: PNTCLSA  MOVE.B  #'A',D7        CLASS=ADDRESS
01:00201AD0 47F80428        	  3746:          LEA     REGS+32,A3     OFFSET
01:00201AD4 6104            	  3747: PNTCLSB  BSR.S   PNTCLS
01:00201AD6 6000EB56        	  3748:          BRA     MACSBUG
                            	  3749: 
01:00201ADA 610005B4        	  3750: PNTCLS   BSR     FIXBUF
01:00201ADE 7C00            	  3751:          CLR.L   D6             REGISTER COUNTER
01:00201AE0 611C            	  3752: PNTCLS1  BSR.S   PNTREG         PRINT THE REGISTER
01:00201AE2 0C060004        	  3753:          CMPI.B  #4,D6          DISPLAY AFTER 3&7
01:00201AE6 660A            	  3754:          BNE.S   PNTCLS2
01:00201AE8 61000500        	  3755:          BSR     OUT1CR
01:00201AEC 610005A2        	  3756:          BSR     FIXBUF
01:00201AF0 60EE            	  3757:          BRA     PNTCLS1        DO SOME MORE
                            	  3758: 
01:00201AF2 0C060008        	  3759: PNTCLS2  CMPI.B  #8,D6          AT END?
01:00201AF6 66E8            	  3760:          BNE     PNTCLS1
01:00201AF8 610004F0        	  3761:          BSR     OUT1CR         PRINT IT
01:00201AFC 4E75            	  3762:          RTS
                            	  3763: 
                            	  3764: *  SUBROUTINE TO PRINT REGISTER  X#=01234567.
                            	  3765: 
01:00201AFE 1CC7            	  3766: PNTREG   MOVE.B  D7,(A6)+       CLASS
01:00201B00 1006            	  3767:          MOVE.B  D6,D0          REG#
01:00201B02 610002B6        	  3768:          BSR     PUTHEX
01:00201B06 1CFC003D        	  3769:          MOVE.B  #'=',(A6)+     EQUAL SIGN
01:00201B0A 2006            	  3770:          MOVE.L  D6,D0          COMPUTE ADDRESS OF REG
01:00201B0C E588            	  3771:          LSL.L   #2,D0          MULT BY FOUR
01:00201B0E D08B            	  3772:          ADD.L   A3,D0          ADD IN OFFSET
01:00201B10 2840            	  3773:          MOVE.L  D0,A4          SET UP TO GET DEFFERED
01:00201B12 B8FC0444        	  3774:          CMPA.L  #REGA7,A4      SEE IF REG A7
01:00201B16 660E            	  3775:          BNE.S   PNTREG1
01:00201B18 20380404        	  3776:          MOVE.L  REGSR,D0       GET STATUS REGISTER
01:00201B1C 02402000        	  3777:          ANDI.W  #$2000,D0      CHECK SUPERVISOR BIT
01:00201B20 6604            	  3778:          BNE.S   PNTREG1
01:00201B22 49F80448        	  3779:          LEA     REGUS,A4       TAKE ADDRESS OF USER STACK
01:00201B26 2014            	  3780: PNTREG1  MOVE.L  (A4),D0        GET REG CONTENT
01:00201B28 61000272        	  3781:          BSR     PNT8HX         PUT IN BUFFER
01:00201B2C 1CFC0020        	  3782:          MOVE.B  #BLANK,(A6)+   SPACE
01:00201B30 5286            	  3783:          ADDQ.L  #1,D6          BUMP REG#
01:00201B32 4E75            	  3784:          RTS
                            	  3785: 
                            	  3786: 
                            	  3787: 
                            	  3788: 
                            	  3789: *-------------------------------------------------------------------------
                            	  3790: * File PF        "PFCMD", Port format                             05/19/82
                            	  3791: 
                            	  3792: * **PF**   PF      DISPLAY PORT PROFILE
                            	  3793: *          PF1     DISPLAY/CHANGE PORT 1
                            	  3794: *          PF2     DISPLAY/CHANGE PORT 2
                            	  3795: 
01:00201B34 1C15            	  3796: PFCMD    MOVE.B  (A5),D6        D6 = PORT #
01:00201B36 0C060031        	  3797:          CMPI.B  #'1',D6
01:00201B3A 675A            	  3798:          BEQ.S   PFCMD1         CHANGE PORT 1
01:00201B3C 0C060032        	  3799:          CMPI.B  #'2',D6
01:00201B40 6754            	  3800:          BEQ.S   PFCMD1         CHANGE PORT 2
                            	  3801: 
01:00201B42 43F8064C        	  3802:          LEA     MD1CON,A1      PRINT BOTH PORTS
01:00201B46 4BFA00A2        	  3803:          LEA     MSG003(PC),A5
01:00201B4A 6132            	  3804:          BSR.S   PFPT           DISPLAY/CHANGE
01:00201B4C 610004B6        	  3805:          BSR     OUTPUT
                            	  3806: 
01:00201B50 43F80618        	  3807:          LEA     NULLPADS,A1
01:00201B54 4BFA009F        	  3808:          LEA     MSG004(PC),A5
01:00201B58 6124            	  3809:          BSR.S   PFPT
01:00201B5A 610004A8        	  3810:          BSR     OUTPUT
                            	  3811: 
01:00201B5E 43F8061A        	  3812:          LEA     CRPADS,A1
01:00201B62 4BFA009C        	  3813:          LEA     MSG005(PC),A5
01:00201B66 6116            	  3814:          BSR.S   PFPT
                            	  3815: 
01:00201B68 4BFA00A1        	  3816:          LEA     MSG031(PC),A5  TELL WHERE XONOFF IS
01:00201B6C 6100E980        	  3817:          BSR     FIXDADD
01:00201B70 203C000004E6    	  3818:          MOVE.L  #OPTIONS,D0
01:00201B76 6100022C        	  3819:          BSR     PNT6HX         "OPTIONS@AAAAAA"
01:00201B7A 6000E924        	  3820:          BRA     MSG
                            	  3821: 
01:00201B7E 6100E97E        	  3822: PFPT     BSR     FIXDCRLF       FORMAT FROM A5
01:00201B82 1011            	  3823:          MOVE.B  (A1),D0
01:00201B84 6100022C        	  3824:          BSR     PNT2HX         FORMAT DATA
01:00201B88 1CFC0020        	  3825:          MOVE.B  #BLANK,(A6)+   SPACE
01:00201B8C 10290001        	  3826:          MOVE.B  1(A1),D0
01:00201B90 61000220        	  3827:          BSR     PNT2HX         FORMAT DATA PORT 2
01:00201B94 4E75            	  3828:          RTS
                            	  3829: 
                            	  3830: 
01:00201B96 43F8064C        	  3831: PFCMD1   LEA     MD1CON,A1
01:00201B9A 4BFA004E        	  3832:          LEA     MSG003(PC),A5
01:00201B9E 6120            	  3833:          BSR.S   PFCH           DISPLAY/CHANGE
                            	  3834: 
01:00201BA0 43F80618        	  3835:          LEA     NULLPADS,A1
01:00201BA4 4BFA004F        	  3836:          LEA     MSG004(PC),A5
01:00201BA8 6116            	  3837:          BSR.S   PFCH
                            	  3838: 
01:00201BAA 43F8061A        	  3839:          LEA     CRPADS,A1
01:00201BAE 4BFA0050        	  3840:          LEA     MSG005(PC),A5
01:00201BB2 610C            	  3841:          BSR.S   PFCH
01:00201BB4 610007BE        	  3842:          BSR     INITSER        PLACE NEW SBITS INTO ACIA
01:00201BB8 610004D6        	  3843:          BSR     FIXBUF         BLANK LINE FOR SPACING
01:00201BBC 6000E8E2        	  3844:          BRA     MSG
                            	  3845: 
01:00201BC0 6100E928        	  3846: PFCH     BSR     FIXDATA        FORMAT FROM A5
01:00201BC4 0C060031        	  3847:          CMPI.B  #'1',D6
01:00201BC8 6702            	  3848:          BEQ.S   PFCH2          PORT 1
01:00201BCA 5289            	  3849:          ADDQ.L  #1,A1          PORT 2
01:00201BCC 1011            	  3850: PFCH2    MOVE.B  (A1),D0
01:00201BCE 610001E2        	  3851:          BSR     PNT2HX         FORMAT DATA
01:00201BD2 1CFC003F        	  3852:          MOVE.B  #'?',(A6)+
01:00201BD6 6100042C        	  3853:          BSR     OUTPUT
                            	  3854: 
01:00201BDA 610004BC        	  3855:          BSR     PORTIN1        INPUT LINE
01:00201BDE BDCD            	  3856:          CMP.L   A5,A6
01:00201BE0 6706            	  3857:          BEQ.S   PFCH4          NOTHING INPUT
                            	  3858: 
01:00201BE2 6100030C        	  3859:          BSR     GETNUMA
01:00201BE6 1280            	  3860:          MOVE.B  D0,(A1)
01:00201BE8 4E75            	  3861: PFCH4    RTS
                            	  3862: 
01:00201BEA 464F524D41543D20	  3863: MSG003   DC.B    'FORMAT=   ',EOT
01:00201BF2 2020
01:00201BF4 04
                            	  3864: 
                            	  3865: 
                            	  3866: 
01:00201BF5 43484152204E554C	  3867: MSG004   DC.B    'CHAR NULL=',EOT
01:00201BFD 4C3D
01:00201BFF 04
                            	  3868: 
                            	  3869: 
                            	  3870: 
01:00201C00 432F5220204E554C	  3871: MSG005   DC.B    'C/R  NULL=',EOT
01:00201C08 4C3D
01:00201C0A 04
                            	  3872: 
                            	  3873: 
                            	  3874: 
01:00201C0B 0D              	  3875: MSG031   DC.B    CR,LF,'OPTIONS@',EOT
01:00201C0C 0A
01:00201C0D 4F5054494F4E5340
01:00201C15 04
                            	  3876: 
                            	  3877: 
                            	  3878: 
                            	  3879: 
                            	  3880: 
                            	  3881: 
                            	  3882: *-------------------------------------------------------------------------
                            	  3883: * File RAMTEST   RAMTEST                                          11/02/81
                            	  3884: 
                            	  3885: ***********************************************************************
                            	  3886: * MEMORY TEST SUBROUTINE.                                             *
                            	  3887: *                                                                     *
                            	  3888: *        A0=BEGINNING ADDRESS (MUST BE EVEN ADDRESS)                  *
                            	  3889: *        A1=ENDING ADDRESS+1  (MUST BE EVEN ADDRESS)                  *
                            	  3890: *        A2=FAILING ADDRESS                                           *
                            	  3891: *        D0=DATA WRITTEN TO RAM                                       *
                            	  3892: *        D1=DATA READ FROM RAM                                        *
                            	  3893: *                                                                     *
                            	  3894: *        ZERO FLAG IS SET IF TEST IS SUCCESSFUL                       *
                            	  3895: *           REGISTERS D2,D3,D4 DESTROYED                              *
                            	  3896: ***********************************************************************
                            	  3897: 
                            	  3898: *       -1ST TEST-
                            	  3899: RAMTEST  DS      0
01:00201C16 2608            	  3900:          MOVE.L  A0,D3          D3 = BEGINNING ADDRESS
01:00201C18 2443            	  3901:          MOVE.L  D3,A2          USE A2 AS POINTER IN MEMORY
01:00201C1A 70FE            	  3902: WALK3    MOVEQ   #-2,D0         PREPARE FOR "WALKING BIT" TEST
                            	  3903: WALK0
01:00201C1C 3480            	  3904:          MOVE.W  D0,(A2)        STORE D0 INTO MEMORY
01:00201C1E 3212            	  3905:          MOVE.W  (A2),D1        D1 CONTAINS RAM DATA
01:00201C20 B240            	  3906:          CMP.W   D0,D1          WRITTEN VS. READ
01:00201C22 6642            	  3907:          BNE.S   RAMERR         STOP ON ERROR
01:00201C24 E358            	  3908:          ROL.W   #1,D0          ROLL A ZERO IN A FIELD OF ONES
01:00201C26 65F4            	  3909:          BCS.S   WALK0          CONTINUE TILL DONE
                            	  3910: 
01:00201C28 7001            	  3911:          MOVEQ   #$00000001,D0  THIS TIME, WALK A 1 THROUGH ZEROS
                            	  3912: WALK1
01:00201C2A 3480            	  3913:          MOVE.W  D0,(A2)        STORE D0 INTO MEMORY
01:00201C2C 3212            	  3914:          MOVE.W  (A2),D1        D1 CONTAINS RAM DATA
01:00201C2E B240            	  3915:          CMP.W   D0,D1          WRITTEN VS. READ
01:00201C30 6634            	  3916:          BNE.S   RAMERR         STOP ON ERROR
01:00201C32 D040            	  3917:          ASL.W   #1,D0          ROLL A ONE TO THE NEXT POSITION
01:00201C34 64F4            	  3918:          BCC.S   WALK1          CONTINUE TILL DONE
                            	  3919: 
01:00201C36 45EA0100        	  3920:          LEA     $0100(A2),A2   GO TO NEXT 256TH POSITION
01:00201C3A B5C9            	  3921:          CMP.L   A1,A2          CHECK TO SEE IF DONE
01:00201C3C 6DDC            	  3922:          BLT.S   WALK3          CONTINUE
                            	  3923: 
                            	  3924: * -2ND TEST-
01:00201C3E 2443            	  3925:          MOVE.L  D3,A2          SET A2 TO POINT TO START OF MEMORY
01:00201C40 7000            	  3926:          MOVEQ   #$00000000,D0  CLEAR D0
                            	  3927: MTCLR
01:00201C42 34C0            	  3928:          MOVE.W  D0,(A2)+       CLEAR MEMORY
01:00201C44 B5C9            	  3929:          CMP.L   A1,A2          DONE?
01:00201C46 66FA            	  3930:          BNE.S   MTCLR          NO... ZERO ALL OF MEMORY
                            	  3931: 
01:00201C48 74FF            	  3932:          MOVEQ   #-1,D2         SET D2 = FFFF
                            	  3933: MTSTOR1
01:00201C4A 3222            	  3934:          MOVE.W  -(A2),D1       FIRST READ BACK MEMORY
01:00201C4C B240            	  3935:          CMP.W   D0,D1          CHK AGAINST WHAT WAS WRITTEN
01:00201C4E 6616            	  3936:          BNE.S   RAMERR         STOP ON ERROR
01:00201C50 3482            	  3937:          MOVE.W  D2,(A2)        STORE COMPLEMENT
01:00201C52 B5C3            	  3938:          CMP.L   D3,A2          DONE?
01:00201C54 66F4            	  3939:          BNE.S   MTSTOR1        NO... COMPLEMENT ALL OF MEMORY
01:00201C56 3002            	  3940:          MOVE.W  D2,D0          D0=WHAT WAS WRITTEN
01:00201C58 4642            	  3941:          NOT.W   D2             SAVE COMPLEMENT FOR LATER
                            	  3942: 
                            	  3943: MTSTOR0
01:00201C5A 3212            	  3944:          MOVE.W  (A2),D1        READ BACK MEMORY
01:00201C5C B240            	  3945:          CMP.W   D0,D1          CHK AGAINST WHAT WAS WRITTEN
01:00201C5E 6606            	  3946:          BNE.S   RAMERR         STOP ON ERROR
01:00201C60 34C2            	  3947:          MOVE.W  D2,(A2)+       STORE COMPLEMENT
01:00201C62 B5C9            	  3948:          CMP.L   A1,A2          DONE?
01:00201C64 66F4            	  3949:          BNE     MTSTOR0        NO...KEEP LOOPING, YES...
                            	  3950: 
01:00201C66 2043            	  3951: RAMERR   MOVE.L  D3,A0          RESTORE A0
01:00201C68 4E75            	  3952:          RTS                    RETURN
                            	  3953: 
                            	  3954: 
                            	  3955: 
                            	  3956: 
                            	  3957: *-------------------------------------------------------------------------
                            	  3958: * File TM        TM  Transparent mode                             12/28/81
                            	  3959: 
                            	  3960: *    TM  [[EXIT CHAR]TRAILING CHAR]
                            	  3961: *
                            	  3962: *  In transparent mode the terminal is physically connected to the
                            	  3963: *  host; at the same time the terminal is watched by TM software
                            	  3964: *  for the EXIT character.  When the exit character is transmitted
                            	  3965: *  by the terminal it goes directly to the host; and at the same
                            	  3966: *  time the TM software reconfigures the hardware.  If a nonnull
                            	  3967: *  trailing character is present it is now sent via port 2 to
                            	  3968: *  the host.
                            	  3969: 
                            	  3970: *   TRANSPARENT MODE
                            	  3971: 
01:00201C6A 41FA0012        	  3972: TMCMD    LEA     P2CMD0(PC),A0
01:00201C6E 610001FE        	  3973:          BSR     FNEXTF         FIND NEXT FIELD
01:00201C72 11DD04EB        	  3974:          MOVE.B  (A5)+,TMCHARS+1 QUIT CHARACTER
01:00201C76 610001F6        	  3975:          BSR     FNEXTF         FIND NEXT FIELD
01:00201C7A 11DD04EA        	  3976:          MOVE.B  (A5)+,TMCHARS  OPTIONAL TRAILING CHAR
01:00201C7E 3E3804EA        	  3977: P2CMD0   MOVE.W  TMCHARS,D7
01:00201C82 610003E8        	  3978:          BSR     GETSER1        ADDRESS FOR PORT1 INTO A0
01:00201C86 4BFA007A        	  3979:          LEA     MSG006(PC),A5  "TRANSPARENT MODE"
01:00201C8A 6100E872        	  3980:          BSR     FIXDCRLF       SET UP FOR MESSAGE
01:00201C8E 2007            	  3981:          MOVE.L  D7,D0          EXIT CHARACTER
01:00201C90 61000120        	  3982:          BSR     PNT2HX         PRINT 2 HEX CHARACTERS
01:00201C94 3CFC203D        	  3983:          MOVE.W  #' =',(A6)+
01:00201C98 1007            	  3984:          MOVE.B  D7,D0          SEE IF CONTROL CHAR
01:00201C9A 0C000020        	  3985:          CMPI.B  #BLANK,D0
01:00201C9E 6A0A            	  3986:          BPL.S   P2CMD01
01:00201CA0 2CFC2043544C    	  3987:          MOVE.L  #' CTL',(A6)+
01:00201CA6 06000040        	  3988:          ADDI.B  #64,D0         MAKE IT A PRINTABLE CHARACTER
01:00201CAA 1CFC0020        	  3989: P2CMD01  MOVE.B  #BLANK,(A6)+
01:00201CAE 1CC0            	  3990:          MOVE.B  D0,(A6)+
01:00201CB0 3CFC0D0A        	  3991:          MOVE.W  #$0D0A,(A6)+
01:00201CB4 61000334        	  3992:          BSR     OUT1CR         GO PRINT BUFFER WITH CRLF
                            	  3993: 
01:00201CB8 10390000064C    	  3994:          MOVE.B  MD1CON.L,D0    PROGRAM ACIA FOR TRANSPARENT MODE
01:00201CBE 0200009F        	  3995:          ANDI.B  #$9F,D0
01:00201CC2 00000040        	  3996:          ORI.B   #$40,D0        FORCE RTS HIGH
01:00201CC6 1080            	  3997:          MOVE.B  D0,(A0)
01:00201CC8 08100000        	  3998: P2CMD2   BTST.B  #$0,(A0)      READ STATUS
01:00201CCC 67FA            	  3999:          BEQ.S   P2CMD2
01:00201CCE 10280001        	  4000:          MOVE.B  1(A0),D0       RECEIVE CHAR FROM PORT 1
01:00201CD2 0200007F        	  4001:          ANDI.B  #$7F,D0
01:00201CD6 B007            	  4002:          CMP.B   D7,D0          SEE IF QUIT CHARACTER (CTL A USUALLY)
01:00201CD8 66EE            	  4003:          BNE.S   P2CMD2
01:00201CDA 10390000064C    	  4004:          MOVE.B  MD1CON.L,D0    REPROGRAM FOR NON-TRANSPARENT
01:00201CE0 0200009F        	  4005:          ANDI.B  #$9F,D0
01:00201CE4 1080            	  4006:          MOVE.B  D0,(A0)
                            	  4007: 
01:00201CE6 E047            	  4008:          ASR.W   #8,D7
01:00201CE8 4A07            	  4009:          TST.B   D7
01:00201CEA 6712            	  4010:          BEQ.S   P2CMD6
                            	  4011: * SPECIAL SECOND CHAR TO HOST SEQUENCE
01:00201CEC 203C00001000    	  4012:          MOVE.L  #DELAYC1,D0
01:00201CF2 5380            	  4013: P2CMD4   SUBQ.L  #1,D0          DELAY; ALLOW HOST TO SYNC
01:00201CF4 66FC            	  4014:          BNE.S   P2CMD4
01:00201CF6 61000386        	  4015:          BSR     GETSER2
01:00201CFA 11470001        	  4016:          MOVE.B  D7,1(A0)       SEND CHAR
01:00201CFE 6000E92E        	  4017: P2CMD6   BRA     MACSBUG
                            	  4018: 
01:00201D02 2A5452414E535041	  4019: MSG006   DC.B    '*TRANSPARENT* EXIT=$',EOT
01:00201D0A 52454E542A204558
01:00201D12 49543D24
01:00201D16 04
                            	  4020: 
                            	  4021: 
                            	  4022: 
                            	  4023: 
                            	  4024: 
01:00201D17 00              	  4025:          DC.B    0              PAD BYTE
                            	  4026: 
                            	  4027: 
                            	  4028: 
                            	  4029: 
                            	  4030: *-------------------------------------------------------------------------
                            	  4031: * File W         Software Abort, Hex print routines               06/05/82
                            	  4032: 
                            	  4033: *
                            	  4034: *   HANDLE THE ABORT BUTTON
                            	  4035: *
01:00201D18 46FC2700        	  4036: ABORTB   MOVE.W  #$2700,SR
                            	  4037:          SAVEREGS
01:00201D1C 21CF0444        	     1M          MOVE.L  A7,REGA7       SAVE STACK POINTER
01:00201D20 4FFA000A        	     2M          LEA     SV_000047(PC),A7    A7 = RETURN ADDRESS (FOR CALL TO SAVE)
01:00201D24 21CF04D6        	     3M          MOVE.L  A7,TEMP        TEMP = RETURN ADDRESS
01:00201D28 6000F35E        	     4M          BRA     SAVE           BSR WITHOUT USING STACK
                            	     5M SV_000047     DS      0
01:00201D2C 6100060A        	  4038:          BSR     FAULTSER       RESET SERIAL PORTS
01:00201D30 4BFA0016        	  4039:          LEA     MSG012(PC),A5  'SOFTWARE ABORT'
                            	  4040: 
01:00201D34 6100063E        	  4041:          BSR     INITSER        RESET SERIAL PORTS (CLEAR TM MODE)
01:00201D38 6100E7C4        	  4042:          BSR     FIXDCRLF       MOVE MESSAGE TO BUFFER
01:00201D3C 610002C6        	  4043: EVECT4   BSR     OUTPUT         MSG TO PORT1
01:00201D40 6100EFBE        	  4044: ABORT335 BSR     TDISPLY        DISPLAY REGISTERS
01:00201D44 6000E8E8        	  4045:          BRA     MACSBUG
                            	  4046: 
01:00201D48 0A              	  4047: MSG012   DC.B    LF,LF,'SOFTWARE ABORT',CR,LF,EOT
01:00201D49 0A
01:00201D4A 534F465457415245
01:00201D52 2041424F5254
01:00201D58 0D
01:00201D59 0A
01:00201D5A 04
                            	  4048: 
                            	  4049: 
                            	  4050: 
                            	  4051: 
01:00201D5B 00              	  4052:          DC.B    0              PAD BYTE
                            	  4053: 
01:00201D5C 21FC3F3F3F3F0030	  4054: ABORTE MOVE.L    #'????',$30    UNKNOWN INTERRUPT
                            	  4055: 
                            	  4056: 
                            	  4057: *    SAVE REGISTERS AND PRINT VECTOR MSG
                            	  4058: *
                            	  4059: EVECTL   SAVEREGS
01:00201D64 21CF0444        	     1M          MOVE.L  A7,REGA7       SAVE STACK POINTER
01:00201D68 4FFA000A        	     2M          LEA     SV_000048(PC),A7    A7 = RETURN ADDRESS (FOR CALL TO SAVE)
01:00201D6C 21CF04D6        	     3M          MOVE.L  A7,TEMP        TEMP = RETURN ADDRESS
01:00201D70 6000F316        	     4M          BRA     SAVE           BSR WITHOUT USING STACK
                            	     5M SV_000048     DS      0
01:00201D74 610005C2        	  4060:          BSR     FAULTSER       RESET SERIAL PORTS
01:00201D78 61000316        	  4061: EVECT2   BSR     FIXBUF         PRINT MESSAGE "XXXX TRAP ERROR"
01:00201D7C 3CFC0D0A        	  4062:          MOVE.W  #$0D0A,(A6)+
01:00201D80 2CF80030        	  4063:          MOVE.L  AV12,(A6)+     TYPE OF ERROR
01:00201D84 4BFA0008        	  4064:          LEA     MSG010(PC),A5  'TRAP ERROR'
01:00201D88 6100E764        	  4065:          BSR     FIXDADD
01:00201D8C 60AE            	  4066:          BRA     EVECT4
                            	  4067: 
01:00201D8E 2054524150204552	  4068: MSG010   DC.B    ' TRAP ERROR',CR,LF,EOT
01:00201D96 524F52
01:00201D99 0D
01:00201D9A 0A
01:00201D9B 04
                            	  4069: 
                            	  4070: 
                            	  4071: 
                            	  4072: 
                            	  4073: *
                            	  4074: *  PRINT HEX ROUTINES
                            	  4075: *
                            	  4076: *
                            	  4077: * PRINT 8 HEX CHARACTERS
                            	  4078: *
                            	  4079: *  D0,D1,D2 DESTROYED
                            	  4080: *
01:00201D9C 4840            	  4081: PNT8HX   SWAP    D0             FLIP REG HALVES
01:00201D9E 610A            	  4082:          BSR.S   PNT4HX         DO TOP WORD
01:00201DA0 4840            	  4083:          SWAP    D0             NOW DO LOWER WORD
01:00201DA2 6006            	  4084:          BRA.S   PNT4HX
                            	  4085: * PRINT 6 HEX CHARACTERS
01:00201DA4 4840            	  4086: PNT6HX   SWAP    D0             FLIP REGISTER HALVES
01:00201DA6 610A            	  4087:          BSR.S   PNT2HX
01:00201DA8 4840            	  4088:          SWAP    D0             FLIP BACK REG HALVES
                            	  4089: * PRINT 4 HEX CHARACTERS IN D0.W
01:00201DAA 3200            	  4090: PNT4HX   MOVE.W  D0,D1          SAVE IN TEMP
01:00201DAC E058            	  4091:          ROR.W   #8,D0          GET BITS 15-8 INTO LOWER BYTE
01:00201DAE 6102            	  4092:          BSR.S   PNT2HX         PRINT IT
01:00201DB0 3001            	  4093:          MOVE.W  D1,D0          PULL IT BACK
                            	  4094: * PRINT 2 HEX CHARACTERS IN D0.B
01:00201DB2 3400            	  4095: PNT2HX   MOVE.W  D0,D2          SAVE IN TEMP REG
01:00201DB4 E850            	  4096:          ROXR.W  #4,D0          FORM UPPER NIBBLE
01:00201DB6 6102            	  4097:          BSR.S   PUTHEX         PUT ASCII INTO PRINT BUFFER
01:00201DB8 3002            	  4098:          MOVE.W  D2,D0          GET BACK FROM TEMP
                            	  4099: * CONVERT D0.NIBBLE TO HEX & PUT IT IN PRINT BUFFER
                            	  4100: *
01:00201DBA 0200000F        	  4101: PUTHEX   ANDI.B  #$0F,D0        SAVE LOWER NIBBLE
01:00201DBE 00000030        	  4102:          ORI.B   #$30,D0        CONVERT TO ASCII
01:00201DC2 0C000039        	  4103:          CMPI.B  #$39,D0        SEE IF IT IS>9
01:00201DC6 6F02            	  4104:          BLE.S   SAVHEX
01:00201DC8 5E40            	  4105:          ADD     #7,D0          ADD TO MAKE 10=>A
01:00201DCA 1CC0            	  4106: SAVHEX   MOVE.B  D0,(A6)+       PUT IT IN PRINT BUFFER
01:00201DCC 4E75            	  4107:          RTS
                            	  4108: 
                            	  4109: * FORMAT RELATIVE ADDRESS  AAAAAA+Rn
                            	  4110: *        ENTER     D0 = VALUE
                            	  4111: *                  A6 = STORE POINTER
                            	  4112: *
01:00201DCE 48E74780        	  4113: FRELADDR MOVEM.L D1/D5-D7/A0,-(A7)
01:00201DD2 41F8044C        	  4114:          LEA     OFFSET,A0
01:00201DD6 7EFF            	  4115:          MOVEQ   #-1,D7         D7 = DIFF. BEST FIT
01:00201DD8 7C00            	  4116:          CLR.L   D6             D6 = OFFSET POSITION
                            	  4117: 
01:00201DDA 2200            	  4118: FREL10   MOVE.L  D0,D1
01:00201DDC 4A90            	  4119:          TST.L   (A0)
01:00201DDE 670C            	  4120:          BEQ.S   FREL15         ZERO OFFSET
01:00201DE0 9290            	  4121:          SUB.L   (A0),D1        D1 = DIFF.
01:00201DE2 6B08            	  4122:          BMI.S   FREL15         NO FIT
                            	  4123: 
01:00201DE4 B287            	  4124:          CMP.L   D7,D1
01:00201DE6 6404            	  4125:          BCC.S   FREL15         OLD FIT BETTER
                            	  4126: 
01:00201DE8 2E01            	  4127:          MOVE.L  D1,D7          D7 = NEW BEST FIT
01:00201DEA 2A06            	  4128:          MOVE.L  D6,D5          D5 = POSITION
                            	  4129: 
01:00201DEC 5888            	  4130: FREL15   ADDQ.L  #4,A0
01:00201DEE 5286            	  4131:          ADDQ.L  #1,D6
01:00201DF0 0C460008        	  4132:          CMPI.W  #8,D6
01:00201DF4 66E4            	  4133:          BNE     FREL10         MORE OFFSETS TO CHECK
                            	  4134: 
01:00201DF6 4A87            	  4135:          TST.L   D7
01:00201DF8 6B1C            	  4136:          BMI.S   FREL25         NO FIT
01:00201DFA 4A46            	  4137:          TST     D6
01:00201DFC 6606            	  4138:          BNE.S   FREL20
01:00201DFE 4AB8044C        	  4139:          TST.L   OFFSET
01:00201E02 6712            	  4140:          BEQ.S   FREL25         R0 = 000000; NO FIT
                            	  4141: 
01:00201E04 2007            	  4142: FREL20   MOVE.L  D7,D0
01:00201E06 619C            	  4143:          BSR     PNT6HX         FORMAT OFFSET
01:00201E08 1CFC002B        	  4144:          MOVE.B  #'+',(A6)+     +
01:00201E0C 1CFC0052        	  4145:          MOVE.B  #'R',(A6)+     R
01:00201E10 06050030        	  4146:          ADDI.B  #'0',D5        MAKE ASCII
01:00201E14 600A            	  4147:          BRA.S   FREL30
                            	  4148: 
01:00201E16 618C            	  4149: FREL25   BSR     PNT6HX         FORMAT ADDRESS AS IS
01:00201E18 1A3C0020        	  4150:          MOVE.B  #BLANK,D5
01:00201E1C 1CC5            	  4151:          MOVE.B  D5,(A6)+       THREE SPACES FOR ALIGNMENT
01:00201E1E 1CC5            	  4152:          MOVE.B  D5,(A6)+
01:00201E20 1CC5            	  4153: FREL30   MOVE.B  D5,(A6)+
                            	  4154: 
01:00201E22 4CDF01E2        	  4155:          MOVEM.L (A7)+,D1/D5-D7/A0
01:00201E26 4E75            	  4156:          RTS
                            	  4157: 
                            	  4158: *
                            	  4159: *
                            	  4160: *   PRINT HEX (ZERO SURPRESS)
                            	  4161: *
01:00201E28 7800            	  4162: PNTZHX   CLR.L   D4             IS ZERO WHEN SURPRESSING
01:00201E2A 2200            	  4163:          MOVE.L  D0,D1          SAVE IN TEMP
01:00201E2C 6738            	  4164:          BEQ.S   PNTZ81         IF ZERO
01:00201E2E 6A08            	  4165:          BPL.S   PNTZ0
01:00201E30 4481            	  4166:          NEG.L   D1             CHANGE TO POSITIVE VALUE
01:00201E32 6B32            	  4167:          BMI.S   PNTZ81         WATCH OUT SPECIAL CASE $80000000
01:00201E34 1CFC002D        	  4168:          MOVE.B  #'-',(A6)+     PUT SIGN INTO BUFFER
01:00201E38 7408            	  4169: PNTZ0    MOVEQ   #8,D2          8 POSSIBLE CHARACTERS
01:00201E3A 2001            	  4170: PNTZ1    MOVE.L  D1,D0          UNSAVE IT
01:00201E3C 2602            	  4171:          MOVE.L  D2,D3          COUNT DOWN FROM HERE
01:00201E3E 5383            	  4172:          SUBQ.L  #1,D3          BACK OFF ONE
01:00201E40 670C            	  4173:          BEQ.S   PNTZ4          IF NO ROTATE SKIP THIS
01:00201E42 E880            	  4174: PNTZ2    ASR.L   #4,D0          ROTATE LRIGHT
01:00201E44 02800FFFFFFF    	  4175:          ANDI.L  #$FFFFFFF,D0   CLEAR TOP NIBBLE
01:00201E4A 5383            	  4176:          SUBQ.L  #1,D3
01:00201E4C 66F4            	  4177:          BNE     PNTZ2
01:00201E4E 0200000F        	  4178: PNTZ4    ANDI.B  #$F,D0         SAVE ONLY NIBBLE
01:00201E52 6604            	  4179:          BNE.S   PNTZ3
01:00201E54 4A04            	  4180:          TST.B   D4             SEE IF STILL SURPRESSING
01:00201E56 6706            	  4181:          BEQ.S   PNTZ8
01:00201E58 6100FF60        	  4182: PNTZ3    BSR     PUTHEX         PUT A HEX CHAR IN BUFFER
01:00201E5C 1800            	  4183:          MOVE.B  D0,D4          MARK AS NON-SURPRESSING MODE
01:00201E5E 5382            	  4184: PNTZ8    SUBQ.L  #1,D2          DO ANOTHER CHAR
01:00201E60 66D8            	  4185:          BNE     PNTZ1
01:00201E62 4A04            	  4186:          TST.B   D4             SEE IF ANYTHING PRINTED
01:00201E64 6604            	  4187:          BNE.S   PNTZ9
01:00201E66 1CFC0030        	  4188: PNTZ81   MOVE.B  #'0',(A6)+     MOVE AT LEAST ONE ZERO
01:00201E6A 4E75            	  4189: PNTZ9    RTS
                            	  4190: 
                            	  4191: * FIND NEXT FIELD... (A5) POINTS TO FIELD, (A0) NULL FIELD RETURN
                            	  4192: *   *-*-WARNING-*-* IF (A0) RETURN IS USED;  RETURN MUST BE AT
                            	  4193: *                   SAME SUBROUTINE LEVEL OR STACK GETS SCREWED UP
                            	  4194: *
                            	  4195: *  SKIP LEADING SPACES
                            	  4196: *  TERMINATE NULL FIELD ON COMA ,SEMICOLEN OR A5=A6
                            	  4197: 
01:00201E6C 528D            	  4198: FNEXTF1  ADDQ.L  #1,A5
                            	  4199: 
01:00201E6E 1015            	  4200: FNEXTF   MOVE.B  (A5),D0        ENTRY POINT
01:00201E70 BBCE            	  4201:          CMP.L   A6,A5
01:00201E72 6414            	  4202:          BCC.S   FNEXTF7        AT END OF BUFFER
01:00201E74 0C000020        	  4203:          CMPI.B  #BLANK,D0
01:00201E78 67F2            	  4204:          BEQ     FNEXTF1        SPACE
                            	  4205: 
01:00201E7A 0C00002C        	  4206:          CMPI.B  #',',D0
01:00201E7E 6708            	  4207:          BEQ.S   FNEXTF7        COMMA - NULL FIELD
01:00201E80 0C00003B        	  4208:          CMPI.B  #';',D0
01:00201E84 6702            	  4209:          BEQ.S   FNEXTF7        SEMICOLON - NULL FIELD
01:00201E86 4E75            	  4210:          RTS                    NORMAL FOUND FIELD RETURN
                            	  4211: 
01:00201E88 588F            	  4212: FNEXTF7  ADDQ.L  #4,A7          TRIM STACK
01:00201E8A 4ED0            	  4213:          JMP     (A0)           NULL FIELD RETURN
                            	  4214: 
                            	  4215: **************************************************************
                            	  4216: * THIS ROUTINE MAKES SURE YOU ARE ON THE CORRECT BOUNDRY.    *
                            	  4217: *  D0 = ARGUMENT...   CHECKS ADDRESS AND WORD ALIGNMENTS.   *
                            	  4218: **************************************************************
                            	  4219: 
01:00201E8C E298            	  4220: CKWADR   ROR.L   #1,D0
01:00201E8E E398            	  4221:          ROL.L   #1,D0
01:00201E90 6508            	  4222:          BCS.S   CKADR39        NOT WORD ALIGNED
                            	  4223: 
01:00201E92 0C8001000000    	  4224: CKADDR   CMPI.L  #$1000000,D0   VALID ADDRESS?
01:00201E98 6514            	  4225:          BCS.S   CKADR99        GOOD ADDRESS
                            	  4226: 
01:00201E9A 4BFA0014        	  4227: CKADR39  LEA     MSG018(PC),A5
01:00201E9E 6100E64A        	  4228:          BSR     FIXDATA
01:00201EA2 6100FEF8        	  4229:          BSR     PNT8HX
01:00201EA6 61000142        	  4230:          BSR     OUT1CR
01:00201EAA 6000E782        	  4231:          BRA     MACSBUG
                            	  4232: 
01:00201EAE 4E75            	  4233: CKADR99  RTS
                            	  4234: 
01:00201EB0 494E56414C494420	  4235: MSG018   DC.B    'INVALID ADDRESS=',EOT
01:00201EB8 414444524553533D
01:00201EC0 04
                            	  4236: 
                            	  4237: 
                            	  4238: 
                            	  4239: 
01:00201EC1 00              	  4240:          DC.B    0              PAD BYTE
                            	  4241: 
                            	  4242: * EVALUATE EXPRESSION
                            	  4243: *  NUMBER PLUS OR MINUS NUMBER....
                            	  4244: *
01:00201EC2 2F07            	  4245: GETEXP   MOVE.L  D7,-(A7)       SAVE D7
01:00201EC4 7E00            	  4246:          CLR.L   D7
01:00201EC6 6128            	  4247: GETEXP21 BSR.S   GETNUMA        GET NUMBER
01:00201EC8 DE80            	  4248:          ADD.L   D0,D7          D7 = NUMBER BEING BUILT
01:00201ECA 121D            	  4249: GETEXP15 MOVE.B  (A5)+,D1       D1 = TERMINATING CHAR
01:00201ECC 7000            	  4250:          CLR.L   D0             D0 = NEXT NUMBER (=0 1ST TIME)
01:00201ECE 0C01002B        	  4251:          CMPI.B  #'+',D1
01:00201ED2 67F2            	  4252:          BEQ     GETEXP21       PLUS
01:00201ED4 0C01002D        	  4253:          CMPI.B  #'-',D1
01:00201ED8 6606            	  4254:          BNE.S   GETEXP39       NOT MINUS
01:00201EDA 6114            	  4255:          BSR.S   GETNUMA        GET NEXT NUMBER
01:00201EDC 9E80            	  4256:          SUB.L   D0,D7
01:00201EDE 60EA            	  4257:          BRA     GETEXP15
                            	  4258: 
01:00201EE0 2007            	  4259: GETEXP39 MOVE.L  D7,D0          D0 = VALUE BUILT
01:00201EE2 538D            	  4260:          SUBQ.L  #1,A5          A5 = CHAR AFTER EXPRESSION
01:00201EE4 2E1F            	  4261:          MOVE.L  (A7)+,D7       RESTORE D7
01:00201EE6 4E75            	  4262:          RTS
                            	  4263: 
                            	  4264: *   ROUTINES TO CONVERT STRING TO BINARY VALUE
                            	  4265: *
                            	  4266: *        ACCEPTS PREFIXES:
                            	  4267: *         % binary
                            	  4268: *         @ octal
                            	  4269: *         & decimal
                            	  4270: *         $ hex
                            	  4271: *
01:00201EE8 610A            	  4272: GETNUMD  BSR.S   GETDECNU       GET DECIMAL NUMBER
01:00201EEA 6600E5BC        	  4273: GETNUMD9 BNE     ERROR
01:00201EEE 4E75            	  4274:          RTS
                            	  4275: 
01:00201EF0 610A            	  4276: GETNUMA  BSR.S   GETHEXNU       GET HEX NUMBER
01:00201EF2 60F6            	  4277:          BRA     GETNUMD9
                            	  4278: 
01:00201EF4 48E77C80        	  4279: GETDECNU MOVEM.L D1-D5/A0,-(A7) DECODE AS A DECIMAL NUMBER
01:00201EF8 760A            	  4280:          MOVEQ   #10,D3         D3 = BASE (DECIMAL)
01:00201EFA 6006            	  4281:          BRA.S   GETN20
                            	  4282: 
01:00201EFC 48E77C80        	  4283: GETHEXNU MOVEM.L D1-D5/A0,-(A7) DECODE AS A HEX NUMBER
01:00201F00 7610            	  4284:          MOVEQ   #16,D3         D3 = BASE
                            	  4285: 
01:00201F02 4244            	  4286: GETN20   CLR.W   D4             D4 = FLAG FOR CHARACTER HIT
01:00201F04 7200            	  4287:          CLR.L   D1             D1 = TEMP RESULTS
01:00201F06 0C150020        	  4288:          CMPI.B  #BLANK,(A5)
01:00201F0A 6778            	  4289:          BEQ.S   GETN80         FIRST CHAR SPACE; ERROR
                            	  4290: 
01:00201F0C BBCE            	  4291: GETN30   CMP.L   A6,A5          SEE IF AT END OF BUFFER
01:00201F0E 677A            	  4292:          BEQ.S   GETN90
01:00201F10 7000            	  4293:          CLR.L   D0
01:00201F12 101D            	  4294:          MOVE.B  (A5)+,D0       D0 = CHARACTER
                            	  4295: 
01:00201F14 41FA007E        	  4296:          LEA     GETNDATA(PC),A0 POINTER TO TERMINATE CHARS
01:00201F18 1A18            	  4297: GETN40   MOVE.B  (A0)+,D5       D5 = TERMINATION CHAR
01:00201F1A 6706            	  4298:          BEQ.S   GETN50         NOT TERM.CHAR
01:00201F1C B005            	  4299:          CMP.B   D5,D0
01:00201F1E 6768            	  4300:          BEQ.S   GETN85         FOUND TERMINATION CHAR; EXIT
01:00201F20 60F6            	  4301:          BRA     GETN40
                            	  4302: 
01:00201F22 0C000025        	  4303: GETN50   CMPI.B  #'%',D0        SEE IF FLAGGED AS BINARY
01:00201F26 660A            	  4304:          BNE.S   GETN60
01:00201F28 7602            	  4305:          MOVEQ   #2,D3          BASE IS BINARY
01:00201F2A 4A44            	  4306: GETN55   TST.W   D4             ANYTHING ENTERED
01:00201F2C 6656            	  4307:          BNE.S   GETN80         CONFLICT
                            	  4308: 
01:00201F2E 78FF            	  4309: GETN57   MOVEQ   #-1,D4         SET DATA ENTERED FLAG
01:00201F30 60DA            	  4310:          BRA     GETN30
                            	  4311: 
01:00201F32 0C000040        	  4312: GETN60   CMPI.B  #'@',D0        SEE IF FLAGGED AS OCTAL
01:00201F36 6604            	  4313:          BNE.S   GETN65
01:00201F38 7608            	  4314:          MOVEQ   #8,D3          BASE IS OCTAL
01:00201F3A 60EE            	  4315:          BRA     GETN55
                            	  4316: 
01:00201F3C 0C000026        	  4317: GETN65   CMPI.B  #'&',D0        SEE IF FLAGGED AS DECIMAL
01:00201F40 6604            	  4318:          BNE.S   GETN70
01:00201F42 760A            	  4319:          MOVEQ   #10,D3         BASE IS DECIMAL
01:00201F44 60E4            	  4320:          BRA     GETN55
                            	  4321: 
01:00201F46 0C000024        	  4322: GETN70   CMPI.B  #'$',D0        SEE IF FLAGGED AS HEX
01:00201F4A 6604            	  4323:          BNE.S   GETN75
01:00201F4C 7610            	  4324:          MOVEQ   #16,D3         BASE IS 16
01:00201F4E 60DA            	  4325:          BRA     GETN55
                            	  4326: 
01:00201F50 04000030        	  4327: GETN75   SUBI.B  #$30,D0
01:00201F54 6D2E            	  4328:          BLT.S   GETN80         LESS THAN ZERO
01:00201F56 0C000009        	  4329:          CMPI.B  #9,D0
01:00201F5A 6F0E            	  4330:          BLE.S   GETN77         VALUE 0 - 9
01:00201F5C 0C000011        	  4331:          CMPI.B  #$11,D0
01:00201F60 6D22            	  4332:          BLT.S   GETN80         LESS THAN A
01:00201F62 0C000016        	  4333:          CMPI.B  #$16,D0
01:00201F66 6E1C            	  4334:          BGT.S   GETN80         GREATER THAN F
01:00201F68 5F00            	  4335:          SUBQ.B  #7,D0          MAKE BINARY
                            	  4336: 
01:00201F6A B043            	  4337: GETN77   CMP.W   D3,D0          IS INPUT LARGER THAN BASE
01:00201F6C 6416            	  4338:          BCC.S   GETN80         LARGER THAN BASE
01:00201F6E 2401            	  4339:          MOVE.L  D1,D2          GET READY TO MULTIPLY D1*BASE
01:00201F70 4841            	  4340:          SWAP    D1
01:00201F72 C2C3            	  4341:          MULU    D3,D1          TOP PART
01:00201F74 4841            	  4342:          SWAP    D1
01:00201F76 4A41            	  4343:          TST.W   D1             CHECK FOR OVERFLOW
01:00201F78 660A            	  4344:          BNE.S   GETN80         VALUE IS TOO LARGE
01:00201F7A C4C3            	  4345:          MULU    D3,D2          NOW WORK ON LOW WORD
01:00201F7C D282            	  4346:          ADD.L   D2,D1          PUT IT BACK TOGETHER
01:00201F7E 6904            	  4347:          BVS.S   GETN80         OVERFLOW?
01:00201F80 D280            	  4348:          ADD.L   D0,D1          ADD IN NEW STUFF
01:00201F82 68AA            	  4349:          BVC     GETN57
01:00201F84 70FF            	  4350: GETN80   MOVEQ   #-1,D0         ERROR RETURN (BNE)
01:00201F86 6006            	  4351:          BRA.S   GETN95
                            	  4352: 
01:00201F88 538D            	  4353: GETN85   SUBQ.L  #1,A5          BACK UP TO POINT AT SPACE/PREVIOUS CHAR
01:00201F8A 2001            	  4354: GETN90   MOVE.L  D1,D0          SET UP RESULT FOR RETURN
01:00201F8C 7200            	  4355:          CLR.L   D1             NORMAL RETURN (BEQ)
01:00201F8E 4CDF013E        	  4356: GETN95   MOVEM.L (A7)+,D1-D5/A0 RESTORE SOME REGISTERS
01:00201F92 4E75            	  4357:          RTS
                            	  4358: 
01:00201F94 20282B2C2D2E3A3B	  4359: GETNDATA DC.B    ' (+,-.:;=^]',0 TERMINATE CHARS
01:00201F9C 3D5E5D
01:00201F9F 00
                            	  4360: 
                            	  4361: 
                            	  4362: 
                            	  4363: *
                            	  4364: *  ***GETHEX***  GET HEX (BINARY VALUE FROM ASCII)
                            	  4365: *   D0.B HAS ASCII CHAR  RETURNS $0-$F BINARY
                            	  4366: *
01:00201FA0 0C000030        	  4367: GETHEX CMPI.B    #$30,D0        IS IT LESS THAN ZERO
01:00201FA4 6D1C            	  4368:        BLT.S     PNMSG011
01:00201FA6 0C000039        	  4369:        CMPI.B    #$39,D0        IS IT GREATER THAN 9
01:00201FAA 6F0E            	  4370:        BLE.S     GTHX2          GOOD HEX
                            	  4371: 
01:00201FAC 0C000041        	  4372:        CMPI.B    #$41,D0        IS IT LESS THAN 'A'
01:00201FB0 6D10            	  4373:        BLT.S     PNMSG011
01:00201FB2 0C000046        	  4374:        CMPI.B    #$46,D0        IS IT GT 'F'
01:00201FB6 6E0A            	  4375:        BGT.S     PNMSG011
01:00201FB8 5F00            	  4376:        SUBQ.B    #7,D0          MAKE IT SMALLER A=10
01:00201FBA 02800000000F    	  4377: GTHX2  ANDI.L    #$F,D0
01:00201FC0 4E75            	  4378:        RTS
                            	  4379: 
01:00201FC2 610000CC        	  4380: PNMSG011 BSR     FIXBUF         PRINT NOT A HEX DIGIT
01:00201FC6 1CC0            	  4381:          MOVE.B  D0,(A6)+       PUT IN OFFENDING CHAR
01:00201FC8 4BFA000A        	  4382:          LEA     MSG011(PC),A5  '  IS NOT A HEX DIGIT'
01:00201FCC 6100E520        	  4383:          BSR     FIXDADD
01:00201FD0 6000E4CE        	  4384:          BRA     MSG            GO PRINT IT AND ENTER MACSBUG
                            	  4385: 
01:00201FD4 20204953204E4F54	  4386: MSG011   DC.B    '  IS NOT A HEX DIGIT',EOT
01:00201FDC 2041204845582044
01:00201FE4 49474954
01:00201FE8 04
                            	  4387: 
                            	  4388: 
                            	  4389: 
                            	  4390: 
                            	  4391: 
01:00201FE9 00              	  4392:          DC.B    0              PAD BYTE
                            	  4393: 
                            	  4394: 
                            	  4395: 
                            	  4396: 
                            	  4397: *-------------------------------------------------------------------------
                            	  4398: * File X         COMMON I/O                                       05/17/82
                            	  4399: 
                            	  4400: ******************************
                            	  4401: *
                            	  4402: *    SEND LINE TO PORT1 WITH CR/LF
                            	  4403: *
01:00201FEA 1CFC000D        	  4404: OUT1CR   MOVE.B  #CR,(A6)+
01:00201FEE 1CFC000A        	  4405:          MOVE.B  #LF,(A6)+
01:00201FF2 4AB8061C        	  4406:          TST.L   OUTTO          SEE IF ALTERNATE ADDRESS
01:00201FF6 6706            	  4407:          BEQ.S   OUT1CRX
01:00201FF8 2F38061C        	  4408:          MOVE.L  OUTTO,-(A7)    PUSH ON STACK
01:00201FFC 4E75            	  4409:          RTS                    GO DO IT
                            	  4410: 
01:00201FFE 2F380630        	  4411: OUT1CRX  MOVE.L  OUTPORT1,-(A7) GO TO I/O ADDRESS
01:00202002 4E75            	  4412:          RTS                    ; (THIS NORMALLY GOES TO OUT1CR0)
                            	  4413: *
                            	  4414: OUT1CR0  DS      0
                            	  4415: *
                            	  4416: *    OUTPUT BUFFER TO PORT1
                            	  4417: *
01:00202004 48E7F0C0        	  4418: OUTPUT   MOVEM.L D0-D3/A0-A1,-(A7) GET SOME WORKING ROOM
01:00202008 7600            	  4419:          CLR.L   D3             D3 = NO OFFSET INTO NULL CHARACTERS
01:0020200A 6160            	  4420:          BSR.S   GETSER1        A0 = GET SERIAL PORT 1 ADDRESS
01:0020200C 601E            	  4421:          BRA.S   OUTP2
                            	  4422: *
                            	  4423: *    SEND LINE TO PORT2 WITH CR
                            	  4424: *
01:0020200E 1CFC000D        	  4425: OUTPUT2  MOVE.B  #$D,(A6)+      TACK ON A "CR"
01:00202012 4AB8061C        	  4426:          TST.L   OUTTO          SEE IF ALTERNATE ADDRESS
01:00202016 6706            	  4427:          BEQ.S   OUTPUT2X
01:00202018 2F38061C        	  4428:          MOVE.L  OUTTO,-(A7)    PUSH ON STACK
01:0020201C 4E75            	  4429:          RTS                    GO DO IT
                            	  4430: 
01:0020201E 2F380638        	  4431: OUTPUT2X MOVE.L  OUTPORT2,-(A7) GO TO IO ROUTINE
01:00202022 4E75            	  4432:          RTS                    ; (THIS NORMALLY GOES TO OUTPUT20)
                            	  4433: *
                            	  4434: OUTPUT20 DS      0
                            	  4435: *
                            	  4436: *     OUTPUT BUFFER TO PORT2
                            	  4437: *
01:00202024 48E7F0C0        	  4438: OUTPUT21 MOVEM.L D0-D3/A0-A1,-(A7)
01:00202028 7601            	  4439:          MOVEQ   #1,D3          SIGNAL FOR PORT2
01:0020202A 6152            	  4440:          BSR.S   GETSER2        RETURNS SERIAL PORT 2 BASE ADDRESS IN A0
                            	  4441: *
                            	  4442: *   SEND BUFFER TO PORT
                            	  4443: *
01:0020202C BBCE            	  4444: OUTP2    CMP.L   A6,A5          SEE IF AT OR BEYOND END OF LINE
01:0020202E 6506            	  4445:          BCS.S   OUTP3          NO... KEEP GOING, ELSE
01:00202030 4CDF030F        	  4446:          MOVEM.L (A7)+,D0-D3/A0-A1 RESTORE REGISTERS
01:00202034 4E75            	  4447:          RTS                    END OF ROUTINE
                            	  4448: 
01:00202036 101D            	  4449: OUTP3    MOVE.B  (A5)+,D0       GRAB BYTE TO OUTPUT
01:00202038 6102            	  4450:          BSR.S   OUTCH1         GO PRINT IT
01:0020203A 60F0            	  4451:          BRA.S   OUTP2          GO DO ANOTHER
                            	  4452: 
                            	  4453: *   SEND CHARACTER IN D0.B TO PORT1
                            	  4454: *   WHOSE BASE ADDRESS IS IN A0
                            	  4455: *   D3=0 FOR PORT1  D3=1 FOR PORT2
                            	  4456: *   PUTS IN NULL PADDING AS NEEDED
                            	  4457: *
01:0020203C 610001D6        	  4458: OUTCH1   BSR     OUTCH          GO PRINT D0
01:00202040 4A00            	  4459:          TST.B   D0             SEE IF NULL
01:00202042 6726            	  4460:          BEQ.S   OUTCHRTS       JUST END IF NULL
01:00202044 7400            	  4461:          CLR.L   D2             CLEAR UPPER BYTES OF NULL LOOP COUNTER
01:00202046 43F80618        	  4462:          LEA     NULLPADS,A1    FORM ADDRESS OF PADS
01:0020204A D3C3            	  4463:          ADD.L   D3,A1          D3=0 FOR PORT1 1=PORT2
01:0020204C 1411            	  4464:          MOVE.B  (A1),D2        DEFAULT NULL PADS
01:0020204E 0C00000D        	  4465:          CMPI.B  #$D,D0         SEE IF CR
01:00202052 6608            	  4466:          BNE.S   OUTCH2
01:00202054 43F8061A        	  4467:          LEA     CRPADS,A1      FORM ADDRESS OF CR PADS
01:00202058 D3C3            	  4468:          ADD.L   D3,A1          D3=0 FOR PORT1  1=PORT2
01:0020205A 1411            	  4469:          MOVE.B  (A1),D2        NULLS AFTER CR
01:0020205C 4A82            	  4470: OUTCH2   TST.L   D2  SEE        IF ANY PADDS TO BE SEND
01:0020205E 670A            	  4471:          BEQ.S   OUTCHRTS       0=NONE
01:00202060 7000            	  4472:          CLR.L   D0             0=NULL CHAR TO BE SEND
01:00202062 610001B0        	  4473: OUTCH3   BSR     OUTCH          SEND A NULL
01:00202066 5382            	  4474:          SUBQ.L  #1,D2          LOOP AROUND
01:00202068 66F8            	  4475:          BNE     OUTCH3
01:0020206A 4E75            	  4476: OUTCHRTS RTS                    END OF OUTCH ROUTINE
                            	  4477: 
                            	  4478: *
                            	  4479: *   GET BASE ADDRESS OF SERIAL PORT 1 IN  A0
                            	  4480: *
                            	  4481: 
01:0020206C 41F9003C0008    	  4482: GETSER1  LEA     SER1,A0        DEFAULT
01:00202072 4AB80624        	  4483:          TST.L   ALTSER1        IF ALTERNATE IS ZERO
01:00202076 6704            	  4484:          BEQ.S   RETURN         THEN RETURN
01:00202078 20780624        	  4485:          MOVE.L  ALTSER1,A0     ELSE USE ALTERNATE SERIAL PORT 1
01:0020207C 4E75            	  4486: RETURN   RTS     RETURN         (USED FROM A COUPLE OF PLACES)
                            	  4487: 
                            	  4488: 
                            	  4489: *
                            	  4490: *   GET BASE ADDRESS OF SERIAL PORT 2 IN A0
                            	  4491: *
                            	  4492: 
01:0020207E 41F9003C0008    	  4493: GETSER2  LEA     SER2,A0        DEFAULT SERIAL PORT 2
01:00202084 4AB80628        	  4494:          TST.L   ALTSER2        IF ALTERNATE IS ZERO
01:00202088 67F2            	  4495:          BEQ     RETURN         THEN RETURN
01:0020208A 20780628        	  4496:          MOVE.L  ALTSER2,A0     ELSE USE ALTERNATE SERIAL PORT 2
01:0020208E 4E75            	  4497:          RTS                    RETURN
                            	  4498: *
                            	  4499: *     FIX THE BUFFER A5 & A6 SET TO START OF BUFFER QUE
                            	  4500: *
01:00202090 4BF80540        	  4501: FIXBUF   LEA     BUFFER,A5
01:00202094 2C4D            	  4502:          MOVE.L  A5,A6
01:00202096 4E75            	  4503:          RTS
                            	  4504: 
                            	  4505: *   INPUT A LINE FROM PORT1
                            	  4506: *
01:00202098 4AB80620        	  4507: PORTIN1  TST.L   INFROM         SEE IF ALTERNAME ADDRESS
01:0020209C 6706            	  4508:          BEQ.S   PORTIN1X
01:0020209E 2F380620        	  4509:          MOVE.L  INFROM,-(A7)   PUSH ON STACK
01:002020A2 4E75            	  4510:          RTS                    GO DO IT
01:002020A4 2F38062C        	  4511: PORTIN1X MOVE.L  INPORT1,-(A7)  GO TO IO ROUTINE
01:002020A8 4E75            	  4512:          RTS                    NORMALLY GOES TO PORTIN10
                            	  4513: 
01:002020AA 48E7F9E0        	  4514: PORTIN1N MOVEM.L D0-D4/D7/A0-A2,-(A7)
01:002020AE 4A3804E8        	  4515:          TST.B   XONOFF+2
01:002020B2 6608            	  4516:          BNE.S   PORTIN1V       OVERRIDE "No Auto Line Feed"
01:002020B4 7E01            	  4517:          MOVEQ   #1,D7          "No Auto Line Feed" Entry point
01:002020B6 6006            	  4518:          BRA.S   PORTIN1W
                            	  4519: 
                            	  4520: * ENTRY ALSO POSSIBLE FROM:  PORTIN2
01:002020B8 48E7F9E0        	  4521: PORTIN10 MOVEM.L D0-D4/D7/A0-A2,-(A7)
01:002020BC 7E00            	  4522: PORTIN1V CLR.L   D7             "Auto Line Feed" Entry point.
01:002020BE 7600            	  4523: PORTIN1W CLR.L   D3             FLAG AS PORT1
01:002020C0 61AA            	  4524:          BSR     GETSER1        MOVE ADDRESS INTO A0
                            	  4525: 
01:002020C2 610002DC        	  4526: READBUF  BSR     INCHNE         GO GET SOME DATA  (NO ECHO)
01:002020C6 4A00            	  4527:          TST.B   D0             CHECK FOR NULLS
01:002020C8 67F8            	  4528:          BEQ.S   READBUF
01:002020CA 3800            	  4529:          MOVE.W  D0,D4          SAVE FOR A WHILE
01:002020CC 6100FF6E        	  4530:          BSR     OUTCH1         ECHO WHAT IS IN D0
01:002020D0 3004            	  4531:          MOVE.W  D4,D0          RESTORE IT
01:002020D2 0C00000A        	  4532:          CMPI.B  #LF,D0         SEE IF LINE FEED
01:002020D6 67EA            	  4533:          BEQ.S   READBUF        DONT PUT IT IN BUFFER
                            	  4534: 
01:002020D8 0C000018        	  4535:          CMPI.B  #CTLX,D0       SEE IF CTRL-X "CANCEL LINE"
01:002020DC 6610            	  4536:          BNE.S   CHKCTLH        No... Then go check for backspace
01:002020DE 700D            	  4537:          MOVEQ   #CR,D0         Yes.. 1) Send a carriage return
01:002020E0 6100FF5A        	  4538:          BSR     OUTCH1         *
01:002020E4 700A            	  4539:          MOVEQ   #LF,D0         *     2) Send a line feed
01:002020E6 6100FF54        	  4540:          BSR     OUTCH1         *
01:002020EA 2C4D            	  4541:          MOVE.L  A5,A6          *     3) Set BUFFER at start again
01:002020EC 60D4            	  4542:          BRA.S   READBUF        *     4) Restart this routine
                            	  4543: 
01:002020EE 0C000008        	  4544: CHKCTLH  CMPI.B  #CTLH,D0       CTRL-H? (Backspace)
01:002020F2 6714            	  4545:          BEQ.S   BS4CTLH        Yes...  Go backspace 1 character
01:002020F4 0C00007F        	  4546:          CMPI.B  #DEL,D0        DEL?    (Also a Backspace)
01:002020F8 6624            	  4547:          BNE.S   CHKCTLD        No....  Then go check for CTRL D
01:002020FA BDCD            	  4548: BKSPACE  CMP.L   A5,A6          Yes...  Usually need an extra "Backspace"
01:002020FC 67C4            	  4549:          BEQ     READBUF        If at start of buffer, don't back up any more.
01:002020FE 103C0008        	  4550:          MOVE.B  #CTLH,D0       Backspace cursor.
01:00202102 6100FF38        	  4551:          BSR     OUTCH1         *
01:00202106 6004            	  4552:          BRA.S   BLANKIT        Bypass check for start of buffer
                            	  4553: 
                            	  4554: BS4CTLH  DS      0              CTL-H already backed up 1 character.
01:00202108 BDCD            	  4555:          CMP.L   A5,A6          At beginning of buffer?
01:0020210A 67B6            	  4556:          BEQ     READBUF        Yes...  Then don't back up any more.
01:0020210C 7020            	  4557: BLANKIT  MOVEQ   #$20,D0        Now blank out previous character.
01:0020210E 6100FF2C        	  4558:          BSR     OUTCH1         *
01:00202112 1026            	  4559:          MOVE.B  -(A6),D0       Remove last character from buffer.
01:00202114 103C0008        	  4560:          MOVE.B  #CTLH,D0       Backup cursor again.
01:00202118 6100FF22        	  4561:          BSR     OUTCH1         *
01:0020211C 60A4            	  4562:          BRA     READBUF        Go get next character.
                            	  4563: 
01:0020211E 0C000004        	  4564: CHKCTLD  CMPI.B  #CTLD,D0       CTL D?  (REPRINT)
01:00202122 6626            	  4565:          BNE.S   CHKCR          No....  Then go check if a "CR".
01:00202124 700D            	  4566:          MOVEQ   #CR,D0         Yes...  Print "CR"
01:00202126 6100FF14        	  4567:          BSR     OUTCH1         *
01:0020212A 700A            	  4568:          MOVEQ   #LF,D0         Print "LF"
01:0020212C 6100FF0E        	  4569:          BSR     OUTCH1         *
01:00202130 2F0D            	  4570:          MOVE.L  A5,-(A7)       SAVE ON STACK FOR A MOMENT
01:00202132 6100FED0        	  4571:          BSR     OUTPUT         GO PRINT BUFFER
01:00202136 2A5F            	  4572:          MOVE.L  (A7)+,A5       GET BACK FROM STACK
01:00202138 6088            	  4573:          BRA     READBUF
                            	  4574: 
01:0020213A 1CC0            	  4575: CHARSAVE MOVE.B  D0,(A6)+       SAVE DATA INTO BUFFER
01:0020213C 220E            	  4576:          MOVE.L  A6,D1          CALCULATE ROOM USED
01:0020213E 928D            	  4577:          SUB.L   A5,D1          DONT USE MORE THAN "BUFFSIZE"
01:00202140 0C410080        	  4578:          CMPI.W  #BUFFSIZE,D1
01:00202144 6B00FF7C        	  4579:          BMI     READBUF        We're OK, go get next character.
01:00202148 60B0            	  4580:          BRA     BKSPACE        If not, handle as though a "CNTL-H"
                            	  4581: 
01:0020214A 0C00000D        	  4582: CHKCR    CMPI.B  #CR,D0         CR?  (End of command line).
01:0020214E 66EA            	  4583:          BNE.S   CHARSAVE       No.. Then go store this character.
                            	  4584: 
01:00202150 4A07            	  4585:          TST.B   D7             Check "Auto Line Feed" switch
01:00202152 6606            	  4586:          BNE.S   NOAUTOLF       Yes.. Bypass sending Line feed.
01:00202154 700A            	  4587:          MOVEQ   #LF,D0         No... Set one up and...
01:00202156 6100FEE4        	  4588:          BSR     OUTCH1         .     Send it!
                            	  4589: NOAUTOLF DS      0
                            	  4590: 
01:0020215A 4CDF079F        	  4591:  MOVEM.L (A7)+,D0-D4/D7/A0-A2 Restore Regs.
01:0020215E 4E75            	  4592:          RTS                    RETURN TO CALLER
                            	  4593: 
                            	  4594: 
                            	  4595: 
                            	  4596: 
                            	  4597: 
                            	  4598: *-------------------------------------------------------------------------
                            	  4599: * File Y         TUTOR     I/O Routine                            05/19/82
                            	  4600: 
                            	  4601: 
                            	  4602: *        PRINTER DRIVER
                            	  4603: *
                            	  4604: *    SEND BUFFER TO PRINTER
                            	  4605: *
                            	  4606: PRCRLF   DS      0
                            	  4607: 
01:00202160 48E70006        	  4608:          MOVEM.L A5-A6,-(A7)    SAVE REGISTERS
                            	  4609: *
                            	  4610: *   SEND LINE
                            	  4611: *
01:00202164 BBCE            	  4612: LIST     CMP.L   A6,A5          SEE IF AT END OF BUFFER
01:00202166 6B06            	  4613:          BMI.S   LIST1
01:00202168 4CDF6000        	  4614:          MOVEM.L (A7)+,A5-A6    RESTORE REGISTERS
01:0020216C 4E75            	  4615:          RTS
                            	  4616: *
01:0020216E 101D            	  4617: LIST1    MOVE.B  (A5)+,D0       GRAB BYTE
01:00202170 6102            	  4618:          BSR.S   CHRPRINT       PRINT CHAR
01:00202172 60F0            	  4619:          BRA     LIST
                            	  4620: 
                            	  4621: * OUTPUT CHAR IN D0 TO PRINTER
01:00202174 48E7C186        	  4622: CHRPRINT MOVEM.L D0/D1/D7/A0/A5/A6,-(A7) SAVE SOME REGISTERS
01:00202178 610000D2        	  4623: LIST2    BSR     CHKBRK         CHECK FOR BREAK
                            	  4624: 
01:0020217C 2078064E        	  4625:          MOVE.L  PDIPORT,A0     A0 = ADDRESS OF PORT
                            	  4626: 
01:00202180 102F0003        	  4627:          MOVE.B  3(A7),D0       D0 = CHAR TO BE SENT
                            	  4628: * CHANGE CONTROL CHARS TO "."
01:00202184 0200007F        	  4629:          ANDI.B  #$7F,D0
01:00202188 0C00000D        	  4630:          CMPI.B  #CR,D0
01:0020218C 6716            	  4631:          BEQ.S   LIST25         OK CARRIAGE RETURN
01:0020218E 0C00000A        	  4632:          CMPI.B  #LF,D0
01:00202192 6710            	  4633:          BEQ.S   LIST25         OK LINE FEED
01:00202194 0C000020        	  4634:          CMPI.B  #$20,D0
01:00202198 6D06            	  4635:          BLT.S   LIST24
01:0020219A 0C00007F        	  4636:          CMPI.B  #$7F,D0
01:0020219E 6D04            	  4637:          BLT.S   LIST25
01:002021A0 103C002E        	  4638: LIST24   MOVE.B  #'.',D0        MAKE CHAR A PERIOD
                            	  4639: LIST25   DS      0
                            	  4640: 
01:002021A4 11400001        	  4641:          MOVE.B  D0,PDATA(A0)   SEND DATA
01:002021A8 13FC0068000F000D	  4642:          MOVE.B  #$68,PDI1+13   STROBE PRINTER
                            	  4643: 
01:002021B0 13FC0060000F000D	  4644:          MOVE.B  #$60,PDI1+13
                            	  4645: 
                            	  4646: *
                            	  4647: *
01:002021B8 61000092        	  4648: LIST3    BSR     CHKBRK         CHECK FOR BREAK
01:002021BC 10280003        	  4649:          MOVE.B  PBDATA(A0),D0
01:002021C0 02000003        	  4650:          ANDI.B  #3,D0          PAPER OUT? DESELECTED?
01:002021C4 5300            	  4651:          SUBQ.B  #1,D0
01:002021C6 6728            	  4652:          BEQ.S   LIST5
01:002021C8 3E380652        	  4653:          MOVE.W  CRTPNT,D7
01:002021CC 42780652        	  4654:          CLR.W   CRTPNT
01:002021D0 4BFA002C        	  4655:          LEA     MSG007(PC),A5
01:002021D4 6100E314        	  4656:          BSR     FIXDATA
01:002021D8 6100FE2A        	  4657:          BSR     OUTPUT
                            	  4658: *
                            	  4659: *   WAIT FOR BREAK OR PRINTER TO BE READY
                            	  4660: *
01:002021DC 616E            	  4661: LERR1    BSR.S   CHKBRK
01:002021DE 10280003        	  4662:          MOVE.B  PBDATA(A0),D0
01:002021E2 02000003        	  4663:          ANDI.B  #3,D0
01:002021E6 5300            	  4664:          SUBQ.B  #1,D0
01:002021E8 66F2            	  4665:          BNE     LERR1          PRINTER NOT READY
01:002021EA 31C70652        	  4666:          MOVE.W  D7,CRTPNT      RESTORE POSSIBLE "PA" SWITCH
01:002021EE 6088            	  4667:          BRA     LIST2          TRY AGAIN
                            	  4668: 
01:002021F0 08280000000B    	  4669: LIST5    BTST.B  #0,PSTATUS(A0) ACKNOWLEDGE?
01:002021F6 67C0            	  4670:          BEQ.S   LIST3
                            	  4671: 
01:002021F8 4CDF6183        	  4672:          MOVEM.L (A7)+,D0/D1/D7/A0/A5/A6  RESTORE REGISTERS
01:002021FC 4E75            	  4673:          RTS
                            	  4674: 
01:002021FE 0D              	  4675: MSG007   DC.B    CR,LF,'PRINTER NOT READY',CR,LF,EOT
01:002021FF 0A
01:00202200 5052494E54455220
01:00202208 4E4F542052454144
01:00202210 59
01:00202211 0D
01:00202212 0A
01:00202213 04
                            	  4676: 
                            	  4677: 
                            	  4678: 
                            	  4679: 
                            	  4680: 
                            	  4681:          DS.B    0
                            	  4682: 
                            	  4683: *
                            	  4684: *       SEND CHARACTER IN D0.B TO SERIAL PORT IN (A0) (NO NULL PADS)
                            	  4685: *
01:00202214 6136            	  4686: OUTCH    BSR.S   CHKBRK         CHECK FOR BREAK
01:00202216 1210            	  4687:          MOVE.B  (A0),D1        READ STATUS AGAIN
01:00202218 02010002        	  4688:          ANDI.B  #$2,D1         CHECK FOR READY TO SEND
01:0020221C 67F6            	  4689:          BEQ.S   OUTCH          STILL NOT READY
01:0020221E 11400001        	  4690:          MOVE.B  D0,1(A0)       SEND CHARACTER  ****************
                            	  4691: 
                            	  4692: * IF PRINT FLAG SET GOTO PRINTER
01:00202222 670A            	  4693:          BEQ.S   OUTCH21        NULL; IGNORE SENDING TO PRINTER
01:00202224 4A780652        	  4694:          TST.W   CRTPNT
01:00202228 6704            	  4695:          BEQ.S   OUTCH21        CRT ONLY
01:0020222A 6100FF48        	  4696:          BSR     CHRPRINT       GOTO PRINTER
                            	  4697: OUTCH21  DS      0
                            	  4698: 
                            	  4699: *   CHECK FOR CONTROL W
01:0020222E 1210            	  4700:          MOVE.B  (A0),D1        READ STATUS
01:00202230 02010001        	  4701:          ANDI.B  #1,D1
01:00202234 6714            	  4702:          BEQ.S   CTLW9          CHAR NOT READY
01:00202236 12280001        	  4703:          MOVE.B  1(A0),D1       READ CHARACTER
01:0020223A 0C010017        	  4704:          CMPI.B  #CTLW,D1
01:0020223E 660A            	  4705:          BNE.S   CTLW9          NOT CNTL/W
01:00202240 610A            	  4706: CTLWH    BSR.S   CHKBRK         CHECK FOR BREAK
01:00202242 1210            	  4707:          MOVE.B  (A0),D1        READ STATUS
01:00202244 02010001        	  4708:          ANDI.B  #1,D1
01:00202248 67F6            	  4709:          BEQ     CTLWH          WAIT FOR ANY CHAR TO CONTINUE
01:0020224A 4E75            	  4710: CTLW9    RTS
                            	  4711: *
                            	  4712: *   CHECK FOR BREAK ON PORT #1
                            	  4713: *
01:0020224C 2F08            	  4714: CHKBRK   MOVE.L  A0,-(A7)       SAVE A0 * * *
01:0020224E 6100FE1C        	  4715:          BSR     GETSER1        RETURNS ADDRESS IN A0
01:00202252 1210            	  4716:          MOVE.B  (A0),D1        READ STATUS
01:00202254 02010010        	  4717:          ANDI.B  #$10,D1
01:00202258 661E            	  4718:          BNE.S   BREAK
01:0020225A 205F            	  4719:          MOVE.L  (A7)+,A0       RESTORE A0 * * *
01:0020225C 4E75            	  4720:          RTS
                            	  4721: 
                            	  4722: *    WHAT TO DO WHEN THE BREAK IS PRESSED
                            	  4723: *
                            	  4724: 
01:0020225E 42280001        	  4725: BREAK2   CLR.B   1(A0)          SEND NULL TO ACIA TO RESET
01:00202262 08100001        	  4726: BREAK1   BTST.B  #1,(A0)        CHECK IF "TRANSMIT READY"
01:00202266 67FA            	  4727:          BEQ.S   BREAK1         WAIT FOR READY
                            	  4728: 
01:00202268 10280001        	  4729:          MOVE.B  1(A0),D0       READ TWO CHARS
01:0020226C 10280001        	  4730:          MOVE.B  1(A0),D0       *
                            	  4731: 
01:00202270 08100004        	  4732:          BTST.B  #4,(A0)        SEE IF BREAK BUTTON RELEASED
01:00202274 66E8            	  4733:          BNE     BREAK2         NO... KEEP LOOPING
01:00202276 4E75            	  4734:          RTS
                            	  4735: 
01:00202278 61E4            	  4736: BREAK    BSR     BREAK2
01:0020227A 4BFA000E        	  4737:          LEA     MSG013(PC),A5  MSG:  "BREAK"
                            	  4738: 
01:0020227E 6100E27E        	  4739: BREAK79  BSR     FIXDCRLF       *
01:00202282 6100FD80        	  4740:          BSR     OUTPUT         PRINT MESSAGE
01:00202286 6000E3A6        	  4741:          BRA     MACSBUG        AND REENTER MACSBUG
                            	  4742: 
01:0020228A 0A              	  4743: MSG013   DC.B    LF,LF,'BREAK',CR,LF,LF,EOT
01:0020228B 0A
01:0020228C 425245414B
01:00202291 0D
01:00202292 0A
01:00202293 0A
01:00202294 04
                            	  4744: 
                            	  4745: 
                            	  4746: 
01:00202295 00              	  4747:          DC.B    0              PAD BYTE
                            	  4748: 
                            	  4749: ***  OUTPUT BUFFER TO TAPE  ***
01:00202296 48E7F8C0        	  4750: TAPEOUT  MOVEM.L D0-D4/A0-A1,-(A7)  SAVE REGISTERS
01:0020229A 204D            	  4751:          MOVE.L  A5,A0          REMEMBER WHERE BUFFER STARTS
01:0020229C 227C000F0000    	  4752:          MOVEA.L #PDI1,A1
01:002022A2 42290021        	  4753:          CLR.B   $21(A1)
01:002022A6 0C505330        	  4754:          CMPI.W  #'S0',(A0)     HEADER RECORD?
01:002022AA 6612            	  4755:          BNE.S   TAPEOUT2       NO
01:002022AC 137C00020009    	  4756:          MOVE.B  #2,9(A1)       YES, PC0 INPUT, PC1 OUTPUT
01:002022B2 363C02BC        	  4757:          MOVE.W  #700,D3        OUTPUT NULLS (HEADER)
01:002022B6 4200            	  4758: TAPEOUT1 CLR.B   D0
01:002022B8 6120            	  4759:          BSR.S   TAPEO
01:002022BA 5343            	  4760:          SUBQ.W  #1,D3
01:002022BC 66F8            	  4761:          BNE.S   TAPEOUT1
01:002022BE BBCE            	  4762: TAPEOUT2 CMP.L   A6,A5          SEE IF AT OR BEYOND END OF LINE
01:002022C0 6512            	  4763:          BCS.S   TAPEOUT4       NO. KEEP GOING.
01:002022C2 16380654        	  4764:          MOVE.B  TAPENULS,D3    OUTPUT NULLS AFTER EACH RECORD
01:002022C6 4200            	  4765: TAPEOUT5 CLR.B   D0             YES. OUTPUT A NULL
01:002022C8 6110            	  4766:          BSR.S   TAPEO
01:002022CA 5303            	  4767:          SUBQ.B  #1,D3
01:002022CC 66F8            	  4768:          BNE.S   TAPEOUT5
01:002022CE 4CDF031F        	  4769:          MOVEM.L (A7)+,D0-D4/A0-A1  RESTORE REGISTERS
01:002022D2 4E75            	  4770:          RTS
01:002022D4 101D            	  4771: TAPEOUT4 MOVE.B  (A5)+,D0       GRAB BYTE TO OUTPUT
01:002022D6 6102            	  4772:          BSR.S   TAPEO          GO OUTPUT IT
01:002022D8 60E4            	  4773:          BRA.S   TAPEOUT2       GO DO ANOTHER
                            	  4774: *
                            	  4775: * OUTPUTS THE CHARACTER IN D0.B TO TAPE
                            	  4776: * A LOGIC `0' IS RECORDED AS ONE SQUARE WAVE PERIOD OF
                            	  4777: *        1 MILLISEC DURATION, 50% DUTY CYCLE
                            	  4778: * A LOGIC `1' IS RECORDED AS ONE SQUARE WAVE PERIOD OF
                            	  4779: *        500 MICROSEC DURATION, 50% DUTY CYCLE
                            	  4780: *
01:002022DA 003C0010        	  4781: TAPEO    ORI.B   #%10000,CCR    SET X BIT IN SR
01:002022DE E310            	  4782:          ROXL.B  #1,D0          DATA BIT INTO X
01:002022E0 E312            	  4783: TAPEO1   ROXL.B  #1,D2          DATA BIT INTO D2
01:002022E2 613E            	  4784:          BSR.S   TIMERTST       WAIT UNTIL LAST PULSE DONE
01:002022E4 08A900000021    	  4785:          BCLR.B  #0,$21(A1)     HALT TIMER
01:002022EA 721E            	  4786:          MOVEQ   #30,D1         TIMER COUNT FOR A `1'
01:002022EC 08020000        	  4787:          BTST.L  #0,D2          SENDING A `1'?
01:002022F0 6606            	  4788:          BNE.S   TAPEO2         YES.
01:002022F2 068100000020    	  4789:          ADDI.L  #32,D1         NO. TIMER COUNT FOR 0
01:002022F8 03C90025        	  4790: TAPEO2   MOVEP.L D1,$25(A1)     SET TIMER PRELOAD REGISTER
01:002022FC 08E900010019    	  4791:          BSET.B  #1,$19(A1)     SEND 1 TO TAPE
01:00202302 08E900000021    	  4792:          BSET.B  #0,$21(A1)     START TIMER
01:00202308 6118            	  4793:          BSR.S   TIMERTST       WAIT UNTIL PULSE DONE
01:0020230A 08A900000021    	  4794:          BCLR.B  #0,$21(A1)     HALT TIMER
01:00202310 08A900010019    	  4795:          BCLR.B  #1,$19(A1)     SEND 0 TO TAPE
01:00202316 08E900000021    	  4796:          BSET.B  #0,$21(A1)     START TIMER
01:0020231C D000            	  4797:          ASL.B   #1,D0          SENT 8 BITS?
01:0020231E 66C0            	  4798:          BNE     TAPEO1         NO. CONTINUE
01:00202320 4E75            	  4799:          RTS
                            	  4800: *
                            	  4801: * WAITS UNTIL PROGRAMMED TIME DELAY HAS ELAPSED
                            	  4802: * (IF TIMER IS RUNNING)
                            	  4803: * ALSO CHECKS FOR BREAK
                            	  4804: * USES D1
                            	  4805: *
01:00202322 6100FF28        	  4806: TIMERTST BSR     CHKBRK         CHECK FOR BREAK
01:00202326 082900000021    	  4807:          BTST.B  #0,$21(A1)     IS TIMER RUNNING?
01:0020232C 6708            	  4808:          BEQ.S   TIMERTS1       NO. RETURN
01:0020232E 082900000035    	  4809:          BTST.B  #0,$35(A1)     HAS TIME DELAY ELAPSED?
01:00202334 67EC            	  4810:          BEQ.S   TIMERTST       NO. WAIT
01:00202336 4E75            	  4811: TIMERTS1 RTS
                            	  4812: 
                            	  4813: *   IF FAULT THEN INITIALIZE AN ACIA
                            	  4814: *
01:00202338 48E78080        	  4815: FAULTSER MOVEM.L D0/A0,-(A7)  FREE UP SOME WORKING REGISTERS
                            	  4816: 
                            	  4817: * DELAY TO ALLOW ACIA TO FINISH TRANSMITTING
                            	  4818: *  LONGEST TIME FOR TWO CHARACTERS; 110 BAUD, 16MHZ NO WAIT STATES
01:0020233C 203C0000C350    	  4819:          MOVE.L  #50000,D0      DELAY A WHILE
01:00202342 5380            	  4820: FAULTAC4 SUBQ.L  #1,D0          LOOP AROUND
01:00202344 66FC            	  4821:          BNE     FAULTAC4
                            	  4822: 
01:00202346 6100FD24        	  4823:          BSR     GETSER1        MOVE ADDRESS INTO A0
01:0020234A 1010            	  4824:          MOVE.B  (A0),D0        READ STATUS
01:0020234C 02000070        	  4825:          ANDI.B  #$70,D0        SEE IF FAULT
01:00202350 6708            	  4826:          BEQ.S   FAULTAC2
01:00202352 10BC0003        	  4827:          MOVE.B  #RESET,(A0)    MASTER RESET
01:00202356 10B8064C        	  4828:          MOVE.B  MD1CON,(A0)    HOW TO PROGRAM IT
                            	  4829: 
01:0020235A 6100FD22        	  4830: FAULTAC2 BSR     GETSER2        MOVE ADDRESS INTO A0
01:0020235E 1010            	  4831:          MOVE.B  (A0),D0
01:00202360 02000070        	  4832:          ANDI.B  #$70,D0
01:00202364 6708            	  4833:          BEQ.S   FAULTAC3
01:00202366 10BC0003        	  4834:          MOVE.B  #RESET,(A0)    MASTER RESET
01:0020236A 10B8064D        	  4835:          MOVE.B  MD1CON+1,(A0)  HOW TO PROGRAM IT
                            	  4836: FAULTAC3
01:0020236E 4CDF0101        	  4837:          MOVEM.L (A7)+,A0/D0    RESTORE REGISTERS
01:00202372 4E75            	  4838:          RTS
                            	  4839: 
                            	  4840: *   INITIALIZE BOTH ACIAs
                            	  4841: *
01:00202374 48E78080        	  4842: INITSER  MOVEM.L D0/A0,-(A7)  FREE UP SOME WORKING REGISTERS
                            	  4843: 
                            	  4844: * DELAY TO ALLOW ACIA TO FINISH TRANSMITTING
                            	  4845: *  LONGEST TIME FOR TWO CHARACTERS; 110 BAUD, 16MHZ NO WAIT STATES
01:00202378 203C0000C350    	  4846:          MOVE.L  #50000,D0      DELAY A WHILE
01:0020237E 5380            	  4847: INITAC3  SUBQ.L  #1,D0          LOOP AROUND
01:00202380 66FC            	  4848:          BNE     INITAC3
                            	  4849: 
01:00202382 6100FCE8        	  4850:          BSR     GETSER1        MOVE ADDRESS INTO A0
01:00202386 10BC0003        	  4851:          MOVE.B  #RESET,(A0)    MASTER RESET
01:0020238A 10B8064C        	  4852:          MOVE.B  MD1CON,(A0)    HOW TO PROGRAM IT
01:0020238E 6100FCEE        	  4853:          BSR     GETSER2        MOVE ADDRESS INTO A0
01:00202392 10BC0003        	  4854:          MOVE.B  #RESET,(A0)    MASTER RESET
01:00202396 10B8064D        	  4855:          MOVE.B  MD1CON+1,(A0)  HOW TO PROGRAM IT
01:0020239A 4CDF0101        	  4856:          MOVEM.L (A7)+,A0/D0    RESTORE REGISTERS
01:0020239E 4E75            	  4857:          RTS
                            	  4858: 
                            	  4859: *    INPUT CHARACTER FROM PORT1
                            	  4860: *    ACIA ADDRESS IN (A0)
                            	  4861: *
                            	  4862: 
01:002023A0 1210            	  4863: INCHNE   MOVE.B  (A0),D1        (INCH NO ECHO) LOAD STATUS SIDE
01:002023A2 02010010        	  4864:          ANDI.B  #$10,D1        .              CHECK FOR BREAK
01:002023A6 6600FED0        	  4865:          BNE     BREAK          .              GO PROCESS IT
                            	  4866: 
01:002023AA 1210            	  4867:          MOVE.B  (A0),D1        LOAD STATUS SIDE
01:002023AC 02010001        	  4868:          ANDI.B  #1,D1          SEE IF READY
01:002023B0 67EE            	  4869:          BEQ.S   INCHNE         IF NOT READY
01:002023B2 10280001        	  4870:          MOVE.B  1(A0),D0       READ DATA SIDE   *****************
01:002023B6 0200007F        	  4871:          ANDI.B  #$7F,D0        DROP PARITY BIT
01:002023BA 4E75            	  4872:          RTS
                            	  4873: 
                            	  4874: *  INPUT A LINE FROM PORT2 (ACIA2)
                            	  4875: *   [ECHO TO PORT1 (ACIA1)]
                            	  4876: *                  XONOFF
                            	  4877: *                   0000     NULL  NULL    DO NOTHING
                            	  4878: *                   0817   BKSPACE CNTL/W
                            	  4879: *                   1214     X-ON  X-OFF   READER ON OFF
                            	  4880: *
01:002023BC 4AB80620        	  4881: PORTIN2  TST.L   INFROM         SEE IF ALTERNATE ADDRESS
01:002023C0 6706            	  4882:          BEQ.S   PORTIN2X
01:002023C2 2F380620        	  4883:          MOVE.L  INFROM,-(A7)
01:002023C6 4E75            	  4884:          RTS                    GO DO IT
01:002023C8 2F380634        	  4885: PORTIN2X MOVE.L  INPORT2,-(A7)  GO TO IO ROUTINE
01:002023CC 4E75            	  4886:          RTS                    ; (THIS NORMALLY GOES TO PORTIN20)
                            	  4887: *
01:002023CE 48E77090        	  4888: PORTIN20 MOVEM.L D1-D3/A0/A3,-(A7)  SAVE WORKING REGISTERS
                            	  4889: 
01:002023D2 6100FCAA        	  4890:          BSR     GETSER2
01:002023D6 2648            	  4891:          MOVE.L  A0,A3          A3 = ADDRESS OF PORT 2
01:002023D8 6100FC92        	  4892:          BSR     GETSER1        A0 = ADDRESS OF PORT 1
                            	  4893: 
01:002023DC 243C000320C8    	  4894:          MOVE.L  #LTIME,D2 D2 = 5 SEC DEADMAN @ 8MHZ
                            	  4895: 
01:002023E2 614A            	  4896: PORT2100 BSR.S   P2READY
01:002023E4 6704            	  4897:          BEQ.S   PORT2120       PORT2 DATA IN NOT-READY
                            	  4898: 
01:002023E6 615C            	  4899:          BSR.S   RES            READ/ECHO/STORE CHAR
01:002023E8 60F8            	  4900:          BRA     PORT2100
                            	  4901: 
01:002023EA 7601            	  4902: PORT2120 MOVEQ   #1,D3          D3 = MLS TIMER (ONE TICK)
01:002023EC 6140            	  4903: PORT2130 BSR.S   P2READY
01:002023EE 6622            	  4904:          BNE.S   PORT2250       PORT2 DATA IN READY
                            	  4905: 
01:002023F0 5382            	  4906:          SUBQ.L  #1,D2
01:002023F2 6B2A            	  4907:          BMI.S   PORT2300       SECOND TIME OUT
                            	  4908: 
01:002023F4 5383            	  4909:          SUBQ.L  #1,D3
01:002023F6 66F4            	  4910:          BNE     PORT2130       MLS TIMER
                            	  4911: 
01:002023F8 103804E6        	  4912: PORT2140 MOVE.B  XONOFF,D0
01:002023FC 670C            	  4913:          BEQ.S   PORT2150       NULL; IGNORE READER ON
01:002023FE 1213            	  4914:          MOVE.B  (A3),D1
01:00202400 02010002        	  4915:          ANDI.B  #2,D1
01:00202404 67E4            	  4916:          BEQ     PORT2120       PORT2 DATA OUT NOT-READY
01:00202406 17400002        	  4917:          MOVE.B  D0,2(A3)       SEND START READER CHAR
                            	  4918: PORT2150
                            	  4919: 
01:0020240A 263C0000A028    	  4920:          MOVE.L  #STIME,D3      D3 = 100 MLS @ 8MHZ
01:00202410 60DA            	  4921:          BRA     PORT2130
                            	  4922: 
01:00202412 611A            	  4923: PORT2250 BSR.S   P2READY
01:00202414 6702            	  4924:          BEQ.S   PORT2260       PORT2 DATA IN NOT-READY
01:00202416 612C            	  4925:          BSR.S   RES            READ/ECHO/STORE CHAR
                            	  4926: 
01:00202418 5383            	  4927: PORT2260 SUBQ.L  #1,D3
01:0020241A 6BDC            	  4928:          BMI     PORT2140       CHARACTER TIME OUT
01:0020241C 60F4            	  4929:          BRA     PORT2250
                            	  4930: 
01:0020241E 4BFA0006        	  4931: PORT2300 LEA     MSG030(PC),A5  TIMEOUT ERROR
01:00202422 6000FE5A        	  4932:          BRA     BREAK79
                            	  4933: 
01:00202426 54494D454F5554  	  4934: MSG030   DC.B    'TIMEOUT',EOT
01:0020242D 04
                            	  4935: 
                            	  4936: 
01:0020242E 1210            	  4937: P2READY  MOVE.B  (A0),D1        CHECK FOR ACTIVITY ON PORT1
01:00202430 02010010        	  4938:          ANDI.B  #$10,D1        CHECK FOR BREAK
01:00202434 6600FE42        	  4939:          BNE     BREAK
01:00202438 12280001        	  4940:          MOVE.B  1(A0),D1       READ POSSIBLE CHAR PORT 1; IGNORE
                            	  4941: 
01:0020243C 1213            	  4942:          MOVE.B  (A3),D1        READ STATUS OF PORT2
01:0020243E 02010001        	  4943:          ANDI.B  #1,D1          SEE IF CHARACTER SENT
01:00202442 4E75            	  4944:          RTS
                            	  4945: 
01:00202444 122B0002        	  4946: RES      MOVE.B  2(A3),D1       D1 = CHAR READ FROM PORT2
01:00202448 0201007F        	  4947:          ANDI.B  #$7F,D1        DROP PARITY BIT
                            	  4948: 
01:0020244C 4A7804E2        	  4949:          TST.W   ECHOPT1        SEE IF ECHO ON
01:00202450 6704            	  4950:          BEQ.S   RES140
01:00202452 11410001        	  4951:          MOVE.B  D1,1(A0)       SEND TO DATA SIDE (PORT1)
                            	  4952: RES140
                            	  4953: 
01:00202456 0C01000D        	  4954:          CMPI.B  #CR,D1
01:0020245A 671C            	  4955:          BEQ.S   RES190         END OF LINE
                            	  4956: 
01:0020245C 0C010020        	  4957:          CMPI.B  #$20,D1        IGNORE CONTROL CHARACTERS (NULLS)
01:00202460 6D14            	  4958:          BLT.S   RES150
01:00202462 1C81            	  4959:          MOVE.B  D1,(A6)        SAVE CHAR IN BUFFER
                            	  4960: 
01:00202464 263C00019064    	  4961:          MOVE.L  #LTIME/2,D3    D3 = 2 1/2 SEC @ 8MHZ (CHARATER  TIMER)
                            	  4962: 
01:0020246A 220E            	  4963:          MOVE.L  A6,D1          CHECK BUFFER FULL
01:0020246C 928D            	  4964:          SUB.L   A5,D1
01:0020246E 0C410050        	  4965:          CMPI.W  #BUFSIZE,D1
01:00202472 6A02            	  4966:          BPL.S   RES150         FULL
01:00202474 528E            	  4967:          ADDQ.L  #1,A6          INCREMENT STORE POINTER
01:00202476 4E75            	  4968: RES150   RTS
                            	  4969: 
                            	  4970: 
01:00202478 BDCD            	  4971: RES190   CMP.L   A5,A6
01:0020247A 67FA            	  4972:          BEQ     RES150         NULL RECORD; IGNORE
                            	  4973: 
01:0020247C 588F            	  4974:          ADDQ.L  #4,A7          TRIM STACK
                            	  4975: 
01:0020247E 103804E7        	  4976:          MOVE.B  XONOFF+1,D0
01:00202482 670C            	  4977:          BEQ.S   RES195         XOFF = NULL CHAR; IGNORE
01:00202484 1213            	  4978: RES194   MOVE.B  (A3),D1
01:00202486 02010002        	  4979:          ANDI.B  #2,D1
01:0020248A 67F8            	  4980:          BEQ     RES194         PORT2 DATA OUT NOT-READY
01:0020248C 17400002        	  4981:          MOVE.B  D0,2(A3)       STOP READER
                            	  4982: RES195
                            	  4983: 
01:00202490 4CDF090E        	  4984:          MOVEM.L (A7)+,D1-D3/A0/A3   RESTORE THE REGISTERS
01:00202494 4E75            	  4985:          RTS
                            	  4986: 
                            	  4987: *
                            	  4988: * INPUT A LINE FROM AUDIO TAPE (PI/T)
                            	  4989: * [ECHO TO PORT1 (ACIA1)]
                            	  4990: *
01:00202496 48E778F0        	  4991: TAPEIN   MOVEM.L D1-D4/A0-A3,-(A7)  SAVE WORKING REGISTERS
01:0020249A 6100FBD0        	  4992:          BSR     GETSER1        ACIA1 ADDRESS INTO A0
01:0020249E 227C000F0000    	  4993:          MOVEA.L #PDI1,A1
01:002024A4 13FC0002000F0009	  4994:          MOVE.B  #2,PITCDDR     PC0 INPUT, PC1 OUTPUT.
                            	  4995: 
                            	  4996: * SYNCHRONIZE ON S CHARACTER
01:002024AC 4201            	  4997:          CLR.B   D1
01:002024AE 613C            	  4998: TAPEIN10 BSR.S   TAPEIN40       GET TAPE
01:002024B0 65FC            	  4999:          BCS.S   TAPEIN10       WAIT FOR LOW
01:002024B2 6138            	  5000: TAPEIN11 BSR.S   TAPEIN40       GET TAPE
01:002024B4 64FC            	  5001:          BCC.S   TAPEIN11       WAIT FOR HIGH
01:002024B6 6154            	  5002:          BSR.S   STARTIMR       START TIMER
01:002024B8 D201            	  5003: TAPEIN12 ASL.B   #1,D1
01:002024BA 6110            	  5004:          BSR.S   TAPEIN30       GET ONE BIT FROM TAPE
01:002024BC 0C010053        	  5005:          CMPI.B  #'S',D1        S?
01:002024C0 66F6            	  5006:          BNE.S   TAPEIN12       NO. GET NEXT BIT
01:002024C2 6072            	  5007:          BRA.S   TAPEIN51
                            	  5008: 
                            	  5009: * GET ONE CHARACTER FROM THE TAPE
01:002024C4 7202            	  5010: TAPEIN20 MOVEQ   #2,D1          SET STOP BIT
01:002024C6 6104            	  5011: TAPEIN21 BSR.S   TAPEIN30       GET 1 BIT FROM TAPE
01:002024C8 D201            	  5012:          ASL.B   #1,D1          STOP IN CARRY
01:002024CA 64FA            	  5013:          BCC.S   TAPEIN21       NO
                            	  5014: *FALL INTO LOAD BIT ROUTINE FOR LAST BIT
01:002024CC 611E            	  5015: TAPEIN30 BSR.S   TAPEIN40       GET TAPE
01:002024CE 65FC            	  5016:          BCS.S   TAPEIN30       WAIT FOR LOW
01:002024D0 611A            	  5017: TAPEIN31 BSR.S   TAPEIN40       GET TAPE
01:002024D2 64FC            	  5018:          BCC.S   TAPEIN31       WAIT FOR HIGH
01:002024D4 4239000F0021    	  5019:          CLR.B   PITTCR         STOP TIMER
01:002024DA 0749002D        	  5020:          MOVEP.L $2D(A1),D3     GET PERIOD MEASUREMENT
01:002024DE 612C            	  5021:          BSR.S   STARTIMR       START TIMER
01:002024E0 048300FFFFA1    	  5022:          SUBI.L  #$FFFFFF-94,D3 IS IT A LOGIC 1?
01:002024E6 6502            	  5023:          BLO.S   TAPEIN32       NO
01:002024E8 5201            	  5024:          ADDQ.B  #1,D1          YES. STORE LOGIC 1
01:002024EA 4E75            	  5025: TAPEIN32 RTS
                            	  5026: 
                            	  5027: * READ THE TAPE LEVEL INTO THE CARRY AND CHECK FOR BREAK
01:002024EC 1410            	  5028: TAPEIN40 MOVE.B  (A0),D2        CHECK FOR ACTIVITY ON PORT1
01:002024EE 02020010        	  5029:          ANDI.B  #$10,D2        CHECK FOR BREAK
01:002024F2 6600FD84        	  5030:          BNE     BREAK
01:002024F6 1410            	  5031:          MOVE.B  (A0),D2        SEE IF CHARACTER SENT
01:002024F8 02020001        	  5032:          ANDI.B  #1,D2
01:002024FC 6704            	  5033:          BEQ.S   TAPEIN41       NONE SENT.
01:002024FE 14280001        	  5034:          MOVE.B  1(A0),D2       READ WHAT WAS SENT
01:00202502 1439000F0019    	  5035: TAPEIN41 MOVE.B  PITPCDR,D2     READ PI/T
01:00202508 E202            	  5036:          ASR.B   #1,D2          DATA INTO CARRY
01:0020250A 4E75            	  5037:          RTS
                            	  5038: 
                            	  5039: *STARTS PROGRAMMABLE TIMER
01:0020250C 283C00FFFFFF    	  5040: STARTIMR MOVE.L  #$00FFFFFF,D4  INIT. COUNT. PRELOAD REG.
01:00202512 09C90025        	  5041:          MOVEP.L D4,$25(A1)
01:00202516 13FC0001000F0021	  5042:          MOVE.B  #1,PITTCR      START TIMER
                            	  5043: 
01:0020251E 4E75            	  5044:          RTS
                            	  5045: 
01:00202520 0C010020        	  5046: TAPEIN53 CMPI.B  #$20,D1
01:00202524 6D0E            	  5047:          BLT.S   TAPEIN50       IGNORE CONTROL CHARACTERS
01:00202526 1C81            	  5048:          MOVE.B  D1,(A6)        SAVE CHARACTER IN BUFFER
01:00202528 220E            	  5049:          MOVE.L  A6,D1          CHECK BUFFER FULL
01:0020252A 928D            	  5050:          SUB.L   A5,D1
01:0020252C 0C410050        	  5051:          CMPI.W  #BUFSIZE,D1
01:00202530 6A02            	  5052:          BPL.S   TAPEIN50       FULL
01:00202532 528E            	  5053:          ADDQ.L  #1,A6          INCREMENT BUFFER POINTER
                            	  5054: 
01:00202534 618E            	  5055: TAPEIN50 BSR     TAPEIN20       GET ONE CHARACTER FROM TAPE
01:00202536 0201007F        	  5056: TAPEIN51 ANDI.B  #$7F,D1        DROP PARITY BIT
01:0020253A 4A7804E2        	  5057:          TST.W   ECHOPT1        SEE IF ECHO ON
01:0020253E 6704            	  5058:          BEQ.S   TAPEIN52
01:00202540 11410001        	  5059:          MOVE.B  D1,1(A0)       SEND TO PORT1
01:00202544 0C01000A        	  5060: TAPEIN52 CMPI.B  #LF,D1         END OF LINE?
01:00202548 66D6            	  5061:          BNE.S   TAPEIN53       NO.
01:0020254A 4CDF0F1E        	  5062:          MOVEM.L (A7)+,D1-D4/A0-A3  RESTORE REGISTERS
01:0020254E 4E75            	  5063:          RTS
                            	  5064: 
                            	  5065: *     SCAN COMMAND LINE FOR PORT NUMBER
                            	  5066: *     DU LO VE MD
                            	  5067: *
01:00202550 42B80620        	  5068: SCANPORT CLR.L   INFROM         DEFAULT IS WHATEVER IS CALLED
01:00202554 42B8061C        	  5069:          CLR.L   OUTTO
01:00202558 1015            	  5070:          MOVE.B  (A5),D0        NO....GET CHARACTER
01:0020255A 0C000020        	  5071:          CMPI.B  #BLANK,D0      .     IS IT A BLANK?
01:0020255E 6750            	  5072:          BEQ.S   SCANP6         .     YES..EXIT
                            	  5073: 
01:00202560 0C000031        	  5074:          CMPI.B  #'1',D0        SEE IF PORT 1 OVERRIDE
01:00202564 660E            	  5075:          BNE.S   SCANP4
01:00202566 21F8062C0620    	  5076:          MOVE.L  INPORT1,INFROM
01:0020256C 21F80630061C    	  5077:          MOVE.L  OUTPORT1,OUTTO
01:00202572 603A            	  5078:          BRA.S   SCANP7
                            	  5079: 
01:00202574 0C000032        	  5080: SCANP4   CMPI.B  #'2',D0        SEE IF PORT 2 OVERRIDE
01:00202578 660E            	  5081:          BNE.S   SCANP5
01:0020257A 21F806340620    	  5082:          MOVE.L  INPORT2,INFROM
01:00202580 21F80638061C    	  5083:          MOVE.L  OUTPORT2,OUTTO
01:00202586 6026            	  5084:          BRA.S   SCANP7
                            	  5085: 
01:00202588 0C000033        	  5086: SCANP5   CMPI.B  #'3',D0        SEE IF PORT3 OVERRIDE
01:0020258C 660E            	  5087:          BNE.S   SCANP8
01:0020258E 21F8063C0620    	  5088:          MOVE.L  INPORT3,INFROM
01:00202594 21F80640061C    	  5089:          MOVE.L  OUTPORT3,OUTTO
01:0020259A 6012            	  5090:          BRA.S   SCANP7
                            	  5091: 
01:0020259C 0C000034        	  5092: SCANP8   CMPI.B  #'4',D0        SEE IF PORT4 OVERRIDE
01:002025A0 660E            	  5093:          BNE.S   SCANP6
01:002025A2 21F806440620    	  5094:          MOVE.L  INPORT4,INFROM
01:002025A8 21F80648061C    	  5095:          MOVE.L  OUTPORT4,OUTTO
                            	  5096: 
01:002025AE 528D            	  5097: SCANP7   ADDQ.L  #1,A5          ADJUST GET CHAR POINTER
01:002025B0 4E75            	  5098: SCANP6   RTS
                            	  5099: 
                            	  5100: *       *  P A  *      "PRINTER ATTACH" COMMAND          *
                            	  5101: *                                                        *
                            	  5102: * IF THE "PRINTER" HAS BEEN ATTACHED, ALL CHARACTERS     *
                            	  5103: * ENTERED AND TRANSMITTED VIA THE CONSOLE WILL PRINT ON  *
                            	  5104: * THE HARD COPY PRINTER. -- TO TERMINATE, ENTER "NOPA"   *
                            	  5105: *                                                        *
                            	  5106: * THIS COMMAND MAKES USE OF THE "NO" OPTION.  THERE IS A *
                            	  5107: * 4 BYTE HARD BRANCH INFRONT OF THE REGULAR ENTRY POINT. *
                            	  5108: **********************************************************
                            	  5109: 
01:002025B2 6004            	  5110:          BRA     NOPACMD        ENTRY FOR "NOPA"
                            	  5111: 
                            	  5112: *
01:002025B4 70FF            	  5113: PACMD    MOVEQ   #-1,D0         ENTRY FOR "PA" (D0=-1[CRT & PRINT])
01:002025B6 6002            	  5114:          BRA.S   SETCRTPR       GO ACTUALLY SET THE SWITCH
01:002025B8 7000            	  5115: NOPACMD  CLR.L   D0             D0 = ZEROS... "CRT" ONLY
01:002025BA 31C00652        	  5116: SETCRTPR MOVE.W  D0,CRTPNT      SET THE "CRT" AND "PRINTER" SWITCH
01:002025BE 6000E06E        	  5117:          BRA     MACSBUG        GO BE "READY"
                            	  5118: 
                            	  5119: 
                            	  5120: 
                            	  5121: 
                            	  5122: *-------------------------------------------------------------------------
                            	  5123: * File CODE68K   68K ONE LINE ASSEMBLER                           07/23/82
                            	  5124: 
                            	  5125: * EVALUATE EXPRESSION
                            	  5126: *  NUMBER PLUS OR MINUS NUMBER....
                            	  5127: *
                            	  5128: EV       DS      0
01:002025C2 2F07            	  5129:          MOVE.L  D7,-(A7)       SAVE D7
01:002025C4 7E00            	  5130:          CLR.L   D7
01:002025C6 6120            	  5131: EV21     BSR.S   GETFIELD       GET NUMBER
01:002025C8 DE80            	  5132:          ADD.L   D0,D7          D7 = NUMBER BEING BUILT
01:002025CA 121D            	  5133: EV15     MOVE.B  (A5)+,D1       D1 = TERMINATING CHAR
01:002025CC 7000            	  5134:          CLR.L   D0             D0 = NEXT NUMBER (=0 1ST TIME)
01:002025CE 0C01002B        	  5135:          CMPI.B  #'+',D1
01:002025D2 67F2            	  5136:          BEQ     EV21           PLUS
01:002025D4 0C01002D        	  5137:          CMPI.B  #'-',D1
01:002025D8 6606            	  5138:          BNE.S   EV39           NOT MINUS
01:002025DA 610C            	  5139:          BSR.S   GETFIELD       GET NEXT NUMBER
01:002025DC 9E80            	  5140:          SUB.L   D0,D7
01:002025DE 60EA            	  5141:          BRA     EV15
                            	  5142: 
01:002025E0 2007            	  5143: EV39     MOVE.L  D7,D0          D0 = VALUE BUILT
01:002025E2 538D            	  5144:          SUBQ.L  #1,A5          A5 = CHAR AFTER EXPRESSION
01:002025E4 2E1F            	  5145:          MOVE.L  (A7)+,D7       RESTORE D7
01:002025E6 4E75            	  5146:          RTS
                            	  5147: 
                            	  5148: GETFIELD DS      0
01:002025E8 0C15002A        	  5149:          CMPI.B  #'*',(A5)
01:002025EC 6606            	  5150:          BNE.S   GETF305
                            	  5151: 
01:002025EE 2004            	  5152:          MOVE.L  D4,D0          D0 = PROGRAM COUNTER
01:002025F0 528D            	  5153:          ADDQ.L  #1,A5
01:002025F2 6036            	  5154:          BRA.S   GETF333
                            	  5155: 
01:002025F4 0C150027        	  5156: GETF305  CMPI.B  #$27,(A5)
01:002025F8 662A            	  5157:          BNE.S   GETF325        NOT LITERAL
                            	  5158: 
01:002025FA 528D            	  5159:          ADDQ.L  #1,A5
01:002025FC 7000            	  5160:          CLR.L   D0
                            	  5161: 
01:002025FE 3229000C        	  5162:          MOVE.W  TLENGTH(A1),D1  D1 = SIZE
01:00202602 6704            	  5163:          BEQ.S   GETF308        .B = 0
01:00202604 EA49            	  5164:          LSR.W   #5,D1          .W = 1
01:00202606 5381            	  5165:          SUBQ.L  #1,D1          .L = 3
                            	  5166: GETF308
                            	  5167: 
01:00202608 E188            	  5168: GETF311  LSL.L   #8,D0
01:0020260A 101D            	  5169:          MOVE.B  (A5)+,D0
01:0020260C 0C150027        	  5170:          CMPI.B  #$27,(A5)
01:00202610 6706            	  5171:          BEQ.S   GETF312        CLOSING QUOTE
01:00202612 51C9FFF4        	  5172:          DBF     D1,GETF311
01:00202616 6056            	  5173:          BRA.S   ER1            OVERFLOW
                            	  5174: 
01:00202618 528D            	  5175: GETF312  ADDQ.L  #1,A5          MOVE PAST CLOSING QUOTE
01:0020261A 6002            	  5176:          BRA.S   GETF314
                            	  5177: 
01:0020261C E188            	  5178: GETF313  LSL.L   #8,D0
01:0020261E 51C9FFFC        	  5179: GETF314  DBF     D1,GETF313     LEFT NORNALIZE
01:00202622 6006            	  5180:          BRA.S   GETF333
                            	  5181: 
01:00202624 6100F8CE        	  5182: GETF325  BSR     GETDECNU       GET DECIMAL NUMBER
01:00202628 6644            	  5183:          BNE.S   ER1            MESSED UP NUMBER
                            	  5184: 
01:0020262A 4E75            	  5185: GETF333  RTS
                            	  5186: 
                            	  5187: XBASE    DS        0
                            	  5188: 
                            	  5189: * FIND AND SET SIZE
                            	  5190: * BIT 5432109876543210
                            	  5191: *     ........00......  = BYTE
                            	  5192: *     ........01......  = WORD
                            	  5193: *     ........10......  = LONG
                            	  5194: *
01:0020262C 8469000C        	  5195: FSIZE    OR.W    TLENGTH(A1),D2  SET SIZE BITS
01:00202630 4E75            	  5196:          RTS
                            	  5197: 
                            	  5198: *  D0 = VALUE 0 - 7
                            	  5199: *  D1 = 0 IF D@     = 1 IF A@
01:00202632 7200            	  5200: GETREGD  CLR.L   D1
01:00202634 0C1D0044        	  5201:          CMPI.B  #'D',(A5)+
01:00202638 6634            	  5202:          BNE.S   ER1
01:0020263A 7000            	  5203: GET41    CLR.L   D0
01:0020263C 101D            	  5204:          MOVE.B  (A5)+,D0
01:0020263E 04000030        	  5205:          SUBI.B  #'0',D0
01:00202642 6B2A            	  5206:          BMI.S   ER1
01:00202644 0C000007        	  5207:          CMPI.B  #$7,D0
01:00202648 6E24            	  5208:          BGT.S   ER1
01:0020264A 4E75            	  5209:          RTS
                            	  5210: 
01:0020264C 7200            	  5211: GETREGA  CLR.L   D1
01:0020264E 123C0008        	  5212:          MOVE.B  #8,D1
01:00202652 0C1D0041        	  5213:          CMPI.B  #'A',(A5)+
01:00202656 6616            	  5214:          BNE.S   ER1
01:00202658 60E0            	  5215:          BRA     GET41
                            	  5216: 
01:0020265A 4241            	  5217: GETREGAD CLR     D1
01:0020265C 101D            	  5218:          MOVE.B  (A5)+,D0
01:0020265E 0C000044        	  5219:          CMPI.B  #'D',D0
01:00202662 67D6            	  5220:          BEQ     GET41
01:00202664 123C0008        	  5221:          MOVE.B  #8,D1
01:00202668 0C000041        	  5222:          CMPI.B  #'A',D0
01:0020266C 67CC            	  5223:          BEQ     GET41
01:0020266E 60000786        	  5224: ER1      BRA     ER
                            	  5225: 
01:00202672 3E3C01FD        	  5226: EADA     MOVE.W  #$1FD,D7       DATA ALTERABLE ONLY
01:00202676 6022            	  5227:          BRA.S   EA
                            	  5228: 
01:00202678 3E3C07E4        	  5229: EAC      MOVE.W  #$7E4,D7       CONTROL ONLY
01:0020267C 601C            	  5230:          BRA.S   EA
                            	  5231: 
01:0020267E 3E3C01FC        	  5232: EAM      MOVE.W  #$1FC,D7       MEMORY ALTERABLE ONLY
01:00202682 6016            	  5233:          BRA.S   EA
                            	  5234: 
01:00202684 3E3C0800        	  5235: EAZ      MOVE.W  #$800,D7       IMMEDIATE ONLY
01:00202688 6010            	  5236:          BRA.S   EA
                            	  5237: 
01:0020268A 3E3C0FFD        	  5238: EADADDR  MOVE.W  #$FFD,D7       DATA ADDRESSING
01:0020268E 600A            	  5239:          BRA.S   EA
                            	  5240: 
01:00202690 3E3C01FF        	  5241: EAA      MOVE.W  #$1FF,D7       ALTERABLE ADDRESSING
01:00202694 6004            	  5242:          BRA.S   EA
                            	  5243: 
01:00202696 3E3C0FFF        	  5244: EAALL    MOVE.W  #$FFF,D7       ALL MODES
                            	  5245: 
                            	  5246: *  ...............1  D@                DATA REGISTER
                            	  5247: *  ..............1.  A@
                            	  5248: *  .............1..  (A@)
                            	  5249: *  ............1...  -(A@)
                            	  5250: *  ...........1....  (A@)+
                            	  5251: *  ..........1.....  DATA(A@)
                            	  5252: *  .........1......  DATA(A@,R@)
                            	  5253: *  ........1.......  DATA  (SHORT)
                            	  5254: *  .......1........  DATA  (LONG)
                            	  5255: *  ......1.........  DATA(PC)
                            	  5256: *  .....1..........  DATA(PC,R@)
                            	  5257: *  ....1...........  #DATA
                            	  5258: *  1...............  SPECIAL CASE JMP.L
                            	  5259: 
                            	  5260: * D0 = VALUE CALCULATED
                            	  5261: * D2 = MASK WORD (1ST WORD OF INSTRUCTION)
                            	  5262: * D3 = OFFSET FOR DATA STORE (TDATA+..)
                            	  5263: * D4 = EXTENSION WORD
                            	  5264: * D5 = <DATA>
                            	  5265: * D6 = MODE AS BUILT   .........XXXXXX
                            	  5266: * D7 = MODES ALLOWED
                            	  5267: *
                            	  5268: * A4 = BASE ADDRESS FOR DATA STORE (TDATA+..)[A4,D3]
                            	  5269: EA       DS      0
01:0020269A 7A00            	  5270:          CLR.L   D5             ZERO VALUE
01:0020269C 7C00            	  5271:          CLR.L   D6             MODE = 000000
01:0020269E 1015            	  5272:          MOVE.B  (A5),D0
01:002026A0 0C000023        	  5273:          CMPI.B  #'#',D0
01:002026A4 6646            	  5274:          BNE.S   EA10
                            	  5275: 
                            	  5276: * IMMEDIATE MODE
                            	  5277: 
01:002026A6 0807000B        	  5278:          BTST    #11,D7
01:002026AA 67C2            	  5279:          BEQ     ER1
                            	  5280: 
01:002026AC 1C3C003C        	  5281:          MOVE.B  #$3C,D6        D6 = MODE  111100
01:002026B0 528D            	  5282:          ADDQ.L  #1,A5
                            	  5283: 
01:002026B2 6100FF0E        	  5284:          BSR     EV             EVALUATE EXPRESSION
01:002026B6 2A00            	  5285:          MOVE.L  D0,D5          D5 = VALUE
                            	  5286: 
01:002026B8 4A29000B        	  5287:          TST.B   TLSPEC(A1)
01:002026BC 670A            	  5288:          BEQ.S   EA0633         .SIZE NOT SPECIFIED (.W ASSUMED)
                            	  5289: 
01:002026BE 3029000C        	  5290:          MOVE.W  TLENGTH(A1),D0
01:002026C2 6714            	  5291:          BEQ.S   EA0635         .BYTE
                            	  5292: 
01:002026C4 4A00            	  5293:          TST.B   D0
01:002026C6 6B18            	  5294:          BMI.S   EA0637         .LONG
                            	  5295: 
01:002026C8 61000238        	  5296: EA0633   BSR     EA16BIT        .WORD     -32K TO +64K
01:002026CC 39853000        	  5297: EA0634   MOVE.W  D5,(A4,D3)
01:002026D0 5429000A        	  5298:          ADDQ.B  #2,TNB(A1)     BYTE COUNT
01:002026D4 5483            	  5299:          ADDQ.L  #2,D3          OFFSET
01:002026D6 4E75            	  5300:          RTS
                            	  5301: 
01:002026D8 6100023E        	  5302: EA0635   BSR     EA8BIT         -127 TO +255
01:002026DC 6690            	  5303:          BNE     ER1
01:002026DE 60EC            	  5304:          BRA     EA0634
                            	  5305: 
01:002026E0 29853000        	  5306: EA0637   MOVE.L  D5,(A4,D3)
01:002026E4 5829000A        	  5307:          ADDQ.B  #4,TNB(A1)
01:002026E8 5883            	  5308:          ADDQ.L  #4,D3
01:002026EA 4E75            	  5309:          RTS
                            	  5310: 
                            	  5311: EA10     DS      0
01:002026EC 0C15002D        	  5312:          CMPI.B  #'-',(A5)
01:002026F0 6626            	  5313:          BNE.S   EA11
                            	  5314: 
01:002026F2 0C2D00280001    	  5315:          CMPI.B  #'(',1(A5)
01:002026F8 66000090        	  5316:          BNE     EA41           MAY BE "-<DATA>
                            	  5317: 
01:002026FC 548D            	  5318:          ADDQ.L  #2,A5
01:002026FE 3C3C0020        	  5319:          MOVE.W  #$0020,D6      MODE = -(A@)    100AAA
                            	  5320: 
01:00202702 08070004        	  5321:          BTST    #4,D7
01:00202706 6700FF66        	  5322:          BEQ     ER1            THIS MODE NOT ALLOWED
                            	  5323: 
01:0020270A 6100FF40        	  5324:          BSR     GETREGA
01:0020270E 8C40            	  5325:          OR.W    D0,D6
                            	  5326: 
01:00202710 0C1D0029        	  5327:          CMPI.B  #')',(A5)+
01:00202714 6670            	  5328:          BNE.S   ER3            NO CLOSING PAREN
01:00202716 4E75            	  5329:          RTS
                            	  5330: 
01:00202718 0C000041        	  5331: EA11     CMPI.B  #'A',D0
01:0020271C 6612            	  5332:          BNE.S   EA21
                            	  5333: 
01:0020271E 1C3C0008        	  5334:          MOVE.B  #$08,D6        MODE = 001...
01:00202722 08070001        	  5335:          BTST    #1,D7
01:00202726 675E            	  5336:          BEQ.S   ER3            MODE NOT ALLOWED
                            	  5337: 
01:00202728 6100FF22        	  5338:          BSR     GETREGA
01:0020272C 8C40            	  5339:          OR.W    D0,D6
01:0020272E 4E75            	  5340:          RTS
                            	  5341: 
01:00202730 0C000044        	  5342: EA21     CMPI.B  #'D',D0
01:00202734 660E            	  5343:          BNE.S   EA31
                            	  5344: 
01:00202736 08070000        	  5345:          BTST    #0,D7
01:0020273A 674A            	  5346:          BEQ.S   ER3            MODE NOT ALLOWED
                            	  5347: 
01:0020273C 6100FEF4        	  5348:          BSR     GETREGD        MODE = D@   000AAA
01:00202740 8C40            	  5349:          OR.W    D0,D6
01:00202742 4E75            	  5350:          RTS
                            	  5351: 
01:00202744 0C000028        	  5352: EA31     CMPI.B  #'(',D0
01:00202748 6640            	  5353:          BNE.S   EA41
                            	  5354: 
                            	  5355: * POSSIBLE
                            	  5356: *  (A@)
                            	  5357: *  (A@)+
                            	  5358: *  (A@,R@)  IMPLIED ZERO DISPLACEMENT
                            	  5359: *
01:0020274A 528D            	  5360:          ADDQ.L  #1,A5
01:0020274C 6100FEFE        	  5361:          BSR     GETREGA
01:00202750 8C40            	  5362:          OR.W    D0,D6
                            	  5363: 
01:00202752 101D            	  5364:          MOVE.B  (A5)+,D0
01:00202754 0C00002C        	  5365:          CMPI.B  #',',D0
01:00202758 670000D0        	  5366:          BEQ     EA5116         MODE = (A@,R@)  ;IMPLIED D5 = 0 DATA
                            	  5367: 
01:0020275C 0C000029        	  5368:          CMPI.B  #')',D0        LOOK FOR CLOSING )
01:00202760 6624            	  5369:          BNE.S   ER3
                            	  5370: 
01:00202762 0C150020        	  5371:          CMPI.B  #BLANK,(A5)    LOOK FOR BLANK
01:00202766 6714            	  5372:          BEQ.S   EA35           MODE = (A@)
                            	  5373: 
01:00202768 0C15002B        	  5374:          CMPI.B  #'+',(A5)
01:0020276C 660E            	  5375:          BNE.S   EA35
01:0020276E 528D            	  5376:          ADDQ.L  #1,A5
                            	  5377: 
01:00202770 00460018        	  5378:          ORI.W   #$18,D6        MODE = 011...    (A@)+
                            	  5379: 
01:00202774 08070003        	  5380:          BTST    #3,D7
01:00202778 670C            	  5381:          BEQ.S   ER3            MODE NOT ALLOWED
                            	  5382: 
01:0020277A 4E75            	  5383: EA34     RTS
                            	  5384: 
01:0020277C 00460010        	  5385: EA35     ORI.W   #$10,D6        MODE = 010...   (A@)
                            	  5386: 
01:00202780 08070002        	  5387:          BTST    #2,D7
01:00202784 66F4            	  5388:          BNE     EA34           MODE ALLOWED
01:00202786 6000066E        	  5389: ER3      BRA     ER             MODE NOT ALLOWED
                            	  5390: 
                            	  5391: * POSSIBLE
                            	  5392: *   <DATA>   SHORT
                            	  5393: *   <DATA>   LONG
                            	  5394: *   <DATA>(A@)
                            	  5395: *   <DATA>(A@,R@)
                            	  5396: *   <DATA>(A@,R@.W)
                            	  5397: *   <DATA>(A@,R@.L)
                            	  5398: *   <DATA>(PC)
                            	  5399: *   <DATA>(PC,R@)
                            	  5400: *   <DATA>(PC,R@.W)
                            	  5401: *   <DATA>(PC,R@.L)
                            	  5402: *
01:0020278A 6100FE36        	  5403: EA41     BSR     EV             EVALUATE EXPRESSION
01:0020278E 2A00            	  5404:          MOVE.L  D0,D5          D5 = <DATA>
                            	  5405: 
01:00202790 1015            	  5406:          MOVE.B  (A5),D0
01:00202792 0C00002C        	  5407:          CMPI.B  #',',D0
01:00202796 6706            	  5408:          BEQ.S   EA4102
01:00202798 0C000020        	  5409:          CMPI.B  #BLANK,D0
01:0020279C 6642            	  5410:          BNE.S   EA4120
                            	  5411: 
                            	  5412: *  <DATA>         ONLY
                            	  5413: * CHECK IF NEGATIVE NUMBER
                            	  5414: 
01:0020279E 2005            	  5415: EA4102   MOVE.L  D5,D0
01:002027A0 6A02            	  5416:          BPL.S   EA4105         POSITIVE NUMBER
01:002027A2 4680            	  5417:          NOT.L   D0
01:002027A4 02408000        	  5418: EA4105   ANDI.W  #$8000,D0
01:002027A8 4A80            	  5419:          TST.L   D0
01:002027AA 661E            	  5420:          BNE.S   EA4135         .LONG
                            	  5421: 
                            	  5422: *  <DATA>.W
01:002027AC 08070007        	  5423:          BTST    #7,D7
01:002027B0 6608            	  5424:          BNE.S   EA4127         SHORT ALLOWED
01:002027B2 0807000F        	  5425:          BTST    #15,D7
01:002027B6 67CE            	  5426:          BEQ     ER3            MODE NOT ALLOWED
01:002027B8 6010            	  5427:          BRA.S   EA4135         SPECIAL CASE (JMP.L)
                            	  5428: 
01:002027BA 00460038        	  5429: EA4127   ORI.W   #$38,D6        EA = ABSOULTE SHORT
01:002027BE 39853000        	  5430:          MOVE.W  D5,(A4,D3)     D5 = DATA
01:002027C2 5429000A        	  5431:          ADDQ.B  #2,TNB(A1)     BYTE COUNT
01:002027C6 5483            	  5432:          ADDQ.L  #2,D3
01:002027C8 4E75            	  5433:          RTS
                            	  5434: 
                            	  5435: *EA4134  CMPI.B  #'L',D0
                            	  5436: *        BNE     ER3
                            	  5437: 
                            	  5438: *  <DATA>.L
01:002027CA 00460039        	  5439: EA4135   ORI.W   #$39,D6        EA = ABSOLUTE LONG
01:002027CE 29853000        	  5440:          MOVE.L  D5,(A4,D3)
01:002027D2 5829000A        	  5441:          ADDQ.B  #4,TNB(A1)     BYTE COUNT
01:002027D6 5883            	  5442:          ADDQ.L  #4,D3
01:002027D8 08070008        	  5443:          BTST    #8,D7
01:002027DC 67A8            	  5444:          BEQ     ER3            MODE NOT ALLOWED
01:002027DE 4E75            	  5445:          RTS
                            	  5446: 
01:002027E0 528D            	  5447: EA4120   ADDQ.L  #1,A5
01:002027E2 0C000028        	  5448:          CMPI.B  #'(',D0
01:002027E6 669E            	  5449:          BNE     ER3
                            	  5450: 
01:002027E8 0C150050        	  5451:          CMPI.B  #'P',(A5)
01:002027EC 6700008E        	  5452:          BEQ     EA61
                            	  5453: 
                            	  5454: * <DATA>(A@.......
01:002027F0 6100011A        	  5455:          BSR     EA16BITS       -32K TO +32K
                            	  5456: 
01:002027F4 6100FE56        	  5457:          BSR     GETREGA
01:002027F8 8C40            	  5458:          OR.W    D0,D6
                            	  5459: 
01:002027FA 1015            	  5460:          MOVE.B  (A5),D0
01:002027FC 0C000029        	  5461:          CMPI.B  #')',D0
01:00202800 6624            	  5462:          BNE.S   EA5115
                            	  5463: 
                            	  5464: * <DATA>(A@)
01:00202802 528D            	  5465:          ADDQ.L  #1,A5
                            	  5466: 
01:00202804 08070005        	  5467:          BTST    #5,D7
01:00202808 670000A0        	  5468:          BEQ     ER4            MODE NOT ALLOWED
                            	  5469: 
01:0020280C 00460028        	  5470:          ORI.W   #$0028,D6      MODE = 101AAA
                            	  5471: 
01:00202810 0C8500010000    	  5472:          CMPI.L  #$10000,D5
01:00202816 6A000092        	  5473:          BPL     ER4
                            	  5474: 
01:0020281A 39853000        	  5475:          MOVE.W  D5,(A4,D3)
01:0020281E 5429000A        	  5476:          ADDQ.B  #2,TNB(A1)
01:00202822 5483            	  5477:          ADDQ.L  #2,D3
01:00202824 4E75            	  5478:          RTS
                            	  5479: 
01:00202826 610005B4        	  5480: EA5115   BSR     COMMA
                            	  5481: 
                            	  5482: *  <DATA>(A@,-----    ADDRESS REGISTER WITH INDEX
01:0020282A 48C5            	  5483: EA5116   EXT.L   D5
01:0020282C 610000F2        	  5484:          BSR     EA8BITS        -128 TO +127
01:00202830 6678            	  5485:          BNE.S   ER4
01:00202832 024500FF        	  5486:          ANDI.W  #$00FF,D5
01:00202836 00460030        	  5487:          ORI.W   #$0030,D6      MODE  110---
                            	  5488: 
01:0020283A 08070006        	  5489:          BTST    #6,D7
01:0020283E 676A            	  5490:          BEQ.S   ER4            MODE NOT ALLOWED
                            	  5491: 
01:00202840 6100FE18        	  5492:          BSR     GETREGAD
01:00202844 8041            	  5493:          OR.W    D1,D0
01:00202846 E858            	  5494:          ROR.W   #4,D0
01:00202848 8A40            	  5495:          OR.W    D0,D5          EXTENSION WORD
                            	  5496: 
                            	  5497: * BIT 11 EXTENSION WORD
                            	  5498: *   0 = SIGN EXTENDED, LOW ORDER INTEGER IN INDEX REGISTER
                            	  5499: *   1 = LONG VALUE IN INDEX REGISTER  (DEFAULT)
                            	  5500: *
01:0020284A 101D            	  5501:          MOVE.B  (A5)+,D0
01:0020284C 0C000029        	  5502:          CMPI.B  #')',D0
01:00202850 671E            	  5503:          BEQ.S   EA5119         DEFAULT   .W
                            	  5504: 
01:00202852 0C00002E        	  5505:          CMPI.B  #'.',D0
01:00202856 6652            	  5506:          BNE.S   ER4
                            	  5507: 
01:00202858 101D            	  5508:          MOVE.B  (A5)+,D0
01:0020285A 0C000057        	  5509:          CMPI.B  #'W',D0
01:0020285E 670A            	  5510:          BEQ.S   EA5118
                            	  5511: 
01:00202860 0C00004C        	  5512:          CMPI.B  #'L',D0
01:00202864 6644            	  5513:          BNE.S   ER4            NEITHER .W NOR .L
                            	  5514: 
01:00202866 00450800        	  5515:          ORI.W   #$0800,D5      EXTENSION WORD, W/L BIT = .L
                            	  5516: 
01:0020286A 0C1D0029        	  5517: EA5118   CMPI.B  #')',(A5)+
01:0020286E 663A            	  5518:          BNE.S   ER4            NO CLOSING ")"
                            	  5519: 
01:00202870 39853000        	  5520: EA5119   MOVE.W  D5,(A4,D3)
01:00202874 5429000A        	  5521:          ADDQ.B  #2,TNB(A1)
01:00202878 5483            	  5522:          ADDQ.L  #2,D3
01:0020287A 4E75            	  5523: EA5119E  RTS
                            	  5524: 
                            	  5525: *  <DATA>(P-----
01:0020287C 528D            	  5526: EA61     ADDQ.L  #1,A5
01:0020287E 0C1D0043        	  5527:          CMPI.B  #'C',(A5)+
01:00202882 66000572        	  5528:          BNE     ER
                            	  5529: 
01:00202886 9AA9000E        	  5530:          SUB.L   PCOUNTER(A1),D5  D5 = D5 - PC
01:0020288A 5585            	  5531:          SUBQ.L  #2,D5          D5 = D5 - (PC + 2)
                            	  5532: 
01:0020288C 101D            	  5533:          MOVE.B  (A5)+,D0
01:0020288E 0C000029        	  5534:          CMPI.B  #')',D0
01:00202892 661A            	  5535:          BNE.S   EA71
                            	  5536: 
                            	  5537: *  <DATA>(PC)
01:00202894 0046003A        	  5538:          ORI.W   #$3A,D6        MODE = 111010
                            	  5539: 
01:00202898 6172            	  5540:          BSR.S   EA16BITS       -32K TO +32K
01:0020289A 39853000        	  5541:          MOVE.W  D5,(A4,D3)
01:0020289E 5429000A        	  5542:          ADDQ.B  #2,TNB(A1)
01:002028A2 5483            	  5543:          ADDQ.L  #2,D3
                            	  5544: 
01:002028A4 08070009        	  5545:          BTST    #9,D7
01:002028A8 66D0            	  5546:          BNE     EA5119E
01:002028AA 6000054A        	  5547: ER4      BRA     ER
                            	  5548: 
                            	  5549: *  <DATA>(PC----          PROGRAM COUNTER WITH INDEX
01:002028AE 3C3C003B        	  5550: EA71     MOVE.W  #$003B,D6      MODE = 111011
                            	  5551: 
01:002028B2 0C00002C        	  5552:          CMPI.B  #',',D0
01:002028B6 66F2            	  5553:          BNE     ER4
                            	  5554: 
01:002028B8 0807000A        	  5555:          BTST    #10,D7
01:002028BC 67EC            	  5556:          BEQ     ER4            MODE NOT ALLOWED
                            	  5557: 
01:002028BE 6160            	  5558:          BSR.S   EA8BITS        -128 TO +127
01:002028C0 66E8            	  5559:          BNE     ER4
                            	  5560: 
01:002028C2 024500FF        	  5561:          ANDI.W  #$00FF,D5      D5 = VALUE
01:002028C6 6100FD92        	  5562:          BSR     GETREGAD
01:002028CA 8041            	  5563:          OR.W    D1,D0
                            	  5564: 
01:002028CC E858            	  5565:          ROR.W   #4,D0
01:002028CE 8A40            	  5566:          OR.W    D0,D5          D5 = EXTENSION WORD
                            	  5567: 
01:002028D0 101D            	  5568:          MOVE.B  (A5)+,D0
01:002028D2 0C000029        	  5569:          CMPI.B  #')',D0
01:002028D6 671E            	  5570:          BEQ.S   EA7115         DEFAULT  .W
                            	  5571: 
01:002028D8 0C00002E        	  5572:          CMPI.B  #'.',D0
01:002028DC 66CC            	  5573:          BNE     ER4
                            	  5574: 
01:002028DE 101D            	  5575:          MOVE.B  (A5)+,D0
01:002028E0 0C000057        	  5576:          CMPI.B  #'W',D0
01:002028E4 670A            	  5577:          BEQ.S   EA7113
                            	  5578: 
01:002028E6 0C00004C        	  5579:          CMPI.B  #'L',D0
01:002028EA 66BE            	  5580:          BNE     ER4
01:002028EC 00450800        	  5581:          ORI.W   #$0800,D5      EXTENSION WORD W/L = .L
                            	  5582: 
01:002028F0 0C1D0029        	  5583: EA7113   CMPI.B  #')',(A5)+
01:002028F4 66B4            	  5584:          BNE     ER4            NO CLOSING ")"
                            	  5585: 
01:002028F6 39853000        	  5586: EA7115   MOVE.W  D5,(A4,D3)
01:002028FA 5429000A        	  5587:          ADDQ.B  #2,TNB(A1)
01:002028FE 5483            	  5588:          ADDQ.L  #2,D3
01:00202900 4E75            	  5589:          RTS
                            	  5590: 
                            	  5591: ****************************************************************************
                            	  5592: *
                            	  5593: *        ROUTINES TO TEST FOR VALID EFFECTIVE ADDRESSES
                            	  5594: *
                            	  5595: *        EA16BIT   tests that -32768 <= D5 <= 65535.  (signed or unsigned)
                            	  5596: *        EA16BITS  tests that -32768 <= D5 <= 32767.  (signed only)
                            	  5597: *        EA8BIT    tests that   -128 <= D5 <=   255.  (signed or unsigned)
                            	  5598: *        EA8BITS   tests that   -128 <= D5 <=   127.  (signed only)
                            	  5599: *
                            	  5600: *        The 16-bit tests branch to ER if invalid, else return.
                            	  5601: *        The  8-bit tests return condition codes <EQ> if valid, else <NE>.
                            	  5602: *        D5 is preserved unless a branch to ER results.
                            	  5603: *        D1 is destroyed.
                            	  5604: *
                            	  5605: ****************************************************************************
                            	  5606: 
                            	  5607: EA16BIT:
01:00202902 610C            	  5608:          BSR.S   EA16BITC       CHECK RANGE -32768 TO 32767.  IF
01:00202904 2205            	  5609:          MOVE.L  D5,D1          INVALID, CHECK WHETHER THE HIGH 16
01:00202906 4841            	  5610:          SWAP    D1             BITS ARE 0 (WHICH IMPLIES THAT
01:00202908 4A41            	  5611:          TST.W   D1             D5 <= 65535).  IF NOT, FALL THRU TO
01:0020290A 6728            	  5612:          BEQ.S   EASEX          THE 16-BIT SIGNED TEST--WE WILL
                            	  5613: *                               FAIL AND GO TO ER.
                            	  5614: 
                            	  5615: EA16BITS:
01:0020290C 487A04E8        	  5616:          PEA     ER(PC)         SET UP TO RETURN TO ER IF INVALID.
                            	  5617: 
01:00202910 223C00007FFF    	  5618: EA16BITC MOVE.L  #$7FFF,D1      D1  <--  2^16-1.
01:00202916 600E            	  5619:          BRA.S   EAS            GO TO THE COMMON TEST ROUTINE.
                            	  5620: 
                            	  5621: 
                            	  5622: EA8BIT:
01:00202918 610A            	  5623:          BSR.S   EA8BITC        CHECK RANGE -128 TO 127.  IF INVALID,
01:0020291A 2205            	  5624:          MOVE.L  D5,D1          CHECK WHETHER THE HIGH 24 BITS ARE
01:0020291C E089            	  5625:          LSR.L   #8,D1          0 (WHICH IMPLIES THAT D5 <= 255).
01:0020291E 4E75            	  5626:          RTS
                            	  5627: 
                            	  5628: EA8BITS:
01:00202920 6102            	  5629:          BSR.S   EA8BITC        JUST CHECK FOR -127 <= D5 <= 128.
01:00202922 4E75            	  5630:          RTS                    ; (BSR PUTS NEEDED ADDRESS ON STACK!)
                            	  5631: 
01:00202924 727F            	  5632: EA8BITC  MOVEQ   #$7F,D1        D1  <--  2^8 - 1.
                            	  5633: 
                            	  5634: *                  *** NOTE: THIS ROUTINE PLAYS WITH THE STACK ***
01:00202926 BA81            	  5635: EAS      CMP.L   D1,D5          IF D5 > 2^N-1, RETURN WITH <NE> (INVAL).
01:00202928 6E0A            	  5636:          BGT.S   EASEX
01:0020292A 4681            	  5637:          NOT.L   D1             IF D5 < -2^N,  RETURN WITH <NE> (INVAL).
01:0020292C BA81            	  5638:          CMP.L   D1,D5
01:0020292E 6D04            	  5639:          BLT.S   EASEX
                            	  5640: 
01:00202930 588F            	  5641:          ADDQ.L  #4,A7          POP THE RETURN ADDRESS OFF THE STACK,
01:00202932 7200            	  5642:          CLR.L   D1             SET <EQ> (VALID), AND RETURN.
                            	  5643: 
01:00202934 4E75            	  5644: EASEX    RTS
                            	  5645: 
                            	  5646: ADR      MACRO
                            	  5647:          DC.W    M\1-XBASE
                            	  5648:          ENDM
                            	  5649: 
                            	  5650: TBLKEYS  DS      0              INDEX
                            	  5651:          ADR     ABCD            0  ABCD SBCD
01:00202936 0808            	     1M          DC.W    MABCD-XBASE
                            	  5652:          ADR     ADD             1  ADD  SUB
01:00202938 08BE            	     1M          DC.W    MADD-XBASE
                            	  5653:          ADR     ADDA            2  ADDA CMPA SUBA
01:0020293A 0966            	     1M          DC.W    MADDA-XBASE
                            	  5654:          ADR     ADDI            3  ADDI CMPI SUBI
01:0020293C 0918            	     1M          DC.W    MADDI-XBASE
                            	  5655:          ADR     ADDQ            4  ADDQ SUBQ
01:0020293E 098E            	     1M          DC.W    MADDQ-XBASE
                            	  5656:          ADR     ADDX            5  ADDX SUBX
01:00202940 09D0            	     1M          DC.W    MADDX-XBASE
                            	  5657:          ADR     AND             6  AND  EOR OR
01:00202942 0A12            	     1M          DC.W    MAND-XBASE
                            	  5658:          ADR     ASL             7  ASL  LSL ROL ROXL
01:00202944 0AC0            	     1M          DC.W    MASL-XBASE
                            	  5659:          ADR     DBCC            8  DBCC
01:00202946 0BAC            	     1M          DC.W    MDBCC-XBASE
                            	  5660:          ADR     BCHG            9  BCHG
01:00202948 0B30            	     1M          DC.W    MBCHG-XBASE
                            	  5661:          ADR     BRA            10  BRA  BSR  BCC
01:0020294A 0BBA            	     1M          DC.W    MBRA-XBASE
                            	  5662:          ADR     BSET           11  BSET
01:0020294C 0B88            	     1M          DC.W    MBSET-XBASE
                            	  5663:          ADR     CHK            12  CHK  DIVS DIVU MILS MULU
01:0020294E 0C12            	     1M          DC.W    MCHK-XBASE
                            	  5664:          ADR     CLR            13  CLR NEG NEGX NOT TST
01:00202950 0C2C            	     1M          DC.W    MCLR-XBASE
                            	  5665:          ADR     CMPM           14  CMPM
01:00202952 0C3A            	     1M          DC.W    MCMPM-XBASE
                            	  5666:          ADR     MOVEQ          15  MOVEQ
01:00202954 0E18            	     1M          DC.W    MMOVEQ-XBASE
                            	  5667:          ADR     EXG            16  EXG
01:00202956 0C64            	     1M          DC.W    MEXG-XBASE
                            	  5668:          ADR     EXT            17  EXT
01:00202958 0C9E            	     1M          DC.W    MEXT-XBASE
                            	  5669:          ADR     JMP            18  JMP  JSR
01:0020295A 0FAC            	     1M          DC.W    MJMP-XBASE
                            	  5670:          ADR     LEA            19  LEA
01:0020295C 0FD8            	     1M          DC.W    MLEA-XBASE
                            	  5671:          ADR     LINK           20  LINK
01:0020295E 1022            	     1M          DC.W    MLINK-XBASE
                            	  5672:          ADR     MOVE           21  MOVE
01:00202960 0E64            	     1M          DC.W    MMOVE-XBASE
                            	  5673:          ADR     CMMD2          22  NOP RESET RTE RTR RTS TRAPV
01:00202962 07D8            	     1M          DC.W    MCMMD2-XBASE
                            	  5674:          ADR     STOP           23  STOP
01:00202964 1040            	     1M          DC.W    MSTOP-XBASE
                            	  5675:          ADR     SWAP           24  SWAP
01:00202966 1000            	     1M          DC.W    MSWAP-XBASE
                            	  5676:          ADR     TRAP           25  TRAP
01:00202968 1058            	     1M          DC.W    MTRAP-XBASE
                            	  5677:          ADR     UNLK           26  UNLK
01:0020296A 106A            	     1M          DC.W    MUNLK-XBASE
                            	  5678:          ADR     MOVEM          27  MOVEM
01:0020296C 0CB8            	     1M          DC.W    MMOVEM-XBASE
                            	  5679:          ADR     ANDI           28  ANDI EORI ORI
01:0020296E 092E            	     1M          DC.W    MANDI-XBASE
                            	  5680:          ADR     SCC            29  NBCD SCC TAS
01:00202970 0B22            	     1M          DC.W    MSCC-XBASE
                            	  5681:          ADR     BCLR           30  BCLR
01:00202972 0B94            	     1M          DC.W    MBCLR-XBASE
                            	  5682:          ADR     BTST           31  BTST
01:00202974 0BA0            	     1M          DC.W    MBTST-XBASE
                            	  5683:          ADR     MOVEA          32  MOVEA
01:00202976 0F80            	     1M          DC.W    MMOVEA-XBASE
                            	  5684:          ADR     MOVEP          33  MOVEP
01:00202978 0DB8            	     1M          DC.W    MMOVEP-XBASE
                            	  5685:          ADR     CMP            34  CMP
01:0020297A 084C            	     1M          DC.W    MCMP-XBASE
                            	  5686:          ADR     EOR            35  EOR
01:0020297C 0A74            	     1M          DC.W    MEOR-XBASE
                            	  5687:          ADR     PEA            36  PEA
01:0020297E 0FF2            	     1M          DC.W    MPEA-XBASE
                            	  5688:          ADR     DC             37  DC.W
01:00202980 1074            	     1M          DC.W    MDC-XBASE
                            	  5689: 
                            	  5690: 
                            	  5691: * \1,\2 = MNEUMONIC (\2 SIGN BIT SET AS LAST CHARACTER)
                            	  5692: * \3    = INDEX TO TABLKEYS
                            	  5693: * \4,\5 = FIRST WORD MASK
                            	  5694: * \6    = NO OPERAND ALLOWED IF SIGN SET
                            	  5695: * \7    = .S ALLOWED (.W NOT ALLOWED)
                            	  5696: OPC      MACRO
                            	  5697:          DC.B    '\1','\2'+128
                            	  5698:          DC.B    \3+\6+\7,$\4,$\5
                            	  5699:          ENDM
                            	  5700: 
                            	  5701: NOC      EQU     $80            (BIT 7 SET) NO OPERAND
                            	  5702: NW       EQU     $40            (BIT 6 SET) .W NOT ALLOWED
                            	  5703: 
                            	  5704: TBLOPC   OPC     ABC,D,0,C1,00,0,0     ABCD
01:00202982 414243          	     1M          DC.B    'ABC','D'+128
01:00202985 C4
01:00202986 00              	     2M          DC.B    0+0+0,$C1,$00
01:00202987 C1
01:00202988 00
                            	  5705:          OPC     ADD,A,2,D0,C0,0,0     ADDA
01:00202989 414444          	     1M          DC.B    'ADD','A'+128
01:0020298C C1
01:0020298D 02              	     2M          DC.B    2+0+0,$D0,$C0
01:0020298E D0
01:0020298F C0
                            	  5706:          OPC     ADD,I,3,06,00,0,0     ADDI
01:00202990 414444          	     1M          DC.B    'ADD','I'+128
01:00202993 C9
01:00202994 03              	     2M          DC.B    3+0+0,$06,$00
01:00202995 06
01:00202996 00
                            	  5707:          OPC     ADD,Q,4,50,00,0,0     ADDQ
01:00202997 414444          	     1M          DC.B    'ADD','Q'+128
01:0020299A D1
01:0020299B 04              	     2M          DC.B    4+0+0,$50,$00
01:0020299C 50
01:0020299D 00
                            	  5708:          OPC     ADD,X,5,D1,00,0,0     ADDX
01:0020299E 414444          	     1M          DC.B    'ADD','X'+128
01:002029A1 D8
01:002029A2 05              	     2M          DC.B    5+0+0,$D1,$00
01:002029A3 D1
01:002029A4 00
                            	  5709:          OPC     AD,D,1,D0,00,0,0      ADD
01:002029A5 4144            	     1M          DC.B    'AD','D'+128
01:002029A7 C4
01:002029A8 01              	     2M          DC.B    1+0+0,$D0,$00
01:002029A9 D0
01:002029AA 00
                            	  5710:          OPC     AND,I,28,02,00,0,0    ANDI
01:002029AB 414E44          	     1M          DC.B    'AND','I'+128
01:002029AE C9
01:002029AF 1C              	     2M          DC.B    28+0+0,$02,$00
01:002029B0 02
01:002029B1 00
                            	  5711:          OPC     AN,D,6,C0,00,0,0      AND
01:002029B2 414E            	     1M          DC.B    'AN','D'+128
01:002029B4 C4
01:002029B5 06              	     2M          DC.B    6+0+0,$C0,$00
01:002029B6 C0
01:002029B7 00
                            	  5712:          OPC     AS,L,7,E1,00,0,0      ASL
01:002029B8 4153            	     1M          DC.B    'AS','L'+128
01:002029BA CC
01:002029BB 07              	     2M          DC.B    7+0+0,$E1,$00
01:002029BC E1
01:002029BD 00
                            	  5713:          OPC     AS,R,07,E0,00,0,0     ASR
01:002029BE 4153            	     1M          DC.B    'AS','R'+128
01:002029C0 D2
01:002029C1 07              	     2M          DC.B    07+0+0,$E0,$00
01:002029C2 E0
01:002029C3 00
                            	  5714:          OPC     BR,A,10,60,00,0,NW    BRA
01:002029C4 4252            	     1M          DC.B    'BR','A'+128
01:002029C6 C1
01:002029C7 4A              	     2M          DC.B    10+0+NW,$60,$00
01:002029C8 60
01:002029C9 00
                            	  5715:          OPC     BH,I,10,62,00,0,NW    BHI
01:002029CA 4248            	     1M          DC.B    'BH','I'+128
01:002029CC C9
01:002029CD 4A              	     2M          DC.B    10+0+NW,$62,$00
01:002029CE 62
01:002029CF 00
                            	  5716:          OPC     BL,S,10,63,00,0,NW    BLS
01:002029D0 424C            	     1M          DC.B    'BL','S'+128
01:002029D2 D3
01:002029D3 4A              	     2M          DC.B    10+0+NW,$63,$00
01:002029D4 63
01:002029D5 00
                            	  5717:          OPC     BC,C,10,64,00,0,NW    BCC
01:002029D6 4243            	     1M          DC.B    'BC','C'+128
01:002029D8 C3
01:002029D9 4A              	     2M          DC.B    10+0+NW,$64,$00
01:002029DA 64
01:002029DB 00
                            	  5718:          OPC     BC,S,10,65,00,0,NW    BCS
01:002029DC 4243            	     1M          DC.B    'BC','S'+128
01:002029DE D3
01:002029DF 4A              	     2M          DC.B    10+0+NW,$65,$00
01:002029E0 65
01:002029E1 00
                            	  5719:          OPC     BN,E,10,66,00,0,NW    BNE
01:002029E2 424E            	     1M          DC.B    'BN','E'+128
01:002029E4 C5
01:002029E5 4A              	     2M          DC.B    10+0+NW,$66,$00
01:002029E6 66
01:002029E7 00
                            	  5720:          OPC     BE,Q,10,67,00,0,NW    BEQ
01:002029E8 4245            	     1M          DC.B    'BE','Q'+128
01:002029EA D1
01:002029EB 4A              	     2M          DC.B    10+0+NW,$67,$00
01:002029EC 67
01:002029ED 00
                            	  5721:          OPC     BV,C,10,68,00,0,NW    BVC
01:002029EE 4256            	     1M          DC.B    'BV','C'+128
01:002029F0 C3
01:002029F1 4A              	     2M          DC.B    10+0+NW,$68,$00
01:002029F2 68
01:002029F3 00
                            	  5722:          OPC     BV,S,10,69,00,0,NW    BVS
01:002029F4 4256            	     1M          DC.B    'BV','S'+128
01:002029F6 D3
01:002029F7 4A              	     2M          DC.B    10+0+NW,$69,$00
01:002029F8 69
01:002029F9 00
                            	  5723:          OPC     BP,L,10,6A,00,0,NW    BPL
01:002029FA 4250            	     1M          DC.B    'BP','L'+128
01:002029FC CC
01:002029FD 4A              	     2M          DC.B    10+0+NW,$6A,$00
01:002029FE 6A
01:002029FF 00
                            	  5724:          OPC     BM,I,10,6B,00,0,NW    BMI
01:00202A00 424D            	     1M          DC.B    'BM','I'+128
01:00202A02 C9
01:00202A03 4A              	     2M          DC.B    10+0+NW,$6B,$00
01:00202A04 6B
01:00202A05 00
                            	  5725:          OPC     BG,E,10,6C,00,0,NW    BGE
01:00202A06 4247            	     1M          DC.B    'BG','E'+128
01:00202A08 C5
01:00202A09 4A              	     2M          DC.B    10+0+NW,$6C,$00
01:00202A0A 6C
01:00202A0B 00
                            	  5726:          OPC     BL,T,10,6D,00,0,NW    BLT
01:00202A0C 424C            	     1M          DC.B    'BL','T'+128
01:00202A0E D4
01:00202A0F 4A              	     2M          DC.B    10+0+NW,$6D,$00
01:00202A10 6D
01:00202A11 00
                            	  5727:          OPC     BG,T,10,6E,00,0,NW    BGT
01:00202A12 4247            	     1M          DC.B    'BG','T'+128
01:00202A14 D4
01:00202A15 4A              	     2M          DC.B    10+0+NW,$6E,$00
01:00202A16 6E
01:00202A17 00
                            	  5728:          OPC     BL,E,10,6F,00,0,NW    BLE
01:00202A18 424C            	     1M          DC.B    'BL','E'+128
01:00202A1A C5
01:00202A1B 4A              	     2M          DC.B    10+0+NW,$6F,$00
01:00202A1C 6F
01:00202A1D 00
                            	  5729:          OPC     BCH,G,9,01,40,0,0     BCHG
01:00202A1E 424348          	     1M          DC.B    'BCH','G'+128
01:00202A21 C7
01:00202A22 09              	     2M          DC.B    9+0+0,$01,$40
01:00202A23 01
01:00202A24 40
                            	  5730:          OPC     BCL,R,30,01,80,0,0    BCLR      DYNAMIC
01:00202A25 42434C          	     1M          DC.B    'BCL','R'+128
01:00202A28 D2
01:00202A29 1E              	     2M          DC.B    30+0+0,$01,$80
01:00202A2A 01
01:00202A2B 80
                            	  5731:          OPC     BSE,T,11,01,C0,0,0    BSET
01:00202A2C 425345          	     1M          DC.B    'BSE','T'+128
01:00202A2F D4
01:00202A30 0B              	     2M          DC.B    11+0+0,$01,$C0
01:00202A31 01
01:00202A32 C0
                            	  5732:          OPC     BS,R,10,61,00,0,NW    BSR
01:00202A33 4253            	     1M          DC.B    'BS','R'+128
01:00202A35 D2
01:00202A36 4A              	     2M          DC.B    10+0+NW,$61,$00
01:00202A37 61
01:00202A38 00
                            	  5733:          OPC     BTS,T,31,01,00,0,0    BTST
01:00202A39 425453          	     1M          DC.B    'BTS','T'+128
01:00202A3C D4
01:00202A3D 1F              	     2M          DC.B    31+0+0,$01,$00
01:00202A3E 01
01:00202A3F 00
                            	  5734:          OPC     B,T,10,60,00,0,NW     BT
01:00202A40 42              	     1M          DC.B    'B','T'+128
01:00202A41 D4
01:00202A42 4A              	     2M          DC.B    10+0+NW,$60,$00
01:00202A43 60
01:00202A44 00
                            	  5735:          OPC     CH,K,12,41,80,0,0     CHK
01:00202A45 4348            	     1M          DC.B    'CH','K'+128
01:00202A47 CB
01:00202A48 0C              	     2M          DC.B    12+0+0,$41,$80
01:00202A49 41
01:00202A4A 80
                            	  5736:          OPC     CL,R,13,42,00,0,0     CLR
01:00202A4B 434C            	     1M          DC.B    'CL','R'+128
01:00202A4D D2
01:00202A4E 0D              	     2M          DC.B    13+0+0,$42,$00
01:00202A4F 42
01:00202A50 00
                            	  5737:          OPC     CMP,A,2,B0,C0,0,0     CMPA
01:00202A51 434D50          	     1M          DC.B    'CMP','A'+128
01:00202A54 C1
01:00202A55 02              	     2M          DC.B    2+0+0,$B0,$C0
01:00202A56 B0
01:00202A57 C0
                            	  5738:          OPC     CMP,I,3,0C,00,0,0     CMPI
01:00202A58 434D50          	     1M          DC.B    'CMP','I'+128
01:00202A5B C9
01:00202A5C 03              	     2M          DC.B    3+0+0,$0C,$00
01:00202A5D 0C
01:00202A5E 00
                            	  5739:          OPC     CMP,M,14,B1,08,0,0    CMPM
01:00202A5F 434D50          	     1M          DC.B    'CMP','M'+128
01:00202A62 CD
01:00202A63 0E              	     2M          DC.B    14+0+0,$B1,$08
01:00202A64 B1
01:00202A65 08
                            	  5740:          OPC     CM,P,34,B0,00,0,0     CMP
01:00202A66 434D            	     1M          DC.B    'CM','P'+128
01:00202A68 D0
01:00202A69 22              	     2M          DC.B    34+0+0,$B0,$00
01:00202A6A B0
01:00202A6B 00
                            	  5741:          OPC     DB,T,8,50,C8,0,NW     DBT
01:00202A6C 4442            	     1M          DC.B    'DB','T'+128
01:00202A6E D4
01:00202A6F 48              	     2M          DC.B    8+0+NW,$50,$C8
01:00202A70 50
01:00202A71 C8
                            	  5742:          OPC     DB,F,8,51,C8,0,NW     DBF
01:00202A72 4442            	     1M          DC.B    'DB','F'+128
01:00202A74 C6
01:00202A75 48              	     2M          DC.B    8+0+NW,$51,$C8
01:00202A76 51
01:00202A77 C8
                            	  5743:          OPC     DBR,A,8,51,C8,0,NW    DBRA
01:00202A78 444252          	     1M          DC.B    'DBR','A'+128
01:00202A7B C1
01:00202A7C 48              	     2M          DC.B    8+0+NW,$51,$C8
01:00202A7D 51
01:00202A7E C8
                            	  5744:          OPC     DBH,I,8,52,C8,0,NW    DBHI
01:00202A7F 444248          	     1M          DC.B    'DBH','I'+128
01:00202A82 C9
01:00202A83 48              	     2M          DC.B    8+0+NW,$52,$C8
01:00202A84 52
01:00202A85 C8
                            	  5745:          OPC     DBL,S,8,53,C8,0,NW    DBLS
01:00202A86 44424C          	     1M          DC.B    'DBL','S'+128
01:00202A89 D3
01:00202A8A 48              	     2M          DC.B    8+0+NW,$53,$C8
01:00202A8B 53
01:00202A8C C8
                            	  5746:          OPC     DBC,C,8,54,C8,0,NW    DBCC
01:00202A8D 444243          	     1M          DC.B    'DBC','C'+128
01:00202A90 C3
01:00202A91 48              	     2M          DC.B    8+0+NW,$54,$C8
01:00202A92 54
01:00202A93 C8
                            	  5747:          OPC     DBC,S,8,55,C8,0,NW    DBCS
01:00202A94 444243          	     1M          DC.B    'DBC','S'+128
01:00202A97 D3
01:00202A98 48              	     2M          DC.B    8+0+NW,$55,$C8
01:00202A99 55
01:00202A9A C8
                            	  5748:          OPC     DBN,E,8,56,C8,0,NW    DBNE
01:00202A9B 44424E          	     1M          DC.B    'DBN','E'+128
01:00202A9E C5
01:00202A9F 48              	     2M          DC.B    8+0+NW,$56,$C8
01:00202AA0 56
01:00202AA1 C8
                            	  5749:          OPC     DBE,Q,8,57,C8,0,NW    DBEQ
01:00202AA2 444245          	     1M          DC.B    'DBE','Q'+128
01:00202AA5 D1
01:00202AA6 48              	     2M          DC.B    8+0+NW,$57,$C8
01:00202AA7 57
01:00202AA8 C8
                            	  5750:          OPC     DBV,C,8,58,C8,0,NW    DBVC
01:00202AA9 444256          	     1M          DC.B    'DBV','C'+128
01:00202AAC C3
01:00202AAD 48              	     2M          DC.B    8+0+NW,$58,$C8
01:00202AAE 58
01:00202AAF C8
                            	  5751:          OPC     DBV,S,8,59,C8,0,NW    DBVS
01:00202AB0 444256          	     1M          DC.B    'DBV','S'+128
01:00202AB3 D3
01:00202AB4 48              	     2M          DC.B    8+0+NW,$59,$C8
01:00202AB5 59
01:00202AB6 C8
                            	  5752:          OPC     DBP,L,8,5A,C8,0,NW    DBPL
01:00202AB7 444250          	     1M          DC.B    'DBP','L'+128
01:00202ABA CC
01:00202ABB 48              	     2M          DC.B    8+0+NW,$5A,$C8
01:00202ABC 5A
01:00202ABD C8
                            	  5753:          OPC     DBM,I,8,5B,C8,0,NW    DBMI
01:00202ABE 44424D          	     1M          DC.B    'DBM','I'+128
01:00202AC1 C9
01:00202AC2 48              	     2M          DC.B    8+0+NW,$5B,$C8
01:00202AC3 5B
01:00202AC4 C8
                            	  5754:          OPC     DBG,E,8,5C,C8,0,NW    DBGE
01:00202AC5 444247          	     1M          DC.B    'DBG','E'+128
01:00202AC8 C5
01:00202AC9 48              	     2M          DC.B    8+0+NW,$5C,$C8
01:00202ACA 5C
01:00202ACB C8
                            	  5755:          OPC     DBL,T,8,5D,C8,0,NW    DBLT
01:00202ACC 44424C          	     1M          DC.B    'DBL','T'+128
01:00202ACF D4
01:00202AD0 48              	     2M          DC.B    8+0+NW,$5D,$C8
01:00202AD1 5D
01:00202AD2 C8
                            	  5756:          OPC     DBG,T,8,5E,C8,0,NW    DBGT
01:00202AD3 444247          	     1M          DC.B    'DBG','T'+128
01:00202AD6 D4
01:00202AD7 48              	     2M          DC.B    8+0+NW,$5E,$C8
01:00202AD8 5E
01:00202AD9 C8
                            	  5757:          OPC     DBL,E,8,5F,C8,0,NW    DBLE
01:00202ADA 44424C          	     1M          DC.B    'DBL','E'+128
01:00202ADD C5
01:00202ADE 48              	     2M          DC.B    8+0+NW,$5F,$C8
01:00202ADF 5F
01:00202AE0 C8
                            	  5758:          OPC     DC.,W,37,00,00,0,0    DC.W  (WORD ONLY)
01:00202AE1 44432E          	     1M          DC.B    'DC.','W'+128
01:00202AE4 D7
01:00202AE5 25              	     2M          DC.B    37+0+0,$00,$00
01:00202AE6 00
01:00202AE7 00
                            	  5759:          OPC     DIV,S,12,81,C0,0,0    DIVS
01:00202AE8 444956          	     1M          DC.B    'DIV','S'+128
01:00202AEB D3
01:00202AEC 0C              	     2M          DC.B    12+0+0,$81,$C0
01:00202AED 81
01:00202AEE C0
                            	  5760:          OPC     DIV,U,12,80,C0,0,0    DIVU
01:00202AEF 444956          	     1M          DC.B    'DIV','U'+128
01:00202AF2 D5
01:00202AF3 0C              	     2M          DC.B    12+0+0,$80,$C0
01:00202AF4 80
01:00202AF5 C0
                            	  5761:          OPC     EOR,I,28,0A,00,0,0    EORI
01:00202AF6 454F52          	     1M          DC.B    'EOR','I'+128
01:00202AF9 C9
01:00202AFA 1C              	     2M          DC.B    28+0+0,$0A,$00
01:00202AFB 0A
01:00202AFC 00
                            	  5762:          OPC     EO,R,35,B1,00,0,0     EOR
01:00202AFD 454F            	     1M          DC.B    'EO','R'+128
01:00202AFF D2
01:00202B00 23              	     2M          DC.B    35+0+0,$B1,$00
01:00202B01 B1
01:00202B02 00
                            	  5763:          OPC     EX,G,16,C1,00,0,0     EXG
01:00202B03 4558            	     1M          DC.B    'EX','G'+128
01:00202B05 C7
01:00202B06 10              	     2M          DC.B    16+0+0,$C1,$00
01:00202B07 C1
01:00202B08 00
                            	  5764:          OPC     EX,T,17,48,00,0,0     EXT
01:00202B09 4558            	     1M          DC.B    'EX','T'+128
01:00202B0B D4
01:00202B0C 11              	     2M          DC.B    17+0+0,$48,$00
01:00202B0D 48
01:00202B0E 00
                            	  5765:          OPC     JM,P,18,4E,C0,0,NW    JMP
01:00202B0F 4A4D            	     1M          DC.B    'JM','P'+128
01:00202B11 D0
01:00202B12 52              	     2M          DC.B    18+0+NW,$4E,$C0
01:00202B13 4E
01:00202B14 C0
                            	  5766:          OPC     JS,R,18,4E,80,0,NW    JSR
01:00202B15 4A53            	     1M          DC.B    'JS','R'+128
01:00202B17 D2
01:00202B18 52              	     2M          DC.B    18+0+NW,$4E,$80
01:00202B19 4E
01:00202B1A 80
                            	  5767:          OPC     LE,A,19,41,C0,0,0     LEA
01:00202B1B 4C45            	     1M          DC.B    'LE','A'+128
01:00202B1D C1
01:00202B1E 13              	     2M          DC.B    19+0+0,$41,$C0
01:00202B1F 41
01:00202B20 C0
                            	  5768:          OPC     LIN,K,20,4E,50,0,0    LINK
01:00202B21 4C494E          	     1M          DC.B    'LIN','K'+128
01:00202B24 CB
01:00202B25 14              	     2M          DC.B    20+0+0,$4E,$50
01:00202B26 4E
01:00202B27 50
                            	  5769:          OPC     LS,L,7,E3,08,0,0      LSL
01:00202B28 4C53            	     1M          DC.B    'LS','L'+128
01:00202B2A CC
01:00202B2B 07              	     2M          DC.B    7+0+0,$E3,$08
01:00202B2C E3
01:00202B2D 08
                            	  5770:          OPC     LS,R,07,E2,08,0,0     LSR
01:00202B2E 4C53            	     1M          DC.B    'LS','R'+128
01:00202B30 D2
01:00202B31 07              	     2M          DC.B    07+0+0,$E2,$08
01:00202B32 E2
01:00202B33 08
                            	  5771:          OPC     MOVE,A,32,00,04,0,0   MOVEA
01:00202B34 4D4F5645        	     1M          DC.B    'MOVE','A'+128
01:00202B38 C1
01:00202B39 20              	     2M          DC.B    32+0+0,$00,$04
01:00202B3A 00
01:00202B3B 04
                            	  5772:          OPC     MOVE,M,27,48,80,0,0   MOVEM
01:00202B3C 4D4F5645        	     1M          DC.B    'MOVE','M'+128
01:00202B40 CD
01:00202B41 1B              	     2M          DC.B    27+0+0,$48,$80
01:00202B42 48
01:00202B43 80
                            	  5773:          OPC     MOVE,P,33,01,08,0,0   MOVEP
01:00202B44 4D4F5645        	     1M          DC.B    'MOVE','P'+128
01:00202B48 D0
01:00202B49 21              	     2M          DC.B    33+0+0,$01,$08
01:00202B4A 01
01:00202B4B 08
                            	  5774:          OPC     MOVE,Q,15,70,00,0,0   MOVEQ
01:00202B4C 4D4F5645        	     1M          DC.B    'MOVE','Q'+128
01:00202B50 D1
01:00202B51 0F              	     2M          DC.B    15+0+0,$70,$00
01:00202B52 70
01:00202B53 00
                            	  5775:          OPC     MOV,E,21,00,00,0,0    MOVE
01:00202B54 4D4F56          	     1M          DC.B    'MOV','E'+128
01:00202B57 C5
01:00202B58 15              	     2M          DC.B    21+0+0,$00,$00
01:00202B59 00
01:00202B5A 00
                            	  5776:          OPC     MUL,S,12,C1,C0,0,0    MULS
01:00202B5B 4D554C          	     1M          DC.B    'MUL','S'+128
01:00202B5E D3
01:00202B5F 0C              	     2M          DC.B    12+0+0,$C1,$C0
01:00202B60 C1
01:00202B61 C0
                            	  5777:          OPC     MUL,U,12,C0,C0,0,0    MULU
01:00202B62 4D554C          	     1M          DC.B    'MUL','U'+128
01:00202B65 D5
01:00202B66 0C              	     2M          DC.B    12+0+0,$C0,$C0
01:00202B67 C0
01:00202B68 C0
                            	  5778:          OPC     NBC,D,29,48,0,0,0     NBCD
01:00202B69 4E4243          	     1M          DC.B    'NBC','D'+128
01:00202B6C C4
01:00202B6D 1D              	     2M          DC.B    29+0+0,$48,$0
01:00202B6E 48
01:00202B6F 00
                            	  5779:          OPC     NEG,X,13,40,00,0,0    NEGX
01:00202B70 4E4547          	     1M          DC.B    'NEG','X'+128
01:00202B73 D8
01:00202B74 0D              	     2M          DC.B    13+0+0,$40,$00
01:00202B75 40
01:00202B76 00
                            	  5780:          OPC     NE,G,13,44,00,0,0     NEG
01:00202B77 4E45            	     1M          DC.B    'NE','G'+128
01:00202B79 C7
01:00202B7A 0D              	     2M          DC.B    13+0+0,$44,$00
01:00202B7B 44
01:00202B7C 00
                            	  5781:          OPC     NO,P,22,4E,71,NOC,0   NOP
01:00202B7D 4E4F            	     1M          DC.B    'NO','P'+128
01:00202B7F D0
01:00202B80 96              	     2M          DC.B    22+NOC+0,$4E,$71
01:00202B81 4E
01:00202B82 71
                            	  5782:          OPC     NO,T,13,46,00,0,0     NOT
01:00202B83 4E4F            	     1M          DC.B    'NO','T'+128
01:00202B85 D4
01:00202B86 0D              	     2M          DC.B    13+0+0,$46,$00
01:00202B87 46
01:00202B88 00
                            	  5783:          OPC     OR,I,28,00,00,0,0     ORI
01:00202B89 4F52            	     1M          DC.B    'OR','I'+128
01:00202B8B C9
01:00202B8C 1C              	     2M          DC.B    28+0+0,$00,$00
01:00202B8D 00
01:00202B8E 00
                            	  5784:          OPC     O,R,6,80,00,0,0       OR
01:00202B8F 4F              	     1M          DC.B    'O','R'+128
01:00202B90 D2
01:00202B91 06              	     2M          DC.B    6+0+0,$80,$00
01:00202B92 80
01:00202B93 00
                            	  5785:          OPC     PE,A,36,48,40,0,0     PEA
01:00202B94 5045            	     1M          DC.B    'PE','A'+128
01:00202B96 C1
01:00202B97 24              	     2M          DC.B    36+0+0,$48,$40
01:00202B98 48
01:00202B99 40
                            	  5786:          OPC     RESE,T,22,4E,70,NOC,0 RESET
01:00202B9A 52455345        	     1M          DC.B    'RESE','T'+128
01:00202B9E D4
01:00202B9F 96              	     2M          DC.B    22+NOC+0,$4E,$70
01:00202BA0 4E
01:00202BA1 70
                            	  5787:          OPC     RO,L,7,E7,18,0,0      ROL
01:00202BA2 524F            	     1M          DC.B    'RO','L'+128
01:00202BA4 CC
01:00202BA5 07              	     2M          DC.B    7+0+0,$E7,$18
01:00202BA6 E7
01:00202BA7 18
                            	  5788:          OPC     RO,R,07,E6,18,0,0     ROR
01:00202BA8 524F            	     1M          DC.B    'RO','R'+128
01:00202BAA D2
01:00202BAB 07              	     2M          DC.B    07+0+0,$E6,$18
01:00202BAC E6
01:00202BAD 18
                            	  5789:          OPC     ROX,L,7,E5,10,0,0     ROXL
01:00202BAE 524F58          	     1M          DC.B    'ROX','L'+128
01:00202BB1 CC
01:00202BB2 07              	     2M          DC.B    7+0+0,$E5,$10
01:00202BB3 E5
01:00202BB4 10
                            	  5790:          OPC     ROX,R,07,E4,10,0,0    ROXR
01:00202BB5 524F58          	     1M          DC.B    'ROX','R'+128
01:00202BB8 D2
01:00202BB9 07              	     2M          DC.B    07+0+0,$E4,$10
01:00202BBA E4
01:00202BBB 10
                            	  5791:          OPC     RT,E,22,4E,73,NOC,0   RTE
01:00202BBC 5254            	     1M          DC.B    'RT','E'+128
01:00202BBE C5
01:00202BBF 96              	     2M          DC.B    22+NOC+0,$4E,$73
01:00202BC0 4E
01:00202BC1 73
                            	  5792:          OPC     RT,R,22,4E,77,NOC,0   RTR
01:00202BC2 5254            	     1M          DC.B    'RT','R'+128
01:00202BC4 D2
01:00202BC5 96              	     2M          DC.B    22+NOC+0,$4E,$77
01:00202BC6 4E
01:00202BC7 77
                            	  5793:          OPC     RT,S,22,4E,75,NOC,0   RTS
01:00202BC8 5254            	     1M          DC.B    'RT','S'+128
01:00202BCA D3
01:00202BCB 96              	     2M          DC.B    22+NOC+0,$4E,$75
01:00202BCC 4E
01:00202BCD 75
                            	  5794:          OPC     SBC,D,0,81,00,0,0     SBCD
01:00202BCE 534243          	     1M          DC.B    'SBC','D'+128
01:00202BD1 C4
01:00202BD2 00              	     2M          DC.B    0+0+0,$81,$00
01:00202BD3 81
01:00202BD4 00
                            	  5795:          OPC     S,F,29,51,C0,0,0      SF
01:00202BD5 53              	     1M          DC.B    'S','F'+128
01:00202BD6 C6
01:00202BD7 1D              	     2M          DC.B    29+0+0,$51,$C0
01:00202BD8 51
01:00202BD9 C0
                            	  5796:          OPC     SH,I,29,52,C0,0,0     SHI
01:00202BDA 5348            	     1M          DC.B    'SH','I'+128
01:00202BDC C9
01:00202BDD 1D              	     2M          DC.B    29+0+0,$52,$C0
01:00202BDE 52
01:00202BDF C0
                            	  5797:          OPC     SL,S,29,53,C0,0,0     SLS
01:00202BE0 534C            	     1M          DC.B    'SL','S'+128
01:00202BE2 D3
01:00202BE3 1D              	     2M          DC.B    29+0+0,$53,$C0
01:00202BE4 53
01:00202BE5 C0
                            	  5798:          OPC     SC,C,29,54,C0,0,0     SCC
01:00202BE6 5343            	     1M          DC.B    'SC','C'+128
01:00202BE8 C3
01:00202BE9 1D              	     2M          DC.B    29+0+0,$54,$C0
01:00202BEA 54
01:00202BEB C0
                            	  5799:          OPC     SC,S,29,55,C0,0,0     SCS
01:00202BEC 5343            	     1M          DC.B    'SC','S'+128
01:00202BEE D3
01:00202BEF 1D              	     2M          DC.B    29+0+0,$55,$C0
01:00202BF0 55
01:00202BF1 C0
                            	  5800:          OPC     SN,E,29,56,C0,0,0     SNE
01:00202BF2 534E            	     1M          DC.B    'SN','E'+128
01:00202BF4 C5
01:00202BF5 1D              	     2M          DC.B    29+0+0,$56,$C0
01:00202BF6 56
01:00202BF7 C0
                            	  5801:          OPC     SE,Q,29,57,C0,0,0     SEQ
01:00202BF8 5345            	     1M          DC.B    'SE','Q'+128
01:00202BFA D1
01:00202BFB 1D              	     2M          DC.B    29+0+0,$57,$C0
01:00202BFC 57
01:00202BFD C0
                            	  5802:          OPC     SV,C,29,58,C0,0,0     SVC
01:00202BFE 5356            	     1M          DC.B    'SV','C'+128
01:00202C00 C3
01:00202C01 1D              	     2M          DC.B    29+0+0,$58,$C0
01:00202C02 58
01:00202C03 C0
                            	  5803:          OPC     SV,S,29,59,C0,0,0     SVS
01:00202C04 5356            	     1M          DC.B    'SV','S'+128
01:00202C06 D3
01:00202C07 1D              	     2M          DC.B    29+0+0,$59,$C0
01:00202C08 59
01:00202C09 C0
                            	  5804:          OPC     SP,L,29,5A,C0,0,0     SPL
01:00202C0A 5350            	     1M          DC.B    'SP','L'+128
01:00202C0C CC
01:00202C0D 1D              	     2M          DC.B    29+0+0,$5A,$C0
01:00202C0E 5A
01:00202C0F C0
                            	  5805:          OPC     SM,I,29,5B,C0,0,0     SMI
01:00202C10 534D            	     1M          DC.B    'SM','I'+128
01:00202C12 C9
01:00202C13 1D              	     2M          DC.B    29+0+0,$5B,$C0
01:00202C14 5B
01:00202C15 C0
                            	  5806:          OPC     SG,E,29,5C,C0,0,0     SGE
01:00202C16 5347            	     1M          DC.B    'SG','E'+128
01:00202C18 C5
01:00202C19 1D              	     2M          DC.B    29+0+0,$5C,$C0
01:00202C1A 5C
01:00202C1B C0
                            	  5807:          OPC     SL,T,29,5D,C0,0,0     SLT
01:00202C1C 534C            	     1M          DC.B    'SL','T'+128
01:00202C1E D4
01:00202C1F 1D              	     2M          DC.B    29+0+0,$5D,$C0
01:00202C20 5D
01:00202C21 C0
                            	  5808:          OPC     SG,T,29,5E,C0,0,0     SGT
01:00202C22 5347            	     1M          DC.B    'SG','T'+128
01:00202C24 D4
01:00202C25 1D              	     2M          DC.B    29+0+0,$5E,$C0
01:00202C26 5E
01:00202C27 C0
                            	  5809:          OPC     SL,E,29,5F,C0,0,0     SLE
01:00202C28 534C            	     1M          DC.B    'SL','E'+128
01:00202C2A C5
01:00202C2B 1D              	     2M          DC.B    29+0+0,$5F,$C0
01:00202C2C 5F
01:00202C2D C0
                            	  5810:          OPC     STO,P,23,4E,72,0,0    STOP
01:00202C2E 53544F          	     1M          DC.B    'STO','P'+128
01:00202C31 D0
01:00202C32 17              	     2M          DC.B    23+0+0,$4E,$72
01:00202C33 4E
01:00202C34 72
                            	  5811:          OPC     S,T,29,50,C0,0,0      ST
01:00202C35 53              	     1M          DC.B    'S','T'+128
01:00202C36 D4
01:00202C37 1D              	     2M          DC.B    29+0+0,$50,$C0
01:00202C38 50
01:00202C39 C0
                            	  5812:          OPC     SUB,A,2,90,C0,0,0     SUBA
01:00202C3A 535542          	     1M          DC.B    'SUB','A'+128
01:00202C3D C1
01:00202C3E 02              	     2M          DC.B    2+0+0,$90,$C0
01:00202C3F 90
01:00202C40 C0
                            	  5813:          OPC     SUB,I,3,04,00,0,0     SUBI
01:00202C41 535542          	     1M          DC.B    'SUB','I'+128
01:00202C44 C9
01:00202C45 03              	     2M          DC.B    3+0+0,$04,$00
01:00202C46 04
01:00202C47 00
                            	  5814:          OPC     SUB,Q,4,51,00,0,0     SUBQ
01:00202C48 535542          	     1M          DC.B    'SUB','Q'+128
01:00202C4B D1
01:00202C4C 04              	     2M          DC.B    4+0+0,$51,$00
01:00202C4D 51
01:00202C4E 00
                            	  5815:          OPC     SUB,X,5,91,00,0,0     SUBX
01:00202C4F 535542          	     1M          DC.B    'SUB','X'+128
01:00202C52 D8
01:00202C53 05              	     2M          DC.B    5+0+0,$91,$00
01:00202C54 91
01:00202C55 00
                            	  5816:          OPC     SU,B,1,90,00,0,0      SUB
01:00202C56 5355            	     1M          DC.B    'SU','B'+128
01:00202C58 C2
01:00202C59 01              	     2M          DC.B    1+0+0,$90,$00
01:00202C5A 90
01:00202C5B 00
                            	  5817:          OPC     SWA,P,24,48,40,0,0    SWAP
01:00202C5C 535741          	     1M          DC.B    'SWA','P'+128
01:00202C5F D0
01:00202C60 18              	     2M          DC.B    24+0+0,$48,$40
01:00202C61 48
01:00202C62 40
                            	  5818:          OPC     TA,S,29,4A,C0,0,0     TAS
01:00202C63 5441            	     1M          DC.B    'TA','S'+128
01:00202C65 D3
01:00202C66 1D              	     2M          DC.B    29+0+0,$4A,$C0
01:00202C67 4A
01:00202C68 C0
                            	  5819:          OPC     TRAP,V,22,4E,76,NOC,0 TRAPV
01:00202C69 54524150        	     1M          DC.B    'TRAP','V'+128
01:00202C6D D6
01:00202C6E 96              	     2M          DC.B    22+NOC+0,$4E,$76
01:00202C6F 4E
01:00202C70 76
                            	  5820:          OPC     TRA,P,25,4E,40,0,0    TRAP
01:00202C71 545241          	     1M          DC.B    'TRA','P'+128
01:00202C74 D0
01:00202C75 19              	     2M          DC.B    25+0+0,$4E,$40
01:00202C76 4E
01:00202C77 40
                            	  5821:          OPC     TS,T,13,4A,00,0,0     TST
01:00202C78 5453            	     1M          DC.B    'TS','T'+128
01:00202C7A D4
01:00202C7B 0D              	     2M          DC.B    13+0+0,$4A,$00
01:00202C7C 4A
01:00202C7D 00
                            	  5822:          OPC     UNL,K,26,4E,58,0,0    UNLK
01:00202C7E 554E4C          	     1M          DC.B    'UNL','K'+128
01:00202C81 CB
01:00202C82 1A              	     2M          DC.B    26+0+0,$4E,$58
01:00202C83 4E
01:00202C84 58
                            	  5823: 
01:00202C85 00              	  5824:          DC.B    0              PAD BYTE
                            	  5825: 
                            	  5826: TBLOPCE  DS      0
                            	  5827: 
                            	  5828: * WITHOUT LABEL FIELD
                            	  5829: * 012345678901234567890123456789012345678901234567890
                            	  5830: * AAAAAA DDDDDDDDDDDDDDDDDDDD OPCODE  OPERAND
                            	  5831: *        FDATA                FOC     FOP
                            	  5832: 
                            	  5833: * 012345678901234567890123456789012345678901234567890
                            	  5834: * AAAAAA DDDDDDDDDDDDDDDDDDDD LLLLLLLL OPCODE  OPERAND
                            	  5835: *        FDATA                FOL      FOC     FOP
                            	  5836: 
                            	  5837: * A3 = STORE POINTER
                            	  5838: * A4 = PROGRAM COUNTER
                            	  5839: * A5 = SOURCE PTR BEGINNING
                            	  5840: * A6 = SOURCE PTR END+1
                            	  5841: *
                            	  5842: OUTBSIZE EQU     80        BUFFER SIZE
                            	  5843: FDATA    EQU     10        OFFSET TO DATA
                            	  5844: FOL      EQU     31        OFFSET TO LABEL
                            	  5845: FOC      EQU     31        OFFSET TO OP-CODE (NO LABEL FIELD)
                            	  5846: FOP      EQU     39        OFFSET TO OPERAND (NO LABEL FIELD)
                            	  5847: 
01:00202C86 4E51FFDE        	  5848: CODE68K  LINK    A1,#0-(ESKE-ESKB)
01:00202C8A 2F49001E        	  5849:          MOVE.L  A1,LINK(A7)    SAVE LINKAGE
01:00202C8E 224F            	  5850:          MOVE.L  A7,A1          A1 = BASE REGISTER TO DATA
                            	  5851: 
01:00202C90 1CBC0020        	  5852:          MOVE.B  #BLANK,(A6)    INSURE LAST CHAR IS SPACE
                            	  5853: 
01:00202C94 204B            	  5854:          MOVE.L  A3,A0
01:00202C96 704F            	  5855:          MOVEQ   #OUTBSIZE-1,D0
01:00202C98 10FC0020        	  5856: M300     MOVE.B  #BLANK,(A0)+   SPACE FILL BUFFER
01:00202C9C 51C8FFFA        	  5857:          DBRA    D0,M300
01:00202CA0 5588            	  5858:          SUBQ.L  #2,A0
01:00202CA2 2348001A        	  5859:          MOVE.L  A0,PTRBUFE(A1) PTR TO END OF BUFFER
                            	  5860: 
01:00202CA6 234C000E        	  5861:          MOVE.L  A4,PCOUNTER(A1)  FORMAT PC
01:00202CAA 280C            	  5862:          MOVE.L  A4,D4          D4 = P-COUNTER
01:00202CAC 200C            	  5863:          MOVE.L  A4,D0
                            	  5864: 
01:00202CAE 2F0E            	  5865:          MOVE.L  A6,-(A7)       SAVE A6
01:00202CB0 2C4B            	  5866:          MOVE.L  A3,A6
01:00202CB2 6100F11A        	  5867:          BSR     FRELADDR       FORM RELATIVE ADDRESS
01:00202CB6 2C5F            	  5868:          MOVE.L  (A7)+,A6       RESTORE A6
                            	  5869: 
01:00202CB8 7E01            	  5870:          MOVEQ   #1,D7          POSSIBLE ERROR CODE
01:00202CBA 200C            	  5871:          MOVE.L  A4,D0
01:00202CBC E298            	  5872:          ROR.L   #1,D0
01:00202CBE 6B00013A        	  5873:          BMI     ERDONE         PC ODD ADDRESS
                            	  5874: 
01:00202CC2 7E1F            	  5875:          MOVEQ   #FOL,D7        POSSIBLE ERROR CODE
01:00202CC4 0C1D0020        	  5876:          CMPI.B  #BLANK,(A5)+
01:00202CC8 66000130        	  5877:          BNE     ERDONE         1ST CHAR NOT SPACE
                            	  5878: 
01:00202CCC 137C0002000A    	  5879:          MOVE.B  #2,TNB(A1)     INZ # OF BYTES
01:00202CD2 337C0040000C    	  5880:          MOVE.W  #$40,TLENGTH(A1)  SIZE = .W (DEFAULT)
01:00202CD8 4229000B        	  5881:          CLR.B   TLSPEC(A1)     DEFAULT (SIZE NOT SPECIFIED)
                            	  5882: 
01:00202CDC 204B            	  5883:          MOVE.L  A3,A0          A0 = STORE ADDRESS
01:00202CDE 41E8001F        	  5884:          ADD.L   #FOC,A0
                            	  5885: 
01:00202CE2 61000108        	  5886: M340     BSR     GETCHARF       GET PAST SPACES
01:00202CE6 0C000020        	  5887:          CMPI.B  #BLANK,D0
01:00202CEA 67F6            	  5888:          BEQ     M340
                            	  5889: 
01:00202CEC 538D            	  5890:          SUBQ.L  #1,A5          FORMAT OP-CODE
01:00202CEE 610000FC        	  5891: M350     BSR     GETCHARF
01:00202CF2 10C0            	  5892:          MOVE.B  D0,(A0)+
01:00202CF4 0C00002E        	  5893:          CMPI.B  #'.',D0
01:00202CF8 6628            	  5894:          BNE.S   M352
                            	  5895: 
01:00202CFA 1355000B        	  5896:          MOVE.B  (A5),TLSPEC(A1)  NOT DEFAULT
01:00202CFE 0C150057        	  5897:          CMPI.B  #'W',(A5)
01:00202D02 671E            	  5898:          BEQ.S   M352
01:00202D04 0C150053        	  5899:          CMPI.B  #'S',(A5)
01:00202D08 6718            	  5900:          BEQ.S   M352           .SHORT = .WORD
01:00202D0A 4269000C        	  5901:          CLR.W   TLENGTH(A1)
01:00202D0E 0C150042        	  5902:          CMPI.B  #'B',(A5)
01:00202D12 670E            	  5903:          BEQ.S   M352           SIZE = .W
01:00202D14 337C0080000C    	  5904:          MOVE.W  #$80,TLENGTH(A1)
01:00202D1A 0C15004C        	  5905:          CMPI.B  #'L',(A5)
01:00202D1E 660000D4        	  5906:          BNE     ERF
                            	  5907: 
01:00202D22 0C000020        	  5908: M352     CMPI.B  #BLANK,D0
01:00202D26 66C6            	  5909:          BNE     M350           NOT SPACE CONTINUE
                            	  5910: 
                            	  5911: * SEARCH OP-CODE TABLE
01:00202D28 41FAFC58        	  5912:          LEA     TBLOPC(PC),A0  A0 = PTR TO TABLE OF CODES
01:00202D2C 244B            	  5913: M410     MOVE.L  A3,A2          A3 = START OF STORE BUFFER
01:00202D2E 45EA001F        	  5914:          ADD.L   #FOC,A2        A2 = PTR TO OP-CODE JUST FORMATTED
                            	  5915: 
01:00202D32 1018            	  5916: M415     MOVE.B  (A0)+,D0       XXXXXXDD
01:00202D34 4880            	  5917:          EXT.W   D0             XXXXSSDD  SIGN EXTENDED
01:00202D36 0200007F        	  5918:          ANDI.B  #$7F,D0
01:00202D3A B01A            	  5919:          CMP.B   (A2)+,D0
01:00202D3C 6606            	  5920:          BNE.S   M420           NON-MATCH
01:00202D3E 4A40            	  5921:          TST.W   D0
01:00202D40 6AF0            	  5922:          BPL     M415           SIGN RESET; CONTINUE
01:00202D42 6018            	  5923:          BRA.S   M430           MATCH COMPLETE
                            	  5924: 
01:00202D44 4A40            	  5925: M420     TST.W   D0             SEQUENCE TO NEXT CODE
01:00202D46 6B04            	  5926:          BMI.S   M426
01:00202D48 1018            	  5927: M424     MOVE.B  (A0)+,D0
01:00202D4A 6AFC            	  5928:          BPL     M424           FINISH THIS OP-CODE
01:00202D4C 5688            	  5929: M426     ADDQ.L  #3,A0          ADJUST PTR TO TABLE
01:00202D4E 45FAFF36        	  5930:          LEA     TBLOPCE(PC),A2
01:00202D52 B5C8            	  5931:          CMP.L   A0,A2
01:00202D54 66D6            	  5932:          BNE     M410
                            	  5933: 
01:00202D56 7E1F            	  5934: M428     MOVEQ   #FOC,D7        ERROR CODE
01:00202D58 600000A0        	  5935:          BRA     ERDONE
                            	  5936: 
                            	  5937: * GET GOTO INDEX
                            	  5938: * GET FIRST WORD MASK
01:00202D5C 1012            	  5939: M430     MOVE.B  (A2),D0        MUST TERMINATE OP-CODE
01:00202D5E 0C000020        	  5940:          CMPI.B  #BLANK,D0        WITH SPACE OR PERIOD
01:00202D62 6706            	  5941:          BEQ.S   M432
01:00202D64 0C00002E        	  5942:          CMPI.B  #'.',D0
01:00202D68 66EC            	  5943:          BNE     M428           ERROR
                            	  5944: M432
                            	  5945: 
01:00202D6A 7000            	  5946:          CLR.L   D0
01:00202D6C 1018            	  5947:          MOVE.B  (A0)+,D0       D0 =  KEYS  INDEX
01:00202D6E 1200            	  5948:          MOVE.B  D0,D1          D1 =  KEYS (INDEX)
01:00202D70 0200003F        	  5949:          ANDI.B  #$3F,D0        D0 =        INDEX
01:00202D74 D080            	  5950:          ASL.L   #1,D0          INDEX * TWO
01:00202D76 1418            	  5951:          MOVE.B  (A0)+,D2
01:00202D78 E14A            	  5952:          LSL.W   #8,D2
01:00202D7A 1418            	  5953:          MOVE.B  (A0)+,D2       D2 = FIRST WORD MASK
01:00202D7C 3282            	  5954:          MOVE.W  D2,(A1)        *D2,TDATA(A1)
                            	  5955: 
                            	  5956: * INSURE .S .W MATCH OP-CODE
                            	  5957: 
01:00202D7E 1629000B        	  5958:          MOVE.B  TLSPEC(A1),D3  D3 = .n SPECIFIED
01:00202D82 671A            	  5959:          BEQ.S   M4326          NOT SPECIFIED
01:00202D84 08010006        	  5960:          BTST    #6,D1
01:00202D88 670E            	  5961:          BEQ.S   M4324          .W ALLOWED (.S NOT ALLOWED)
01:00202D8A 0C030057        	  5962:          CMPI.B  #'W',D3
01:00202D8E 67C6            	  5963:          BEQ     M428           .W NOT ALLOWED
01:00202D90 0C030042        	  5964:          CMPI.B  #'B',D3
01:00202D94 67C0            	  5965:          BEQ     M428           .B NOT ALLOWED
01:00202D96 6006            	  5966:          BRA.S   M4326
                            	  5967: 
01:00202D98 0C030053        	  5968: M4324    CMPI.B  #'S',D3
01:00202D9C 67B8            	  5969:          BEQ     M428           .S NOT ALLOWED
                            	  5970: M4326
                            	  5971: 
                            	  5972: * CALCULATE GOTO ADDRESS
                            	  5973: 
01:00202D9E 41FAFB96        	  5974:          LEA     TBLKEYS(PC),A0 A0 = PTR TO KEYS
01:00202DA2 30300000        	  5975:          MOVE.W  (A0,D0),D0     D0 = 16 BIT OFFSET
01:00202DA6 45FAF884        	  5976:          LEA     XBASE(PC),A2   A2 = BASE ADDRESS
01:00202DAA D5C0            	  5977:          ADD.L   D0,A2          A2 = COMPUTED GO TO  ADDRESS
                            	  5978: 
                            	  5979: * FORMAT OPERAND IF REGUIRED
                            	  5980: 
01:00202DAC 4A01            	  5981:          TST.B   D1             LOOK AT KEY
01:00202DAE 6B20            	  5982:          BMI.S   M440           OPERAND NOT REQUIRED
                            	  5983: 
01:00202DB0 204B            	  5984:          MOVE.L  A3,A0
01:00202DB2 41E80027        	  5985:          ADD.L   #FOP,A0        STORE POINTER
01:00202DB6 23480012        	  5986:          MOVE.L  A0,PTROP(A1)   POINTER TO OPERAND (FORMATED)
01:00202DBA 6130            	  5987: M435     BSR.S   GETCHARF       D0 = CHAR
01:00202DBC 0C000020        	  5988:          CMPI.B  #BLANK,D0
01:00202DC0 67F8            	  5989:          BEQ     M435           SKIP SPACES
                            	  5990: 
01:00202DC2 10C0            	  5991: M437     MOVE.B  D0,(A0)+       MOVE REST OF SOURCE LINE
01:00202DC4 6126            	  5992:          BSR.S   GETCHARF       D0 = CHAR
01:00202DC6 BDCD            	  5993:          CMP.L   A5,A6
01:00202DC8 6AF8            	  5994:          BPL     M437
01:00202DCA 2348001A        	  5995:          MOVE.L  A0,PTRBUFE(A1) POINTER TO END FORMATED SOURCE
01:00202DCE 2C48            	  5996:          MOVE.L  A0,A6          A6 = POINTER TO END OF SOURCE
                            	  5997: M440
                            	  5998: 
01:00202DD0 2A690012        	  5999:          MOVE.L  PTROP(A1),A5   A5 = PTR TO OPERAND
01:00202DD4 49E90002        	  6000:          LEA     TDATA+2(A1),A4 A4 = BASE ADDR FOR DATA STORE
01:00202DD8 7600            	  6001:          CLR.L   D3             D3 = OFFSET FOR DATA STORE
01:00202DDA 4ED2            	  6002:          JMP     (A2)           GOTO ROUTINE
                            	  6003: *                               D2 = MASK
                            	  6004: *                               D4 = P-COUNTER
                            	  6005: 
01:00202DDC 0C1D002C        	  6006: COMMA    CMPI.B  #',',(A5)+
01:00202DE0 6614            	  6007:          BNE.S   ER             NOT COMMA
01:00202DE2 4E75            	  6008:          RTS
                            	  6009: 
01:00202DE4 BDCD            	  6010: GETCHAR  CMP.L   A5,A6
01:00202DE6 6B0E            	  6011:          BMI.S   ER
01:00202DE8 101D            	  6012:          MOVE.B  (A5)+,D0
01:00202DEA 4E75            	  6013:          RTS
                            	  6014: 
01:00202DEC BDCD            	  6015: GETCHARF CMP.L   A5,A6
01:00202DEE 6B04            	  6016:          BMI.S   ERF
01:00202DF0 101D            	  6017:          MOVE.B  (A5)+,D0
01:00202DF2 4E75            	  6018:          RTS
                            	  6019: 
01:00202DF4 2A48            	  6020: ERF      MOVE.L  A0,A5
                            	  6021: 
01:00202DF6 2E0D            	  6022: ER       MOVE.L  A5,D7          D7 = ERROR FLAG
01:00202DF8 9E8B            	  6023:          SUB.L   A3,D7          ..& POSITION OF ERROR
01:00202DFA 7C00            	  6024: ERDONE   CLR.L   D6             D6 = (ZERO) BYTE COUNT
01:00202DFC 6022            	  6025:          BRA.S   CMMD35
                            	  6026: 
01:00202DFE 0C150020        	  6027: CMMD2    CMPI.B  #BLANK,(A5)
01:00202E02 66F2            	  6028:          BNE     ER             OPERAND DID NOT END WITH SPACE
                            	  6029: 
                            	  6030: MCMMD2   DS      0              NO OPERAND SEQUENCE
01:00202E04 3282            	  6031:          MOVE.W  D2,(A1)        *D2,TDATA(A1)
                            	  6032: 
01:00202E06 1629000A        	  6033:          MOVE.B  TNB(A1),D3     FORMAT DATA
01:00202E0A 2C03            	  6034:          MOVE.L  D3,D6          D7 = NUMBER OF BYTES
01:00202E0C 45D1            	  6035:          LEA     (A1),A2        A2 = PTR TO HEX DATA  *TDATA(A1),A2
01:00202E0E 2C4B            	  6036:          MOVE.L  A3,A6          D3 = NUMBER OF BYTES
01:00202E10 4DEE000A        	  6037:          ADD.L   #FDATA,A6      A6 = STORE PTR
01:00202E14 101A            	  6038: FPR315   MOVE.B  (A2)+,D0
01:00202E16 6100EF9A        	  6039:          BSR     PNT2HX
01:00202E1A 5383            	  6040:          SUBQ.L  #1,D3
01:00202E1C 66F6            	  6041:          BNE     FPR315         MORE BYTES
                            	  6042: 
01:00202E1E 7E00            	  6043:          CLR.L   D7             RESET ERROR FLAG
                            	  6044: 
01:00202E20 4CD10007        	  6045: CMMD35   MOVEM.L (A1),D0-D2       D0-D2 = DATA   *TDATA(A1),D0-D2
                            	  6046: 
01:00202E24 2C69001A        	  6047:          MOVE.L  PTRBUFE(A1),A6   A6 = POINTER TO END OF BUFFER
                            	  6048: 
01:00202E28 2869000E        	  6049:          MOVE.L  PCOUNTER(A1),A4  A4 = ORGINAL PC
                            	  6050: 
01:00202E2C 2269001E        	  6051:          MOVE.L  LINK(A1),A1
01:00202E30 4E59            	  6052:          UNLK    A1
01:00202E32 4E75            	  6053:          RTS                    RETURN TO REQUESTOR
                            	  6054: *                               A3 = POINTER TO START OF BUFFER
                            	  6055: *                               D6 = NUMBER OF BYTES ASSEMBLED
                            	  6056: *                               D7 = ERROR FLAG (POSITION)
                            	  6057: 
                            	  6058: 
                            	  6059: *  SIZE = BYTE
                            	  6060: *    DY,DX
                            	  6061: *    -(AY),-(AX)
                            	  6062: *    ....RX@.SS...RY@
                            	  6063: MABCD    DS      0              (INDEX 0) ABCD SBCD
01:00202E34 4A29000B        	  6064:          TST.B   TLSPEC(A1)
01:00202E38 6706            	  6065:          BEQ.S   MABCD9         DEFAULT SIZE = BYTE
01:00202E3A 4A69000C        	  6066:          CMPI.W  #$00,TLENGTH(A1)
01:00202E3E 66B6            	  6067:          BNE     ER             NOT .B
                            	  6068: MABCD9
                            	  6069: 
01:00202E40 3E3C0011        	  6070:          MOVE.W  #$11,D7
01:00202E44 6100F854        	  6071:          BSR     EA
                            	  6072: 
01:00202E48 6192            	  6073:          BSR     COMMA
                            	  6074: 
01:00202E4A 2006            	  6075:          MOVE.L  D6,D0
01:00202E4C 02400007        	  6076:          ANDI.W  #7,D0
01:00202E50 8440            	  6077:          OR.W    D0,D2
                            	  6078: 
01:00202E52 08060005        	  6079:          BTST    #5,D6
01:00202E56 6716            	  6080:          BEQ.S   MABCD55        D@,D@ MODE
                            	  6081: 
01:00202E58 00420008        	  6082:          ORI.W   #$0008,D2      -(A@),-(A@) MODE
                            	  6083: 
01:00202E5C 3E3C0010        	  6084:          MOVE.W  #$10,D7
01:00202E60 6100F838        	  6085:          BSR     EA
                            	  6086: 
01:00202E64 02460007        	  6087:          ANDI.W  #7,D6
01:00202E68 EE5E            	  6088:          ROR.W   #7,D6
01:00202E6A 8446            	  6089:          OR.W    D6,D2
01:00202E6C 6090            	  6090:          BRA     CMMD2
                            	  6091: 
01:00202E6E 6100F7C2        	  6092: MABCD55  BSR     GETREGD        D@,D@
01:00202E72 EE58            	  6093:          ROR.W   #7,D0
01:00202E74 8440            	  6094:          OR.W    D0,D2
01:00202E76 6086            	  6095: CMMD2S10 BRA     CMMD2
                            	  6096: 
                            	  6097: 
                            	  6098: MCMP     DS      0              (INDEX 34)
01:00202E78 6100F81C        	  6099:          BSR     EAALL
01:00202E7C 2806            	  6100:          MOVE.L  D6,D4          D4 = SOURCE MODE
                            	  6101: 
01:00202E7E 6166            	  6102:          BSR.S   COMMAS20
                            	  6103: 
01:00202E80 0C150041        	  6104:          CMPI.B  #'A',(A5)
01:00202E84 67000116        	  6105:          BEQ     MADDA21        DESTINATION = A@
                            	  6106: 
01:00202E88 0C04003C        	  6107:          CMPI.B  #$3C,D4
01:00202E8C 6748            	  6108:          BEQ.S   MCMP56         SOURCE  ....I  #<DATA>,...
                            	  6109: 
01:00202E8E 6100F79C        	  6110:          BSR     FSIZE
                            	  6111: 
01:00202E92 3E3C0009        	  6112:          MOVE.W  #$009,D7
01:00202E96 6100F802        	  6113:          BSR     EA             D@ + (A@)+
01:00202E9A 2006            	  6114:          MOVE.L  D6,D0          MMMRRR
01:00202E9C 02400038        	  6115:          ANDI.W  #$38,D0        MMM...
                            	  6116: 
01:00202EA0 672C            	  6117:          BEQ.S   MCMP39         DESTINATION  D@
                            	  6118: 
01:00202EA2 0C000018        	  6119:          CMPI.B  #$18,D0
01:00202EA6 6600FF4E        	  6120:          BNE     ER
                            	  6121: 
01:00202EAA 0246000F        	  6122:          ANDI.W  #$F,D6         (AY)+,(AX)+
01:00202EAE EE5E            	  6123:          ROR.W   #7,D6
01:00202EB0 8446            	  6124:          OR.W    D6,D2          ....AX@.........
01:00202EB2 00420100        	  6125:          ORI.W   #$0100,D2      ...1AX@.........
                            	  6126: 
01:00202EB6 2004            	  6127:          MOVE.L  D4,D0
01:00202EB8 02400038        	  6128:          ANDI.W  #$38,D0
01:00202EBC 0C400018        	  6129:          CMPI.W  #$18,D0
01:00202EC0 6600FF34        	  6130:          BNE     ER             NOT (A@)+
01:00202EC4 0244000F        	  6131:          ANDI.W  #$F,D4         ............1AY@
01:00202EC8 8444            	  6132:          OR.W    D4,D2
01:00202ECA 6000FF32        	  6133:          BRA     CMMD2
                            	  6134: 
                            	  6135: *  <EA>,D@
01:00202ECE EE5E            	  6136: MCMP39   ROR.W   #7,D6
01:00202ED0 8446            	  6137:          OR.W    D6,D2
                            	  6138: 
01:00202ED2 8444            	  6139:          OR.W    D4,D2
01:00202ED4 600E            	  6140:          BRA.S   CMMD2S11
                            	  6141: 
01:00202ED6 343C0C00        	  6142: MCMP56   MOVE.W  #$0C00,D2      #<DATA>,<EA>      MASK = CMPI
                            	  6143: 
01:00202EDA 6100F750        	  6144:          BSR     FSIZE
                            	  6145: 
01:00202EDE 6100F792        	  6146:          BSR     EADA
01:00202EE2 8446            	  6147:          OR.W    D6,D2
01:00202EE4 6090            	  6148: CMMD2S11 BRA     CMMD2S10
                            	  6149: 
01:00202EE6 6000FEF4        	  6150: COMMAS20 BRA     COMMA
                            	  6151: 
                            	  6152: MADD     DS      0              (INDEX 1)
01:00202EEA 6100F7AA        	  6153:          BSR     EAALL
01:00202EEE 2806            	  6154:          MOVE.L  D6,D4          D4 = SOURCE MODE
                            	  6155: 
01:00202EF0 61F4            	  6156:          BSR     COMMAS20
                            	  6157: 
01:00202EF2 0C150041        	  6158:          CMPI.B  #'A',(A5)
01:00202EF6 670000A4        	  6159:          BEQ     MADDA21        DESTINATION = A@
                            	  6160: 
01:00202EFA 0C04003C        	  6161:          CMPI.B  #$3C,D4
01:00202EFE 6728            	  6162:          BEQ.S   MADD56         SOURCE  ....I  #<DATA>,...
                            	  6163: 
01:00202F00 6100F72A        	  6164:          BSR     FSIZE
                            	  6165: 
01:00202F04 3E3C01FF        	  6166:          MOVE.W  #$1FF,D7
01:00202F08 6100F790        	  6167:          BSR     EA             ALTERABLE + D@
01:00202F0C 2006            	  6168:          MOVE.L  D6,D0          MMMRRR
01:00202F0E 02400038        	  6169:          ANDI.W  #$38,D0        MMM...
01:00202F12 6608            	  6170:          BNE.S   MADD46         DESTINATION NOT  D@
                            	  6171: 
                            	  6172: *  <EA>,D@
01:00202F14 EE5E            	  6173:          ROR.W   #7,D6
01:00202F16 8446            	  6174:          OR.W    D6,D2
                            	  6175: 
01:00202F18 8444            	  6176:          OR.W    D4,D2
01:00202F1A 60C8            	  6177:          BRA     CMMD2S11
                            	  6178: 
                            	  6179: MADD46   DS      0              D@,<EA>
01:00202F1C 00420100        	  6180:          ORI.W   #$100,D2
                            	  6181: 
01:00202F20 EE5C            	  6182:          ROR.W   #7,D4
01:00202F22 8444            	  6183:          OR.W    D4,D2          <EA> AS DESTINATION
                            	  6184: 
01:00202F24 8446            	  6185:          OR.W    D6,D2          D@  AS SOURCE
01:00202F26 60BC            	  6186:          BRA     CMMD2S11
                            	  6187: 
01:00202F28 2002            	  6188: MADD56   MOVE.L  D2,D0          #<DATA>,<EA>
01:00202F2A 343C0600        	  6189:          MOVE.W  #$0600,D2      MASK = ADDI
                            	  6190: 
01:00202F2E 0C40D000        	  6191:          CMPI.W  #$D000,D0
01:00202F32 6704            	  6192:          BEQ.S   MADD58
01:00202F34 343C0400        	  6193:          MOVE.W  #$400,D2       MASK = SUBI
                            	  6194: MADD58
                            	  6195: 
01:00202F38 6100F6F2        	  6196:          BSR     FSIZE
                            	  6197: 
01:00202F3C 6100F734        	  6198:          BSR     EADA           DATA ALTERABLE ONLY
01:00202F40 8446            	  6199:          OR.W    D6,D2
01:00202F42 60A0            	  6200:          BRA     CMMD2S11
                            	  6201: 
01:00202F44 2A690012        	  6202: MADDI    MOVE.L  PTROP(A1),A5   (INDEX 3) CMPI
01:00202F48 6100F6E2        	  6203:          BSR     FSIZE
                            	  6204: 
01:00202F4C 6100F736        	  6205:          BSR     EAZ
                            	  6206: 
01:00202F50 6194            	  6207:          BSR     COMMAS20
                            	  6208: 
01:00202F52 6100F71E        	  6209:          BSR     EADA           DATA ALTERABLE ONLY
01:00202F56 8446            	  6210:          OR.W    D6,D2
01:00202F58 608A            	  6211:          BRA     CMMD2S11
                            	  6212: 
                            	  6213: *  SIZE =  BYTE, WORD, LONG
                            	  6214: *  #<DATA>,SR
                            	  6215: *  #<DATA>,<EA>    DATA ALTERABLE ONLY
                            	  6216: MANDI    DS      0              (INDEX 28) ANDI EORI ORI
01:00202F5A 6100F6D0        	  6217:          BSR     FSIZE
                            	  6218: 
01:00202F5E 6100F724        	  6219:          BSR     EAZ
                            	  6220: 
01:00202F62 6182            	  6221:          BSR     COMMAS20
                            	  6222: 
01:00202F64 0C150053        	  6223:          CMPI.B  #'S',(A5)
01:00202F68 670A            	  6224:          BEQ.S   MANDI23
                            	  6225: 
01:00202F6A 6100F706        	  6226:          BSR     EADA
01:00202F6E 8446            	  6227:          OR.W    D6,D2
01:00202F70 6000FF72        	  6228:          BRA     CMMD2S11
                            	  6229: 
01:00202F74 0C2D00520001    	  6230: MANDI23  CMPI.B  #'R',1(A5)     #<DATA>,SR
01:00202F7A 6600FE7A        	  6231:          BNE     ER
01:00202F7E 0C690080000C    	  6232:          CMPI.W  #$0080,TLENGTH(A1)
01:00202F84 6700FE70        	  6233:          BEQ     ER             .L NOT ALLOWED WITH SR
01:00202F88 0042003C        	  6234:          ORI.W   #$003C,D2
01:00202F8C 548D            	  6235:          ADDQ.L  #2,A5          POINTER TO END OF OPERAND
01:00202F8E 6000FE6E        	  6236:          BRA     CMMD2
                            	  6237: 
                            	  6238: MADDA    DS      0              (INDEX 2)
01:00202F92 6100F702        	  6239:          BSR     EAALL
01:00202F96 8446            	  6240:          OR.W    D6,D2
                            	  6241: 
01:00202F98 6100FE42        	  6242:          BSR     COMMA
                            	  6243: 
01:00202F9C 8446            	  6244: MADDA21  OR.W    D6,D2
01:00202F9E 3029000C        	  6245:          MOVE.W  TLENGTH(A1),D0
01:00202FA2 6700FE52        	  6246:          BEQ     ER             .BYTE NOT ALLOWED
01:00202FA6 E348            	  6247:          LSL.W   #1,D0          .W = 011......
01:00202FA8 004000C0        	  6248:          ORI.W   #$00C0,D0      .L = 111......
01:00202FAC 8440            	  6249:          OR.W    D0,D2
                            	  6250: 
01:00202FAE 6100F69C        	  6251:          BSR     GETREGA
01:00202FB2 EE58            	  6252:          ROR.W   #7,D0
01:00202FB4 8440            	  6253:          OR.W    D0,D2
01:00202FB6 6000FE46        	  6254:          BRA     CMMD2
                            	  6255: 
                            	  6256: MADDQ    DS      0              (INDEX 4)
01:00202FBA 6100F670        	  6257:          BSR     FSIZE
                            	  6258: 
01:00202FBE 61000680        	  6259:          BSR     GETIMM
                            	  6260: 
01:00202FC2 4A80            	  6261:          TST.L   D0
01:00202FC4 6700FE30        	  6262:          BEQ     ER             DATA = ZERO
01:00202FC8 0C000009        	  6263:          CMPI.B  #9,D0
01:00202FCC 6A00FE28        	  6264:          BPL     ER             VALUE TOO BIG
01:00202FD0 02400007        	  6265:          ANDI.W  #$7,D0         MAKE 8 = 0
01:00202FD4 EE58            	  6266:          ROR.W   #7,D0          SHIFT DATA TO BITS 9-11
01:00202FD6 8440            	  6267:          OR.W    D0,D2
                            	  6268: 
01:00202FD8 6100FE02        	  6269:          BSR     COMMA
                            	  6270: 
01:00202FDC 6100F6B2        	  6271:          BSR     EAA            ALTERABLE ADDRESSING
                            	  6272: 
01:00202FE0 8446            	  6273:          OR.W    D6,D2
01:00202FE2 2002            	  6274:          MOVE.L  D2,D0
01:00202FE4 024000C0        	  6275:          ANDI.W  #$C0,D0
01:00202FE8 660E            	  6276:          BNE.S   MADDQ25
                            	  6277: 
                            	  6278: * BYTE SIZE; ADDRESS REGISTER DIRECT NOT ALLOWED
01:00202FEA 2002            	  6279:          MOVE.L  D2,D0
01:00202FEC 02400038        	  6280:          ANDI.W  #$38,D0
01:00202FF0 0C000008        	  6281:          CMPI.B  #$08,D0
01:00202FF4 6700FE00        	  6282:          BEQ     ER
01:00202FF8 6000FE04        	  6283: MADDQ25  BRA     CMMD2
                            	  6284: 
                            	  6285: * SIZE = BYTE, WORD, LONG
                            	  6286: *    DY,DX
                            	  6287: *    -(AY),-(AX)
                            	  6288: *    ....RX@.SS...RY@
                            	  6289: MADDX    DS      0              (INDEX 5)
01:00202FFC 6100F62E        	  6290:          BSR     FSIZE
                            	  6291: 
01:00203000 3E3C0011        	  6292:          MOVE.W  #$11,D7
01:00203004 6100F694        	  6293:          BSR     EA
                            	  6294: 
01:00203008 6100FDD2        	  6295:          BSR     COMMA
                            	  6296: 
01:0020300C 2006            	  6297:          MOVE.L  D6,D0
01:0020300E 02400007        	  6298:          ANDI.W  #7,D0
01:00203012 8440            	  6299:          OR.W    D0,D2
                            	  6300: 
01:00203014 08060005        	  6301:          BTST    #5,D6
01:00203018 6718            	  6302:          BEQ.S   MADDX5         D@,D@ MODE
                            	  6303: 
01:0020301A 00420008        	  6304:          ORI.W   #$0008,D2      -(A@),-(A@) MODE
                            	  6305: 
01:0020301E 3E3C0010        	  6306:          MOVE.W  #$10,D7
01:00203022 6100F676        	  6307:          BSR     EA
                            	  6308: 
01:00203026 02460007        	  6309:          ANDI.W  #7,D6
01:0020302A EE5E            	  6310:          ROR.W   #7,D6
01:0020302C 8446            	  6311:          OR.W    D6,D2
01:0020302E 6000FDCE        	  6312:          BRA     CMMD2
                            	  6313: 
01:00203032 6100F5FE        	  6314: MADDX5   BSR     GETREGD        D@,D@
01:00203036 EE58            	  6315:          ROR.W   #7,D0
01:00203038 8440            	  6316:          OR.W    D0,D2
01:0020303A 6000FDC2        	  6317:          BRA     CMMD2
                            	  6318: 
                            	  6319: *  SIZE = BYTE, WORD, LONG
                            	  6320: *         <EA>,D@
                            	  6321: *         D@,<EA>
01:0020303E 6100F5EC        	  6322: MAND     BSR     FSIZE          (INDEX 6)
                            	  6323: 
01:00203042 0C150023        	  6324:          CMPI.B  #'#',(A5)
01:00203046 6740            	  6325:          BEQ.S   MAND90
                            	  6326: 
01:00203048 61000082        	  6327:          BSR     A5TODEST       MOVE A5 TO DESTINATION
                            	  6328: 
01:0020304C 1015            	  6329:          MOVE.B  (A5),D0        D0 = 1ST CHAR OF DESTINATION
01:0020304E 2A690012        	  6330:          MOVE.L  PTROP(A1),A5   A5 = POINTER TO OPERAND
01:00203052 0C000044        	  6331:          CMPI.B  #'D',D0
01:00203056 671A            	  6332:          BEQ.S   MAND77
                            	  6333: 
01:00203058 00420100        	  6334:          ORI.W   #$0100,D2       D@,<EA>
                            	  6335: 
01:0020305C 6100F5D4        	  6336:          BSR     GETREGD
01:00203060 EE58            	  6337:          ROR.W   #7,D0
01:00203062 8440            	  6338:          OR.W    D0,D2
                            	  6339: 
01:00203064 6100FD76        	  6340:          BSR     COMMA
                            	  6341: 
01:00203068 6100F614        	  6342:          BSR     EAM            ALTERABLE MEMORY
01:0020306C 8446            	  6343:          OR.W    D6,D2
01:0020306E 6000FD8E        	  6344:          BRA     CMMD2
                            	  6345: 
01:00203072 6100F616        	  6346: MAND77   BSR     EADADDR        <EA>,D@
01:00203076 8446            	  6347:          OR.W    D6,D2
                            	  6348: 
01:00203078 6100FD62        	  6349:          BSR     COMMA
                            	  6350: 
01:0020307C 6100F5B4        	  6351:          BSR     GETREGD
01:00203080 EE58            	  6352:          ROR.W   #7,D0
01:00203082 8440            	  6353:          OR.W    D0,D2
01:00203084 6000FD78        	  6354:          BRA     CMMD2
                            	  6355: 
01:00203088 0242F000        	  6356: MAND90   ANDI.W  #$F000,D2
01:0020308C 0C42C000        	  6357:          CMPI.W  #$C000,D2
01:00203090 6708            	  6358:          BEQ.S   MAND97          AND
01:00203092 343C0000        	  6359:          MOVE.W  #$0000,D2      CHANGE TO "ORI"
01:00203096 6000FEC2        	  6360: MAND91   BRA     MANDI
01:0020309A 343C0200        	  6361: MAND97   MOVE.W  #$0200,D2      CHANGE TO "ADDI"
01:0020309E 60F6            	  6362:          BRA     MAND91
                            	  6363: 
01:002030A0 6100F58A        	  6364: MEOR     BSR     FSIZE          (INDEX 35)
                            	  6365: 
01:002030A4 0C150023        	  6366:          CMPI.B  #'#',(A5)
01:002030A8 6716            	  6367:          BEQ.S   MEOR90
                            	  6368: 
01:002030AA 6100F586        	  6369:          BSR     GETREGD
01:002030AE EE58            	  6370:          ROR.W   #7,D0
01:002030B0 8440            	  6371:          OR.W    D0,D2
                            	  6372: 
01:002030B2 6100FD28        	  6373:          BSR     COMMA
                            	  6374: 
01:002030B6 6100F5BA        	  6375:          BSR     EADA           DATA ALTERABLE ADDRESSING
01:002030BA 8446            	  6376:          OR.W    D6,D2
01:002030BC 6000FD40        	  6377:          BRA     CMMD2
                            	  6378: 
01:002030C0 2A690012        	  6379: MEOR90   MOVE.L  PTROP(A1),A5   A5 = POINTER TO OPERAND
01:002030C4 343C0A00        	  6380:          MOVE.W  #$0A00,D2      CHANGE TO "EORI"
01:002030C8 6000FE90        	  6381:          BRA     MANDI
                            	  6382: 
01:002030CC 7200            	  6383: A5TODEST CLR.L   D1             MOVE A5 TO DESTINATION
01:002030CE 6100FD14        	  6384: A5300    BSR     GETCHAR
01:002030D2 0C000028        	  6385:          CMPI.B  #'(',D0
01:002030D6 6602            	  6386:          BNE.S   A5305
01:002030D8 2200            	  6387:          MOVE.L  D0,D1
01:002030DA 0C000029        	  6388: A5305    CMPI.B  #')',D0
01:002030DE 67EC            	  6389:          BEQ     A5TODEST
01:002030E0 0C00002C        	  6390:          CMPI.B  #',',D0
01:002030E4 66E8            	  6391:          BNE     A5300
01:002030E6 4A41            	  6392:          TST     D1
01:002030E8 66E4            	  6393:          BNE     A5300
01:002030EA 4E75            	  6394:          RTS
                            	  6395: 
                            	  6396: MASL     DS      0              (INDEX 7)
                            	  6397: 
                            	  6398: *         ASL     LSL     ROL     ROXL
                            	  6399: *  MASKS  E000    E008    E018    E010
                            	  6400: *         E0C0    E2C0    E6C0    E4C0   SHIFT MEMORY
                            	  6401: 
01:002030EC 6100F53E        	  6402:          BSR     FSIZE
                            	  6403: 
01:002030F0 101D            	  6404:          MOVE.B  (A5)+,D0
01:002030F2 0C000023        	  6405:          CMPI.B  #'#',D0
01:002030F6 6628            	  6406:          BNE.S   MSL200
                            	  6407: 
                            	  6408: *  #<COUNT>,D@
01:002030F8 6100F4C8        	  6409:          BSR     EV
01:002030FC 0C8000000008    	  6410:          CMPI.L  #8,D0
01:00203102 6E00FCF2        	  6411:          BGT     ER             GREATER THAN 8
                            	  6412: 
01:00203106 02000007        	  6413:          ANDI.B  #$7,D0         MAKE 8 INTO 0
01:0020310A EE58            	  6414: MSL150   ROR.W   #7,D0
01:0020310C 0242F1FF        	  6415:          ANDI.W  #$F1FF,D2
01:00203110 8440            	  6416:          OR.W    D0,D2          COUNT/REG
                            	  6417: 
01:00203112 6100FCC8        	  6418:          BSR     COMMA
                            	  6419: 
01:00203116 6100F51A        	  6420:          BSR     GETREGD
01:0020311A 8440            	  6421:          OR.W    D0,D2
01:0020311C 6000FCE0        	  6422:          BRA     CMMD2
                            	  6423: 
                            	  6424: MSL200   DS      0              D@,D@
01:00203120 0C000044        	  6425:          CMPI.B  #'D',D0
01:00203124 660C            	  6426:          BNE.S   MSL300
                            	  6427: 
                            	  6428: *        D@,D@
01:00203126 00420020        	  6429:          ORI.W   #$20,D2
01:0020312A 538D            	  6430:          SUBQ.L  #1,A5
01:0020312C 6100F504        	  6431:          BSR     GETREGD
01:00203130 60D8            	  6432:          BRA     MSL150
                            	  6433: 
                            	  6434: MSL300   DS      0              <EA>      SHIFT MEMORY
01:00203132 538D            	  6435:          SUBQ.L  #1,A5
01:00203134 004200C0        	  6436:          ORI.W   #$00C0,D2      SIZE = MEMORY
                            	  6437: 
01:00203138 0242FFC0        	  6438:          ANDI.W  #$FFC0,D2      REMOVE "SHIFT MEMORY" BITS
                            	  6439: 
01:0020313C 0C690040000C    	  6440:          CMPI.W  #$0040,TLENGTH(A1)
01:00203142 6658            	  6441:          BNE.S   ER2            NOT .WORD
                            	  6442: 
01:00203144 6100F538        	  6443:          BSR     EAM
01:00203148 8446            	  6444:          OR.W    D6,D2
01:0020314A 6000FCB2        	  6445:          BRA     CMMD2
                            	  6446: 
01:0020314E 61000332        	  6447: MSCC     BSR     SIZEBYTE       (INDEX 29) NBCD SCC TAS
                            	  6448: 
01:00203152 6100F51E        	  6449:          BSR     EADA           DATA ALTERABLE ONLY
01:00203156 8446            	  6450:          OR.W    D6,D2
01:00203158 6000FCA4        	  6451:          BRA     CMMD2
                            	  6452: 
                            	  6453: MBCHG    DS      0              (9)
01:0020315C 0C150023        	  6454:          CMPI.B  #'#',(A5)
01:00203160 6648            	  6455:          BNE.S   MB200
                            	  6456: 
01:00203162 343C0840        	  6457:          MOVE.W  #$0840,D2      NEW OP-CODE MASK
                            	  6458: 
01:00203166 528D            	  6459: MB100    ADDQ.L  #1,A5
01:00203168 6100F458        	  6460:          BSR     EV             EVALUATE EXPRESSION
01:0020316C 0C8000000021    	  6461:          CMPI.L  #33,D0
01:00203172 6E28            	  6462:          BGT.S   ER2            (MODULO 32)
01:00203174 33400002        	  6463:          MOVE.W  D0,TDATA+2(A1)
01:00203178 5483            	  6464:          ADDQ.L  #2,D3          STORE POINTER
                            	  6465: 
01:0020317A 5429000A        	  6466:          ADDQ.B  #2,TNB(A1)
                            	  6467: 
01:0020317E 6100FC5C        	  6468: MB105    BSR     COMMA
                            	  6469: 
01:00203182 6100F4EE        	  6470:          BSR     EADA           DESTINATION
01:00203186 8446            	  6471:          OR.W    D6,D2
                            	  6472: 
01:00203188 4A29000B        	  6473:          TST.B   TLSPEC(A1)     ..
01:0020318C 6718            	  6474:          BEQ.S   MB185          DEFAULT
                            	  6475: 
01:0020318E 02460038        	  6476:          ANDI.W  #$0038,D6
01:00203192 660C            	  6477:          BNE.S   MB145          DESTINATION <EA> WAS NOT D@
                            	  6478: 
01:00203194 0C690080000C    	  6479:          CMPI.W  #$80,TLENGTH(A1)  DESTINATION <EA> WAS D@
01:0020319A 670A            	  6480:          BEQ.S   MB185          LENGTH IS .L
01:0020319C 6000FC58        	  6481: ER2      BRA     ER
                            	  6482: 
01:002031A0 4A69000C        	  6483: MB145    TST.W   TLENGTH(A1)
01:002031A4 66F6            	  6484:          BNE     ER2            NOT BYTE LENGTH
                            	  6485: 
01:002031A6 6000FC56        	  6486: MB185    BRA     CMMD2
                            	  6487: 
01:002031AA 6100F486        	  6488: MB200    BSR     GETREGD        DYNAMIC
01:002031AE EE58            	  6489:          ROR.W   #7,D0
01:002031B0 8440            	  6490:          OR.W    D0,D2
                            	  6491: 
01:002031B2 60CA            	  6492:          BRA     MB105
                            	  6493: 
01:002031B4 0C150023        	  6494: MBSET    CMPI.B  #'#',(A5)      (INDEX 11) BCLR BSET
01:002031B8 66F0            	  6495:          BNE     MB200
                            	  6496: 
01:002031BA 343C08C0        	  6497:          MOVE.W  #$08C0,D2
01:002031BE 60A6            	  6498:          BRA     MB100
                            	  6499: 
01:002031C0 0C150023        	  6500: MBCLR    CMPI.B  #'#',(A5)      (INDEX 30)
01:002031C4 66E4            	  6501:          BNE     MB200
                            	  6502: 
01:002031C6 343C0880        	  6503:          MOVE.W  #$0880,D2
01:002031CA 609A            	  6504:          BRA     MB100
                            	  6505: 
01:002031CC 0C150023        	  6506: MBTST    CMPI.B  #'#',(A5)      (INDEX 31)
01:002031D0 66D8            	  6507:          BNE     MB200
                            	  6508: 
01:002031D2 343C0800        	  6509:          MOVE.W  #$0800,D2
01:002031D6 608E            	  6510:          BRA     MB100
                            	  6511: 
                            	  6512: MDBCC    DS      0              (INDEX 8)
01:002031D8 6100F458        	  6513:          BSR     GETREGD
01:002031DC 8440            	  6514:          OR.W    D0,D2
                            	  6515: 
01:002031DE 6100FBFC        	  6516:          BSR     COMMA
01:002031E2 613C            	  6517:          BSR.S   EVSR
01:002031E4 601A            	  6518:          BRA.S   MBRA23
                            	  6519: 
                            	  6520: *  SIZE   .S  =  .W   (DEFAULT)
                            	  6521: *         .L  =  .L
                            	  6522: MBRA     DS      0              (INDEX 10)
01:002031E6 6138            	  6523:          BSR.S   EVSR
                            	  6524: 
01:002031E8 0C690080000C    	  6525:          CMPI.W  #$0080,TLENGTH(A1)
01:002031EE 6710            	  6526:          BEQ.S   MBRA23         FORCED LONG
                            	  6527: 
01:002031F0 6100F72E        	  6528:          BSR     EA8BITS        -128 TO +127
01:002031F4 660A            	  6529:          BNE.S   MBRA23         NOT 8 BIT VALUE
                            	  6530: 
01:002031F6 8405            	  6531:          OR.B    D5,D2
01:002031F8 6000FC04        	  6532:          BRA     CMMD2          .SHORT
                            	  6533: 
01:002031FC 6000FBF8        	  6534: EVER     BRA     ER             ERROR HANDLER
                            	  6535: 
01:00203200 4A29000B        	  6536: MBRA23   TST.B   TLSPEC(A1)
01:00203204 6708            	  6537:          BEQ.S   MBRA27
01:00203206 0C690040000C    	  6538:          CMPI.W  #$0040,TLENGTH(A1)
01:0020320C 67EE            	  6539:          BEQ     EVER           .S SPECIFIED
                            	  6540: MBRA27
                            	  6541: 
01:0020320E 2A04            	  6542:          MOVE.L  D4,D5          RESTORE D5
01:00203210 6100F6FA        	  6543:          BSR     EA16BITS       -32K TO +32K
01:00203214 33450002        	  6544:          MOVE.W  D5,TDATA+2(A1)
01:00203218 5429000A        	  6545:          ADDQ.B  #2,TNB(A1)
01:0020321C 6000FBE0        	  6546:          BRA     CMMD2
                            	  6547: 
01:00203220 6100F3A0        	  6548: EVSR     BSR     EV
01:00203224 0C150020        	  6549:          CMPI.B  #BLANK,(A5)
01:00203228 66D2            	  6550:          BNE     EVER           DID NOT TERMINATE WITH SPACE
                            	  6551: 
01:0020322A 2A00            	  6552:          MOVE.L  D0,D5
01:0020322C E280            	  6553:          ASR.L   #1,D0
01:0020322E 65CC            	  6554:          BCS     EVER           ODD VALUE
01:00203230 2829000E        	  6555:          MOVE.L  PCOUNTER(A1),D4
01:00203234 5484            	  6556:          ADDQ.L  #2,D4          D4 = PC + 2
01:00203236 9A84            	  6557:          SUB.L   D4,D5
01:00203238 67C2            	  6558:          BEQ     EVER           ZERO; SPECIAL CASE ERROR
01:0020323A 2805            	  6559:          MOVE.L  D5,D4
01:0020323C 4E75            	  6560:          RTS
                            	  6561: 
                            	  6562: MCHK     DS      0              (INDEX 12) CHK DIV MUL
01:0020323E 61000236        	  6563:          BSR     SIZEWORD
                            	  6564: 
01:00203242 6100F446        	  6565:          BSR     EADADDR        DATA ADDRESSING ONLY
01:00203246 8446            	  6566:          OR.W    D6,D2
                            	  6567: 
01:00203248 6100FB92        	  6568:          BSR     COMMA
                            	  6569: 
01:0020324C 6100F3E4        	  6570:          BSR     GETREGD
01:00203250 EE58            	  6571:          ROR.W   #7,D0
01:00203252 8440            	  6572:          OR.W    D0,D2
                            	  6573: 
01:00203254 6000FBA8        	  6574:          BRA     CMMD2
                            	  6575: 
                            	  6576: MCLR     DS      0              (INDEX 13)
01:00203258 6100F3D2        	  6577:          BSR     FSIZE
                            	  6578: 
01:0020325C 6100F414        	  6579:          BSR     EADA           DATA ALTERABLE ONLY
01:00203260 8446            	  6580:          OR.W    D6,D2
01:00203262 6000FB9A        	  6581:          BRA     CMMD2
                            	  6582: 
                            	  6583: * SIZE = BYTE, WORD, LONG
                            	  6584: MCMPM    DS      0              (INDEX 14)
01:00203266 6100F3C4        	  6585:          BSR     FSIZE
                            	  6586: 
01:0020326A 3E3C0008        	  6587:          MOVE.W  #$0008,D7
01:0020326E 6100F42A        	  6588:          BSR     EA             -(A@)   ONLY
01:00203272 02460007        	  6589:          ANDI.W  #7,D6
01:00203276 8446            	  6590:          OR.W    D6,D2
                            	  6591: 
01:00203278 6100FB62        	  6592:          BSR     COMMA
                            	  6593: 
01:0020327C 3E3C0008        	  6594:          MOVE.W  #$0008,D7
01:00203280 6100F418        	  6595:          BSR     EA
01:00203284 02460007        	  6596:          ANDI.W  #7,D6
01:00203288 EE5E            	  6597:          ROR.W   #7,D6
01:0020328A 8446            	  6598:          OR.W    D6,D2
01:0020328C 6000FB70        	  6599:          BRA     CMMD2
                            	  6600: 
                            	  6601: MEXG     DS      0              (INDEX 16)
01:00203290 610001D4        	  6602:          BSR     SIZELONG
                            	  6603: 
01:00203294 6100F3C4        	  6604:          BSR     GETREGAD
01:00203298 2800            	  6605:          MOVE.L  D0,D4          D4 = REG NUMBER
01:0020329A 2A01            	  6606:          MOVE.L  D1,D5          D5 = REG TYPE
                            	  6607: 
01:0020329C 6100FB3E        	  6608:          BSR     COMMA          TEST FOR COMMA
                            	  6609: 
01:002032A0 6100F3B8        	  6610:          BSR     GETREGAD
                            	  6611: 
01:002032A4 BA81            	  6612:          CMP.L   D1,D5
01:002032A6 6714            	  6613:          BEQ.S   MEXG35         BOTH REGS THE SAME
                            	  6614: 
                            	  6615: *  DX,AY  OR  AY,DX
01:002032A8 00420088        	  6616:          ORI.W   #$88,D2        MODE
01:002032AC 4A01            	  6617:          TST.B   D1
01:002032AE 6602            	  6618:          BNE.S   MEXG25
                            	  6619: 
01:002032B0 C144            	  6620:          EXG     D0,D4          SWAP SOURCE & DESTINATION
                            	  6621: 
01:002032B2 8440            	  6622: MEXG25   OR.W    D0,D2          .......MMMMMYYY
01:002032B4 EE5C            	  6623:          ROR.W   #7,D4
01:002032B6 8444            	  6624:          OR.W    D4,D2          ....XXXMMMMMYYY
01:002032B8 6000FB44        	  6625:          BRA     CMMD2
                            	  6626: 
01:002032BC 00420040        	  6627: MEXG35   ORI.W   #$0040,D2      OP-MODE
01:002032C0 4A01            	  6628:          TST.B   D1
01:002032C2 67EE            	  6629:          BEQ     MEXG25         DX,DY
                            	  6630: 
01:002032C4 00420048        	  6631:          ORI.W   #$0048,D2      AX,AY
01:002032C8 60E8            	  6632:          BRA     MEXG25
                            	  6633: 
                            	  6634: 
                            	  6635: MEXT     DS      0              (INDEX 17)
01:002032CA 4A69000C        	  6636:          TST.W   TLENGTH(A1)
01:002032CE 6700FB26        	  6637:          BEQ     ER             BYTE SIZE NOT ALLOWED
                            	  6638: 
01:002032D2 6100F358        	  6639:          BSR     FSIZE          .W = ........10......
01:002032D6 06420040        	  6640:          ADDI.W  #$0040,D2      .L = ........11......
                            	  6641: 
01:002032DA 6100F356        	  6642:          BSR     GETREGD
01:002032DE 8440            	  6643:          OR.W    D0,D2
01:002032E0 6000FB1C        	  6644:          BRA     CMMD2
                            	  6645: 
                            	  6646: MMOVEM   DS      0              (INDEX 27)
01:002032E4 3029000C        	  6647:          MOVE.W  TLENGTH(A1),D0 SIZE BITS  76 TO 6
01:002032E8 6700FB0C        	  6648:          BEQ     ER             BYTE       00  ERROR
01:002032EC E248            	  6649:          LSR.W   #1,D0          WORD       01    0
01:002032EE 02400040        	  6650:          ANDI.W  #$0040,D0      LONG       10    1
01:002032F2 8440            	  6651:          OR.W    D0,D2
                            	  6652: 
01:002032F4 5429000A        	  6653:          ADDQ.B  #2,TNB(A1)     NUMBER OF BYTES
01:002032F8 5483            	  6654:          ADDQ.L  #2,D3          FORCE STORE PTR PAST MASK
                            	  6655: 
01:002032FA 0C150041        	  6656:          CMPI.B  #'A',(A5)
01:002032FE 671E            	  6657:          BEQ.S   MMM44
01:00203300 0C150044        	  6658:          CMPI.B  #'D',(A5)
01:00203304 6718            	  6659:          BEQ.S   MMM44
                            	  6660: 
                            	  6661: *    <EA>,<REGISTER LIST>       MEMORY TO REGISTER
01:00203306 00420400        	  6662:          ORI.W   #$0400,D2      DIRECTION BIT
                            	  6663: 
01:0020330A 3E3C07EC        	  6664:          MOVE.W  #$7EC,D7       MODES ALLOWED
01:0020330E 6100F38A        	  6665:          BSR     EA
01:00203312 8446            	  6666:          OR.W    D6,D2
                            	  6667: 
01:00203314 6100FAC6        	  6668:          BSR     COMMA
                            	  6669: 
01:00203318 612A            	  6670:          BSR.S   MMM48
01:0020331A 6000FAE2        	  6671:          BRA     CMMD2
                            	  6672: 
                            	  6673: 
                            	  6674: *   <REGISTER LIST>,<EA>        REGISTER TO MEMORY
                            	  6675: MMM44    DS      0
                            	  6676: 
                            	  6677: * EVALUATE DESTINATION FIRST
01:0020331E 6100FAC4        	  6678: MMM46    BSR     GETCHAR
01:00203322 0C00002C        	  6679:          CMPI.B  #',',D0        FIND COMMA
01:00203326 66F6            	  6680:          BNE     MMM46
                            	  6681: 
01:00203328 3E3C01F4        	  6682:          MOVE.W  #$1F4,D7       MODES ALLOWED
01:0020332C 6100F36C        	  6683:          BSR     EA
01:00203330 8446            	  6684:          OR.W    D6,D2
01:00203332 234D0016        	  6685:          MOVE.L  A5,PENDOP(A1)  END OF OPERAND
01:00203336 2A690012        	  6686:          MOVE.L  PTROP(A1),A5
01:0020333A 6108            	  6687:          BSR.S   MMM48          EVALUATE REGISTERS
01:0020333C 2A690016        	  6688:          MOVE.L  PENDOP(A1),A5  POINTER TO END OF OPERAND
01:00203340 6000FABC        	  6689:          BRA     CMMD2
                            	  6690: 
                            	  6691: *        D6 = CORRESPONDENCE MASK
                            	  6692: *        D4 = CONTROL  $FF '-BLANK/'
01:00203344 7C00            	  6693: MMM48    CLR.L   D6             MASK
01:00203346 78FF            	  6694:          MOVEQ   #-1,D4         CONTROL = $FF
                            	  6695: 
01:00203348 6100FA9A        	  6696: RL111    BSR     GETCHAR
01:0020334C 0C00002C        	  6697:          CMPI.B  #',',D0
01:00203350 6706            	  6698:          BEQ.S   RL114          DONE; FOUND COMMA
01:00203352 0C000020        	  6699:          CMPI.B  #BLANK,D0
01:00203356 6602            	  6700:          BNE.S   RL115          NOT SPACE
01:00203358 4E75            	  6701: RL114    RTS     DONE
                            	  6702: 
01:0020335A 0C00002F        	  6703: RL115    CMPI.B  #'/',D0
01:0020335E 6614            	  6704:          BNE.S   RL444
                            	  6705: 
01:00203360 4A04            	  6706:          TST.B   D4             CONTROL
01:00203362 6B00FA92        	  6707:          BMI     ER
01:00203366 2800            	  6708:          MOVE.L  D0,D4          CONTROL = '/'
01:00203368 6100F2F0        	  6709: RL333    BSR     GETREGAD
01:0020336C 8200            	  6710:          OR.B    D0,D1          D1 = BIT POSITION
01:0020336E 1A01            	  6711:          MOVE.B  D1,D5          D5 = LAST REGISTER ENTERED
01:00203370 6146            	  6712:          BSR.S   SETBIT
01:00203372 60D4            	  6713:          BRA     RL111
                            	  6714: 
01:00203374 0C00002D        	  6715: RL444    CMPI.B  #'-',D0
01:00203378 6630            	  6716:          BNE.S   RL666
                            	  6717: 
01:0020337A 0C04002F        	  6718:          CMPI.B  #'/',D4        CONTROL
01:0020337E 6600FA76        	  6719:          BNE     ER
01:00203382 2800            	  6720:          MOVE.L  D0,D4          CONTROL = '-'
01:00203384 6100F2D4        	  6721:          BSR     GETREGAD
01:00203388 8200            	  6722:          OR.B    D0,D1
01:0020338A 2E01            	  6723:          MOVE.L  D1,D7          D7 = NOW REGISTER
01:0020338C 1005            	  6724:          MOVE.B  D5,D0          D5 = LAST REG
01:0020338E B300            	  6725:          EOR.B   D1,D0
01:00203390 02000038        	  6726:          ANDI.B  #$38,D0
01:00203394 6600FA60        	  6727:          BNE     ER             NOT MATCED SET
01:00203398 BA01            	  6728:          CMP.B   D1,D5
01:0020339A 6A00FA5A        	  6729:          BPL     ER
                            	  6730: 
01:0020339E 5285            	  6731: RL555    ADDQ.L  #1,D5
01:002033A0 2205            	  6732:          MOVE.L  D5,D1
01:002033A2 6114            	  6733:          BSR.S   SETBIT
01:002033A4 BA07            	  6734:          CMP.B   D7,D5
01:002033A6 6BF6            	  6735:          BMI     RL555
01:002033A8 609E            	  6736:          BRA     RL111
                            	  6737: 
01:002033AA 4A04            	  6738: RL666    TST.B   D4
01:002033AC 6A00FA48        	  6739:          BPL     ER
01:002033B0 183C002F        	  6740:          MOVE.B  #'/',D4        CONTROL = '/'
01:002033B4 538D            	  6741:          SUBQ.L  #1,A5
01:002033B6 60B0            	  6742:          BRA     RL333
                            	  6743: 
01:002033B8 41FA001A        	  6744: SETBIT   LEA     MTBL(PC),A0    SET BIT IN CORRESPONDENCE MASK
01:002033BC 2002            	  6745:          MOVE.L  D2,D0
01:002033BE 02400038        	  6746:          ANDI.W  #$38,D0
01:002033C2 0C400020        	  6747:          CMPI.W  #$20,D0
01:002033C6 6604            	  6748:          BNE.S   RL30           NOT PREDECREMENT
01:002033C8 12301000        	  6749:          MOVE.B  (A0,D1),D1     D1 = BIT  (FOR SURE)
01:002033CC 03C6            	  6750: RL30     BSET    D1,D6
                            	  6751: 
01:002033CE 33460002        	  6752:          MOVE.W  D6,TDATA+2(A1) SAVE CORRESPONDENCE MASK
01:002033D2 4E75            	  6753:          RTS
                            	  6754: 
01:002033D4 0F              	  6755: MTBL     DC.B    15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,0
01:002033D5 0E
01:002033D6 0D
01:002033D7 0C
01:002033D8 0B
01:002033D9 0A
01:002033DA 09
01:002033DB 08
01:002033DC 07
01:002033DD 06
01:002033DE 05
01:002033DF 04
01:002033E0 03
01:002033E1 02
01:002033E2 01
01:002033E3 00
                            	  6756: 
                            	  6757: 
                            	  6758: 
                            	  6759: 
                            	  6760: *   D@,<DATA>(A@)
                            	  6761: *   <DATA>(A@),D@
                            	  6762: *         (A@),D@            FORCED TO 0(A@),D0
                            	  6763: *         D@,(A@)            FORCED TO D0,0(A@)
                            	  6764: *
                            	  6765: *  SIZE = WORD, LONG
                            	  6766: MMOVEP   DS      0              (INDEX 33)
01:002033E4 3029000C        	  6767:          MOVE.W  TLENGTH(A1),D0
01:002033E8 6700FA0C        	  6768:          BEQ     ER             .BYTE NOT ALLOWED
01:002033EC E248            	  6769:          LSR.W   #1,D0
01:002033EE 02400040        	  6770:          ANDI.W  #$0040,D0
01:002033F2 8440            	  6771:          OR.W    D0,D2          SIZE
                            	  6772: 
01:002033F4 3E3C0025        	  6773:          MOVE.W  #$25,D7
01:002033F8 6100F2A0        	  6774:          BSR     EA             D6 = MODE
                            	  6775: 
01:002033FC 6100F9DE        	  6776:          BSR     COMMA
                            	  6777: 
01:00203400 2006            	  6778:          MOVE.L  D6,D0
01:00203402 02400038        	  6779:          ANDI.W  #$38,D0
01:00203406 4A00            	  6780:          CMPI.B  #$0,D0
01:00203408 670A            	  6781:          BEQ.S   MMP344         D@,<DATA>(A@)
                            	  6782: 
                            	  6783: *    <DATA>(A@),D@
01:0020340A 6100F226        	  6784:          BSR     GETREGD
01:0020340E EE58            	  6785:          ROR.W   #7,D0
01:00203410 8440            	  6786:          OR.W    D0,D2          D@
01:00203412 6010            	  6787:          BRA.S   MMP348
                            	  6788: 
01:00203414 00420080        	  6789: MMP344   ORI.W   #$0080,D2      REGISTER TO MEMORY
                            	  6790: 
01:00203418 EE5E            	  6791:          ROR.W   #7,D6
01:0020341A 8446            	  6792:          OR.W    D6,D2          D@
                            	  6793: 
01:0020341C 3E3C0024        	  6794:          MOVE.W  #$24,D7
01:00203420 6100F278        	  6795:          BSR     EA
01:00203424 2006            	  6796: MMP348   MOVE.L  D6,D0
01:00203426 02460007        	  6797:          ANDI.W  #7,D6
01:0020342A 8446            	  6798:          OR.W    D6,D2          A@
                            	  6799: 
01:0020342C 02400038        	  6800:          ANDI.W  #$38,D0
01:00203430 0C000010        	  6801:          CMPI.B  #$10,D0
01:00203434 660A            	  6802:          BNE.S   MMP368         <DATA>(A@)
                            	  6803: 
01:00203436 42690002        	  6804:          CLR.W   TDATA+2(A1)    <DATA> FORCED TO ZERO;  "(A@)"
01:0020343A 5429000A        	  6805:          ADDQ.B  #2,TNB(A1)     NUMBER OF BYTES
01:0020343E 5483            	  6806:          ADDQ.L  #2,D3          STORE POINTER
01:00203440 6000F9BC        	  6807: MMP368   BRA     CMMD2
                            	  6808: 
                            	  6809: MMOVEQ   DS      0              (INDEX 34)
01:00203444 610001FA        	  6810:          BSR     GETIMM
01:00203448 2A00            	  6811:          MOVE.L  D0,D5
                            	  6812: 
01:0020344A 6100F4D4        	  6813:          BSR     EA8BITS        -128 TO +127
01:0020344E 6600F9A6        	  6814:          BNE     ER
01:00203452 8405            	  6815:          OR.B    D5,D2          D5 = VALUE
                            	  6816: 
01:00203454 6100F986        	  6817:          BSR     COMMA
                            	  6818: 
01:00203458 6100F1D8        	  6819:          BSR     GETREGD        D@
01:0020345C EE58            	  6820:          ROR.W   #7,D0
                            	  6821: 
01:0020345E 8440            	  6822: MMQ20    OR.W    D0,D2
01:00203460 6104            	  6823:          BSR.S   SIZELONG
01:00203462 6000F99A        	  6824:          BRA     CMMD2
                            	  6825: 
01:00203466 4A29000B        	  6826: SIZELONG TST.B   TLSPEC(A1)     MUST BE .LONG
01:0020346A 6708            	  6827:          BEQ.S   SI201          DEFAULT SIZE OK
01:0020346C 0C690080000C    	  6828:          CMPI.W  #$0080,TLENGTH(A1)
01:00203472 660A            	  6829:          BNE.S   ER10           NOT .LONG
01:00203474 4E75            	  6830: SI201    RTS
                            	  6831: 
01:00203476 0C690040000C    	  6832: SIZEWORD CMPI.W  #$0040,TLENGTH(A1)  MUST BE .WORD
01:0020347C 67F6            	  6833:          BEQ     SI201          [RTS]
01:0020347E 6000F976        	  6834: ER10     BRA     ER
                            	  6835: 
01:00203482 4A29000B        	  6836: SIZEBYTE TST.B   TLSPEC(A1)
01:00203486 6706            	  6837:          BEQ.S   SI222          DEFAULT SIZE OK
01:00203488 4A69000C        	  6838:          TST.W   TLENGTH(A1)
01:0020348C 66F0            	  6839:          BNE     ER10
01:0020348E 4E75            	  6840: SI222    RTS
                            	  6841: 
                            	  6842: MMOVE    DS      0              (INDEX 21)
01:00203490 0C150053        	  6843:          CMPI.B  #'S',(A5)
01:00203494 661C            	  6844:          BNE.S   MMM40
01:00203496 343C40C0        	  6845:          MOVE.W  #$40C0,D2      SR,<EA>
01:0020349A 528D            	  6846:          ADDQ.L  #1,A5
01:0020349C 0C1D0052        	  6847:          CMPI.B  #'R',(A5)+
01:002034A0 66DC            	  6848:          BNE     ER10
                            	  6849: 
01:002034A2 6100F938        	  6850:          BSR     COMMA
                            	  6851: 
01:002034A6 6100F1CA        	  6852:          BSR     EADA           DATA ALTERABLE ONLY (DESTINATION)
                            	  6853: 
01:002034AA 8446            	  6854: MM315    OR.W    D6,D2
01:002034AC 61C8            	  6855:          BSR     SIZEWORD
01:002034AE 6000F94E        	  6856:          BRA     CMMD2
                            	  6857: 
01:002034B2 0C150055        	  6858: MMM40    CMPI.B  #'U',(A5)
01:002034B6 661C            	  6859:          BNE.S   MMM50
01:002034B8 528D            	  6860:          ADDQ.L  #1,A5
01:002034BA 0C1D0053        	  6861:          CMPI.B  #'S',(A5)+
01:002034BE 66BE            	  6862:          BNE     ER10
01:002034C0 0C1D0050        	  6863:          CMPI.B  #'P',(A5)+
01:002034C4 66B8            	  6864:          BNE     ER10
                            	  6865: 
01:002034C6 6100F914        	  6866:          BSR     COMMA
                            	  6867: 
01:002034CA 343C4E68        	  6868:          MOVE.W  #$4E68,D2      USP,A@
01:002034CE 6100F17C        	  6869:          BSR     GETREGA
01:002034D2 608A            	  6870:          BRA     MMQ20
                            	  6871: 
                            	  6872: * GET EXCEPTIONS FROM DESTINATION
                            	  6873: MMM50    DS      0
                            	  6874: 
01:002034D4 6100FBF6        	  6875:          BSR     A5TODEST       MOVE A5 TO DESTINATION
                            	  6876: 
01:002034D8 101D            	  6877:          MOVE.B  (A5)+,D0
01:002034DA 0C000043        	  6878:          CMPI.B  #'C',D0
01:002034DE 6622            	  6879:          BNE.S   MMM60
01:002034E0 0C1D0043        	  6880:          CMPI.B  #'C',(A5)+
01:002034E4 6698            	  6881:          BNE     ER10
01:002034E6 0C1D0052        	  6882:          CMPI.B  #'R',(A5)+
01:002034EA 6692            	  6883:          BNE     ER10
01:002034EC 343C44C0        	  6884:          MOVE.W  #$44C0,D2      <EA>,CCR
                            	  6885: 
01:002034F0 234D0016        	  6886: MM508    MOVE.L  A5,PENDOP(A1)  SAVE POINTER
01:002034F4 2A690012        	  6887:          MOVE.L  PTROP(A1),A5   A5 = POINTER TO OPERAND
                            	  6888: 
01:002034F8 6100F190        	  6889:          BSR     EADADDR        DATA ADDRESSING ONLY (SOURCE)
01:002034FC 2A690016        	  6890:          MOVE.L  PENDOP(A1),A5
01:00203500 60A8            	  6891:          BRA     MM315
                            	  6892: 
01:00203502 0C000053        	  6893: MMM60    CMPI.B  #'S',D0
01:00203506 660E            	  6894:          BNE.S   MM70
01:00203508 343C46C0        	  6895:          MOVE.W  #$46C0,D2      <EA>,SR
01:0020350C 0C1D0052        	  6896:          CMPI.B  #'R',(A5)+
01:00203510 6600F8E4        	  6897:          BNE     ER
01:00203514 60DA            	  6898:          BRA     MM508
                            	  6899: 
01:00203516 0C000055        	  6900: MM70     CMPI.B  #'U',D0
01:0020351A 6628            	  6901:          BNE.S   MM80
01:0020351C 343C4E60        	  6902:          MOVE.W  #$4E60,D2      A@,USP
01:00203520 0C1D0053        	  6903:          CMPI.B  #'S',(A5)+
01:00203524 6600F8D0        	  6904:          BNE     ER
01:00203528 0C1D0050        	  6905:          CMPI.B  #'P',(A5)+
01:0020352C 6600F8C8        	  6906:          BNE     ER
                            	  6907: 
01:00203530 234D0016        	  6908:          MOVE.L  A5,PENDOP(A1)
01:00203534 2A690012        	  6909:          MOVE.L  PTROP(A1),A5
01:00203538 6100F112        	  6910:          BSR     GETREGA
01:0020353C 2A690016        	  6911:          MOVE.L  PENDOP(A1),A5  RESTORE A5
01:00203540 6000FF1C        	  6912:          BRA     MMQ20
                            	  6913: 
01:00203544 2A690012        	  6914: MM80     MOVE.L  PTROP(A1),A5   A5 = POINTER TO SOURCE FIELD
01:00203548 6100F0E2        	  6915:          BSR     FSIZE          GET SIZE (BITS  7 - 6)
01:0020354C ED4A            	  6916:          LSL.W   #6,D2          ADJUST TO(BITS 13-12)
01:0020354E 0802000D        	  6917:          BTST    #13,D2
01:00203552 6608            	  6918:          BNE.S   MM804          .L 10 TO 10
01:00203554 06421000        	  6919:          ADDI.W  #$1000,D2      .W 01 TO 11
01:00203558 00421000        	  6920:          ORI.W   #$1000,D2      .B 00 TO 01
01:0020355C 6100F138        	  6921: MM804    BSR     EAALL          SOURCE; ALL MODES ALLOWED
01:00203560 8446            	  6922:          OR.W    D6,D2
                            	  6923: 
                            	  6924: * IF BYTE SIZE; "ADDRESS REGISTER DIRECT" NOT ALLOWED
                            	  6925: 
01:00203562 2002            	  6926:          MOVE.L  D2,D0
01:00203564 02403000        	  6927:          ANDI.W  #$3000,D0
01:00203568 0C401000        	  6928:          CMPI.W  #$1000,D0
01:0020356C 660C            	  6929:          BNE.S   MM806          NOT .B SIZE
01:0020356E 02060038        	  6930:          ANDI.B  #$38,D6
01:00203572 0C060008        	  6931:          CMPI.B  #$08,D6
01:00203576 6700F87E        	  6932:          BEQ     ER
                            	  6933: MM806    DS      0
                            	  6934: 
01:0020357A 6100F860        	  6935:          BSR     COMMA
                            	  6936: 
01:0020357E 3E3C01FF        	  6937:          MOVE.W  #$1FF,D7       DATA ALTERABLE + A@
01:00203582 6100F116        	  6938:          BSR     EA
                            	  6939: 
01:00203586 2006            	  6940:          MOVE.L  D6,D0          DESTINATION
01:00203588 02400038        	  6941:          ANDI.W  #$0038,D0
01:0020358C 0C400008        	  6942:          CMPI.W  #$0008,D0
01:00203590 6712            	  6943:          BEQ.S   MMOVEA1        A@ MAKE MOVEA
                            	  6944: 
                            	  6945: * POSITION REGISTER AND MODE OF DESTINATION
                            	  6946: 
01:00203592 E69E            	  6947: MM825    ROR.L   #3,D6          RRR............. .............MMM
01:00203594 E65E            	  6948:          ROR.W   #3,D6                           MMM.............
01:00203596 4846            	  6949:          SWAP    D6             MMM............. RRR.............
01:00203598 E75E            	  6950:          ROL.W   #3,D6                           .............RRR
01:0020359A E39E            	  6951:          ROL.L   #1,D6          MM.............. ............RRRM
01:0020359C E19E            	  6952:          ROL.L   #8,D6          ................ ....RRRMMM......
01:0020359E 8446            	  6953:          OR.W    D6,D2
01:002035A0 6000F85C        	  6954:          BRA     CMMD2
                            	  6955: 
01:002035A4 7600            	  6956: MMOVEA1  CLR.L   D3
01:002035A6 137C0002000A    	  6957:          MOVE.B  #2,TNB(A1)
                            	  6958: 
                            	  6959: MMOVEA   DS      0              (INDEX 32)
01:002035AC 2A690012        	  6960:          MOVE.L  PTROP(A1),A5   A5 = POINTER TO OPERAND
                            	  6961: 
01:002035B0 3429000C        	  6962:          MOVE.W  TLENGTH(A1),D2 D0 = SIZE
01:002035B4 6700F840        	  6963:          BEQ     ER             .BYTE NOT ALLOWED
                            	  6964: 
01:002035B8 ED4A            	  6965:          LSL.W   #6,D2          .SIZE
01:002035BA 0802000C        	  6966:          BTST    #12,D2
01:002035BE 6704            	  6967:          BEQ.S   MMA225         .L = ..10
01:002035C0 00423000        	  6968:          ORI.W   #$3000,D2      .W = ..11
                            	  6969: MMA225
                            	  6970: 
01:002035C4 6100F0D0        	  6971:          BSR     EAALL          ALL MODES ALLOWED
01:002035C8 8446            	  6972:          OR.W    D6,D2
                            	  6973: 
01:002035CA 6100F810        	  6974:          BSR     COMMA
                            	  6975: 
01:002035CE 3E3C0002        	  6976:          MOVE.W  #$0002,D7      A@ ONLY
01:002035D2 6100F0C6        	  6977:          BSR     EA
01:002035D6 60BA            	  6978:          BRA     MM825
                            	  6979: 
                            	  6980: 
                            	  6981: MJMP     DS      0              (INDEX 18)
01:002035D8 4A29000B        	  6982:          TST.B   TLSPEC(A1)
01:002035DC 671C            	  6983:          BEQ.S   MJMP32         DEFAULT (ALLOW EITHER .S OR .L)
01:002035DE 3029000C        	  6984:          MOVE.W  TLENGTH(A1),D0
01:002035E2 6700F812        	  6985:          BEQ     ER             .B NOT ALLOWED
01:002035E6 3E3C06E4        	  6986:          MOVE.W  #$6E4,D7       D7 = MODES ALLOWED
01:002035EA 0C400040        	  6987:          CMPI.W  #$40,D0
01:002035EE 6704            	  6988:          BEQ.S   MJMP22         .S SPECIFIED (.W ACCEPTED)
01:002035F0 3E3C8764        	  6989:          MOVE.W  #$8764,D7      MODE FOR .L
01:002035F4 6100F0A4        	  6990: MJMP22   BSR     EA
01:002035F8 6004            	  6991:          BRA.S   MJMP42
                            	  6992: 
01:002035FA 6100F07C        	  6993: MJMP32   BSR     EAC            CONTROL ADDRESSING ONLY
01:002035FE 8446            	  6994: MJMP42   OR.W    D6,D2
01:00203600 6000F7FC        	  6995:          BRA     CMMD2
                            	  6996: 
                            	  6997: * SIZE = LONG
                            	  6998: MLEA     DS      0              (INDEX 19)
01:00203604 6100FE60        	  6999:          BSR     SIZELONG
                            	  7000: 
01:00203608 6100F06E        	  7001:          BSR     EAC            CONTROL ADDRESSING ONLY
01:0020360C 8446            	  7002:          OR.W    D6,D2
                            	  7003: 
01:0020360E 6100F7CC        	  7004:          BSR     COMMA
                            	  7005: 
01:00203612 6100F038        	  7006:          BSR     GETREGA
01:00203616 EE58            	  7007:          ROR.W   #7,D0
01:00203618 8440            	  7008:          OR.W    D0,D2
01:0020361A 6000F7E2        	  7009:          BRA     CMMD2
                            	  7010: 
                            	  7011: 
                            	  7012: * SIZE = LONG
                            	  7013: MPEA     DS      0              (INDEX 36)
01:0020361E 6100FE46        	  7014:          BSR     SIZELONG
                            	  7015: 
01:00203622 6100F054        	  7016:          BSR     EAC            CONTROL ADDRESSING ONLY
01:00203626 8446            	  7017:          OR.W    D6,D2
01:00203628 6000F7D4        	  7018:          BRA     CMMD2
                            	  7019: 
                            	  7020: MSWAP    DS      0              (INDEX 24)
                            	  7021: * SIZE WORD
01:0020362C 0C690040000C    	  7022:          CMPI.W  #$0040,TLENGTH(A1)
01:00203632 6600F7C2        	  7023:          BNE     ER             NOT .W
                            	  7024: 
01:00203636 6100EFFA        	  7025:          BSR     GETREGD        D@ ONLY
01:0020363A 8440            	  7026:          OR.W    D0,D2
01:0020363C 6000F7C0        	  7027:          BRA     CMMD2
                            	  7028: 
01:00203640 0C1D0023        	  7029: GETIMM   CMPI.B  #'#',(A5)+
01:00203644 6600F7B0        	  7030:          BNE     ER
                            	  7031: 
01:00203648 6100EF78        	  7032:          BSR     EV             EVALUATE EXPRESSION
01:0020364C 4E75            	  7033:          RTS                    D0 = VALUE
                            	  7034: 
01:0020364E 6100EFFC        	  7035: MLINK    BSR     GETREGA        (INDEX 20)
01:00203652 8440            	  7036:          OR.W    D0,D2
                            	  7037: 
01:00203654 6100F786        	  7038:          BSR     COMMA
                            	  7039: 
01:00203658 61E6            	  7040:          BSR     GETIMM
01:0020365A 2A00            	  7041:          MOVE.L  D0,D5
01:0020365C 6100F2AE        	  7042:          BSR     EA16BITS       -32K TO +32K
01:00203660 33400002        	  7043:          MOVE.W  D0,TDATA+2(A1)
                            	  7044: 
01:00203664 5429000A        	  7045:          ADDQ.B  #2,TNB(A1)
01:00203668 6000F794        	  7046:          BRA     CMMD2
                            	  7047: 
                            	  7048: MSTOP    DS      0              (INDEX 23)
                            	  7049: * UNSIZED
01:0020366C 61D2            	  7050:          BSR     GETIMM
01:0020366E 0C8000010000    	  7051:          CMPI.L  #$00010000,D0
01:00203674 6400F780        	  7052:          BCC     ER
01:00203678 33400002        	  7053:          MOVE.W  D0,TDATA+2(A1)
01:0020367C 5429000A        	  7054:          ADDQ.B  #2,TNB(A1)
01:00203680 6000F77C        	  7055:          BRA     CMMD2
                            	  7056: 
                            	  7057: MTRAP    DS      0              (INDEX 25)
01:00203684 61BA            	  7058:          BSR     GETIMM
01:00203686 0C8000000010    	  7059:          CMPI.L  #16,D0
01:0020368C 6400F768        	  7060:          BCC     ER
01:00203690 8440            	  7061:          OR.W    D0,D2
01:00203692 6000F76A        	  7062:          BRA     CMMD2
                            	  7063: 
                            	  7064: MUNLK    DS      0              (INDEX 26)
                            	  7065: * UNSIZED
01:00203696 6100EFB4        	  7066:          BSR     GETREGA
01:0020369A 8440            	  7067:          OR.W    D0,D2
01:0020369C 6000F760        	  7068:          BRA     CMMD2
                            	  7069: 
                            	  7070: MDC      DS      0              (INDEX 37) .W ONLY ALLOWED
01:002036A0 6100EF20        	  7071:          BSR     EV
01:002036A4 2A00            	  7072:          MOVE.L  D0,D5
01:002036A6 6100F25A        	  7073:          BSR     EA16BIT        ONLY .W ALLOWED     -32K TO +64K
01:002036AA 3405            	  7074:          MOVE.W  D5,D2
01:002036AC 6000F750        	  7075:          BRA     CMMD2
                            	  7076: 
                            	  7077: 
                            	  7078: 
                            	  7079: 
                            	  7080: *-------------------------------------------------------------------------
                            	  7081: * File DCODE68K  68K ONE LINE DISASSEMBLER                        07/28/82
                            	  7082: 
                            	  7083: *        CALLING SEQUENCE:
                            	  7084: *   D0,D1,D2 = CODE TO BE DISASSEMBLED
                            	  7085: *   A4 = VALUE OF PROGRAM COUNTER FOR THE CODE
                            	  7086: *   A5 = POINTER TO STORE DATA (BUFSIZE = 80 ASSUMED)
                            	  7087: *        JSR       DCODE68K
                            	  7088: 
                            	  7089: *        RETURN:
                            	  7090: *   A4 = VALUE OF PROGRAM COUNTER FOR NEXT INSTRUCTION
                            	  7091: *   A5 = POINTER TO LINE AS DISASSEMBLED
                            	  7092: *   A6 = POINTER TO END OF LINE
                            	  7093: *
                            	  7094: * 01234567890123456789012345678901234567890123456789
                            	  7095: * AAAAAA FDATA.DDDDDDDDDDDDDD FOC.... FOP.....
                            	  7096: 
                            	  7097: *FDATA   EQU     10             DATA FIELD
                            	  7098: *FOC     EQU     31             OP-CODE FIELD
                            	  7099: *FOP     EQU     39             OPERAND FIELD
                            	  7100: 
                            	  7101: * CAUSES ORGIN MODULO 4
                            	  7102: LONG     MACRO
                            	  7103:          DS      0
                            	  7104:          DS.B    (*-X)&2
                            	  7105:          ENDM
                            	  7106: 
                            	  7107: 
                            	  7108: X        DS      0              BASE ADDRESS THIS MODULE
                            	  7109:          LONG
                            	     1M          DS      0
                            	     2M          DS.B    (*-X)&2
                            	  7110: 
                            	  7111: *  MOVEM REGISTERS TO EA
                            	  7112: *
                            	  7113: *        01001D001S......
                            	  7114: *        ..........XXXXXX       EFFECTIVE ADDRESS
                            	  7115: *        .........0......       WORD
                            	  7116: *        .........1......       LONG
                            	  7117: *        .....0..........       REGISTER TO MEMORY
                            	  7118: *        .....1..........       MEMORY TO REGISTER
                            	  7119: *
                            	  7120: 
                            	  7121: IMOVEMFR DS      0
01:002036B0 6100071E        	  7122:          BSR     MOVEMS         SIZE
                            	  7123: 
01:002036B4 7C38            	  7124:          MOVEQ   #$0038,D6
01:002036B6 CC54            	  7125:          AND.W   (A4),D6
01:002036B8 0C460020        	  7126:          CMPI.W  #$0020,D6
01:002036BC 6706            	  7127:          BEQ.S   IM7788         PREDECREMENT MODE
                            	  7128: 
01:002036BE 7C01            	  7129:          MOVEQ   #1,D6          D6 = INCREMENTER (BIT POSITION)
01:002036C0 7200            	  7130:          MOVEQ   #0,D1          D1 = BIT POSITION
01:002036C2 6004            	  7131:          BRA.S   IM7799
                            	  7132: 
01:002036C4 7CFF            	  7133: IM7788   MOVEQ   #-1,D6         D6 = DECREMENTER (BIT POSITION)
01:002036C6 720F            	  7134:          MOVEQ   #15,D1         D1 = BIT POSITION
01:002036C8 6100071A        	  7135: IM7799   BSR     MOVEMR         BUILD MASK WORD
                            	  7136: 
01:002036CC 1CFC002C        	  7137:          MOVE.B  #',',(A6)+     STORE COMMA
                            	  7138: 
01:002036D0 5483            	  7139:          ADDQ.L  #2,D3
01:002036D2 3814            	  7140:          MOVE.W  (A4),D4
01:002036D4 3E3C01F4        	  7141:          MOVE.W  #$1F4,D7       CONTROL + PREDECREMENT
01:002036D8 61000534        	  7142:          BSR     EEA
01:002036DC 601C            	  7143:          BRA.S   CS16           COMMON
                            	  7144: 
                            	  7145:          LONG
                            	     1M          DS      0
01:002036DE 00              	     2M          DS.B    (*-X)&2
01:002036DF *
                            	  7146: * MOVEM  EA  TO REGISTERS
                            	  7147: *
01:002036E0 610006EE        	  7148: IMOVEMTR BSR     MOVEMS         SIZE
01:002036E4 5483            	  7149:          ADDQ.L  #2,D3
01:002036E6 3E3C07EC        	  7150:          MOVE.W  #$7EC,D7       CONTROL + POSTINCREMENT
01:002036EA 61000522        	  7151:          BSR     EEA
                            	  7152: 
01:002036EE 1CFC002C        	  7153:          MOVE.B  #',',(A6)+     STORE COMMA
                            	  7154: 
01:002036F2 7C01            	  7155:          MOVEQ   #1,D6          D6 = BIT POSITION INCREMENTER
01:002036F4 7200            	  7156:          MOVEQ   #0,D1          D1 = BIT POSITION
01:002036F6 610006EC        	  7157:          BSR     MOVEMR
                            	  7158: 
01:002036FA 606C            	  7159: CS16     BRA.S   CS15           COMMON
                            	  7160: 
                            	  7161: 
                            	  7162:          LONG
                            	     1M          DS      0
                            	     2M          DS.B    (*-X)&2
                            	  7163: ISTOP    DS      0
01:002036FC 302C0002        	  7164:          MOVE.W  2(A4),D0
01:00203700 1CFC0023        	  7165:          MOVE.B  #'#',(A6)+     IMMEDIATE
01:00203704 1CFC0024        	  7166:          MOVE.B  #'$',(A6)+     HEX
01:00203708 6100E6A0        	  7167:          BSR     PNT4HX         VALUE
01:0020370C 600007EA        	  7168:          BRA     COMMON4
                            	  7169: 
                            	  7170:          LONG
                            	     1M          DS      0
                            	     2M          DS.B    (*-X)&2
                            	  7171: IMMED    DS      0              ADD  AND  CMP #  EOR  OR  SUB
01:00203710 61000472        	  7172:          BSR     FORMSIZE
01:00203714 5483            	  7173:          ADDQ.L  #2,D3          SIZE = 4
01:00203716 1CFC0023        	  7174:          MOVE.B  #'#',(A6)+     IMMEDIATE
                            	  7175: 
01:0020371A 7000            	  7176:          CLR.L   D0
01:0020371C 302C0002        	  7177:          MOVE.W  2(A4),D0       D0 = EXTENSION WORD
01:00203720 3214            	  7178:          MOVE.W  (A4),D1
01:00203722 EC49            	  7179:          LSR.W   #6,D1
01:00203724 02410003        	  7180:          ANDI.W  #3,D1
01:00203728 6746            	  7181:          BEQ.S   IMMED65        .BYTE
                            	  7182: 
01:0020372A 0C010001        	  7183:          CMPI.B  #1,D1
01:0020372E 6750            	  7184:          BEQ.S   IMMED75        .WORD
                            	  7185: 
01:00203730 5483            	  7186:          ADDQ.L  #2,D3          .LONG    SIZE = 6
01:00203732 202C0002        	  7187:          MOVE.L  2(A4),D0       D0 = LONG EXTENSION WORD
                            	  7188: 
01:00203736 6100DC24        	  7189: IMMED45  BSR     HEX2DEC        DECIMAL
                            	  7190: 
01:0020373A 1CC5            	  7191:          MOVE.B  D5,(A6)+       COMMA SEPARATOR
                            	  7192: 
01:0020373C 3014            	  7193:          MOVE    (A4),D0
01:0020373E 0240003F        	  7194:          ANDI.W  #$003F,D0
01:00203742 0C40003C        	  7195:          CMPI.W  #$003C,D0      DESTINATION ADDRESS MODE 111100  "SR"
01:00203746 6622            	  7196:          BNE.S   IMMED55        NOT FOUND
                            	  7197: 
01:00203748 3014            	  7198:          MOVE.W  (A4),D0        "SR"  ILLEGAL FOR
01:0020374A 02404000        	  7199:          ANDI.W  #$4000,D0      ADDI   SUBI  CMPI
01:0020374E 660007D2        	  7200:          BNE     FERROR         0600   0400  0C00
                            	  7201: 
01:00203752 3214            	  7202:          MOVE.W  (A4),D1
01:00203754 024100C0        	  7203:          ANDI.W  #$00C0,D1
01:00203758 0C410080        	  7204:          CMPI.W  #$0080,D1
01:0020375C 670007C4        	  7205:          BEQ     FERROR         .LONG NOT ALLOWED
                            	  7206: 
01:00203760 1CFC0053        	  7207:          MOVE.B  #'S',(A6)+     #,SR FOR ANDI, EORI, ORI
01:00203764 1CFC0052        	  7208:          MOVE.B  #'R',(A6)+
01:00203768 603E            	  7209: CS15     BRA.S   CS14           COMMON
                            	  7210: 
01:0020376A 610004A2        	  7211: IMMED55  BSR     EEA
01:0020376E 6038            	  7212:          BRA.S   CS14           COMMON
                            	  7213: 
01:00203770 2200            	  7214: IMMED65  MOVE.L  D0,D1          D1 = XXXXXXXX........
01:00203772 E049            	  7215:          LSR.W   #8,D1          D1 = 00000000XXXXXXXX
01:00203774 670A            	  7216:          BEQ.S   IMMED75
01:00203776 2200            	  7217:          MOVE.L  D0,D1
01:00203778 EE41            	  7218:          ASR.W   #7,D1
01:0020377A 5241            	  7219:          ADDQ.W  #1,D1          CHECK FOR NEGATIVE
01:0020377C 660007A4        	  7220:          BNE     FERROR
                            	  7221: 
01:00203780 48C0            	  7222: IMMED75  EXT.L   D0
01:00203782 60B2            	  7223:          BRA     IMMED45
                            	  7224: 
                            	  7225: *  BIT   5432109876543210
                            	  7226: *        ....RRRMMM......       DESTINATION REGISTER MODE
                            	  7227: *        ..........MMMRRR       SOURCE MODE REGISTER
                            	  7228: *        0001............       .BYTE
                            	  7229: *        0011............       .WORD
                            	  7230: *        0010............       .LONG
                            	  7231: *
                            	  7232: * IF BYTE SIZE; DESTINATION ADDRESS DIRECT NOT ALLOWED
                            	  7233:          LONG
                            	     1M          DS      0
                            	     2M          DS.B    (*-X)&2
                            	  7234: IMOVE    DS      0
01:00203784 600003A2        	  7235:          BRA     IMOVEA1
                            	  7236: 
                            	  7237:          LONG
                            	     1M          DS      0
                            	     2M          DS.B    (*-X)&2
                            	  7238: ILINK    DS      0
01:00203788 615E            	  7239:          BSR.S   FORMREGA
                            	  7240: 
01:0020378A 1CC5            	  7241:          MOVE.B  D5,(A6)+       COMMA SERARATOR
                            	  7242: 
01:0020378C 1CFC0023        	  7243:          MOVE.B  #'#',(A6)+
01:00203790 302C0002        	  7244:          MOVE.W  2(A4),D0
01:00203794 48C0            	  7245:          EXT.L   D0
01:00203796 6100DBC4        	  7246:          BSR     HEX2DEC        DECIMAL DISPLACEMENT
01:0020379A 6000075C        	  7247:          BRA     COMMON4
                            	  7248: 
                            	  7249:          LONG
                            	     1M          DS      0
01:0020379E 00              	     2M          DS.B    (*-X)&2
01:0020379F *
                            	  7250: FORM1    DS      0              CLR  NEG  NEGX  NOT TST
01:002037A0 610003E2        	  7251:          BSR     FORMSIZE
                            	  7252: 
                            	  7253: 
                            	  7254: *                               NBCD TAS
01:002037A4 61000468        	  7255: FORM1A   BSR     EEA            DATA ALTERABLE ONLY
01:002037A8 606E            	  7256: CS14     BRA.S   CS13           COMMON
                            	  7257: 
                            	  7258:          LONG
                            	     1M          DS      0
01:002037AA 00              	     2M          DS.B    (*-X)&2
01:002037AB *
                            	  7259: FORM3    DS      0              EXT  SWAP
01:002037AC 614A            	  7260:          BSR.S   FORMREGD
01:002037AE 6068            	  7261:          BRA.S   CS13           COMMON
                            	  7262: 
                            	  7263:          LONG
                            	     1M          DS      0
                            	     2M          DS.B    (*-X)&2
                            	  7264: FORM4    DS      0              TRAP
01:002037B0 1CFC0023        	  7265:          MOVE.B  #'#',(A6)+
01:002037B4 3014            	  7266:          MOVE.W  (A4),D0
01:002037B6 02800000000F    	  7267:          ANDI.L  #$0F,D0
01:002037BC 6100DB9E        	  7268:          BSR     HEX2DEC        DECIMAL
01:002037C0 6056            	  7269:          BRA.S   CS13           COMMON
                            	  7270: 
                            	  7271:          LONG
                            	     1M          DS      0
01:002037C2 00              	     2M          DS.B    (*-X)&2
01:002037C3 *
                            	  7272: FORM5    DS      0              UNLNK
01:002037C4 6122            	  7273:          BSR.S   FORMREGA
01:002037C6 6050            	  7274:          BRA.S   CS13           COMMON
                            	  7275: 
                            	  7276: *  BIT   5432109876543210
                            	  7277: *        ....RRR.........       ADDRESS REGISTER
                            	  7278: *        ..........XXXXXX       EFFECTIVE ADDRESS
                            	  7279: *
                            	  7280:          LONG
                            	     1M          DS      0
                            	     2M          DS.B    (*-X)&2
                            	  7281: FORM6A   DS      0              LEA
01:002037C8 3E3C07E4        	  7282:          MOVE.W  #$7E4,D7       CONTROL ADDRESSING
01:002037CC 6154            	  7283:          BSR.S   EEA10
                            	  7284: 
01:002037CE 1CC5            	  7285:          MOVE.B  D5,(A6)+       COMMA SEPARATOR
                            	  7286: 
01:002037D0 3814            	  7287:          MOVE.W  (A4),D4
01:002037D2 EF5C            	  7288:          ROL.W   #7,D4
01:002037D4 6112            	  7289:          BSR.S   FORMREGA
01:002037D6 6040            	  7290:          BRA.S   CS13           COMMON
                            	  7291: 
                            	  7292: *  BIT   5432109876543210
                            	  7293: *        ....DDD.........       DATA REGISTER
                            	  7294: *        ..........XXXXXX       EFFECTIVE ADDRESS
                            	  7295: *
                            	  7296:          LONG
                            	     1M          DS      0
                            	     2M          DS.B    (*-X)&2
                            	  7297: FORM6D   DS      0              CHK  DIVS  DIVU  MULS  MULU
01:002037D8 3E3C0FFD        	  7298:          MOVE.W  #$FFD,D7       DATA ADDRESSING
01:002037DC 6144            	  7299:          BSR.S   EEA10
                            	  7300: 
01:002037DE 1CC5            	  7301:          MOVE.B  D5,(A6)+       COMMA SEPARATOR
                            	  7302: 
01:002037E0 3814            	  7303:          MOVE.W  (A4),D4
01:002037E2 EF5C            	  7304:          ROL.W   #7,D4
01:002037E4 6112            	  7305:          BSR.S   FORMREGD
01:002037E6 6030            	  7306:          BRA.S   CS13           COMMON
                            	  7307: 
01:002037E8 1CFC0041        	  7308: FORMREGA MOVE.B  #'A',(A6)+     FORMAT A@
01:002037EC 02040007        	  7309: FORMREG5 ANDI.B  #$07,D4
01:002037F0 00040030        	  7310:          ORI.B   #'0',D4
01:002037F4 1CC4            	  7311:          MOVE.B  D4,(A6)+
01:002037F6 4E75            	  7312:          RTS
                            	  7313: 
01:002037F8 1CFC0044        	  7314: FORMREGD MOVE.B  #'D',(A6)+     FORMAT D@
01:002037FC 60EE            	  7315:          BRA     FORMREG5
                            	  7316: 
                            	  7317: *  BIT   5432109876543210
                            	  7318: *        ....DDD......DDD       DATA REGISTERS
                            	  7319: *
                            	  7320:          LONG
                            	     1M          DS      0
01:002037FE 00              	     2M          DS.B    (*-X)&2
01:002037FF *
                            	  7321: FORM7    DS      0              EXG
01:00203800 EF5C            	  7322:          ROL.W   #7,D4
01:00203802 61F4            	  7323:          BSR     FORMREGD
                            	  7324: 
01:00203804 1CC5            	  7325:          MOVE.B  D5,(A6)+       COMMA SEPARATOR
                            	  7326: 
01:00203806 3814            	  7327:          MOVE.W  (A4),D4
01:00203808 61EE            	  7328:          BSR     FORMREGD
01:0020380A 600C            	  7329:          BRA.S   CS13           COMMON
                            	  7330: 
                            	  7331: *  BIT   5432109876543210
                            	  7332: *        ....AAA......AAA       ADDRESS REGISTERS
                            	  7333: *
                            	  7334:          LONG
                            	     1M          DS      0
                            	     2M          DS.B    (*-X)&2
                            	  7335: FORM8    DS      0              EXG
01:0020380C EF5C            	  7336:          ROL.W   #7,D4
01:0020380E 61D8            	  7337:          BSR     FORMREGA
                            	  7338: 
01:00203810 1CFC002C        	  7339: FORM815  MOVE.B  #',',(A6)+     COMMA SEPARATOR
                            	  7340: 
01:00203814 3814            	  7341:          MOVE.W  (A4),D4
01:00203816 61D0            	  7342:          BSR     FORMREGA
01:00203818 60000080        	  7343: CS13     BRA     CS12           COMMON
                            	  7344: 
                            	  7345: *  BIT   5432109876543210
                            	  7346: *        ....DDD.........       DATA REGISTER
                            	  7347: *        .............AAA       ADDRESS REGISTER
                            	  7348: *
                            	  7349:          LONG
                            	     1M          DS      0
                            	     2M          DS.B    (*-X)&2
                            	  7350: FORM9    DS      0              EXG
01:0020381C EF5C            	  7351:          ROL.W   #7,D4
01:0020381E 61D8            	  7352:          BSR     FORMREGD       DATA REGISTER
01:00203820 60EE            	  7353:          BRA     FORM815
                            	  7354: 
01:00203822 600003EA        	  7355: EEA10    BRA     EEA
                            	  7356: 
                            	  7357: *  BIT   5432109876543210
                            	  7358: *        ..........AAAAAA         EFFECTIVE ADDRESS
                            	  7359: *        .......MMM......         OP-MODE
                            	  7360: *        ....RRR.........         D-REGISTER
                            	  7361: *        .......011......         WORD  EA,A@
                            	  7362: *        .......111......         LONG  EA,A@
                            	  7363: *        .......000......         EA,D@ BYTE (ADDRESS REGISTER DIRECT NOT ALLOWED)
                            	  7364: *        .......0........         EA,D@
                            	  7365: *        .......1........         D@,EA
                            	  7366: *        ........00......         BYTE
                            	  7367: *        ........01......         WORD
                            	  7368: *        ........10......         LONG
                            	  7369: *
                            	  7370:          LONG
                            	     1M          DS      0
01:00203826 00              	     2M          DS.B    (*-X)&2
01:00203827 *
                            	  7371: *                               ADD <EA>,A@   CMP <EA>,A@   SUB <EA>,A@
                            	  7372: FORM10EX DS      0              ADD  CMP  SUB
01:00203828 3E3C0FFF        	  7373:          MOVE.W  #$FFF,D7       ALL MODES ALLOWED
01:0020382C 2004            	  7374:          MOVE.L  D4,D0
01:0020382E 024001C0        	  7375:          ANDI.W  #$01C0,D0
01:00203832 673A            	  7376:          BEQ.S   FORM103        .......000......
01:00203834 0C4001C0        	  7377:          CMPI.W  #$01C0,D0
01:00203838 6710            	  7378:          BEQ.S   FORM10E3       .......111......
01:0020383A 0C4000C0        	  7379:          CMPI.W  #$00C0,D0
01:0020383E 661E            	  7380:          BNE.S   FORM10E6
                            	  7381: 
01:00203840 1AFC002E        	  7382:          MOVE.B  #'.',(A5)+     .......011......       STORE PERIOD
01:00203844 1AFC0057        	  7383:          MOVE.B  #'W',(A5)+
01:00203848 6008            	  7384:          BRA.S   FORM10E4
                            	  7385: 
01:0020384A 1AFC002E        	  7386: FORM10E3 MOVE.B  #'.',(A5)+
01:0020384E 1AFC004C        	  7387:          MOVE.B  #'L',(A5)+
                            	  7388: 
01:00203852 61CE            	  7389: FORM10E4 BSR     EEA10
                            	  7390: 
01:00203854 1CC5            	  7391:          MOVE.B  D5,(A6)+       STORE COMMA SEPARATOR
                            	  7392: 
01:00203856 3814            	  7393:          MOVE.W  (A4),D4
01:00203858 EF5C            	  7394:          ROL.W   #7,D4
01:0020385A 618C            	  7395:          BSR     FORMREGA       <EA>,A@
01:0020385C 603C            	  7396:          BRA.S   CS12           COMMON
                            	  7397: 
01:0020385E 08140000        	  7398: FORM10E6 BTST.B  #0,(A4)
01:00203862 6620            	  7399:          BNE.S   FORM105        .......1........    D@,<EA>
01:00203864 600C            	  7400:          BRA.S   FORM104        .......0........    <EA>,D@
                            	  7401: 
                            	  7402: *  BIT   5432109876543210
                            	  7403: *        ..........AAAAAA       EFFECTIVE ADDRESS
                            	  7404: *        .......MMM......       OP-MODE
                            	  7405: *        ....RRR.........       D-REGISTER
                            	  7406: *        .......0........       EA,D@
                            	  7407: *        .......1........       D@,EA
                            	  7408: *        ........00......       BYTE
                            	  7409: *        ........01......       WORD
                            	  7410: *        ........10......       LONG
                            	  7411:          LONG
                            	     1M          DS      0
01:00203866 00              	     2M          DS.B    (*-X)&2
01:00203867 *
                            	  7412: FORM10   DS      0              AND  EOR  OR
01:00203868 08140000        	  7413:          BTST.B  #0,(A4)
01:0020386C 6616            	  7414:          BNE.S   FORM105
                            	  7415: 
01:0020386E 3E3C0FFD        	  7416: FORM103  MOVE.W  #$FFD,D7       DATA ADDRESSING
01:00203872 61000310        	  7417: FORM104  BSR     FORMSIZE
01:00203876 61AA            	  7418:          BSR     EEA10          <EA>,D@
                            	  7419: 
01:00203878 1CC5            	  7420:          MOVE.B  D5,(A6)+       COMMA SEPARATOR
                            	  7421: 
01:0020387A 1814            	  7422:          MOVE.B  (A4),D4
01:0020387C E20C            	  7423:          LSR.B   #1,D4
01:0020387E 6100FF78        	  7424:          BSR     FORMREGD
01:00203882 6016            	  7425:          BRA.S   CS12           COMMON
                            	  7426: 
01:00203884 610002FE        	  7427: FORM105  BSR     FORMSIZE       D@,<EA>
01:00203888 1814            	  7428:          MOVE.B  (A4),D4
01:0020388A E20C            	  7429:          LSR.B   #1,D4
01:0020388C 6100FF6A        	  7430:          BSR     FORMREGD
                            	  7431: 
01:00203890 1CC5            	  7432:          MOVE.B  D5,(A6)+       COMMA SEPARATOR
                            	  7433: 
01:00203892 3814            	  7434:          MOVE.W  (A4),D4
01:00203894 3E3C01FD        	  7435:          MOVE.W  #$1FD,D7       ALTERABLE MEMORY ADDRESSING
01:00203898 6188            	  7436:          BSR     EEA10
01:0020389A 6000065E        	  7437: CS12     BRA     COMMON
                            	  7438: 
                            	  7439:          LONG
                            	     1M          DS      0
01:0020389E 00              	     2M          DS.B    (*-X)&2
01:0020389F *
                            	  7440: *                               PEA     (JMP  JSR)
01:002038A0 3E3C07E4        	  7441: FORM11   MOVE.W  #$7E4,D7       CONTROL ADDERSSING
01:002038A4 6100FF7C        	  7442:          BSR     EEA10
01:002038A8 60F0            	  7443:          BRA     CS12           COMMON
                            	  7444: 
                            	  7445:          LONG
                            	     1M          DS      0
01:002038AA 00              	     2M          DS.B    (*-X)&2
01:002038AB *
                            	  7446: *                               JMP  JSR
01:002038AC 2004            	  7447: FORM11SL MOVE.L  D4,D0          LOOK FOR .S  OR  .L
01:002038AE 0240003F        	  7448:          ANDI.W  #$3F,D0
01:002038B2 0C400038        	  7449:          CMPI.W  #$38,D0
01:002038B6 6608            	  7450:          BNE.S   FORM112        NOT .S
01:002038B8 1AFC002E        	  7451:          MOVE.B  #'.',(A5)+     PERIOD
01:002038BC 1AFC0053        	  7452:          MOVE.B  #'S',(A5)+     S
01:002038C0 0C400039        	  7453: FORM112  CMPI.W  #$39,D0
01:002038C4 6608            	  7454:          BNE.S   FORM114
01:002038C6 1AFC002E        	  7455:          MOVE.B  #'.',(A5)+     PERIOD
01:002038CA 1AFC004C        	  7456:          MOVE.B  #'L',(A5)+     L
01:002038CE 60D0            	  7457: FORM114  BRA     FORM11
                            	  7458: 
                            	  7459: *  BIT   5432109876543210
                            	  7460: *        ....XXX.....0...       DATA DESTINATION REGISTER
                            	  7461: *        ....XXX.....1...       ADDRESS REGISTER
                            	  7462: *        ....XXX.00......       BYTE
                            	  7463: *        ........01......       WORD
                            	  7464: *        ........10......       LONG
                            	  7465: *        ............0...       DATA REGISTER TO DATA REGISTER
                            	  7466: *        ............1...       MEMORY TO MEMORY
                            	  7467: *        ............0XXX       DATA SOURCE REGISTER
                            	  7468: *        ............1XXX       ADDRESS SOURCE REGISTER
                            	  7469: *
                            	  7470:          LONG
                            	     1M          DS      0
                            	     2M          DS.B    (*-X)&2
                            	  7471: FORM12   DS      0              ABCD  ADDX  SBCD  SUBX
01:002038D0 610002B2        	  7472:          BSR     FORMSIZE
                            	  7473: 
01:002038D4 08040003        	  7474:          BTST    #3,D4
01:002038D8 6610            	  7475:          BNE.S   FORM125
                            	  7476: 
01:002038DA 6100FF1C        	  7477:          BSR     FORMREGD       D@,D@;   FORMAT SOURCE
                            	  7478: 
01:002038DE 1CC5            	  7479:          MOVE.B  D5,(A6)+       COMMA SEPARATOR
                            	  7480: 
01:002038E0 1814            	  7481:          MOVE.B  (A4),D4
01:002038E2 E20C            	  7482:          LSR.B   #1,D4
01:002038E4 6100FF12        	  7483:          BSR     FORMREGD       FORMAT DESTINATION
01:002038E8 6046            	  7484:          BRA.S   CS11           COMMON
                            	  7485: 
01:002038EA 1CFC002D        	  7486: FORM125  MOVE.B  #'-',(A6)+     -
01:002038EE 1CFC0028        	  7487:          MOVE.B  #'(',(A6)+     (
01:002038F2 6100FEF4        	  7488:          BSR     FORMREGA       A@    SOURCE
                            	  7489: 
01:002038F6 203C282D2C29    	  7490:          MOVE.L  #'(-,)',D0     ),-(
01:002038FC 6152            	  7491:          BSR.S   SCHR           STORE CHARS
                            	  7492: 
01:002038FE 1814            	  7493:          MOVE.B  (A4),D4
01:00203900 E20C            	  7494:          LSR.B   #1,D4
01:00203902 6100FEE4        	  7495:          BSR     FORMREGA       A@   DESTINATION
01:00203906 1CFC0029        	  7496:          MOVE.B  #')',(A6)+
01:0020390A 6024            	  7497:          BRA.S   CS11           COMMON
                            	  7498: 
                            	  7499: *  BIT   5432109876543210
                            	  7500: *        ....XXX.....1...       ADDRESS REGISTER    DESTINATION
                            	  7501: *        ....XXX.00......       BYTE
                            	  7502: *        ........01......       WORD
                            	  7503: *        ........10......       LONG
                            	  7504: *        ............1...       MEMORY TO MEMORY
                            	  7505: *        ............1XXX       ADDRESS SOURCE REGISTER
                            	  7506: *
                            	  7507:          LONG
                            	     1M          DS      0
                            	     2M          DS.B    (*-X)&2
                            	  7508: FORM12A  DS      0              CMPM
01:0020390C 61000276        	  7509:          BSR     FORMSIZE
                            	  7510: 
01:00203910 1CFC0028        	  7511:          MOVE.B  #'(',(A6)+     (
01:00203914 6100FED2        	  7512:          BSR     FORMREGA       A@
                            	  7513: 
01:00203918 203C282C2B29    	  7514:          MOVE.L  #'(,+)',D0     )+,(
01:0020391E 6130            	  7515:          BSR.S   SCHR           STORE CHARS
                            	  7516: 
01:00203920 1814            	  7517:          MOVE.B  (A4),D4
01:00203922 E20C            	  7518:          LSR.B   #1,D4
01:00203924 6100FEC2        	  7519:          BSR     FORMREGA       A@
01:00203928 1CFC0029        	  7520:          MOVE.B  #')',(A6)+
01:0020392C 1CFC002B        	  7521:          MOVE.B  #'+',(A6)+
01:00203930 600005C8        	  7522: CS11     BRA     COMMON
                            	  7523: 
                            	  7524:          LONG
                            	     1M          DS      0
                            	     2M          DS.B    (*-X)&2
01:00203934 6000021E        	  7525: IQUICK   BRA     IQUICKA        ADDQ  SUBQ
                            	  7526: 
                            	  7527: *  BIT   5432109876543210
                            	  7528: *        0111...0........       FIXED
                            	  7529: *        ....RRR.........       DATA REGISTER
                            	  7530: *        ........DDDDDDDD       SIGN EXTENDED DATA
                            	  7531: *
                            	  7532:          LONG
                            	     1M          DS      0
                            	     2M          DS.B    (*-X)&2
                            	  7533: IMOVEQ   DS      0
01:00203938 1CFC0023        	  7534:          MOVE.B  #'#',(A6)+     IMMEDIATE
                            	  7535: 
01:0020393C 3014            	  7536:          MOVE.W  (A4),D0
01:0020393E 4880            	  7537:          EXT.W   D0
01:00203940 48C0            	  7538:          EXT.L   D0
01:00203942 6100DA18        	  7539:          BSR     HEX2DEC        DECIMAL
                            	  7540: 
01:00203946 1CC5            	  7541:          MOVE.B  D5,(A6)+       COMMA SEPARATOR
                            	  7542: 
01:00203948 EF5C            	  7543:          ROL.W   #7,D4
01:0020394A 6100FEAC        	  7544:          BSR     FORMREGD
01:0020394E 60E0            	  7545:          BRA     CS11           COMMON
                            	  7546: 
01:00203950 1CC0            	  7547: SCHR     MOVE.B  D0,(A6)+       OUTPUT STRING
01:00203952 E088            	  7548:          LSR.L   #8,D0
01:00203954 66FA            	  7549:          BNE     SCHR           MORE TO OUTPUT
01:00203956 4E75            	  7550:          RTS
                            	  7551: 
                            	  7552: * MOVE FROM SR  (STATUS REGISTER)
                            	  7553: *
                            	  7554:          LONG
                            	     1M          DS      0
                            	     2M          DS.B    (*-X)&2
01:00203958 203C002C5253    	  7555: IMVFSR   MOVE.L  #',RS'+0,D0   SR,
                            	  7556: 
01:0020395E 61F0            	  7557:          BSR     SCHR
01:00203960 610002AC        	  7558:          BSR     EEA            DATA ALTERABLE
01:00203964 60CA            	  7559:          BRA     CS11           COMMON
                            	  7560: 
                            	  7561: * MOVE FROM USP (USER STACK POINTER)
                            	  7562: *
                            	  7563:          LONG
                            	     1M          DS      0
01:00203966 00              	     2M          DS.B    (*-X)&2
01:00203967 *
01:00203968 203C2C505355    	  7564: IMVFUSP  MOVE.L  #',PSU',D0     USP,
01:0020396E 61E0            	  7565:          BSR     SCHR
01:00203970 6100FE76        	  7566:          BSR     FORMREGA
01:00203974 60BA            	  7567:          BRA     CS11           COMMON
                            	  7568: 
                            	  7569: * MOVE TO SR (STATUS REGISTER)
                            	  7570: *
                            	  7571:          LONG
                            	     1M          DS      0
01:00203976 00              	     2M          DS.B    (*-X)&2
01:00203977 *
01:00203978 3E3C0FFD        	  7572: IMVTSR   MOVE.W  #$FFD,D7       DATA ADDRESSING
01:0020397C 61000290        	  7573:          BSR     EEA
01:00203980 203C0052532C    	  7574:          MOVE.L  #'RS,'+0,D0   ,SR
01:00203986 61C8            	  7575: IMVT44   BSR     SCHR
01:00203988 60A6            	  7576:          BRA     CS11           COMMON
                            	  7577: 
                            	  7578: * MOVE TO USP (USER STACK POINTER)
                            	  7579: *
                            	  7580:          LONG
                            	     1M          DS      0
01:0020398A 00              	     2M          DS.B    (*-X)&2
01:0020398B *
01:0020398C 6100FE5A        	  7581: IMVTUSP  BSR     FORMREGA
01:00203990 203C5053552C    	  7582:          MOVE.L  #'PSU,',D0     ,USP
01:00203996 60EE            	  7583:          BRA     IMVT44
                            	  7584: 
                            	  7585: *  MOVE TO CCR (CONDITION CODE REGISTER)
                            	  7586: *
                            	  7587:          LONG
                            	     1M          DS      0
                            	     2M          DS.B    (*-X)&2
01:00203998 3E3C0FFD        	  7588: IMVTCCR  MOVE.W  #$FFD,D7       DATA ADDRESSING
01:0020399C 61000270        	  7589:          BSR     EEA
01:002039A0 203C5243432C    	  7590:          MOVE.L  #'RCC,',D0     ,CCR
01:002039A6 60DE            	  7591:          BRA     IMVT44
                            	  7592: 
                            	  7593: *  BIT   5432109876543210
                            	  7594: *        0000...1..001...       FIXED
                            	  7595: *        ....XXX.........       DATA REGISTER
                            	  7596: *        ........0.......       MEMORY TO REGISTER
                            	  7597: *        ........1.......       REGISTER TO MEMORY
                            	  7598: *        .........0......       WORD
                            	  7599: *        .........1......       LONG
                            	  7600: *        .............XXX       ADDRESS REGISTER
                            	  7601: *
                            	  7602:          LONG
                            	     1M          DS      0
                            	     2M          DS.B    (*-X)&2
                            	  7603: IMOVEP   DS      0
01:002039A8 1AFC002E        	  7604:          MOVE.B  #'.',(A5)+     D@,#(A@)
01:002039AC 303C4C57        	  7605:          MOVE.W  #'LW',D0
01:002039B0 08040006        	  7606:          BTST    #6,D4
01:002039B4 6702            	  7607:          BEQ.S   IMOVEP11       USE "W"
01:002039B6 E048            	  7608:          LSR.W   #8,D0          USE "L"
01:002039B8 1AC0            	  7609: IMOVEP11 MOVE.B  D0,(A5)+       LENGTH
                            	  7610: 
01:002039BA 1814            	  7611:          MOVE.B  (A4),D4
01:002039BC E20C            	  7612:          LSR.B   #1,D4
                            	  7613: 
01:002039BE 082C00070001    	  7614:          BTST.B  #7,1(A4)
01:002039C4 670E            	  7615:          BEQ.S   IMOVEP35
                            	  7616: 
01:002039C6 6100FE30        	  7617:          BSR     FORMREGD       D@,$HHHH(A@)
                            	  7618: 
01:002039CA 1CC5            	  7619:          MOVE.B  D5,(A6)+       COMMA SEPARATOR
                            	  7620: 
01:002039CC 3814            	  7621:          MOVE.W  (A4),D4
01:002039CE 6112            	  7622:          BSR.S   IMOVEP66
01:002039D0 60000526        	  7623: CS20     BRA     COMMON4
                            	  7624: 
01:002039D4 610C            	  7625: IMOVEP35 BSR.S   IMOVEP66       $HHHH(A@),D@
                            	  7626: 
01:002039D6 1CC5            	  7627:          MOVE.B  D5,(A6)+       COMMA SEPARATOR
                            	  7628: 
01:002039D8 1814            	  7629:          MOVE.B  (A4),D4
01:002039DA E20C            	  7630:          LSR.B   #1,D4
01:002039DC 6100FE1A        	  7631:          BSR     FORMREGD
01:002039E0 60EE            	  7632:          BRA     CS20           COMMON4
                            	  7633: 
01:002039E2 1CFC0024        	  7634: IMOVEP66 MOVE.B  #'$',(A6)+     FORMAT DISPLACEMENT
01:002039E6 302C0002        	  7635:          MOVE.W  2(A4),D0
01:002039EA 6100E3BE        	  7636:          BSR     PNT4HX
                            	  7637: 
01:002039EE 1CFC0028        	  7638:          MOVE.B  #'(',(A6)+
                            	  7639: 
01:002039F2 3814            	  7640:          MOVE.W  (A4),D4
01:002039F4 6100FDF2        	  7641:          BSR     FORMREGA
01:002039F8 1CFC0029        	  7642:          MOVE.B  #')',(A6)+
01:002039FC 4E75            	  7643:          RTS
                            	  7644: 
                            	  7645:          LONG
                            	     1M          DS      0
01:002039FE 00              	     2M          DS.B    (*-X)&2
01:002039FF *
01:00203A00 600004F8        	  7646: SCOMMON  BRA     COMMON         NOP RESET RTE RTR RTS TRAPV
                            	  7647: 
                            	  7648:          LONG
                            	     1M          DS      0
                            	     2M          DS.B    (*-X)&2
01:00203A04 610000EA        	  7649: ISCC     BSR     ICCCC          GET REST OF OP-CODE
01:00203A08 61000204        	  7650:          BSR     EEA            DATA ALTERABLE
01:00203A0C 60F2            	  7651:          BRA     SCOMMON
                            	  7652: 
                            	  7653: 
                            	  7654:          LONG
                            	     1M          DS      0
01:00203A0E 00              	     2M          DS.B    (*-X)&2
01:00203A0F *
                            	  7655: IDBCC    DS      0              DB--
01:00203A10 3814            	  7656:          MOVE.W  (A4),D4
01:00203A12 6100FDE4        	  7657:          BSR     FORMREGD
                            	  7658: 
01:00203A16 1CC5            	  7659:          MOVE.B  D5,(A6)+       COMMA SEPARATOR
01:00203A18 1CFC0024        	  7660:          MOVE.B  #'$',(A6)+     HEX FIELD TO FOLLOW
                            	  7661: 
01:00203A1C 610000D2        	  7662:          BSR     ICCCC
01:00203A20 602E            	  7663:          BRA.S   ICC55
                            	  7664: 
                            	  7665: *  BIT   5432109876543210
                            	  7666: *        0110............       FIXED
                            	  7667: *        ....CCCC........       CONDITION
                            	  7668: *        ........DDDDDDD0       DISPLACEMENT
                            	  7669: *        ...............1       ERROR (ODD BOUNDRY DISPLACEMENT)
                            	  7670: *
                            	  7671:          LONG
                            	     1M          DS      0
01:00203A22 00              	     2M          DS.B    (*-X)&2
01:00203A23 *
                            	  7672: ICC      DS      0              B--
01:00203A24 610000CA        	  7673:          BSR     ICCCC
                            	  7674: 
01:00203A28 1CFC0024        	  7675: IBSR     MOVE.B  #'$',(A6)+     BSR   BRA
                            	  7676: 
01:00203A2C 4A04            	  7677:          TST.B   D4
01:00203A2E 6720            	  7678:          BEQ.S   ICC55          16 BIT DISPLACEMENT
                            	  7679: 
01:00203A30 1AFC002E        	  7680:          MOVE.B  #'.',(A5)+
01:00203A34 1AFC0053        	  7681:          MOVE.B  #'S',(A5)+
01:00203A38 4884            	  7682:          EXT.W   D4             8 BIT DISPLACEMENT
                            	  7683: 
01:00203A3A 48C4            	  7684: ICC35    EXT.L   D4             SIGN-EXTENDED DISPLACEMENT
01:00203A3C D8A9FFFC        	  7685:          ADD.L   HISPC(A1),D4   + PROGRAM COUNTER
01:00203A40 5484            	  7686:          ADDQ.L  #2,D4          + TWO
01:00203A42 2004            	  7687:          MOVE.L  D4,D0
                            	  7688: 
01:00203A44 E284            	  7689:          ASR.L   #1,D4
01:00203A46 650004DA        	  7690:          BCS     FERROR         ODD BOUNDRY DISPLACEMENT
                            	  7691: 
01:00203A4A 6100E358        	  7692:          BSR     PNT6HX
01:00203A4E 60B0            	  7693:          BRA     SCOMMON
                            	  7694: 
01:00203A50 5483            	  7695: ICC55    ADDQ.L  #2,D3          SIZE
01:00203A52 382C0002        	  7696:          MOVE.W  2(A4),D4
01:00203A56 1AFC002E        	  7697:          MOVE.B  #'.',(A5)+
01:00203A5A 1AFC004C        	  7698:          MOVE.B  #'L',(A5)+     .L FOR 16 BIT DISPLACEMENT
01:00203A5E 60DA            	  7699:          BRA     ICC35
                            	  7700: 
                            	  7701:          LONG
                            	     1M          DS      0
                            	     2M          DS.B    (*-X)&2
                            	  7702: *                               BCHG  BCLR  BSET  BTST
                            	  7703: ISETD    DS      0              DYNAMIC BIT
01:00203A60 EF5C            	  7704:          ROL.W   #7,D4
01:00203A62 6100FD94        	  7705:          BSR     FORMREGD       DATA REGISTER
                            	  7706: 
01:00203A66 1CC5            	  7707: ISETD12  MOVE.B  D5,(A6)+       COMMA SEPARATOR
                            	  7708: 
01:00203A68 3814            	  7709:          MOVE.W  (A4),D4
01:00203A6A 610001A2        	  7710:          BSR     EEA            DATA ALTERABLE
01:00203A6E 6090            	  7711: CS18     BRA     SCOMMON
                            	  7712: 
                            	  7713:          LONG
                            	     1M          DS      0
                            	     2M          DS.B    (*-X)&2
                            	  7714: *                            BCHG  BCLR  BSET  BTST
                            	  7715: *  1ST WORD     .... .... ..XX XXXX    EA   DATA ALTERABLE ONLY
                            	  7716: *  2ND WORD     0000 0000 000Y YYYY    BIT NUMBER
                            	  7717: *
                            	  7718: ISETS    DS      0              STATIC BIT
01:00203A70 5483            	  7719:          ADDQ.L  #2,D3     SIZE
01:00203A72 1CFC0023        	  7720:          MOVE.B  #'#',(A6)+     IMMEDIATE
                            	  7721: 
01:00203A76 7000            	  7722:          CLR.L   D0
01:00203A78 302C0002        	  7723:          MOVE.W  2(A4),D0       GET BIT POSITION FROM 2ND WORD
01:00203A7C 2200            	  7724:          MOVE.L  D0,D1
01:00203A7E EA89            	  7725:          LSR.L   #5,D1
01:00203A80 660004A0        	  7726:          BNE     FERROR
01:00203A84 6100D8D6        	  7727:          BSR     HEX2DEC        DECIMAL
                            	  7728: 
01:00203A88 60DC            	  7729:          BRA     ISETD12
                            	  7730: 
                            	  7731: *   BIT  5432109876543210
                            	  7732: *        ....XXX.........       IMMEDIATE COUNT/REGISTER
                            	  7733: *        .......0........       RIGHT SHIFT
                            	  7734: *        .......1........       LEFT SHIFT
                            	  7735: *        ........00......       BYTE
                            	  7736: *        ........01......       WORD
                            	  7737: *        ........10......       LONG
                            	  7738: *        ....0...11......       WORD (MEMORY)
                            	  7739: *        ....0...11AAAAAA       EFFECTIVE ADDRESS
                            	  7740: *        ..........0.....       SHIFT IMMEDIATE COUNT
                            	  7741: *        ..........1.....       SHIFT COUNT (MODULO 64) IN DATA REGISTER
                            	  7742: *
                            	  7743:          LONG
                            	     1M          DS      0
01:00203A8A 00              	     2M          DS.B    (*-X)&2
01:00203A8B *
                            	  7744: ISHIFT   DS      0              AS-  LS-  RO-  ROX-
01:00203A8C 303C4C52        	  7745:          MOVE.W  #'LR',D0
01:00203A90 08040008        	  7746:          BTST    #8,D4          DIRECTION BIT
01:00203A94 6702            	  7747:          BEQ.S   ISHIFT13       RIGHT
01:00203A96 E048            	  7748:          LSR.W   #8,D0          LEFT
01:00203A98 1AC0            	  7749: ISHIFT13 MOVE.B  D0,(A5)+       DIRECTION; "L" OR "R"
                            	  7750: 
01:00203A9A 3014            	  7751:          MOVE.W  (A4),D0
01:00203A9C 024000C0        	  7752:          ANDI.W  #$00C0,D0
01:00203AA0 0C4000C0        	  7753:          CMPI.W  #$00C0,D0
01:00203AA4 6730            	  7754:          BEQ.S   ISHIFTM1       MEMORY SHIFT
                            	  7755: 
01:00203AA6 610000DC        	  7756:          BSR     FORMSIZE
                            	  7757: 
01:00203AAA EF5C            	  7758:          ROL.W   #7,D4
01:00203AAC 0804000C        	  7759:          BTST    #12,D4         I/R BIT
01:00203AB0 6616            	  7760:          BNE.S   ISHIFT33       COUNT IN REGISTER
                            	  7761: 
01:00203AB2 02040007        	  7762:          ANDI.B  #$07,D4        IMMEDIATE COUNT
01:00203AB6 6604            	  7763:          BNE.S   ISHIFT23
01:00203AB8 00040008        	  7764:          ORI.B   #$08,D4        CHANGE ZERO TO EIGHT
01:00203ABC 00040030        	  7765: ISHIFT23 ORI.B   #'0',D4
01:00203AC0 1CFC0023        	  7766:          MOVE.B  #'#',(A6)+
01:00203AC4 1CC4            	  7767:          MOVE.B  D4,(A6)+
01:00203AC6 6004            	  7768:          BRA.S   ISHIFT44
                            	  7769: 
01:00203AC8 6100FD2E        	  7770: ISHIFT33 BSR     FORMREGD
                            	  7771: 
01:00203ACC 1CC5            	  7772: ISHIFT44 MOVE.B  D5,(A6)+       COMMA SEPARATOR
                            	  7773: 
01:00203ACE 3814            	  7774:          MOVE.W  (A4),D4
01:00203AD0 6100FD26        	  7775:          BSR     FORMREGD
01:00203AD4 6098            	  7776: CS17     BRA     CS18           COMMON
                            	  7777: 
01:00203AD6 1AFC002E        	  7778: ISHIFTM1 MOVE.B  #'.',(A5)+     PERIOD
01:00203ADA 1AFC0057        	  7779:          MOVE.B  #'W',(A5)+     .WORD
                            	  7780: 
01:00203ADE 0804000B        	  7781:          BTST    #11,D4
01:00203AE2 6600043E        	  7782:          BNE     FERROR         BIT 11 MUST BE ZERO
                            	  7783: 
01:00203AE6 3E3C01FC        	  7784:          MOVE.W  #$1FC,D7       MEMORY ALTERABLE ADDRESSING
01:00203AEA 61000122        	  7785:          BSR     EEA
01:00203AEE 60E4            	  7786:          BRA     CS17           COMMON
                            	  7787: 
01:00203AF0 700F            	  7788: ICCCC    MOVEQ   #$0F,D0        APPEND CONDITION CODE
01:00203AF2 C014            	  7789:          AND.B   (A4),D0        D0 = CCC
01:00203AF4 E388            	  7790:          LSL.L   #1,D0          D0 = CCC*2
                            	  7791: 
01:00203AF6 323B0010        	  7792:          MOVE.W  BRTBL(PC,D0.W),D1  GET BRANCH MNEMONIC
01:00203AFA 1AC1            	  7793:          MOVE.B  D1,(A5)+           (REVERSED) FROM THE TABLE
01:00203AFC E049            	  7794:          LSR.W   #8,D1              AND ADD THE NONBLANK PORTION
01:00203AFE 0C010020        	  7795:          CMPI.B  #BLANK,D1          TO THE BUFFER.
01:00203B02 6702            	  7796:          BEQ.S   ICCCC9
01:00203B04 1AC1            	  7797:          MOVE.B  D1,(A5)+
01:00203B06 4E75            	  7798: ICCCC9   RTS
                            	  7799: 
01:00203B08 2054            	  7800: BRTBL    DC.B    ' T'      ; 'T '  BRA ACCEPTED
01:00203B0A 2046            	  7801:          DC.B    ' F'      ; 'F '
01:00203B0C 4948            	  7802:          DC.B    'IH'      ; 'HI'
01:00203B0E 534C            	  7803:          DC.B    'SL'      ; 'LS'
01:00203B10 4343            	  7804:          DC.B    'CC'      ; 'CC'
01:00203B12 5343            	  7805:          DC.B    'SC'      ; 'CS'
01:00203B14 454E            	  7806:          DC.B    'EN'      ; 'NE'
01:00203B16 5145            	  7807:          DC.B    'QE'      ; 'EQ'
01:00203B18 4356            	  7808:          DC.B    'CV'      ; 'VC'
01:00203B1A 5356            	  7809:          DC.B    'SV'      ; 'VS'
01:00203B1C 4C50            	  7810:          DC.B    'LP'      ; 'PL'
01:00203B1E 494D            	  7811:          DC.B    'IM'      ; 'MI'
01:00203B20 4547            	  7812:          DC.B    'EG'      ; 'GE'
01:00203B22 544C            	  7813:          DC.B    'TL'      ; 'LT'
01:00203B24 5447            	  7814:          DC.B    'TG'      ; 'GT'
01:00203B26 454C            	  7815:          DC.B    'EL'      ; 'LE'
                            	  7816: 
                            	  7817: *   BIT  5432109876543210
                            	  7818: *        ....RRRMMM......    DESTINATION REGISTER MODE
                            	  7819: *        ..........MMMRRR    SOURCE MODE REGISTER
                            	  7820: *
                            	  7821: * IF BYTE SIZE; ADDRESS DIRECT NOT ALLOWED AS SOURCE
                            	  7822: *
                            	  7823: IMOVEA1  DS      0
01:00203B28 3E3C0FFF        	  7824:          MOVE.W  #$FFF,D7       ALL MODES
01:00203B2C 610000E0        	  7825:          BSR     EEA
                            	  7826: 
01:00203B30 1CC5            	  7827:          MOVE.B  D5,(A6)+       COMMA SEPARATOR
                            	  7828: 
01:00203B32 3814            	  7829:          MOVE.W  (A4),D4        ....RRRMMM......
01:00203B34 E24C            	  7830:          LSR.W   #1,D4          .....RRRMMM.....
01:00203B36 EA0C            	  7831:          LSR.B   #5,D4          .....RRR.....MMM
01:00203B38 E05C            	  7832:          ROR.W   #8,D4          .....MMM.....RRR
01:00203B3A EB0C            	  7833:          LSL.B   #5,D4          .....MMMRRR.....
01:00203B3C EA4C            	  7834:          LSR.W   #5,D4          ..........MMMRRR
                            	  7835: 
                            	  7836: * IF .BYTE DESTINATION A@ NOT ALLOWED
01:00203B3E 3E3C01FF        	  7837:          MOVE.W  #$1FF,D7       DATA ALTERABLE + A@
01:00203B42 1014            	  7838:          MOVE.B  (A4),D0
01:00203B44 0C000001        	  7839:          CMPI.B  #$01,D0
01:00203B48 6604            	  7840:          BNE.S   IMOVE19        NOT BYTE SIZE
                            	  7841: 
01:00203B4A 3E3C01FD        	  7842:          MOVE.W  #$1FD,D7       DATA ALTERABLE
                            	  7843: IMOVE19
                            	  7844: 
01:00203B4E 610000BE        	  7845:          BSR     EEA
01:00203B52 602C            	  7846:          BRA.S   CS19           COMMON
                            	  7847: 
                            	  7848: *  IF BYTE; ADDRESS REGISTER DIRECT NOT ALLOWED
                            	  7849: IQUICKA  DS      0              ADDQ  SUBQ
01:00203B54 612E            	  7850:          BSR.S   FORMSIZE
                            	  7851: 
01:00203B56 1CFC0023        	  7852:          MOVE.B  #'#',(A6)+
01:00203B5A EF5C            	  7853:          ROL.W   #7,D4
01:00203B5C 02040007        	  7854:          ANDI.B  #7,D4
01:00203B60 6604            	  7855:          BNE.S   IQUICK21
01:00203B62 00040008        	  7856:          ORI.B   #8,D4          MAKE ZERO INTO EIGHT
01:00203B66 00040030        	  7857: IQUICK21 ORI.B   #'0',D4        MAKE ASCII
01:00203B6A 1CC4            	  7858:          MOVE.B  D4,(A6)+
                            	  7859: 
01:00203B6C 1CC5            	  7860:          MOVE.B  D5,(A6)+       COMMA SEPARATOR
                            	  7861: 
01:00203B6E 3814            	  7862:          MOVE.W  (A4),D4
                            	  7863: 
01:00203B70 3014            	  7864:          MOVE.W  (A4),D0
01:00203B72 024000C0        	  7865:          ANDI.W  #$00C0,D0
01:00203B76 6704            	  7866:          BEQ.S   IQUICK31       DATA ALTERABLE
01:00203B78 3E3C01FF        	  7867:          MOVE.W  #$1FF,D7       ALTERABLE ADDRESSING
01:00203B7C 61000090        	  7868: IQUICK31 BSR     EEA
01:00203B80 60000378        	  7869: CS19     BRA     COMMON
                            	  7870: 
                            	  7871: *  BIT   5432109876543210
                            	  7872: *        ........00......       BYTE
                            	  7873: *        ........01......       WORD
                            	  7874: *        ........10......       LONG
                            	  7875: *        ........11......       ERROR
                            	  7876: *
                            	  7877: FORMSIZE DS      0
01:00203B84 3414            	  7878:          MOVE.W  (A4),D2
01:00203B86 1AFC002E        	  7879:          MOVE.B  #'.',(A5)+     STORE PERIOD
01:00203B8A EC4A            	  7880:          LSR.W   #6,D2
01:00203B8C 02420003        	  7881:          ANDI.W  #$03,D2
01:00203B90 6606            	  7882:          BNE.S   FORM91
01:00203B92 1AFC0042        	  7883:          MOVE.B  #'B',(A5)+     STORE "B"
01:00203B96 6016            	  7884:          BRA.S   FORM95
                            	  7885: 
01:00203B98 103C0057        	  7886: FORM91   MOVE.B  #'W',D0
01:00203B9C 0C020001        	  7887:          CMPI.B  #1,D2
01:00203BA0 670A            	  7888:          BEQ.S   FORM93
01:00203BA2 103C004C        	  7889:          MOVE.B  #'L',D0
01:00203BA6 0C020002        	  7890:          CMPI.B  #2,D2
01:00203BAA 665E            	  7891:          BNE.S   FE10           FERROR
01:00203BAC 1AC0            	  7892: FORM93   MOVE.B  D0,(A5)+       STORE "W" OR "L"
01:00203BAE 4E75            	  7893: FORM95   RTS
                            	  7894: 
01:00203BB0 6100FC46        	  7895: EA000    BSR     FORMREGD
01:00203BB4 08070000        	  7896:          BTST    #0,D7
01:00203BB8 6750            	  7897:          BEQ.S   FE10           FERROR
01:00203BBA 4E75            	  7898:          RTS
                            	  7899: 
01:00203BBC 6100FC2A        	  7900: EA001    BSR     FORMREGA
01:00203BC0 08070001        	  7901:          BTST    #1,D7
01:00203BC4 6744            	  7902:          BEQ.S   FE10           FERROR  THIS MODE NOT ALLOWED
01:00203BC6 4E75            	  7903:          RTS
                            	  7904: 
01:00203BC8 1CFC0028        	  7905: EA010    MOVE.B  #'(',(A6)+
01:00203BCC 6100FC1A        	  7906:          BSR     FORMREGA
01:00203BD0 1CFC0029        	  7907:          MOVE.B  #')',(A6)+
01:00203BD4 08070002        	  7908:          BTST    #2,D7
01:00203BD8 6730            	  7909:          BEQ.S   FE10           FERROR  THIS MODE NOT ALLOWED
01:00203BDA 4E75            	  7910:          RTS
                            	  7911: 
01:00203BDC 1CFC0028        	  7912: EA011    MOVE.B  #'(',(A6)+
01:00203BE0 6100FC06        	  7913:          BSR     FORMREGA
01:00203BE4 1CFC0029        	  7914:          MOVE.B  #')',(A6)+
01:00203BE8 1CFC002B        	  7915:          MOVE.B  #'+',(A6)+
01:00203BEC 08070003        	  7916:          BTST    #3,D7
01:00203BF0 6718            	  7917:          BEQ.S   FE10           FERROR  THIS MODE NOT ALLOWED
01:00203BF2 4E75            	  7918: EA011RTS RTS
                            	  7919: 
01:00203BF4 1CFC002D        	  7920: EA100    MOVE.B  #'-',(A6)+
01:00203BF8 1CFC0028        	  7921:          MOVE.B  #'(',(A6)+
01:00203BFC 6100FBEA        	  7922:          BSR     FORMREGA
01:00203C00 1CFC0029        	  7923:          MOVE.B  #')',(A6)+
01:00203C04 08070004        	  7924:          BTST    #4,D7
01:00203C08 66E8            	  7925:          BNE     EA011RTS
01:00203C0A 60000316        	  7926: FE10     BRA     FERROR         THIS MODE NOT ALLOWED
                            	  7927: 
                            	  7928: *  ENTER       A4 = POINTER TO FIRST WORD
                            	  7929: *              D3 = OFFSET TO EXTENSION
                            	  7930: *              D4 = VALUE TO PROCESS
                            	  7931: *              D7 = MODES ALLOWED MASK
                            	  7932: *
                            	  7933: EEA      DS      0
01:00203C0E 2004            	  7934:          MOVE.L  D4,D0
01:00203C10 E648            	  7935:          LSR.W   #3,D0
01:00203C12 02400007        	  7936:          ANDI.W  #$7,D0
01:00203C16 6798            	  7937:          BEQ     EA000
                            	  7938: 
01:00203C18 0C000001        	  7939:          CMPI.B  #1,D0
01:00203C1C 679E            	  7940:          BEQ     EA001
                            	  7941: 
01:00203C1E 0C000002        	  7942:          CMPI.B  #2,D0
01:00203C22 67A4            	  7943:          BEQ     EA010
                            	  7944: 
01:00203C24 0C000003        	  7945:          CMPI.B  #3,D0
01:00203C28 67B2            	  7946:          BEQ     EA011
                            	  7947: 
01:00203C2A 0C000004        	  7948:          CMPI.B  #4,D0
01:00203C2E 67C4            	  7949:          BEQ     EA100
                            	  7950: 
01:00203C30 0C000005        	  7951:          CMPI.B  #5,D0
01:00203C34 6760            	  7952:          BEQ.S   EA101
                            	  7953: 
01:00203C36 0C000007        	  7954:          CMPI.B  #7,D0
01:00203C3A 6770            	  7955:          BEQ.S   EA111
                            	  7956: 
                            	  7957: *    EXTENSION WORD
                            	  7958: *   BIT  5432109876543210
                            	  7959: *        0...............    DATA REGISTER
                            	  7960: *        1...............    ADDRESS REGISTER
                            	  7961: *        .RRR............    REGISTER
                            	  7962: *        ....0...........    SIGN EXTENDED, LOW ORDER INTEGER IN INDEX REG
                            	  7963: *        ....1...........    LONG VALUE IN INDEX REGISTER
                            	  7964: *        .....000........
                            	  7965: *        ........DDDDDDDD    DISPLACEMENT INTEGER
                            	  7966: *
                            	  7967: * EA110            ADDRESS REGISTER INDIRECT WITH INDEX
                            	  7968: 
01:00203C3C 08070006        	  7969:          BTST    #6,D7
01:00203C40 67C8            	  7970:          BEQ     FE10           FERROR  THIS MODE NOT ALLOWED
                            	  7971: 
01:00203C42 32343000        	  7972:          MOVE.W  (A4,D3),D1
01:00203C46 02410700        	  7973:          ANDI.W  #$0700,D1
01:00203C4A 66BE            	  7974:          BNE     FE10           FERROR  BITS 10-8 MUST BE ZERO
                            	  7975: 
01:00203C4C 30343000        	  7976:          MOVE.W  (A4,D3),D0     D0 = DISPLACEMENT
01:00203C50 4880            	  7977:          EXT.W   D0
01:00203C52 48C0            	  7978:          EXT.L   D0
01:00203C54 6100D706        	  7979:          BSR     HEX2DEC        DECIMAL
01:00203C58 1CFC0028        	  7980:          MOVE.B  #'(',(A6)+     (
                            	  7981: 
01:00203C5C 6100FB8A        	  7982:          BSR     FORMREGA       XX(A@
                            	  7983: 
01:00203C60 1CFC002C        	  7984:          MOVE.B  #',',(A6)+     XX(A@,
                            	  7985: 
01:00203C64 18343000        	  7986:          MOVE.B  (A4,D3),D4
01:00203C68 E804            	  7987:          ASR.B   #4,D4
01:00203C6A 6A06            	  7988:          BPL.S   EA1105
01:00203C6C 6100FB7A        	  7989:          BSR     FORMREGA
01:00203C70 6004            	  7990:          BRA.S   EA1107
                            	  7991: 
01:00203C72 6100FB84        	  7992: EA1105   BSR     FORMREGD
01:00203C76 1CFC002E        	  7993: EA1107   MOVE.B  #'.',(A6)+     XX(A@,X@.
                            	  7994: 
01:00203C7A 38343000        	  7995:          MOVE.W  (A4,D3),D4     D4 = R@
01:00203C7E 103C0057        	  7996:          MOVE.B  #'W',D0        ..........W
01:00203C82 0804000B        	  7997:          BTST    #11,D4
01:00203C86 6704            	  7998:          BEQ.S   EA1109
01:00203C88 103C004C        	  7999:          MOVE.B  #'L',D0        ..........L
01:00203C8C 1CC0            	  8000: EA1109   MOVE.B  D0,(A6)+
01:00203C8E 1CFC0029        	  8001:          MOVE.B  #')',(A6)+     ...........)
01:00203C92 5483            	  8002:          ADDQ.L  #2,D3
01:00203C94 4E75            	  8003:          RTS
                            	  8004: 
                            	  8005: * ADDRESS REGISTER INDIRECT WITH DISPLACEMENT
                            	  8006: *
01:00203C96 08070005        	  8007: EA101    BTST    #5,D7          101000;   DIS(A@)
01:00203C9A 6756            	  8008:          BEQ.S   FE11           FERROR;  THIS MODE NOT ALLOWED
                            	  8009: 
01:00203C9C 30343000        	  8010:          MOVE.W  (A4,D3),D0
01:00203CA0 48C0            	  8011:          EXT.L   D0
01:00203CA2 6100D6B8        	  8012:          BSR     HEX2DEC        DECIMAL
01:00203CA6 5483            	  8013:          ADDQ.L  #2,D3          SIZE
01:00203CA8 6000FF1E        	  8014:          BRA     EA010
                            	  8015: 
                            	  8016: *  111000        ABSOLUTE SHORT
                            	  8017: *  111001        ABSOLUTE LONG
                            	  8018: *  111010        PROGRAM COUNTER WITH DISPLACEMENT
                            	  8019: *  111011        PROGRAM COUNTER WITH INDEX
                            	  8020: *  111100        IMMEDIATE OR STATUS REG
                            	  8021: *
                            	  8022: EA111
01:00203CAC 02440007        	  8023:          ANDI.W  #7,D4
01:00203CB0 6618            	  8024:          BNE.S   EA1112
                            	  8025: 
01:00203CB2 08070007        	  8026:          BTST    #7,D7
01:00203CB6 673A            	  8027:          BEQ.S   FE11           FERROR;  THIS MODE NOT ALLOWED
                            	  8028: 
01:00203CB8 30343000        	  8029:          MOVE.W  (A4,D3),D0     111000;   ABSOLUTE SHORT
01:00203CBC 48C0            	  8030:          EXT.L   D0
01:00203CBE 1CFC0024        	  8031:          MOVE.B  #'$',(A6)+
01:00203CC2 6100E0D8        	  8032:          BSR     PNT8HX         SIGN EXTENDED VALUE
01:00203CC6 5483            	  8033:          ADDQ.L  #2,D3          SIZE + 2
01:00203CC8 4E75            	  8034:          RTS
                            	  8035: 
01:00203CCA 0C040001        	  8036: EA1112   CMPI.B  #1,D4
01:00203CCE 6616            	  8037:          BNE.S   EA1113
                            	  8038: 
01:00203CD0 08070008        	  8039:          BTST    #8,D7
01:00203CD4 671C            	  8040:          BEQ.S   FE11           FERROR;  THIS MODE NOT ALLOWED
                            	  8041: 
01:00203CD6 1CFC0024        	  8042:          MOVE.B  #'$',(A6)+     HEX
01:00203CDA 20343000        	  8043:          MOVE.L  (A4,D3),D0     111001;     ABSOLUTE LONG
01:00203CDE 6100E0BC        	  8044:          BSR     PNT8HX
                            	  8045: *-       MOVE.B  #'.',(A6)+     FORCE LONG FORMAT
                            	  8046: *-       MOVE.B  #'L',(A6)+     IE   .L
01:00203CE2 5883            	  8047:          ADDQ.L  #4,D3
01:00203CE4 4E75            	  8048:          RTS
                            	  8049: 
01:00203CE6 0C040002        	  8050: EA1113   CMPI.B  #2,D4
01:00203CEA 662C            	  8051:          BNE.S   EA1114
                            	  8052: 
01:00203CEC 08070009        	  8053:          BTST    #9,D7
01:00203CF0 6604            	  8054:          BNE.S   EA1113A
01:00203CF2 6000022E        	  8055: FE11     BRA     FERROR         THIS MODE NOT ALLOWED
                            	  8056: EA1113A
                            	  8057: 
01:00203CF6 30343000        	  8058:          MOVE.W  (A4,D3),D0     111010;  PC + DISPLACEMENT  DESTINATION(PC)
01:00203CFA 48C0            	  8059:          EXT.L   D0
01:00203CFC D0A9FFFC        	  8060:          ADD.L   HISPC(A1),D0
01:00203D00 5480            	  8061:          ADDQ.L  #2,D0
01:00203D02 1CFC0024        	  8062:          MOVE.B  #'$',(A6)+     HEX "$"
01:00203D06 6100E094        	  8063:          BSR     PNT8HX         DESTINATION
01:00203D0A 203C29435028    	  8064:          MOVE.L  #')CP(',D0     (PC)
01:00203D10 6100FC3E        	  8065:          BSR     SCHR           STORE WORD
01:00203D14 5483            	  8066:          ADDQ.L  #2,D3          SIZE
01:00203D16 4E75            	  8067:          RTS
                            	  8068: 
01:00203D18 0C040003        	  8069: EA1114   CMPI.B  #3,D4
01:00203D1C 6664            	  8070:          BNE.S   EA1115
                            	  8071: 
                            	  8072: * PROGRAM COUNTER WITH INDEX    DESTINATION(PC,R@.X)
                            	  8073: *
                            	  8074: *        5432109876543210       SECOND WORD
                            	  8075: *        0...............       DATA REGISTER
                            	  8076: *        1...............       ADDRESS REGISTER
                            	  8077: *        .XXX............       REGISTER
                            	  8078: *        ....0...........       SIGN-EXTENDED, LOW ORDER WORD INTEGER
                            	  8079: *                               ..IN INDEX REGISTER
                            	  8080: *        ....1...........       LONG VALUE IN INDEX REGISTER
                            	  8081: *        .....000........
                            	  8082: *        ........XXXXXXXX       DISPLACEMENT INTEGER
                            	  8083: *
01:00203D1E 0807000A        	  8084:          BTST    #10,D7
01:00203D22 67CE            	  8085:          BEQ     FE11           FERROR  THIS MODE NOT ASLLOWED
                            	  8086: 
01:00203D24 32343000        	  8087:          MOVE.W  (A4,D3),D1
01:00203D28 02410700        	  8088:          ANDI.W  #$0700,D1
01:00203D2C 66C4            	  8089:          BNE     FE11           FERROR;  BITS 10-8 MUST BE ZERO
                            	  8090: 
01:00203D2E 10343001        	  8091:          MOVE.B  1(A4,D3),D0    111100;   DESTINATION(PC,R@.X)
01:00203D32 4880            	  8092:          EXT.W   D0
01:00203D34 48C0            	  8093:          EXT.L   D0
01:00203D36 D0A9FFFC        	  8094:          ADD.L   HISPC(A1),D0
01:00203D3A 5480            	  8095:          ADDQ.L  #2,D0
01:00203D3C 1CFC0024        	  8096:          MOVE.B  #'$',(A6)+     HEX "$"
01:00203D40 6100E05A        	  8097:          BSR     PNT8HX         DESTINATION
                            	  8098: 
01:00203D44 203C2C435028    	  8099:          MOVE.L  #',CP(',D0
01:00203D4A 6100FC04        	  8100:          BSR     SCHR           DES(PC,
                            	  8101: 
01:00203D4E 38343000        	  8102:          MOVE.W  (A4,D3),D4
01:00203D52 E95C            	  8103:          ROL.W   #4,D4
01:00203D54 08040003        	  8104:          BTST    #3,D4
01:00203D58 6706            	  8105:          BEQ.S   EAF25
01:00203D5A 6100FA8C        	  8106:          BSR     FORMREGA
01:00203D5E 6004            	  8107:          BRA.S   EAF27
01:00203D60 6100FA96        	  8108: EAF25    BSR     FORMREGD       DES(PC,R@
                            	  8109: EAF27
                            	  8110: 
01:00203D64 1CFC002E        	  8111:          MOVE.B  #'.',(A6)+     DES(PC,R@.
                            	  8112: 
01:00203D68 38343000        	  8113:          MOVE.W  (A4,D3),D4
01:00203D6C 303C4C57        	  8114:          MOVE.W  #'LW',D0
01:00203D70 0804000B        	  8115:          BTST    #11,D4
01:00203D74 6702            	  8116:          BEQ.S   EAF35
01:00203D76 E048            	  8117:          LSR.W   #8,D0
01:00203D78 1CC0            	  8118: EAF35    MOVE.B  D0,(A6)+       DES(PC,R@.X
                            	  8119: 
01:00203D7A 1CFC0029        	  8120:          MOVE.B  #')',(A6)+     DES(PC,R@.X)
01:00203D7E 5483            	  8121:          ADDQ.L  #2,D3
01:00203D80 4E75            	  8122:          RTS
                            	  8123: 
                            	  8124: *   BIT  5432109876543210
                            	  8125: *        ..........111100       FIRST WORD;  #<IMMEDIATE>
                            	  8126: *
01:00203D82 0C040004        	  8127: EA1115   CMPI.B  #4,D4
01:00203D86 6600FF6A        	  8128:          BNE     FE11           FERROR
                            	  8129: 
01:00203D8A 0807000B        	  8130:          BTST    #11,D7
01:00203D8E 6700FF62        	  8131:          BEQ     FE11           FERROR;  THIS MODE NOT ALLOWED
                            	  8132: 
01:00203D92 1CFC0023        	  8133:          MOVE.B  #'#',(A6)+     IMMEDIATE
                            	  8134: 
01:00203D96 122DFFFF        	  8135:          MOVE.B  -1(A5),D1
01:00203D9A 0C01004C        	  8136:          CMPI.B  #'L',D1
01:00203D9E 6724            	  8137:          BEQ.S   EA11155        LONG
                            	  8138: 
01:00203DA0 30343000        	  8139:          MOVE.W  (A4,D3),D0
                            	  8140: 
01:00203DA4 0C010042        	  8141:          CMPI.B  #'B',D1
01:00203DA8 6610            	  8142:          BNE.S   EA11153        .WORD
                            	  8143: 
                            	  8144: * BYTE SIZE; DATA ALLOWED
                            	  8145: *  0000 0000 XXXX XXXX
                            	  8146: *  1111 1111 1XXX XXXX
01:00203DAA 2200            	  8147:          MOVE.L  D0,D1
01:00203DAC E049            	  8148:          LSR.W   #8,D1
01:00203DAE 670A            	  8149:          BEQ.S   EA11153
01:00203DB0 2200            	  8150:          MOVE.L  D0,D1
01:00203DB2 EE41            	  8151:          ASR.W   #7,D1
01:00203DB4 5241            	  8152:          ADDQ.W  #1,D1
01:00203DB6 6600FF3A        	  8153:          BNE     FE11           FERROR
                            	  8154: 
01:00203DBA 48C0            	  8155: EA11153  EXT.L   D0
01:00203DBC 6100D59E        	  8156:          BSR     HEX2DEC
01:00203DC0 5483            	  8157:          ADDQ.L  #2,D3
01:00203DC2 4E75            	  8158:          RTS
                            	  8159: 
01:00203DC4 20343000        	  8160: EA11155  MOVE.L  (A4,D3),D0
01:00203DC8 6100D592        	  8161:          BSR     HEX2DEC
01:00203DCC 5883            	  8162:          ADDQ.L  #4,D3          SIZE
01:00203DCE 4E75            	  8163:          RTS
                            	  8164: 
01:00203DD0 1AFC002E        	  8165: MOVEMS   MOVE.B  #'.',(A5)+     PERIOD
01:00203DD4 303C4C57        	  8166:          MOVE.W  #'LW',D0
01:00203DD8 08040006        	  8167:          BTST    #6,D4
01:00203DDC 6702            	  8168:          BEQ.S   MOVEMS2
01:00203DDE E048            	  8169:          LSR.W   #8,D0
01:00203DE0 1AC0            	  8170: MOVEMS2  MOVE.B  D0,(A5)+       SIZE
01:00203DE2 4E75            	  8171:          RTS
                            	  8172: 
                            	  8173: * MOVEM - REGISTER EXPANSION
                            	  8174: *
                            	  8175: MOVEMR   DS      0
01:00203DE4 342C0002        	  8176:          MOVE.W  2(A4),D2       D2 = SECOND WORD
01:00203DE8 7020            	  8177:          MOVEQ   #$20,D0        D0 = SPACE
01:00203DEA 7E2F            	  8178:          MOVEQ   #$2F,D7        D7 = /
01:00203DEC 538E            	  8179:          SUBQ.L  #1,A6          ADJUST STORE POINTER
01:00203DEE 7A30            	  8180:          MOVEQ   #$30,D5        D5 = REGISTER #
01:00203DF0 383C4144        	  8181:          MOVE.W  #'AD',D4       D4 = REG CLASS
                            	  8182: 
01:00203DF4 0302            	  8183: MOVEMR11 BTST    D1,D2
01:00203DF6 6730            	  8184:          BEQ.S   MOVEMR77       BIT RESET
                            	  8185: 
01:00203DF8 B016            	  8186:          CMP.B   (A6),D0        BIT SET
01:00203DFA 6612            	  8187:          BNE.S   MOVEMR44       NOT SPACE
                            	  8188: 
01:00203DFC 1D440001        	  8189: MOVEMR33 MOVE.B  D4,1(A6)       REG TYPE
01:00203E00 1D450002        	  8190:          MOVE.B  D5,2(A6)       REG #
01:00203E04 1D7C002D0003    	  8191:          MOVE.B  #'-',3(A6)     -
01:00203E0A 568E            	  8192:          ADDQ.L  #3,A6
01:00203E0C 602E            	  8193:          BRA.S   MOVEMR88
                            	  8194: 
01:00203E0E 0C16002C        	  8195: MOVEMR44 CMPI.B  #',',(A6)
01:00203E12 67E8            	  8196:          BEQ     MOVEMR33       COMMA SEPARATOR
                            	  8197: 
01:00203E14 BE16            	  8198:          CMP.B   (A6),D7        / SEPARATOR
01:00203E16 67E4            	  8199:          BEQ     MOVEMR33
                            	  8200: 
01:00203E18 1D440001        	  8201:          MOVE.B  D4,1(A6)       REG TYPE
01:00203E1C 1D450002        	  8202:          MOVE.B  D5,2(A6)       REG #
01:00203E20 1D7C002D0003    	  8203:          MOVE.B  #'-',3(A6)     - SEPARATOR
01:00203E26 6014            	  8204:          BRA.S   MOVEMR88
                            	  8205: 
01:00203E28 0C16002C        	  8206: MOVEMR77 CMPI.B  #',',(A6)
01:00203E2C 670E            	  8207:          BEQ.S   MOVEMR88       COMMA
                            	  8208: 
01:00203E2E B016            	  8209:          CMP.B   (A6),D0
01:00203E30 670A            	  8210:          BEQ.S   MOVEMR88       SPACE
01:00203E32 B02E0001        	  8211:          CMP.B   1(A6),D0
01:00203E36 6702            	  8212:          BEQ.S   MOVEMR79       SPACE
01:00203E38 568E            	  8213:          ADDQ.L  #3,A6
01:00203E3A 1C87            	  8214: MOVEMR79 MOVE.B  D7,(A6)        / SEPARATOR
                            	  8215: 
01:00203E3C 5285            	  8216: MOVEMR88 ADDQ.L  #1,D5
01:00203E3E D286            	  8217:          ADD.L   D6,D1          D1 = BIT POSITION
01:00203E40 0C050038        	  8218:          CMPI.B  #'8',D5
01:00203E44 66AE            	  8219:          BNE     MOVEMR11
                            	  8220: 
01:00203E46 B016            	  8221:          CMP.B   (A6),D0        SPACE
01:00203E48 670A            	  8222:          BEQ.S   MOVEMR94
                            	  8223: 
01:00203E4A B02E0001        	  8224:          CMP.B   1(A6),D0       SPACE
01:00203E4E 6704            	  8225:          BEQ.S   MOVEMR94
01:00203E50 568E            	  8226:          ADDQ.L  #3,A6
01:00203E52 1C87            	  8227:          MOVE.B  D7,(A6)        /   SEPARATOR
                            	  8228: 
01:00203E54 1A3C0030        	  8229: MOVEMR94 MOVE.B  #'0',D5        RESET REG TO ZERO
01:00203E58 E04C            	  8230:          LSR.W   #8,D4          CHANGE REG TYPE
01:00203E5A 6698            	  8231:          BNE     MOVEMR11       MORE
                            	  8232: 
01:00203E5C 1C80            	  8233:          MOVE.B  D0,(A6)        SPACE
01:00203E5E 4E75            	  8234:          RTS
                            	  8235: 
                            	  8236: DCODE68K DS      0
01:00203E60 4E51FFF0        	  8237:          LINK    A1,#-LOCVARSZ       CREATE A FRAME FOR THE
01:00203E64 48E91007FFF0    	  8238:          MOVEM.L D0-D2/A4,DDATA(A1)  CODE AND ITS PC.  A4
01:00203E6A 49E9FFF0        	  8239:          LEA     DDATA(A1),A4        POINTS TO THE CODE.
                            	  8240: 
01:00203E6E 264D            	  8241:          MOVE.L  A5,A3          A3 = START OF OUTPUT BUFFER
01:00203E70 7050            	  8242:          MOVEQ   #BUFSIZE,D0
01:00203E72 2C4B            	  8243:          MOVE.L  A3,A6
01:00203E74 1CFC0020        	  8244: DEC311   MOVE.B  #BLANK,(A6)+   SPACE FILL BUFFER
01:00203E78 5380            	  8245:          SUBQ.L  #1,D0
01:00203E7A 66F8            	  8246:          BNE     DEC311
                            	  8247: 
01:00203E7C 2C4B            	  8248:          MOVE.L  A3,A6          FORMAT ADDRESS
01:00203E7E 2029FFFC        	  8249:          MOVE.L  HISPC(A1),D0
01:00203E82 6100DF4A        	  8250:          BSR     FRELADDR
                            	  8251: 
                            	  8252: * CHECK FOR KNOWN ILLEGAL CODES
01:00203E86 3014            	  8253:          MOVE.W  (A4),D0
                            	  8254: 
01:00203E88 4BFA00C2        	  8255:          LEA     KI(PC),A5
01:00203E8C 2C4D            	  8256:          MOVE.L  A5,A6
01:00203E8E 548E            	  8257:          ADD.L   #KIEND-KI,A6
01:00203E90 B05D            	  8258: DEC404   CMP.W   (A5)+,D0
01:00203E92 671A            	  8259:          BEQ.S   FE12           FERROR;  ILLEGAL CODE
01:00203E94 BBCE            	  8260:          CMP.L   A6,A5
01:00203E96 66F8            	  8261:          BNE     DEC404
                            	  8262: 
                            	  8263: * LOOK FOR MATCH OF OP-CODE
                            	  8264: *
01:00203E98 4BFA00B4        	  8265:          LEA     TBL(PC),A5     A5 = POINTER TO DECODE TABLE
01:00203E9C 4DFA02BA        	  8266:          LEA     TBLE(PC),A6    A6 = POINTER TO END OF TABLE
01:00203EA0 3014            	  8267: DEC411   MOVE.W  (A4),D0        FIRST WORD
01:00203EA2 C05D            	  8268:          AND.W   (A5)+,D0       MASK
01:00203EA4 B05D            	  8269:          CMP.W   (A5)+,D0
01:00203EA6 6708            	  8270:          BEQ.S   DEC425         FOUND MATCH
01:00203EA8 548D            	  8271:          ADDQ.L  #2,A5          UPDATE POINTER
01:00203EAA BBCE            	  8272:          CMP.L   A6,A5
01:00203EAC 66F2            	  8273:          BNE     DEC411         MORE TABLE
01:00203EAE 6072            	  8274: FE12     BRA.S   FERROR         ILLEGAL INSTRUCTION
                            	  8275: 
01:00203EB0 7C00            	  8276: DEC425   CLR.L   D6
01:00203EB2 1C1D            	  8277:          MOVE.B  (A5)+,D6       D6 = (GOTO OFFSET)/4
01:00203EB4 E58E            	  8278:          LSL.L   #2,D6
                            	  8279: 
01:00203EB6 7E00            	  8280:          CLR.L   D7
01:00203EB8 1E1D            	  8281:          MOVE.B  (A5)+,D7       D7 = INDEX TO OP-CODE
                            	  8282: 
                            	  8283: * MOVE OP-CODE TO BUFFER
                            	  8284: *
01:00203EBA 41FA029C        	  8285:          LEA     OPCTBL(PC),A0
01:00203EBE 4A47            	  8286: DEC510   TST     D7
01:00203EC0 6708            	  8287:          BEQ.S   DEC530         AT INDEX
01:00203EC2 4A18            	  8288: DEC515   TST.B   (A0)+
01:00203EC4 6AFC            	  8289:          BPL     DEC515         MOVE THROUGH FIELD
01:00203EC6 5387            	  8290:          SUBQ.L  #1,D7
01:00203EC8 60F4            	  8291:          BRA     DEC510
                            	  8292: 
01:00203ECA 701F            	  8293: DEC530   MOVEQ   #FOC,D0
01:00203ECC 4BF30000        	  8294:          LEA.L   (A3,D0),A5     A5 = STORE POINTER  OP-CODE
01:00203ED0 1018            	  8295: DEC535   MOVE.B  (A0)+,D0
01:00203ED2 08800007        	  8296:          BCLR    #7,D0
01:00203ED6 6604            	  8297:          BNE.S   DEC537         END OF MOVE
01:00203ED8 1AC0            	  8298:          MOVE.B  D0,(A5)+
01:00203EDA 60F4            	  8299:          BRA     DEC535
01:00203EDC 1AC0            	  8300: DEC537   MOVE.B  D0,(A5)+
                            	  8301: 
                            	  8302: * CALCULATE GOTO AND GO
                            	  8303: *
01:00203EDE 7602            	  8304:          MOVEQ   #2,D3          D3= SIZE
01:00203EE0 41FAF7CE        	  8305:          LEA     X(PC),A0
01:00203EE4 D1C6            	  8306:          ADD.L   D6,A0
                            	  8307: 
01:00203EE6 7027            	  8308:          MOVEQ   #FOP,D0
01:00203EE8 4DF30000        	  8309:          LEA.L   (A3,D0),A6     A6 = POINTER FOR OPERAND
                            	  8310: 
01:00203EEC 3814            	  8311:          MOVE.W  (A4),D4        D4 = FIRST WORD
                            	  8312: 
01:00203EEE 1A3C002C        	  8313:          MOVE.B  #',',D5        D5 = CONTAINS ASCII COMMA
                            	  8314: 
01:00203EF2 3E3C01FD        	  8315:          MOVE.W  #$1FD,D7       D7 = DATA ALTERABLE MODES ALLOWED
                            	  8316: 
01:00203EF6 4ED0            	  8317:          JMP     (A0)
                            	  8318: *
                            	  8319: *  A4 = POINTER TO DATA IN FRAME CREATED BY 'LINK A1,...'
                            	  8320: *  A5 = POINTER STORE OP-CODE
                            	  8321: *  A6 = POINTER STORE OPERAND
                            	  8322: *  D3 = SIZE = 2 BYTES
                            	  8323: *  D4 = FIRST WORD
                            	  8324: *  D7 = ADDRESS MODES ALLOWED ($1FD) DATA ALTERABLE
                            	  8325: 
01:00203EF8 5483            	  8326: COMMON4  ADDQ.L  #2,D3          SIZE = 4
                            	  8327: 
01:00203EFA 2C03            	  8328: COMMON   MOVE.L  D3,D6          D6 = SIZE
01:00203EFC 1CFC0020        	  8329:          MOVE.B  #BLANK,(A6)+   SPACE AS LAST CHAR
                            	  8330: 
01:00203F00 2A4E            	  8331:          MOVE.L  A6,A5          SAVE END OF BUFFER POINTER
01:00203F02 700A            	  8332:          MOVEQ   #FDATA,D0
01:00203F04 4DF30000        	  8333:          LEA.L   (A3,D0),A6
                            	  8334: 
01:00203F08 301C            	  8335: COMMON35 MOVE.W  (A4)+,D0       GET NEXT WORD OF DATA.
01:00203F0A 54A9FFFC        	  8336:          ADDQ.L  #2,HISPC(A1)   ADJUST PROG COUNTER.
01:00203F0E 6100DE9A        	  8337:          BSR     PNT4HX         FORMAT DATA. (A6)+
01:00203F12 5503            	  8338:          SUBQ.B  #2,D3
01:00203F14 66F2            	  8339:          BNE     COMMON35
                            	  8340: 
01:00203F16 2C4D            	  8341:          MOVE.L  A5,A6          A6 = RESTORE END POINTER
                            	  8342: 
01:00203F18 2A4B            	  8343:          MOVE.L  A3,A5          A5 =  BEGINNING OF BUFFER
                            	  8344: 
01:00203F1A 2869FFFC        	  8345:          MOVE.L  HISPC(A1),A4   MOVE THE UPDATED PC
01:00203F1E 4E59            	  8346:          UNLK    A1               TO A4 AND UNDO FRAME.
                            	  8347: 
01:00203F20 4E75            	  8348:          RTS
                            	  8349: 
                            	  8350: 
                            	  8351: FERROR   DS      0
                            	  8352: * ILLEGAL INSTRUCTION
                            	  8353: *
01:00203F22 701F            	  8354:          MOVEQ   #FOC,D0
01:00203F24 4DF30000        	  8355:          LEA.L   (A3,D0),A6
01:00203F28 4BFA0018        	  8356:          LEA     MSG111(PC),A5
01:00203F2C 101D            	  8357: FERROR35 MOVE.B  (A5)+,D0
01:00203F2E 0C000004        	  8358:          CMPI.B  #EOT,D0
01:00203F32 6704            	  8359:          BEQ.S   FERROR39
01:00203F34 1CC0            	  8360:          MOVE.B  D0,(A6)+
01:00203F36 60F4            	  8361:          BRA     FERROR35
                            	  8362: FERROR39 DS      0
                            	  8363: 
01:00203F38 3014            	  8364:          MOVE.W  (A4),D0
01:00203F3A 6100DE6E        	  8365:          BSR     PNT4HX
                            	  8366: 
01:00203F3E 7602            	  8367:          MOVEQ   #2,D3          SIZE
                            	  8368: 
01:00203F40 60B8            	  8369:          BRA     COMMON
                            	  8370: 
01:00203F42 44432E5720202020	  8371: MSG111   DC.B    'DC.W    $',EOT
01:00203F4A 24
01:00203F4B 04
                            	  8372: 
                            	  8373: 
                            	  8374: 
01:00203F4C 4AFB            	  8375: KI       DC.W    $4AFB          KNOWN ILLEGAL CODES
                            	  8376: KIEND    DS      0
                            	  8377: 
                            	  8378: 
                            	  8379: *  \1   MASK
                            	  8380: *  \2   OP-CODE PATTERN
                            	  8381: *  \3   GOTO OFFSET
                            	  8382: *  \4   INDEX TO OP-CODE
                            	  8383: C68      MACRO
                            	  8384:          DC.W    $\1
                            	  8385:          DC.W    $\2
                            	  8386:          DC.B    (\3-X)>>2
                            	  8387:          DC.B    \4
                            	  8388:          ENDM
                            	  8389: 
                            	  8390: TBL      DS      0
                            	  8391:          C68     FEC0,E6C0,ISHIFT,56           RO
01:00203F4E FEC0            	     1M          DC.W    $FEC0
01:00203F50 E6C0            	     2M          DC.W    $E6C0
01:00203F52 F7              	     3M          DC.B    (ISHIFT-X)>>2
01:00203F53 38              	     4M          DC.B    56
                            	  8392:          C68     FEC0,E4C0,ISHIFT,57           ROX
01:00203F54 FEC0            	     1M          DC.W    $FEC0
01:00203F56 E4C0            	     2M          DC.W    $E4C0
01:00203F58 F7              	     3M          DC.B    (ISHIFT-X)>>2
01:00203F59 39              	     4M          DC.B    57
                            	  8393:          C68     FEC0,E2C0,ISHIFT,55           LS
01:00203F5A FEC0            	     1M          DC.W    $FEC0
01:00203F5C E2C0            	     2M          DC.W    $E2C0
01:00203F5E F7              	     3M          DC.B    (ISHIFT-X)>>2
01:00203F5F 37              	     4M          DC.B    55
                            	  8394:          C68     FEC0,E0C0,ISHIFT,54           AS
01:00203F60 FEC0            	     1M          DC.W    $FEC0
01:00203F62 E0C0            	     2M          DC.W    $E0C0
01:00203F64 F7              	     3M          DC.B    (ISHIFT-X)>>2
01:00203F65 36              	     4M          DC.B    54
                            	  8395:          C68     F018,E018,ISHIFT,56           RO
01:00203F66 F018            	     1M          DC.W    $F018
01:00203F68 E018            	     2M          DC.W    $E018
01:00203F6A F7              	     3M          DC.B    (ISHIFT-X)>>2
01:00203F6B 38              	     4M          DC.B    56
                            	  8396:          C68     F018,E010,ISHIFT,57           ROX
01:00203F6C F018            	     1M          DC.W    $F018
01:00203F6E E010            	     2M          DC.W    $E010
01:00203F70 F7              	     3M          DC.B    (ISHIFT-X)>>2
01:00203F71 39              	     4M          DC.B    57
                            	  8397:          C68     F018,E008,ISHIFT,55           LS
01:00203F72 F018            	     1M          DC.W    $F018
01:00203F74 E008            	     2M          DC.W    $E008
01:00203F76 F7              	     3M          DC.B    (ISHIFT-X)>>2
01:00203F77 37              	     4M          DC.B    55
                            	  8398:          C68     F018,E000,ISHIFT,54           AS
01:00203F78 F018            	     1M          DC.W    $F018
01:00203F7A E000            	     2M          DC.W    $E000
01:00203F7C F7              	     3M          DC.B    (ISHIFT-X)>>2
01:00203F7D 36              	     4M          DC.B    54
                            	  8399:          C68     F0C0,D0C0,FORM10EX,4          ADD       <EA>,A@
01:00203F7E F0C0            	     1M          DC.W    $F0C0
01:00203F80 D0C0            	     2M          DC.W    $D0C0
01:00203F82 5E              	     3M          DC.B    (FORM10EX-X)>>2
01:00203F83 04              	     4M          DC.B    4
                            	  8400:          C68     F130,D100,FORM12,53           ADDX
01:00203F84 F130            	     1M          DC.W    $F130
01:00203F86 D100            	     2M          DC.W    $D100
01:00203F88 88              	     3M          DC.B    (FORM12-X)>>2
01:00203F89 35              	     4M          DC.B    53
                            	  8401:          C68     F000,D000,FORM10EX,4            ADD
01:00203F8A F000            	     1M          DC.W    $F000
01:00203F8C D000            	     2M          DC.W    $D000
01:00203F8E 5E              	     3M          DC.B    (FORM10EX-X)>>2
01:00203F8F 04              	     4M          DC.B    4
                            	  8402:          C68     F1F8,C188,FORM9,50            EXG
01:00203F90 F1F8            	     1M          DC.W    $F1F8
01:00203F92 C188            	     2M          DC.W    $C188
01:00203F94 5B              	     3M          DC.B    (FORM9-X)>>2
01:00203F95 32              	     4M          DC.B    50
                            	  8403:          C68     F1F8,C148,FORM8,50            EXG
01:00203F96 F1F8            	     1M          DC.W    $F1F8
01:00203F98 C148            	     2M          DC.W    $C148
01:00203F9A 57              	     3M          DC.B    (FORM8-X)>>2
01:00203F9B 32              	     4M          DC.B    50
                            	  8404:          C68     F1F8,C140,FORM7,50            EXG
01:00203F9C F1F8            	     1M          DC.W    $F1F8
01:00203F9E C140            	     2M          DC.W    $C140
01:00203FA0 54              	     3M          DC.B    (FORM7-X)>>2
01:00203FA1 32              	     4M          DC.B    50
                            	  8405:          C68     F1F0,C100,FORM12,49           ABCD
01:00203FA2 F1F0            	     1M          DC.W    $F1F0
01:00203FA4 C100            	     2M          DC.W    $C100
01:00203FA6 88              	     3M          DC.B    (FORM12-X)>>2
01:00203FA7 31              	     4M          DC.B    49
                            	  8406:          C68     F1C0,C1C0,FORM6D,48           MULS
01:00203FA8 F1C0            	     1M          DC.W    $F1C0
01:00203FAA C1C0            	     2M          DC.W    $C1C0
01:00203FAC 4A              	     3M          DC.B    (FORM6D-X)>>2
01:00203FAD 30              	     4M          DC.B    48
                            	  8407:          C68     F1C0,C0C0,FORM6D,47           MULU
01:00203FAE F1C0            	     1M          DC.W    $F1C0
01:00203FB0 C0C0            	     2M          DC.W    $C0C0
01:00203FB2 4A              	     3M          DC.B    (FORM6D-X)>>2
01:00203FB3 2F              	     4M          DC.B    47
                            	  8408:          C68     F000,C000,FORM10,2            AND
01:00203FB4 F000            	     1M          DC.W    $F000
01:00203FB6 C000            	     2M          DC.W    $C000
01:00203FB8 6E              	     3M          DC.B    (FORM10-X)>>2
01:00203FB9 02              	     4M          DC.B    2
                            	  8409:          C68     F0C0,B0C0,FORM10EX,6          CMP     <EA>,A@
01:00203FBA F0C0            	     1M          DC.W    $F0C0
01:00203FBC B0C0            	     2M          DC.W    $B0C0
01:00203FBE 5E              	     3M          DC.B    (FORM10EX-X)>>2
01:00203FBF 06              	     4M          DC.B    6
                            	  8410:          C68     F138,B108,FORM12A,46           CMPM
01:00203FC0 F138            	     1M          DC.W    $F138
01:00203FC2 B108            	     2M          DC.W    $B108
01:00203FC4 97              	     3M          DC.B    (FORM12A-X)>>2
01:00203FC5 2E              	     4M          DC.B    46
                            	  8411:          C68     F100,B100,FORM10,5            EOR
01:00203FC6 F100            	     1M          DC.W    $F100
01:00203FC8 B100            	     2M          DC.W    $B100
01:00203FCA 6E              	     3M          DC.B    (FORM10-X)>>2
01:00203FCB 05              	     4M          DC.B    5
                            	  8412:          C68     F000,B000,FORM10EX,6            CMP
01:00203FCC F000            	     1M          DC.W    $F000
01:00203FCE B000            	     2M          DC.W    $B000
01:00203FD0 5E              	     3M          DC.B    (FORM10EX-X)>>2
01:00203FD1 06              	     4M          DC.B    6
                            	  8413:          C68     F0C0,90C0,FORM10EX,44         SUB       <EA>,A@
01:00203FD2 F0C0            	     1M          DC.W    $F0C0
01:00203FD4 90C0            	     2M          DC.W    $90C0
01:00203FD6 5E              	     3M          DC.B    (FORM10EX-X)>>2
01:00203FD7 2C              	     4M          DC.B    44
                            	  8414:          C68     F130,9100,FORM12,45           SUBX
01:00203FD8 F130            	     1M          DC.W    $F130
01:00203FDA 9100            	     2M          DC.W    $9100
01:00203FDC 88              	     3M          DC.B    (FORM12-X)>>2
01:00203FDD 2D              	     4M          DC.B    45
                            	  8415:          C68     F000,9000,FORM10EX,44           SUB
01:00203FDE F000            	     1M          DC.W    $F000
01:00203FE0 9000            	     2M          DC.W    $9000
01:00203FE2 5E              	     3M          DC.B    (FORM10EX-X)>>2
01:00203FE3 2C              	     4M          DC.B    44
                            	  8416:          C68     F1F0,8100,FORM12,43           SBCD
01:00203FE4 F1F0            	     1M          DC.W    $F1F0
01:00203FE6 8100            	     2M          DC.W    $8100
01:00203FE8 88              	     3M          DC.B    (FORM12-X)>>2
01:00203FE9 2B              	     4M          DC.B    43
                            	  8417:          C68     F1C0,81C0,FORM6D,42           DIVS
01:00203FEA F1C0            	     1M          DC.W    $F1C0
01:00203FEC 81C0            	     2M          DC.W    $81C0
01:00203FEE 4A              	     3M          DC.B    (FORM6D-X)>>2
01:00203FEF 2A              	     4M          DC.B    42
                            	  8418:          C68     F1C0,80C0,FORM6D,41           DIVU
01:00203FF0 F1C0            	     1M          DC.W    $F1C0
01:00203FF2 80C0            	     2M          DC.W    $80C0
01:00203FF4 4A              	     3M          DC.B    (FORM6D-X)>>2
01:00203FF5 29              	     4M          DC.B    41
                            	  8419:          C68     F000,8000,FORM10,40           OR
01:00203FF6 F000            	     1M          DC.W    $F000
01:00203FF8 8000            	     2M          DC.W    $8000
01:00203FFA 6E              	     3M          DC.B    (FORM10-X)>>2
01:00203FFB 28              	     4M          DC.B    40
                            	  8420:          C68     F100,7000,IMOVEQ,39           MOVEQ
01:00203FFC F100            	     1M          DC.W    $F100
01:00203FFE 7000            	     2M          DC.W    $7000
01:00204000 A2              	     3M          DC.B    (IMOVEQ-X)>>2
01:00204001 27              	     4M          DC.B    39
                            	  8421:          C68     FF00,6100,IBSR,51             BSR
01:00204002 FF00            	     1M          DC.W    $FF00
01:00204004 6100            	     2M          DC.W    $6100
01:00204006 DE              	     3M          DC.B    (IBSR-X)>>2
01:00204007 33              	     4M          DC.B    51
                            	  8422:          C68     FF00,6000,IBSR,65             BRA
01:00204008 FF00            	     1M          DC.W    $FF00
01:0020400A 6000            	     2M          DC.W    $6000
01:0020400C DE              	     3M          DC.B    (IBSR-X)>>2
01:0020400D 41              	     4M          DC.B    65
                            	  8423:          C68     F000,6000,ICC,38              B
01:0020400E F000            	     1M          DC.W    $F000
01:00204010 6000            	     2M          DC.W    $6000
01:00204012 DD              	     3M          DC.B    (ICC-X)>>2
01:00204013 26              	     4M          DC.B    38
                            	  8424:          C68     F0F8,50C8,IDBCC,37              DB
01:00204014 F0F8            	     1M          DC.W    $F0F8
01:00204016 50C8            	     2M          DC.W    $50C8
01:00204018 D8              	     3M          DC.B    (IDBCC-X)>>2
01:00204019 25              	     4M          DC.B    37
                            	  8425:          C68     F0C0,50C0,ISCC,36             S
01:0020401A F0C0            	     1M          DC.W    $F0C0
01:0020401C 50C0            	     2M          DC.W    $50C0
01:0020401E D5              	     3M          DC.B    (ISCC-X)>>2
01:0020401F 24              	     4M          DC.B    36
                            	  8426:          C68     F100,5100,IQUICK,35           SUBQ
01:00204020 F100            	     1M          DC.W    $F100
01:00204022 5100            	     2M          DC.W    $5100
01:00204024 A1              	     3M          DC.B    (IQUICK-X)>>2
01:00204025 23              	     4M          DC.B    35
                            	  8427:          C68     F100,5000,IQUICK,34           ADDQ
01:00204026 F100            	     1M          DC.W    $F100
01:00204028 5000            	     2M          DC.W    $5000
01:0020402A A1              	     3M          DC.B    (IQUICK-X)>>2
01:0020402B 22              	     4M          DC.B    34
                            	  8428:          C68     F1C0,41C0,FORM6A,33           LEA
01:0020402C F1C0            	     1M          DC.W    $F1C0
01:0020402E 41C0            	     2M          DC.W    $41C0
01:00204030 46              	     3M          DC.B    (FORM6A-X)>>2
01:00204031 21              	     4M          DC.B    33
                            	  8429:          C68     F1C0,4180,FORM6D,32           CHK
01:00204032 F1C0            	     1M          DC.W    $F1C0
01:00204034 4180            	     2M          DC.W    $4180
01:00204036 4A              	     3M          DC.B    (FORM6D-X)>>2
01:00204037 20              	     4M          DC.B    32
                            	  8430:          C68     FFC0,4EC0,FORM11SL,31         JMP
01:00204038 FFC0            	     1M          DC.W    $FFC0
01:0020403A 4EC0            	     2M          DC.W    $4EC0
01:0020403C 7F              	     3M          DC.B    (FORM11SL-X)>>2
01:0020403D 1F              	     4M          DC.B    31
                            	  8431:          C68     FFC0,4E80,FORM11SL,30         JSR
01:0020403E FFC0            	     1M          DC.W    $FFC0
01:00204040 4E80            	     2M          DC.W    $4E80
01:00204042 7F              	     3M          DC.B    (FORM11SL-X)>>2
01:00204043 1E              	     4M          DC.B    30
                            	  8432:          C68     FFFF,4E77,SCOMMON,29           RTR
01:00204044 FFFF            	     1M          DC.W    $FFFF
01:00204046 4E77            	     2M          DC.W    $4E77
01:00204048 D4              	     3M          DC.B    (SCOMMON-X)>>2
01:00204049 1D              	     4M          DC.B    29
                            	  8433:          C68     FFFF,4E76,SCOMMON,28           TRAPV
01:0020404A FFFF            	     1M          DC.W    $FFFF
01:0020404C 4E76            	     2M          DC.W    $4E76
01:0020404E D4              	     3M          DC.B    (SCOMMON-X)>>2
01:0020404F 1C              	     4M          DC.B    28
                            	  8434:          C68     FFFF,4E75,SCOMMON,27           RTS
01:00204050 FFFF            	     1M          DC.W    $FFFF
01:00204052 4E75            	     2M          DC.W    $4E75
01:00204054 D4              	     3M          DC.B    (SCOMMON-X)>>2
01:00204055 1B              	     4M          DC.B    27
                            	  8435:          C68     FFFF,4E73,SCOMMON,26           RTE
01:00204056 FFFF            	     1M          DC.W    $FFFF
01:00204058 4E73            	     2M          DC.W    $4E73
01:0020405A D4              	     3M          DC.B    (SCOMMON-X)>>2
01:0020405B 1A              	     4M          DC.B    26
                            	  8436:          C68     FFFF,4E72,ISTOP,25             STOP
01:0020405C FFFF            	     1M          DC.W    $FFFF
01:0020405E 4E72            	     2M          DC.W    $4E72
01:00204060 13              	     3M          DC.B    (ISTOP-X)>>2
01:00204061 19              	     4M          DC.B    25
                            	  8437:          C68     FFFF,4E71,SCOMMON,24           NOP
01:00204062 FFFF            	     1M          DC.W    $FFFF
01:00204064 4E71            	     2M          DC.W    $4E71
01:00204066 D4              	     3M          DC.B    (SCOMMON-X)>>2
01:00204067 18              	     4M          DC.B    24
                            	  8438:          C68     FFFF,4E70,SCOMMON,23           RESET
01:00204068 FFFF            	     1M          DC.W    $FFFF
01:0020406A 4E70            	     2M          DC.W    $4E70
01:0020406C D4              	     3M          DC.B    (SCOMMON-X)>>2
01:0020406D 17              	     4M          DC.B    23
                            	  8439:          C68     FFF8,4E68,IMVFUSP,60          MOVE FROM USP
01:0020406E FFF8            	     1M          DC.W    $FFF8
01:00204070 4E68            	     2M          DC.W    $4E68
01:00204072 AE              	     3M          DC.B    (IMVFUSP-X)>>2
01:00204073 3C              	     4M          DC.B    60
                            	  8440:          C68     FFF8,4E60,IMVTUSP,60          MOVE TO USP
01:00204074 FFF8            	     1M          DC.W    $FFF8
01:00204076 4E60            	     2M          DC.W    $4E60
01:00204078 B7              	     3M          DC.B    (IMVTUSP-X)>>2
01:00204079 3C              	     4M          DC.B    60
                            	  8441:          C68     FFF8,4E58,FORM5,22            UNLINK
01:0020407A FFF8            	     1M          DC.W    $FFF8
01:0020407C 4E58            	     2M          DC.W    $4E58
01:0020407E 45              	     3M          DC.B    (FORM5-X)>>2
01:0020407F 16              	     4M          DC.B    22
                            	  8442:          C68     FFF8,4E50,ILINK,21            LINK
01:00204080 FFF8            	     1M          DC.W    $FFF8
01:00204082 4E50            	     2M          DC.W    $4E50
01:00204084 36              	     3M          DC.B    (ILINK-X)>>2
01:00204085 15              	     4M          DC.B    21
                            	  8443:          C68     FFF0,4E40,FORM4,20            TRAP
01:00204086 FFF0            	     1M          DC.W    $FFF0
01:00204088 4E40            	     2M          DC.W    $4E40
01:0020408A 40              	     3M          DC.B    (FORM4-X)>>2
01:0020408B 14              	     4M          DC.B    20
                            	  8444:          C68     FF80,4C80,IMOVEMTR,15         MOVEM FROM REGISTERS
01:0020408C FF80            	     1M          DC.W    $FF80
01:0020408E 4C80            	     2M          DC.W    $4C80
01:00204090 0C              	     3M          DC.B    (IMOVEMTR-X)>>2
01:00204091 0F              	     4M          DC.B    15
                            	  8445:          C68     FFC0,4AC0,FORM1A,19           TAS
01:00204092 FFC0            	     1M          DC.W    $FFC0
01:00204094 4AC0            	     2M          DC.W    $4AC0
01:00204096 3D              	     3M          DC.B    (FORM1A-X)>>2
01:00204097 13              	     4M          DC.B    19
                            	  8446:          C68     FF00,4A00,FORM1,18            TST
01:00204098 FF00            	     1M          DC.W    $FF00
01:0020409A 4A00            	     2M          DC.W    $4A00
01:0020409C 3C              	     3M          DC.B    (FORM1-X)>>2
01:0020409D 12              	     4M          DC.B    18
                            	  8447:          C68     FFF8,48C0,FORM3,17            EXT.L
01:0020409E FFF8            	     1M          DC.W    $FFF8
01:002040A0 48C0            	     2M          DC.W    $48C0
01:002040A2 3F              	     3M          DC.B    (FORM3-X)>>2
01:002040A3 11              	     4M          DC.B    17
                            	  8448:          C68     FFF8,4880,FORM3,16            EXT.W
01:002040A4 FFF8            	     1M          DC.W    $FFF8
01:002040A6 4880            	     2M          DC.W    $4880
01:002040A8 3F              	     3M          DC.B    (FORM3-X)>>2
01:002040A9 10              	     4M          DC.B    16
                            	  8449:          C68     FF80,4880,IMOVEMFR,15         MOVEA TO REGISTERS
01:002040AA FF80            	     1M          DC.W    $FF80
01:002040AC 4880            	     2M          DC.W    $4880
01:002040AE 00              	     3M          DC.B    (IMOVEMFR-X)>>2
01:002040AF 0F              	     4M          DC.B    15
                            	  8450:          C68     FFF8,4840,FORM3,14            SWAP
01:002040B0 FFF8            	     1M          DC.W    $FFF8
01:002040B2 4840            	     2M          DC.W    $4840
01:002040B4 3F              	     3M          DC.B    (FORM3-X)>>2
01:002040B5 0E              	     4M          DC.B    14
                            	  8451:          C68     FFC0,4840,FORM11,13           PEA
01:002040B6 FFC0            	     1M          DC.W    $FFC0
01:002040B8 4840            	     2M          DC.W    $4840
01:002040BA 7C              	     3M          DC.B    (FORM11-X)>>2
01:002040BB 0D              	     4M          DC.B    13
                            	  8452:          C68     FFC0,4800,FORM1A,12           NBCD
01:002040BC FFC0            	     1M          DC.W    $FFC0
01:002040BE 4800            	     2M          DC.W    $4800
01:002040C0 3D              	     3M          DC.B    (FORM1A-X)>>2
01:002040C1 0C              	     4M          DC.B    12
                            	  8453:          C68     FFC0,46C0,IMVTSR,59           MOVE TO SR
01:002040C2 FFC0            	     1M          DC.W    $FFC0
01:002040C4 46C0            	     2M          DC.W    $46C0
01:002040C6 B2              	     3M          DC.B    (IMVTSR-X)>>2
01:002040C7 3B              	     4M          DC.B    59
                            	  8454:          C68     FF00,4600,FORM1,11            NOT
01:002040C8 FF00            	     1M          DC.W    $FF00
01:002040CA 4600            	     2M          DC.W    $4600
01:002040CC 3C              	     3M          DC.B    (FORM1-X)>>2
01:002040CD 0B              	     4M          DC.B    11
                            	  8455:          C68     FFC0,44C0,IMVTCCR,59          MOVE TO CCR
01:002040CE FFC0            	     1M          DC.W    $FFC0
01:002040D0 44C0            	     2M          DC.W    $44C0
01:002040D2 BA              	     3M          DC.B    (IMVTCCR-X)>>2
01:002040D3 3B              	     4M          DC.B    59
                            	  8456:          C68     FF00,4400,FORM1,10            NEG
01:002040D4 FF00            	     1M          DC.W    $FF00
01:002040D6 4400            	     2M          DC.W    $4400
01:002040D8 3C              	     3M          DC.B    (FORM1-X)>>2
01:002040D9 0A              	     4M          DC.B    10
                            	  8457:          C68     FF00,4200,FORM1,9             CLR
01:002040DA FF00            	     1M          DC.W    $FF00
01:002040DC 4200            	     2M          DC.W    $4200
01:002040DE 3C              	     3M          DC.B    (FORM1-X)>>2
01:002040DF 09              	     4M          DC.B    9
                            	  8458:          C68     FFC0,40C0,IMVFSR,59           MOVE.W  FROM  SR
01:002040E0 FFC0            	     1M          DC.W    $FFC0
01:002040E2 40C0            	     2M          DC.W    $40C0
01:002040E4 AA              	     3M          DC.B    (IMVFSR-X)>>2
01:002040E5 3B              	     4M          DC.B    59
                            	  8459:          C68     FF00,4000,FORM1,8             NEGX
01:002040E6 FF00            	     1M          DC.W    $FF00
01:002040E8 4000            	     2M          DC.W    $4000
01:002040EA 3C              	     3M          DC.B    (FORM1-X)>>2
01:002040EB 08              	     4M          DC.B    8
                            	  8460:          C68     F000,3000,IMOVE,59            MOVE.W
01:002040EC F000            	     1M          DC.W    $F000
01:002040EE 3000            	     2M          DC.W    $3000
01:002040F0 35              	     3M          DC.B    (IMOVE-X)>>2
01:002040F1 3B              	     4M          DC.B    59
                            	  8461:          C68     F000,2000,IMOVE,60            MOVE.L
01:002040F2 F000            	     1M          DC.W    $F000
01:002040F4 2000            	     2M          DC.W    $2000
01:002040F6 35              	     3M          DC.B    (IMOVE-X)>>2
01:002040F7 3C              	     4M          DC.B    60
                            	  8462:          C68     F000,1000,IMOVE,58            MOVE.B
01:002040F8 F000            	     1M          DC.W    $F000
01:002040FA 1000            	     2M          DC.W    $1000
01:002040FC 35              	     3M          DC.B    (IMOVE-X)>>2
01:002040FD 3A              	     4M          DC.B    58
                            	  8463:          C68     FF00,0C00,IMMED,6             CMP       #
01:002040FE FF00            	     1M          DC.W    $FF00
01:00204100 0C00            	     2M          DC.W    $0C00
01:00204102 18              	     3M          DC.B    (IMMED-X)>>2
01:00204103 06              	     4M          DC.B    6
                            	  8464:          C68     FF00,0A00,IMMED,5             EOR       #
01:00204104 FF00            	     1M          DC.W    $FF00
01:00204106 0A00            	     2M          DC.W    $0A00
01:00204108 18              	     3M          DC.B    (IMMED-X)>>2
01:00204109 05              	     4M          DC.B    5
                            	  8465:          C68     FF00,0600,IMMED,4             ADD       #
01:0020410A FF00            	     1M          DC.W    $FF00
01:0020410C 0600            	     2M          DC.W    $0600
01:0020410E 18              	     3M          DC.B    (IMMED-X)>>2
01:0020410F 04              	     4M          DC.B    4
                            	  8466:          C68     FF00,0400,IMMED,3             SUB       #
01:00204110 FF00            	     1M          DC.W    $FF00
01:00204112 0400            	     2M          DC.W    $0400
01:00204114 18              	     3M          DC.B    (IMMED-X)>>2
01:00204115 03              	     4M          DC.B    3
                            	  8467:          C68     FF00,0200,IMMED,2             AND       #
01:00204116 FF00            	     1M          DC.W    $FF00
01:00204118 0200            	     2M          DC.W    $0200
01:0020411A 18              	     3M          DC.B    (IMMED-X)>>2
01:0020411B 02              	     4M          DC.B    2
                            	  8468:          C68     FF00,0000,IMMED,1             OR        #
01:0020411C FF00            	     1M          DC.W    $FF00
01:0020411E 0000            	     2M          DC.W    $0000
01:00204120 18              	     3M          DC.B    (IMMED-X)>>2
01:00204121 01              	     4M          DC.B    1
                            	  8469:          C68     F138,0108,IMOVEP,0            MOVEP
01:00204122 F138            	     1M          DC.W    $F138
01:00204124 0108            	     2M          DC.W    $0108
01:00204126 BE              	     3M          DC.B    (IMOVEP-X)>>2
01:00204127 00              	     4M          DC.B    0
                            	  8470:          C68     FFC0,08C0,ISETS,64            BSET
01:00204128 FFC0            	     1M          DC.W    $FFC0
01:0020412A 08C0            	     2M          DC.W    $08C0
01:0020412C F0              	     3M          DC.B    (ISETS-X)>>2
01:0020412D 40              	     4M          DC.B    64
                            	  8471:          C68     FFC0,0880,ISETS,63            BCLR
01:0020412E FFC0            	     1M          DC.W    $FFC0
01:00204130 0880            	     2M          DC.W    $0880
01:00204132 F0              	     3M          DC.B    (ISETS-X)>>2
01:00204133 3F              	     4M          DC.B    63
                            	  8472:          C68     FFC0,0840,ISETS,62            BCHG
01:00204134 FFC0            	     1M          DC.W    $FFC0
01:00204136 0840            	     2M          DC.W    $0840
01:00204138 F0              	     3M          DC.B    (ISETS-X)>>2
01:00204139 3E              	     4M          DC.B    62
                            	  8473:          C68     FFC0,0800,ISETS,61            BTST
01:0020413A FFC0            	     1M          DC.W    $FFC0
01:0020413C 0800            	     2M          DC.W    $0800
01:0020413E F0              	     3M          DC.B    (ISETS-X)>>2
01:0020413F 3D              	     4M          DC.B    61
                            	  8474:          C68     F1C0,01C0,ISETD,64            BSET
01:00204140 F1C0            	     1M          DC.W    $F1C0
01:00204142 01C0            	     2M          DC.W    $01C0
01:00204144 EC              	     3M          DC.B    (ISETD-X)>>2
01:00204145 40              	     4M          DC.B    64
                            	  8475:          C68     F1C0,0180,ISETD,63            BCLR
01:00204146 F1C0            	     1M          DC.W    $F1C0
01:00204148 0180            	     2M          DC.W    $0180
01:0020414A EC              	     3M          DC.B    (ISETD-X)>>2
01:0020414B 3F              	     4M          DC.B    63
                            	  8476:          C68     F1C0,0140,ISETD,62            BCHG
01:0020414C F1C0            	     1M          DC.W    $F1C0
01:0020414E 0140            	     2M          DC.W    $0140
01:00204150 EC              	     3M          DC.B    (ISETD-X)>>2
01:00204151 3E              	     4M          DC.B    62
                            	  8477:          C68     F1C0,0100,ISETD,61            BTST
01:00204152 F1C0            	     1M          DC.W    $F1C0
01:00204154 0100            	     2M          DC.W    $0100
01:00204156 EC              	     3M          DC.B    (ISETD-X)>>2
01:00204157 3D              	     4M          DC.B    61
                            	  8478: TBLE     DS      0
                            	  8479: 
                            	  8480: N68      MACRO
                            	  8481:          DC.B    '\1',128+'\2'        \1\2
                            	  8482:          ENDM
                            	  8483: 
                            	  8484: OPCTBL   DS      0
                            	  8485:          N68     MOVE,P    0
01:00204158 4D4F5645        	     1M          DC.B    'MOVE',128+'P'        MOVEP
01:0020415C D0
                            	  8486:          N68     O,R       1
01:0020415D 4F              	     1M          DC.B    'O',128+'R'        OR
01:0020415E D2
                            	  8487:          N68     AN,D      2
01:0020415F 414E            	     1M          DC.B    'AN',128+'D'        AND
01:00204161 C4
                            	  8488:          N68     SU,B      3
01:00204162 5355            	     1M          DC.B    'SU',128+'B'        SUB
01:00204164 C2
                            	  8489:          N68     AD,D      4
01:00204165 4144            	     1M          DC.B    'AD',128+'D'        ADD
01:00204167 C4
                            	  8490:          N68     EO,R      5
01:00204168 454F            	     1M          DC.B    'EO',128+'R'        EOR
01:0020416A D2
                            	  8491:          N68     CM,P      6
01:0020416B 434D            	     1M          DC.B    'CM',128+'P'        CMP
01:0020416D D0
                            	  8492:          N68     MOV,E     7
01:0020416E 4D4F56          	     1M          DC.B    'MOV',128+'E'        MOVE
01:00204171 C5
                            	  8493:          N68     NEG,X     8
01:00204172 4E4547          	     1M          DC.B    'NEG',128+'X'        NEGX
01:00204175 D8
                            	  8494:          N68     CL,R      9
01:00204176 434C            	     1M          DC.B    'CL',128+'R'        CLR
01:00204178 D2
                            	  8495:          N68     NE,G      10
01:00204179 4E45            	     1M          DC.B    'NE',128+'G'        NEG
01:0020417B C7
                            	  8496:          N68     NO,T      11
01:0020417C 4E4F            	     1M          DC.B    'NO',128+'T'        NOT
01:0020417E D4
                            	  8497:          N68     NBC,D     12
01:0020417F 4E4243          	     1M          DC.B    'NBC',128+'D'        NBCD
01:00204182 C4
                            	  8498:          N68     PEA.,L    13
01:00204183 5045412E        	     1M          DC.B    'PEA.',128+'L'        PEA.L
01:00204187 CC
                            	  8499:          N68     SWAP.,W   14
01:00204188 535741502E      	     1M          DC.B    'SWAP.',128+'W'        SWAP.W
01:0020418D D7
                            	  8500:          N68     MOVE,M    15
01:0020418E 4D4F5645        	     1M          DC.B    'MOVE',128+'M'        MOVEM
01:00204192 CD
                            	  8501:          N68     EXT.,W    16
01:00204193 4558542E        	     1M          DC.B    'EXT.',128+'W'        EXT.W
01:00204197 D7
                            	  8502:          N68     EXT.,L    17
01:00204198 4558542E        	     1M          DC.B    'EXT.',128+'L'        EXT.L
01:0020419C CC
                            	  8503:          N68     TS,T      18
01:0020419D 5453            	     1M          DC.B    'TS',128+'T'        TST
01:0020419F D4
                            	  8504:          N68     TAS.,B    19
01:002041A0 5441532E        	     1M          DC.B    'TAS.',128+'B'        TAS.B
01:002041A4 C2
                            	  8505:          N68     TRA,P     20
01:002041A5 545241          	     1M          DC.B    'TRA',128+'P'        TRAP
01:002041A8 D0
                            	  8506:          N68     LIN,K     21
01:002041A9 4C494E          	     1M          DC.B    'LIN',128+'K'        LINK
01:002041AC CB
                            	  8507:          N68     UNL,K     22
01:002041AD 554E4C          	     1M          DC.B    'UNL',128+'K'        UNLK
01:002041B0 CB
                            	  8508:          N68     RESE,T    23
01:002041B1 52455345        	     1M          DC.B    'RESE',128+'T'        RESET
01:002041B5 D4
                            	  8509:          N68     NO,P      24
01:002041B6 4E4F            	     1M          DC.B    'NO',128+'P'        NOP
01:002041B8 D0
                            	  8510:          N68     STO,P     25
01:002041B9 53544F          	     1M          DC.B    'STO',128+'P'        STOP
01:002041BC D0
                            	  8511:          N68     RT,E      26
01:002041BD 5254            	     1M          DC.B    'RT',128+'E'        RTE
01:002041BF C5
                            	  8512:          N68     RT,S      27
01:002041C0 5254            	     1M          DC.B    'RT',128+'S'        RTS
01:002041C2 D3
                            	  8513:          N68     TRAP,V    28
01:002041C3 54524150        	     1M          DC.B    'TRAP',128+'V'        TRAPV
01:002041C7 D6
                            	  8514:          N68     RT,R      29
01:002041C8 5254            	     1M          DC.B    'RT',128+'R'        RTR
01:002041CA D2
                            	  8515:          N68     JS,R      30
01:002041CB 4A53            	     1M          DC.B    'JS',128+'R'        JSR
01:002041CD D2
                            	  8516:          N68     JM,P      31
01:002041CE 4A4D            	     1M          DC.B    'JM',128+'P'        JMP
01:002041D0 D0
                            	  8517:          N68     CHK.,W    32
01:002041D1 43484B2E        	     1M          DC.B    'CHK.',128+'W'        CHK.W
01:002041D5 D7
                            	  8518:          N68     LEA.,L    33
01:002041D6 4C45412E        	     1M          DC.B    'LEA.',128+'L'        LEA.L
01:002041DA CC
                            	  8519:          N68     ADD,Q     34
01:002041DB 414444          	     1M          DC.B    'ADD',128+'Q'        ADDQ
01:002041DE D1
                            	  8520:          N68     SUB,Q     35
01:002041DF 535542          	     1M          DC.B    'SUB',128+'Q'        SUBQ
01:002041E2 D1
01:002041E3 D3              	  8521:          DC.B    128+'S'   36
                            	  8522:          N68     D,B       37
01:002041E4 44              	     1M          DC.B    'D',128+'B'        DB
01:002041E5 C2
01:002041E6 C2              	  8523:          DC.B    128+'B'   38
                            	  8524:          N68     MOVEQ.,L  .....39
01:002041E7 4D4F5645512E    	     1M          DC.B    'MOVEQ.',128+'L'        MOVEQ.L
01:002041ED CC
                            	  8525:          N68     O,R       40
01:002041EE 4F              	     1M          DC.B    'O',128+'R'        OR
01:002041EF D2
                            	  8526:          N68     DIVU.,W   41
01:002041F0 444956552E      	     1M          DC.B    'DIVU.',128+'W'        DIVU.W
01:002041F5 D7
                            	  8527:          N68     DIVS.,W   42
01:002041F6 444956532E      	     1M          DC.B    'DIVS.',128+'W'        DIVS.W
01:002041FB D7
                            	  8528:          N68     SBC,D     43
01:002041FC 534243          	     1M          DC.B    'SBC',128+'D'        SBCD
01:002041FF C4
                            	  8529:          N68     SU,B      44
01:00204200 5355            	     1M          DC.B    'SU',128+'B'        SUB
01:00204202 C2
                            	  8530:          N68     SUB,X     45
01:00204203 535542          	     1M          DC.B    'SUB',128+'X'        SUBX
01:00204206 D8
                            	  8531:          N68     CMP,M     46
01:00204207 434D50          	     1M          DC.B    'CMP',128+'M'        CMPM
01:0020420A CD
                            	  8532:          N68     MULU.,W   47
01:0020420B 4D554C552E      	     1M          DC.B    'MULU.',128+'W'        MULU.W
01:00204210 D7
                            	  8533:          N68     MULS.,W   48
01:00204211 4D554C532E      	     1M          DC.B    'MULS.',128+'W'        MULS.W
01:00204216 D7
                            	  8534:          N68     ABC,D    49
01:00204217 414243          	     1M          DC.B    'ABC',128+'D'        ABCD
01:0020421A C4
                            	  8535:          N68     EX,G      50
01:0020421B 4558            	     1M          DC.B    'EX',128+'G'        EXG
01:0020421D C7
                            	  8536:          N68     BS,R      .....51
01:0020421E 4253            	     1M          DC.B    'BS',128+'R'        BSR
01:00204220 D2
                            	  8537:          N68     NUL,L     .....52
01:00204221 4E554C          	     1M          DC.B    'NUL',128+'L'        NULL
01:00204224 CC
                            	  8538:          N68     ADD,X     53
01:00204225 414444          	     1M          DC.B    'ADD',128+'X'        ADDX
01:00204228 D8
                            	  8539:          N68     A,S       54
01:00204229 41              	     1M          DC.B    'A',128+'S'        AS
01:0020422A D3
                            	  8540:          N68     L,S       55
01:0020422B 4C              	     1M          DC.B    'L',128+'S'        LS
01:0020422C D3
                            	  8541:          N68     R,O       56
01:0020422D 52              	     1M          DC.B    'R',128+'O'        RO
01:0020422E CF
                            	  8542:          N68     RO,X      57
01:0020422F 524F            	     1M          DC.B    'RO',128+'X'        ROX
01:00204231 D8
                            	  8543:          N68     MOVE.,B   58
01:00204232 4D4F56452E      	     1M          DC.B    'MOVE.',128+'B'        MOVE.B
01:00204237 C2
                            	  8544:          N68     MOVE.,W   59
01:00204238 4D4F56452E      	     1M          DC.B    'MOVE.',128+'W'        MOVE.W
01:0020423D D7
                            	  8545:          N68     MOVE.,L   60
01:0020423E 4D4F56452E      	     1M          DC.B    'MOVE.',128+'L'        MOVE.L
01:00204243 CC
                            	  8546:          N68     BTS,T     61
01:00204244 425453          	     1M          DC.B    'BTS',128+'T'        BTST
01:00204247 D4
                            	  8547:          N68     BCH,G     62
01:00204248 424348          	     1M          DC.B    'BCH',128+'G'        BCHG
01:0020424B C7
                            	  8548:          N68     BCL,R     63
01:0020424C 42434C          	     1M          DC.B    'BCL',128+'R'        BCLR
01:0020424F D2
                            	  8549:          N68     BSE,T     64
01:00204250 425345          	     1M          DC.B    'BSE',128+'T'        BSET
01:00204253 D4
                            	  8550:          N68     BR,A      65
01:00204254 4252            	     1M          DC.B    'BR',128+'A'        BRA
01:00204256 C1
                            	  8551: 
01:00204257 00              	  8552:          DC.B    0              PAD BYTE
                            	  8553: 
                            	  8554: 
                            	  8555: 
                            	  8556: *-------------------------------------------------------------------------
                            	  8557: * File TRAP14    Trap 14 handler of "TUTOR"                       06/25/82
                            	  8558: 
                            	  8559: *        CALLING SEQUENCE
                            	  8560: *                  D7 = XXXXXXFF   WHERE "FF" IF FUNCTION NUMBER
                            	  8561: *                  TRAP      #14
                            	  8562: 
                            	  8563: TRAP14
01:00204258 48E74160        	  8564:          MOVEM.L D1/D7/A1-A2,-(A7)
                            	  8565: 
01:0020425C 22780656        	  8566:          MOVE.L  CTLINK,A1
01:00204260 1211            	  8567: T100     MOVE.B  (A1),D1        D1 = FUNCTION FROM TABLE
01:00204262 0C0100FF        	  8568:          CMPI.B  #$FF,D1
01:00204266 6740            	  8569:          BEQ.S   T500           END OF TABLE
                            	  8570: 
01:00204268 0C0100FE        	  8571:          CMPI.B  #$FE,D1
01:0020426C 6774            	  8572:          BEQ.S   T600           LINK IN LIST
                            	  8573: 
01:0020426E B207            	  8574:          CMP.B   D7,D1
01:00204270 6704            	  8575:          BEQ.S   T400           FOUND MATCH
                            	  8576: 
01:00204272 5889            	  8577:          ADDQ.L  #4,A1
01:00204274 60EA            	  8578:          BRA     T100
                            	  8579: 
01:00204276 2211            	  8580: T400     MOVE.L  (A1),D1        FFAAAAAA
01:00204278 E181            	  8581:          ASL.L   #8,D1          AAAAAA..
01:0020427A E089            	  8582:          LSR.L   #8,D1          00AAAAAA  GO TO ADDRESS
                            	  8583: 
01:0020427C 082F00050010    	  8584:          BTST.B  #5,16(A7)
01:00204282 6710            	  8585:          BEQ.S   T450           CALL FROM USER MODE
                            	  8586: 
                            	  8587: *  CALL FROM SUPERVISOR MODE
                            	  8588: * STACK (WORDS)
                            	  8589: *   +0   D1 HIGH
                            	  8590: *   +2   D1 LOW
                            	  8591: *   +4   D7 HIGH
                            	  8592: *   +6   D7 LOW
                            	  8593: *   +8   A1 HIGH
                            	  8594: *   +10  A1 LOW
                            	  8595: *   +12  A2 HIGH              STATUS REG
                            	  8596: *   +14  A2 LOW               GOTO HIGH
                            	  8597: *   +16  STATUS REG           GOTO LOW
                            	  8598: *   +18  RETURN HIGH        RETURN HIGH
                            	  8599: *   +20  RETURN LOW         RETURN LOW
                            	  8600: *
01:00204284 2F6F0010000C    	  8601:          MOVE.L  16(A7),12(A7)  SR
01:0020428A 2F41000E        	  8602:          MOVE.L  D1,14(A7)      GOTO ADDRESS
01:0020428E 4CDF0282        	  8603:          MOVEM.L (A7)+,D1/D7/A1 RESTORE REGISTERS
01:00204292 4E73            	  8604:          RTE                    GOTO (AND TRIM STACK)
                            	  8605: 
                            	  8606: * STACK (WORDS)
                            	  8607: *   +0   D1 HIGH
                            	  8608: *   +2   D1 LOW
                            	  8609: *   +4   D7 HIGH
                            	  8610: *   +6   D7 LOW
                            	  8611: *   +8   A1 HIGH
                            	  8612: *   +10  A1 LOW
                            	  8613: *   +12  A2 HIGH                                 (USER STACK)
                            	  8614: *   +14  A2 LOW
                            	  8615: *   +16  STATUS REG         STATUS REG
                            	  8616: *   +18  RETURN HIGH        GOTO HIGH            RETURN HIGH
                            	  8617: *   +20  RETURN LOW         GOTO LOW             RETURN LOW
                            	  8618: *
                            	  8619: * CALL FROM USER MODE
01:00204294 2E2F0012        	  8620: T450     MOVE.L  18(A7),D7      RETURN PC
01:00204298 2F410012        	  8621:          MOVE.L  D1,18(A7)      GOTO ADDRESS
01:0020429C 4E69            	  8622:          MOVE.L  USP,A1         POINTER TO USER STACK
01:0020429E 2307            	  8623:          MOVE.L  D7,-(A1)       RETURN PC TO USER STACK
01:002042A0 4E61            	  8624:          MOVE.L  A1,USP         UPDATED USER STACK POINTER
01:002042A2 4CDF0682        	  8625:          MOVEM.L (A7)+,D1/D7/A1/A2
01:002042A6 4E73            	  8626:          RTE
                            	  8627: 
01:002042A8 4CDF0682        	  8628: T500     MOVEM.L (A7)+,D1/D7/A1/A2
                            	  8629:          SAVEREGS
01:002042AC 21CF0444        	     1M          MOVE.L  A7,REGA7       SAVE STACK POINTER
01:002042B0 4FFA000A        	     2M          LEA     SV_000393(PC),A7    A7 = RETURN ADDRESS (FOR CALL TO SAVE)
01:002042B4 21CF04D6        	     3M          MOVE.L  A7,TEMP        TEMP = RETURN ADDRESS
01:002042B8 6000CDCE        	     4M          BRA     SAVE           BSR WITHOUT USING STACK
                            	     5M SV_000393     DS      0
01:002042BC 4BFA0012        	  8630:          LEA     MSGT14(PC),A5
01:002042C0 6100C228        	  8631:          BSR     FIXDATA
01:002042C4 6100DD24        	  8632:          BSR     OUT1CR
01:002042C8 6100CA36        	  8633:          BSR     TDISPLY
01:002042CC 6000C360        	  8634:          BRA     MACSBUG
                            	  8635: 
01:002042D0 554E444546494E45	  8636: MSGT14   DC.B    'UNDEFINED TRAP 14',EOT
01:002042D8 4420545241502031
01:002042E0 34
01:002042E1 04
                            	  8637: 
                            	  8638: 
                            	  8639: 
                            	  8640: 
                            	  8641: 
01:002042E2 2251            	  8642: T600     MOVE.L  (A1),A1
01:002042E4 6000FF7A        	  8643:          BRA     T100
                            	  8644: 
                            	  8645: T700     DS      0              253 APPEND NEW TABLE
01:002042E8 2208            	  8646:          MOVE.L  A0,D1          ..AAAAAA
01:002042EA 20780656        	  8647:          MOVE.L  CTLINK,A0      A0 = LINK TO BE RETURNED
01:002042EE E199            	  8648:          ROL.L   #8,D1          AAAAAA..
01:002042F0 123C00FE        	  8649:          MOVE.B  #$FE,D1        AAAAAAFE
01:002042F4 E099            	  8650:          ROR.L   #8,D1          FEAAAAAA
01:002042F6 21C10656        	  8651:          MOVE.L  D1,CTLINK
01:002042FA 4E75            	  8652:          RTS
                            	  8653: 
                            	  8654: 
                            	  8655: *  CREATE ENTRY TO FUNCTION/ADDRESS TABLE
                            	  8656: *    FFAAAAAA
                            	  8657: *    FF......      FUNCTION NUMBER
                            	  8658: *    ..AAAAAA      ADDRESS OF FUNCTION
                            	  8659: 
                            	  8660: FADDR    MACRO   \1,\2
                            	  8661:          DC.L    (\1<<24)+\2
                            	  8662:          ENDM
                            	  8663: 
                            	  8664: 
                            	  8665: CT       FADDR   253,T700       APPEND NEW TABLE
01:002042FC FD2042E8        	     1M          DC.L    (253<<24)+T700
                            	  8666:          FADDR   252,FIXDADD    APPEND DATA (A5) TO BUFFER (A6)+
01:00204300 FC2004EE        	     1M          DC.L    (252<<24)+FIXDADD
                            	  8667:          FADDR   251,FIXBUF     SET A5 & A6 AS POINTERS TO BUFFER
01:00204304 FB202090        	     1M          DC.L    (251<<24)+FIXBUF
                            	  8668:          FADDR   250,FIXDATA    MOVE DATA (A5) TO BUFFER; A5=BUFFER A6
01:00204308 FA2004EA        	     1M          DC.L    (250<<24)+FIXDATA
                            	  8669:          FADDR   249,FIXDCRLF
01:0020430C F92004FE        	     1M          DC.L    (249<<24)+FIXDCRLF
                            	  8670:          FADDR   248,F100       OUTPUT CHAR PORT1  D0=CHAR
01:00204310 F8204370        	     1M          DC.L    (248<<24)+F100
                            	  8671:          FADDR   247,F110       INPUT CHAR PORT1  D0=CHAR
01:00204314 F7204378        	     1M          DC.L    (247<<24)+F110
                            	  8672:          FADDR   244,CHRPRINT   OUTPUT CHAR PORT3 D0=CHAR
01:00204318 F4202174        	     1M          DC.L    (244<<24)+CHRPRINT
                            	  8673:          FADDR   243,OUTPUT     OUTPUT STRING PORT1 (A5) (A6)
01:0020431C F3202004        	     1M          DC.L    (243<<24)+OUTPUT
                            	  8674:          FADDR   242,OUTPUT21   OUTPUT STRING PORT2 (A5) (A6)
01:00204320 F2202024        	     1M          DC.L    (242<<24)+OUTPUT21
                            	  8675:          FADDR   241,PORTIN1    INPUT STRING PORT1  (A5) (A6)
01:00204324 F1202098        	     1M          DC.L    (241<<24)+PORTIN1
                            	  8676:          FADDR   240,PORTIN20   INPUT STRING PORT2  (A5) (A6)
01:00204328 F02023CE        	     1M          DC.L    (240<<24)+PORTIN20
                            	  8677:          FADDR   239,TAPEOUT    OUTPUT STRING TO PORT4 (A5) (A6)
01:0020432C EF202296        	     1M          DC.L    (239<<24)+TAPEOUT
                            	  8678:          FADDR   238,TAPEIN     INPUT STRING FROM PORT4 (A5) (A6)
01:00204330 EE202496        	     1M          DC.L    (238<<24)+TAPEIN
                            	  8679:          FADDR   237,PRCRLF     OUTPUT STRING TO PORT3 (A5) (A6)
01:00204334 ED202160        	     1M          DC.L    (237<<24)+PRCRLF
                            	  8680:          FADDR   236,HEX2DEC    CONVERT HEX D0 TO DECIMAL (A6)+
01:00204338 EC20135C        	     1M          DC.L    (236<<24)+HEX2DEC
                            	  8681:          FADDR   235,GETHEX     GET HEX CHAR INTO D0 FROM (A5)+
01:0020433C EB201FA0        	     1M          DC.L    (235<<24)+GETHEX
                            	  8682:          FADDR   234,PUTHEX     FORMAT HEX CHAR FROM D0 TO (A6)+
01:00204340 EA201DBA        	     1M          DC.L    (234<<24)+PUTHEX
                            	  8683:          FADDR   233,PNT2HX     FORMAT 2 HEX CHAR FROM D0 TO (A6)+
01:00204344 E9201DB2        	     1M          DC.L    (233<<24)+PNT2HX
                            	  8684:          FADDR   232,PNT4HX     FORMAT 4 HEX CHAR FROM D0 TO (A6)+
01:00204348 E8201DAA        	     1M          DC.L    (232<<24)+PNT4HX
                            	  8685:          FADDR   231,PNT6HX     FORMAT 6 HEX CHAR FROM D0 TO (A6)+
01:0020434C E7201DA4        	     1M          DC.L    (231<<24)+PNT6HX
                            	  8686:          FADDR   230,PNT8HX     FORMAT 8 HEX CHAR FROM D0 TO (A6)+
01:00204350 E6201D9C        	     1M          DC.L    (230<<24)+PNT8HX
                            	  8687:          FADDR   229,START      RESTART TUTOR INITIALIZE EVERYTHING
01:00204354 E520053A        	     1M          DC.L    (229<<24)+START
                            	  8688:          FADDR   228,MACSBUG    GOTO TUTOR;   PRINT PROMPT
01:00204358 E420062E        	     1M          DC.L    (228<<24)+MACSBUG
                            	  8689:          FADDR   227,F120       OUTPUT STRING,CR,LF PORT1 (A5) (A6)
01:0020435C E3204380        	     1M          DC.L    (227<<24)+F120
                            	  8690:          FADDR   226,GETNUMA    GET HEX NUMBER (A5)+ INTO D0
01:00204360 E2201EF0        	     1M          DC.L    (226<<24)+GETNUMA
                            	  8691:          FADDR   225,GETNUMD    GET DECIMAL NUMBER (A5)+ INTO D0
01:00204364 E1201EE8        	     1M          DC.L    (225<<24)+GETNUMD
                            	  8692:          FADDR   224,PORTIN1N   INPUT STRING PORT1 (NO AUTO LF)
01:00204368 E02020AA        	     1M          DC.L    (224<<24)+PORTIN1N
                            	  8693: 
                            	  8694:          FADDR   255,$FFFFFF    END KEY
01:0020436C FFFFFFFF        	     1M          DC.L    (255<<24)+$FFFFFF
                            	  8695: 
01:00204370 6100DCFA        	  8696: F100     BSR     GETSER1        A0 = PORT1 ADDRESS
01:00204374 6000DE9E        	  8697:          BRA     OUTCH
                            	  8698: 
01:00204378 6100DCF2        	  8699: F110     BSR     GETSER1        A0 = PORT1 ADDRESS
01:0020437C 6000E022        	  8700:          BRA     INCHNE
                            	  8701: 
01:00204380 6100DC82        	  8702: F120     BSR     OUTPUT         OUTPUT STRING,CR,LF PORT1 (A5) (A6)
01:00204384 700D            	  8703:          MOVEQ   #CR,D0
01:00204386 61E8            	  8704:          BSR     F100           OUTPUT CHAR
01:00204388 700A            	  8705:          MOVEQ   #LF,D0
01:0020438A 61E4            	  8706:          BSR     F100           OUTPUT CHAR
01:0020438C 4E75            	  8707:          RTS
                            	  8708: 
                            	  8709: 
01:0020438E 00              	  8710:          DCB.B   $54,0          PAD BYTES
01:0020438F *
                            	  8711: 
                            	  8712: 
                            	  8713: *-------------------------------------------------------------------------
                            	  8714: * File YROM      Version/checksum/identification                  07/29/82
                            	  8715: 
                            	  8716: VERSION  EQU     4         BINARY FOR VERSION 1.3
                            	  8717: *                3         .                  1.2; CKSUM= $44,$DB
                            	  8718: *                2         .                  1.1; CKSUM= $66,$C1
                            	  8719: *                1         .                  1.0
                            	  8720: 
01:002043E2 04              	  8721:          DC.B    VERSION,VERSION
01:002043E3 04
01:002043E4 2E              	  8722:          DC.B    $2E,$BA        CHECKSUM
01:002043E5 BA
01:002043E6 11              	  8723:          DC.B    $11,$10        SOCKET I. D.
01:002043E7 10
                            	  8724: LAST     DS.W    0              LAST ADDRESS+1
                            	  8725: 
                            	  8726:         include "src/basic68k.asm"

Source: "src/basic68k.asm"
                            	     1: *************************************************************************************
                            	     2: *										    *
                            	     3: *	Enhanced BASIC for the Motorola MC680xx					    *
                            	     4: *										    *
                            	     5: *	This version is for the TS2 single board computer.		            *
                            	     6: *	Jeff Tranter (tranter@pobox.com)					    *
                            	     7: *										    *
                            	     8: *************************************************************************************
                            	     9: *										    *
                            	    10: *	Copyright(C) 2002-12 by Lee Davison. This program may be freely distributed *
                            	    11: *	for personal use only. All commercial rights are reserved.		    *
                            	    12: *										    *
                            	    13: *	More 68000 and other projects can be found on my website at ..		    *
                            	    14: *										    *
                            	    15: *	 http://mycorner.no-ip.org/index.html					    *
                            	    16: *										    *
                            	    17: *	mail : leeedavison@googlemail.com					    *
                            	    18: *										    *
                            	    19: *************************************************************************************
                            	    20: 
                            	    21: * Ver 3.54
                            	    22: 
                            	    23: * Ver 3.54 adds experimental support for LOAD/SAVE using Hobbytronics
                            	    24: * USB Flash Drive Host Board
                            	    25: * Ver 3.53 fixes math error that affected exponentiation ("^") and
                            	    26: *  EXP() function. Thanks to joelang for fix.
                            	    27: * Ver 3.52 stops USING$() from reading beyond the end of the format string
                            	    28: * Ver 3.51 fixes the UCASE$() and LCASE$() functions for null strings
                            	    29: * Ver 3.50 unary minus in concatenate generates a type mismatch error
                            	    30: * Ver 3.49 doesn't tokenise 'DEF' or 'DEC' within a hex value
                            	    31: * Ver 3.48 allows scientific notation underflow in the USING$() function
                            	    32: * Ver 3.47 traps the use of array elements as the FOR loop variable
                            	    33: * Ver 3.46 updates function and function variable handling
                            	    34: 
                            	    35: *************************************************************************************
                            	    36: *
                            	    37: * Ver 3.45 makes the handling of non existant variables consistent and gives the
                            	    38: * option of not returning an error for a non existant variable. If this is the
                            	    39: * behaviour you want just change novar to some non zero value
                            	    40: 
                            	    41: novar		EQU	0				* non existant variables cause errors
                            	    42: 
                            	    43: * Set the symbol FLASH_SUPPORT to 1 if you want to enable experimental
                            	    44: * support for LOAD/SAVE using a Hobbytronics USB Flash Drive Host
                            	    45: * Board.
                            	    46: 
                            	    47: FLASH_SUPPORT   EQU     0
                            	    48: 
                            	    49: *************************************************************************************
                            	    50: 
                            	    51: * Ver 3.44 adds overflow indication to the USING$() function
                            	    52: * Ver 3.43 removes an undocumented feature of concatenating null strings
                            	    53: * Ver 3.42 reimplements backspace so that characters are overwritten with [SPACE]
                            	    54: * Ver 3.41 removes undocumented features of the USING$() function
                            	    55: * Ver 3.40 adds the USING$() function
                            	    56: * Ver 3.33 adds the file requester to LOAD and SAVE
                            	    57: * Ver 3.32 adds the optional ELSE clause to IF .. THEN
                            	    58: 
                            	    59: *************************************************************************************
                            	    60: *
                            	    61: * Version 3.25 adds the option to change the behaviour of INPUT so that a null
                            	    62: * response does not cause a program break. If this is the behaviour you want just
                            	    63: * change nobrk to some non zero value.
                            	    64: 
                            	    65: nobrk		EQU	0				* null response to INPUT causes a break
                            	    66: 
                            	    67: 
                            	    68: *************************************************************************************
                            	    69: *
                            	    70: * Version 3.xx replaces the fixed RAM addressing from previous versions with a RAM
                            	    71: * pointer in a3. this means that this could now be run as a task on a multitasking
                            	    72: * system where memory resources may change.
                            	    73: 
                            	    74: 
                            	    75: *************************************************************************************
                            	    76: 
                            	    77: * This lot is in RAM
                            	    78: 
                            	    79: ram_strt    = $0000
                            	    80: ram_base    = $0400
                            	    81: LAB_WARM    = $0400
                            	    82: Wrmjpv      = $0402
                            	    83: Usrjmp      = $0406
                            	    84: Usrjpv      = $0408
                            	    85: V_INPT      = $040C
                            	    86: V_INPTv     = $040E
                            	    87: V_OUTP      = $0412
                            	    88: V_OUTPv     = $0414
                            	    89: V_LOAD      = $0418
                            	    90: V_LOADv     = $041A
                            	    91: V_SAVE      = $041E
                            	    92: V_SAVEv     = $0420
                            	    93: V_CTLC      = $0424
                            	    94: V_CTLCv     = $0426
                            	    95: Itemp       = $042A
                            	    96: Smeml       = $042E
                            	    97: Sfncl       = $0432
                            	    98: Svarl       = $0436
                            	    99: Sstrl       = $043A
                            	   100: Sarryl      = $043E
                            	   101: Earryl      = $0442
                            	   102: Sstorl      = $0446
                            	   103: Ememl       = $044A
                            	   104: Sutill      = $044E
                            	   105: Clinel      = $0452
                            	   106: Blinel      = $0456
                            	   107: Cpntrl      = $045A
                            	   108: Dlinel      = $045E
                            	   109: Dptrl       = $0462
                            	   110: Rdptrl      = $0466
                            	   111: Varname     = $046A
                            	   112: Cvaral      = $046E
                            	   113: Lvarpl      = $0472
                            	   114: des_sk_e    = $0476
                            	   115: des_sk      = $048E
                            	   116: Ibuffs      = $0490
                            	   117: Ibuffe      = $0590
                            	   118: FAC1_m      = $0590
                            	   119: FAC1_e      = $0594
                            	   120: FAC1_s      = $0595
                            	   121: FAC2_m      = $0598
                            	   122: FAC2_e      = $059C
                            	   123: FAC2_s      = $059D
                            	   124: FAC_sc      = $059E
                            	   125: flag        = $059F
                            	   126: PRNlword    = $05A0
                            	   127: ut1_pl      = $05A4
                            	   128: Asptl       = $05A8
                            	   129: Astrtl      = $05AC
                            	   130: numexp      = $05AC
                            	   131: expcnt      = $05AD
                            	   132: expneg      = $05AF
                            	   133: func_l      = $05B0
                            	   134: Defdim      = $05B4
                            	   135: cosout      = $05B4
                            	   136: Dtypef      = $05B5
                            	   137: Binss       = $05B6
                            	   138: Decss       = $05C6
                            	   139: Usdss       = $05CC
                            	   140: Hexss       = $05CE
                            	   141: BHsend      = $05D6
                            	   142: prstk       = $05D8
                            	   143: tpower      = $05D9
                            	   144: Asrch       = $05DA
                            	   145: Dimcnt      = $05DB
                            	   146: Breakf      = $05DC
                            	   147: Oquote      = $05DD
                            	   148: Gclctd      = $05DE
                            	   149: Sufnxf      = $05DF
                            	   150: Imode       = $05E0
                            	   151: Cflag       = $05E1
                            	   152: TabSiz      = $05E2
                            	   153: comp_f      = $05E3
                            	   154: Nullct      = $05E4
                            	   155: TPos        = $05E5
                            	   156: TWidth      = $05E6
                            	   157: Iclim       = $05E7
                            	   158: ccflag      = $05E8
                            	   159: ccbyte      = $05E9
                            	   160: ccnull      = $05EA
                            	   161: load_first  = $05EB
                            	   162: load_filename  = $05EC
                            	   163: prg_strt    = $05EC
                            	   164: 
                            	   165: * Use these two lines when running from ROM
                            	   166: ram_addr	EQU	$08800		* RAM start address just above where Tutor usage ends
                            	   167: ram_size	EQU	$17800		* RAM size
                            	   168: 
                            	   169: * Use these two lines when running from RAM
                            	   170: *ram_addr	EQU	$04000		* RAM start address
                            	   171: *ram_size	EQU	$04000		* RAM size
                            	   172: 							* RAM offset definitions
                            	   173: 
                            	   174: ACIA_1   =      SER1        * Console ACIA base address
                            	   175: ACIA_2   =      SER2        * Auxiliary ACIA base address
                            	   176: 
                            	   177: *************************************************************************************
                            	   178: *
                            	   179: * the following code is simulator specific, change to suit your system
                            	   180: 
                            	   181: * Output character to the console from register d0.b
                            	   182: 
                            	   183: VEC_OUT
01:002043E8 48E74080        	   184:         MOVEM.L  A0/D1,-(A7)    * Save working registers
01:002043EC 41F9003C0008    	   185:         LEA.L    ACIA_1,A0      * A0 points to console ACIA
                            	   186: TXNOTREADY
01:002043F2 1210            	   187:         MOVE.B   (A0),D1        * Read ACIA status
01:002043F4 08010001        	   188:         BTST     #1,D1          * Test TDRE bit
01:002043F8 67F8            	   189:         BEQ.S    TXNOTREADY     * Until ACIA Tx ready
01:002043FA 11400001        	   190:         MOVE.B   D0,1(A0)       * Write character to send
01:002043FE 4CDF0102        	   191:         MOVEM.L  (A7)+,A0/D1    * Restore working registers
01:00204402 4E75            	   192:         RTS
                            	   193: 
                            	   194: * Output character to the second (aux) serial port from register d0.b
                            	   195: 
                            	   196:  ifne   FLASH_SUPPORT
                            	   197: 
                            	   198: VEC_OUT2
                            	   199:         MOVEM.L  A0/D1,-(A7)    * Save working registers
                            	   200:         LEA.L    ACIA_2,A0      * A0 points to console ACIA
                            	   201: TXNOTREADY1
                            	   202:         MOVE.B   (A0),D1        * Read ACIA status
                            	   203:         BTST     #1,D1          * Test TDRE bit
                            	   204:         BEQ.s    TXNOTREADY1    * Until ACIA Tx ready
                            	   205:         MOVE.B   D0,1(A0)       * Write character to send
                            	   206:         MOVEM.L  (A7)+,A0/D1    * Restore working registers
                            	   207:         RTS
                            	   208: 
                            	   209: * Output null terminated string pointed to by A0 to first serial port.
                            	   210: 
                            	   211: PRINTSTRING1
                            	   212:         MOVEM.L  A0/D0,-(A7)    * Save working registers
                            	   213: LP1     CMP.B    #0,(A0)        * Is it null?
                            	   214:         BEQ      RET1           * If so, return
                            	   215:         MOVE.B   (A0)+,D0       * Get character and advance pointer
                            	   216:         JSR      VEC_OUT        * Output it
                            	   217:         BRA      LP1            * Continue for rest of string
                            	   218: 
                            	   219: RET1    MOVEM.L  (A7)+,A0/D0    * Restore working registers
                            	   220:         RTS                     * Return
                            	   221: 
                            	   222: * Output null terminated string pointed to by A0 to second serial port.
                            	   223: 
                            	   224: PRINTSTRING2
                            	   225:         MOVEM.L  A0/D0,-(A7)    * Save working registers
                            	   226: LP2     CMP.B    #0,(A0)        * Is it null?
                            	   227:         BEQ      RET2           * If so, return
                            	   228:         MOVE.B   (A0)+,D0       * Get character and advance pointer
                            	   229:         JSR      VEC_OUT2       * Output it
                            	   230:         BRA      LP2            * Continue for rest of string
                            	   231: 
                            	   232: RET2    MOVEM.L  (A7)+,A0/D0    * Restore working registers
                            	   233:         RTS                     * Return
                            	   234: 
                            	   235:  endc
                            	   236: 
                            	   237: *************************************************************************************
                            	   238: *
                            	   239: * input a character from the console into register d0
                            	   240: * else return Cb=0 if there's no character available
                            	   241: 
                            	   242: VEC_IN
01:00204404 48E74080        	   243:         MOVEM.L  A0/D1,-(A7)    * Save working registers
01:00204408 41F9003C0008    	   244:         LEA.L    ACIA_1,A0      * A0 points to console ACIA
01:0020440E 1210            	   245:         MOVE.B   (A0),D1        * Read ACIA status
01:00204410 08010000        	   246:         BTST     #0,D1          * Test RDRF bit
01:00204414 670E            	   247:         BEQ.S    RXNOTREADY     * Branch if ACIA Rx not ready
01:00204416 10280001        	   248:         MOVE.B   1(A0),D0       * Read character received
01:0020441A 4CDF0102        	   249:         MOVEM.L  (A7)+,A0/D1    * Restore working registers
01:0020441E 003C0001        	   250:         ORI.B    #1,CCR         * Set the carry, flag we got a byte
01:00204422 4E75            	   251:         RTS                     * Return
                            	   252: RXNOTREADY
01:00204424 4CDF0102        	   253:         MOVEM.L  (A7)+,A0/D1    * Restore working registers
01:00204428 023C00FE        	   254:         ANDI.B   #$FE,CCR       * Clear the carry, flag character not available
01:0020442C 4E75            	   255:         RTS
                            	   256: 
                            	   257: * Input routine used in LOAD mode to read file from USB flash storage.
                            	   258: 
                            	   259:  ifne   FLASH_SUPPORT
                            	   260: 
                            	   261: VEC_IN2
                            	   262:         MOVEM.L  A0/D1,-(A7)    * Save working registers
                            	   263:         LEA.L    VEC_OUT2,A0    * Redirect output to aux. port.
                            	   264:         MOVE.L   A0,V_OUTPv(a3)
                            	   265: 
                            	   266: * The first time, send READ <filename> 1 1
                            	   267: * Subsequent times, send READ <filename> n 1
                            	   268: 
                            	   269:         LEA      LAB_READN(pc),A0 * Send READ command string
                            	   270:         BSR      PRINTSTRING2   * Print null terminated string
                            	   271: 
                            	   272:         LEA      load_filename(A3),A0 * Send filename string
                            	   273:         BSR      PRINTSTRING2   * Print null terminated string
                            	   274: 
                            	   275:         MOVE.B   #' ',D0       * Send space
                            	   276:         JSR      VEC_OUT2
                            	   277: 
                            	   278:         CMP.B    #1,load_first(A3) * First time?
                            	   279:         BNE      NOTFIRST1
                            	   280:         MOVE.B   #'1',D0        * Send '1'
                            	   281:         CLR.B    load_first(A3) * Clear first flag
                            	   282:         BRA      SENDCMD1
                            	   283: NOTFIRST1
                            	   284:         MOVE.B   #'n',D0        * Send 'n'
                            	   285: SENDCMD1
                            	   286:         JSR      VEC_OUT2
                            	   287:         MOVE.B   #' ',D0        * Send space
                            	   288:         JSR      VEC_OUT2
                            	   289:         MOVE.B   #'1',D0        * Send '1'
                            	   290:         JSR      VEC_OUT2
                            	   291:         MOVE.B   #$0D,D0        * Send <Return>
                            	   292:         JSR      VEC_OUT2
                            	   293: 
                            	   294:         LEA.L    VEC_OUT,A0     * Redirect output back to console port.
                            	   295:         MOVE.L   A0,V_OUTPv(a3)
                            	   296: 
                            	   297: * Read one byte from USB host
                            	   298: 
                            	   299:         LEA.L    ACIA_2,A0      * A0 points to console ACIA
                            	   300: RXNOTREADY2
                            	   301:         MOVE.B   (A0),D1        * Read ACIA status
                            	   302:         BTST     #0,D1          * Test RDRF bit
                            	   303:         BEQ.S    RXNOTREADY2    * Branch if ACIA Rx not ready
                            	   304:         MOVE.B   1(A0),D0       * Read character received
                            	   305: 
                            	   306: * Check for end of file character ('~') and if found, redirect
                            	   307: * input back to console port.
                            	   308: 
                            	   309:         CMP.B    #'~',D0        * End of file marker?
                            	   310:         BNE      NOTEOF
                            	   311:         MOVE.B   #$0D,D0        * Convert '~' to a Return
                            	   312:         LEA.L    VEC_IN,A0      * Redirect input back to console port.
                            	   313:         MOVE.L   A0,V_INPTv(a3)
                            	   314: NOTEOF
                            	   315:         MOVEM.L  (A7)+,A0/D1    * Restore working registers
                            	   316:         ORI.b    #1,CCR         * Set the carry, flag we got a byte
                            	   317:         RTS                     * Return
                            	   318: 
                            	   319:  endc
                            	   320: 
                            	   321: *************************************************************************************
                            	   322: *
                            	   323: * LOAD routine for the TS2 computer (not implemented)
                            	   324: 
                            	   325:  ifeq   FLASH_SUPPORT
                            	   326: 
                            	   327: VEC_LD
01:0020442E 7E2E            	   328:        MOVEQ           #$2E,d7                         * error code $2E "Not implemented" error
01:00204430 60000144        	   329:        BRA             LAB_XERR                        * do error #d7, then warm start
                            	   330: 
                            	   331:  endc
                            	   332: 
                            	   333: * LOAD routine for the TS2 computer. Supports a Hobbytronics USB Flash
                            	   334: * Drive Host Board connected to the auxiliary serial port.
                            	   335: 
                            	   336:  ifne   FLASH_SUPPORT
                            	   337: 
                            	   338: VEC_LD  LEA             LAB_FILENAME(PC),A0             * Prompt for filename.
                            	   339:         BSR             PRINTSTRING1                    * Print null terminated string
                            	   340:         MOVE.L          A3,A2                           * Save pointer to RAM variables
                            	   341: GETFN1  JSR             VEC_IN                          * Get character
                            	   342:         BCC             GETFN1                          * Go back if carry clear, indicating no key pressed
                            	   343:         JSR             VEC_OUT                         * Echo the character
                            	   344:         CMP.B           #$0D,D0                         * Was it <Return>?
                            	   345:         BEQ             ENDLN1                          * If so, branch
                            	   346:         CMP.B           #$7F,D0                         * Was it <Delete>?
                            	   347:         BEQ             DELETE1                         * If so, handle delete
                            	   348:         CMP.B           #$08,D0                         * Was it <Backspace?
                            	   349:         BEQ             DELETE1                         * If so, handle as delete
                            	   350:         MOVE.B          D0,load_filename(A2)            * Save in buffer
                            	   351:         ADDQ.L          #1,A2                           * Advance string pointer
                            	   352:         BRA             GETFN1                          * Go back and get next character
                            	   353: DELETE1 SUBQ.L          #1,A2                           * Delete last character entered
                            	   354:         BRA             GETFN1                          * Go back and get next character
                            	   355: 
                            	   356: ENDLN1  MOVE.B          #0,load_filename(A2)            * Add terminating null to filename
                            	   357:         LEA.L           VEC_IN2,A0                      * Redirect input from aux. port.
                            	   358:         MOVE.L          A0,V_INPTv(a3)
                            	   359:         MOVE.B          #1,load_first(A3)               * Set load_first flag
                            	   360: 
                            	   361: * Input routine will detect end of file and redirect input back to
                            	   362: * console port.
                            	   363: 
                            	   364:         RTS
                            	   365: 
                            	   366:  endc
                            	   367: 
                            	   368: *************************************************************************************
                            	   369: *
                            	   370: * SAVE routine for the TS2 computer (not implemented)
                            	   371: 
                            	   372:  ifeq   FLASH_SUPPORT
                            	   373: VEC_SV
01:00204434 7E2E            	   374:        MOVEQ           #$2E,d7                         * error code $2E "Not implemented" error
01:00204436 6000013E        	   375:        BRA             LAB_XERR                        * do error #d7, then warm start
                            	   376:  endc
                            	   377: 
                            	   378:  ifne   FLASH_SUPPORT
                            	   379: 
                            	   380: * SAVE routine for the TS2 computer. Supports a Hobbytronics USB Flash
                            	   381: * Drive Host Board connected to the auxiliary serial port.
                            	   382: 
                            	   383: * TODO: Make configurable at build time
                            	   384: 
                            	   385: VEC_SV  LEA             LAB_FILENAME(PC),A0             * Prompt for filename.
                            	   386:         BSR             PRINTSTRING1                    * Print null terminated string
                            	   387:         MOVE.L          A3,A2                           * Save pointer to RAM variables
                            	   388: GETFN   JSR             VEC_IN                          * Get character
                            	   389:         BCC             GETFN                           * Go back if carry clear, indicating no key pressed
                            	   390:         JSR             VEC_OUT                         * Echo the character
                            	   391:         CMP.B           #$0D,D0                         * Was it <Return>?
                            	   392:         BEQ             ENDLN                           * If so, branch
                            	   393:         CMP.B           #$7F,D0                         * Was it <Delete>?
                            	   394:         BEQ             DELETE                          * If so, handle delete
                            	   395:         CMP.B           #$08,D0                         * Was it <Backspace?
                            	   396:         BEQ             DELETE                          * If so, handle as delete
                            	   397:         MOVE.B          D0,load_filename(A2)            * Save in buffer
                            	   398:         ADDQ.L          #1,A2                           * Advance string pointer
                            	   399:         BRA             GETFN                           * Go back and get next character
                            	   400: DELETE  SUBQ.L          #1,A2                           * Delete last character entered
                            	   401:         BRA             GETFN                           * Go back and get next character
                            	   402: 
                            	   403: ENDLN   MOVE.B          #0,load_filename(A2)            * Add terminating null to filename
                            	   404: 
                            	   405:         LEA.L           VEC_OUT2,A0                     * Redirect output to aux. port.
                            	   406:         MOVE.L          A0,V_OUTPv(a3)
                            	   407: 
                            	   408:         LEA             LAB_WRITE(pc),A0                * Send WRITE command string
                            	   409:         BSR             PRINTSTRING2                    * Print null terminated string
                            	   410: 
                            	   411:         LEA             load_filename(A3),A0            * Send filename string
                            	   412:         BSR             PRINTSTRING2                    * Print null terminated string
                            	   413: 
                            	   414:         MOVE.B          #$0D,D0                         * Send <Return>
                            	   415:         JSR             VEC_OUT2
                            	   416: 
                            	   417:         MOVE.l          #356000,d0                      * Delay approx. 1 second to allow USB to create file
                            	   418: DELAY   SUBQ.l          #1,d0
                            	   419:         BNE             DELAY
                            	   420: 
                            	   421:         MOVEQ           #0,d0                           * Tells LIST no arguments
                            	   422:         ANDI.b          #$FE,CCR                        * Clear carry
                            	   423:         BSR             LAB_LIST                        * Call LIST routine
                            	   424: 
                            	   425:         MOVEQ           #'~',d0                         * Send tilde symbol indicate end of file (used when loading)
                            	   426:         BSR             LAB_PRNA
                            	   427: 
                            	   428:         MOVEQ           #26,d0                          * Send Control-Z to indicate end of file save operation
                            	   429:         BSR             LAB_PRNA
                            	   430: 
                            	   431:         LEA.L           VEC_OUT,A0                      * Redirect output back to console port.
                            	   432:         MOVE.L          A0,V_OUTPv(a3)
                            	   433:         RTS                                             * Return
                            	   434: 
                            	   435: LAB_WRITE
                            	   436:         dc.b            '$WRITE ',$00
                            	   437: 
                            	   438: LAB_READN
                            	   439:         dc.b            '$READ ',$00
                            	   440: 
                            	   441: LAB_FILENAME
                            	   442:         dc.b            'Filename? ',$00
                            	   443: 
                            	   444:  endc
                            	   445:         even
                            	   446: 
                            	   447: *************************************************************************************
                            	   448: 
                            	   449: code_start
                            	   450:                                 * Set up ACIA parameters
01:0020443A 41F9003C0008    	   451:         LEA.L   ACIA_1,A0       * A0 points to console ACIA
01:00204440 10BC0015        	   452:         MOVE.B  #$15,(A0)       * Set up ACIA1 constants (no IRQ,
                            	   453:                                 * RTS* low, 8 bit, no parity, 1 stop)
01:00204444 41F9003C0008    	   454:         LEA.L   ACIA_2,A0       * A0 points to aux. ACIA
01:0020444A 10BC0015        	   455:         MOVE.B  #$15,(A0)       * Set up ACIA2 constants (no IRQ,
                            	   456:                                 * RTS* low, 8 bit, no parity, 1 stop)
                            	   457: 
                            	   458: * to tell EhBASIC where and how much RAM it has pass the address in a0 and the size
                            	   459: * in d0. these values are at the end of the .inc file
                            	   460: 
01:0020444E 207C00008800    	   461: 	MOVEA.l	#ram_addr,a0		* tell BASIC where RAM starts
01:00204454 203C00017800    	   462: 	MOVE.l	#ram_size,d0		* tell BASIC how big RAM is
                            	   463: 
                            	   464: * end of simulator specific code
                            	   465: 
                            	   466: 
                            	   467: ****************************************************************************************
                            	   468: ****************************************************************************************
                            	   469: ****************************************************************************************
                            	   470: ****************************************************************************************
                            	   471: *
                            	   472: * Register use :- (must improve this !!)
                            	   473: *
                            	   474: *	a6 -	temp Bpntr				* temporary BASIC execute pointer
                            	   475: *	a5 -	Bpntr					* BASIC execute (get byte) pointer
                            	   476: *	a4 -	des_sk				        * descriptor stack pointer
                            	   477: *	a3 -	ram_strt				* start of RAM. all RAM references are offsets
                            	   478: *							* from this value
                            	   479: *
                            	   480: 
                            	   481: *************************************************************************************
                            	   482: *
                            	   483: * BASIC cold start entry point. assume entry with RAM address in a0 and RAM length
                            	   484: * in d0
                            	   485: 
                            	   486: LAB_COLD
01:0020445A B0BC00004000    	   487: 	CMP.l		#$4000,d0			* compare size with 16k
01:00204460 6C08            	   488: 	BGE.s		LAB_sizok			* branch if >= 16k
                            	   489: 
01:00204462 7005            	   490: 	MOVEQ		#5,d0				* error 5 - not enough RAM
01:00204464 1E3C00E4        	   491:         move.b          #228,D7                         * Go to TUTOR function
01:00204468 4E4E            	   492:         trap            #14                             * Call TRAP14 handler
                            	   493: 
                            	   494: LAB_sizok
01:0020446A 2648            	   495: 	MOVEA.l	a0,a3				* copy RAM base to a3
01:0020446C D1C0            	   496: 	ADDA.l	d0,a0				* a0 is top of RAM
01:0020446E 2748044A        	   497: 	MOVE.l	a0,Ememl(a3)		* set end of mem
01:00204472 4FEB0400        	   498: 	LEA		ram_base(a3),sp		* set stack to RAM start + 1k
                            	   499: 
01:00204476 303C4EF9        	   500: 	MOVE.w	#$4EF9,d0			* JMP opcode
01:0020447A 204F            	   501: 	MOVEA.l	sp,a0				* point to start of vector table
                            	   502: 
01:0020447C 30C0            	   503: 	MOVE.w	d0,(a0)+			* LAB_WARM
01:0020447E 43FAFFDA        	   504: 	LEA		LAB_COLD(pc),a1		* initial warm start vector
01:00204482 20C9            	   505: 	MOVE.l	a1,(a0)+			* set vector
                            	   506: 
01:00204484 30C0            	   507: 	MOVE.w	d0,(a0)+			* Usrjmp
01:00204486 43FA00DC        	   508: 	LEA		LAB_FCER(pc),a1		* initial user function vector
                            	   509: 							* "Function call" error
01:0020448A 20C9            	   510: 	MOVE.l	a1,(a0)+			* set vector
                            	   511: 
01:0020448C 30C0            	   512: 	MOVE.w	d0,(a0)+			* V_INPT JMP opcode
01:0020448E 43FAFF74        	   513: 	LEA		VEC_IN(pc),a1		* get byte from input device vector
01:00204492 20C9            	   514: 	MOVE.l	a1,(a0)+			* set vector
                            	   515: 
01:00204494 30C0            	   516: 	MOVE.w	d0,(a0)+			* V_OUTP JMP opcode
01:00204496 43FAFF50        	   517: 	LEA		VEC_OUT(pc),a1		* send byte to output device vector
01:0020449A 20C9            	   518: 	MOVE.l	a1,(a0)+			* set vector
                            	   519: 
01:0020449C 30C0            	   520: 	MOVE.w	d0,(a0)+			* V_LOAD JMP opcode
01:0020449E 43FAFF8E        	   521: 	LEA		VEC_LD(pc),a1		* load BASIC program vector
01:002044A2 20C9            	   522: 	MOVE.l	a1,(a0)+			* set vector
                            	   523: 
01:002044A4 30C0            	   524: 	MOVE.w	d0,(a0)+			* V_SAVE JMP opcode
01:002044A6 43FAFF8C        	   525: 	LEA		VEC_SV(pc),a1		* save BASIC program vector
01:002044AA 20C9            	   526: 	MOVE.l	a1,(a0)+			* set vector
                            	   527: 
01:002044AC 30C0            	   528: 	MOVE.w	d0,(a0)+			* V_CTLC JMP opcode
01:002044AE 43FA2608        	   529: 	LEA		VEC_CC(pc),a1		* save CTRL-C check vector
01:002044B2 20C9            	   530: 	MOVE.l	a1,(a0)+			* set vector
                            	   531: 
                            	   532: * set-up start values
                            	   533: 
                            	   534: *##LAB_GMEM
01:002044B4 7000            	   535: 	MOVEQ		#$00,d0			* clear d0
01:002044B6 174005E4        	   536: 	MOVE.b	d0,Nullct(a3)		* default NULL count
01:002044BA 174005E5        	   537: 	MOVE.b	d0,TPos(a3)			* clear terminal position
01:002044BE 174005E8        	   538: 	MOVE.b	d0,ccflag(a3)		* allow CTRL-C check
01:002044C2 374005EA        	   539: 	MOVE.w	d0,prg_strt-2(a3)		* clear start word
01:002044C6 374005D6        	   540: 	MOVE.w	d0,BHsend(a3)		* clear value to string end word
                            	   541: 
01:002044CA 177C005005E6    	   542: 	MOVE.b	#$50,TWidth(a3)		* default terminal width byte for simulator
01:002044D0 177C000E05E2    	   543: 	MOVE.b	#$0E,TabSiz(a3)		* save default tab size = 14
                            	   544: 
01:002044D6 177C003805E7    	   545: 	MOVE.b	#$38,Iclim(a3)		* default limit for TAB = 14 for simulator
                            	   546: 
01:002044DC 49EB048E        	   547: 	LEA		des_sk(a3),a4		* set descriptor stack start
                            	   548: 
01:002044E0 41EB05EC        	   549: 	LEA		prg_strt(a3),a0		* get start of mem
01:002044E4 2748042E        	   550: 	MOVE.l	a0,Smeml(a3)		* save start of mem
                            	   551: 
01:002044E8 61000322        	   552: 	BSR		LAB_1463			* do "NEW" and "CLEAR"
01:002044EC 61000896        	   553: 	BSR		LAB_CRLF			* print CR/LF
01:002044F0 202B044A        	   554: 	MOVE.l	Ememl(a3),d0		* get end of mem
01:002044F4 90AB042E        	   555: 	SUB.l		Smeml(a3),d0		* subtract start of mem
                            	   556: 
01:002044F8 61001BBE        	   557: 	BSR		LAB_295E			* print d0 as unsigned integer (bytes free)
01:002044FC 41FA33D6        	   558: 	LEA		LAB_SMSG(pc),a0		* point to start message
01:00204500 610008E0        	   559: 	BSR		LAB_18C3			* print null terminated string from memory
                            	   560: 
01:00204504 41FA29BA        	   561: 	LEA		LAB_RSED(pc),a0		* get pointer to value
01:00204508 61001A5A        	   562: 	BSR		LAB_UFAC			* unpack memory (a0) into FAC1
                            	   563: 
01:0020450C 41FA0092        	   564: 	LEA		LAB_1274(pc),a0		* get warm start vector
01:00204510 27480402        	   565: 	MOVE.l	a0,Wrmjpv(a3)		* set warm start vector
01:00204514 61001FC4        	   566: 	BSR		LAB_RND			* initialise
01:00204518 4EEB0400        	   567: 	JMP		LAB_WARM(a3)		* go do warm start
                            	   568: 
                            	   569: 
                            	   570: *************************************************************************************
                            	   571: *
                            	   572: * do format error
                            	   573: 
                            	   574: LAB_FOER
01:0020451C 7E2C            	   575: 	MOVEQ		#$2C,d7			* error code $2C "Format" error
01:0020451E 6056            	   576: 	BRA.s		LAB_XERR			* do error #d7, then warm start
                            	   577: 
                            	   578: 
                            	   579: *************************************************************************************
                            	   580: *
                            	   581: * do address error
                            	   582: 
                            	   583: LAB_ADER
01:00204520 7E2A            	   584: 	MOVEQ		#$2A,d7			* error code $2A "Address" error
01:00204522 6052            	   585: 	BRA.s		LAB_XERR			* do error #d7, then warm start
                            	   586: 
                            	   587: 
                            	   588: *************************************************************************************
                            	   589: *
                            	   590: * do wrong dimensions error
                            	   591: 
                            	   592: LAB_WDER
01:00204524 7E28            	   593: 	MOVEQ		#$28,d7			* error code $28 "Wrong dimensions" error
01:00204526 604E            	   594: 	BRA.s		LAB_XERR			* do error #d7, then warm start
                            	   595: 
                            	   596: 
                            	   597: *************************************************************************************
                            	   598: *
                            	   599: * do undimensioned array error
                            	   600: 
                            	   601: LAB_UDER
01:00204528 7E26            	   602: 	MOVEQ		#$26,d7			* error code $26 "undimensioned array" error
01:0020452A 604A            	   603: 	BRA.s		LAB_XERR			* do error #d7, then warm start
                            	   604: 
                            	   605: 
                            	   606: *************************************************************************************
                            	   607: *
                            	   608: * do undefined variable error
                            	   609: 
                            	   610: LAB_UVER
                            	   611: 
                            	   612: * if you do want a non existant variable to return an error then leave the novar
                            	   613: * value at the top of this file set to zero
                            	   614: 
                            	   615:  ifeq	novar
                            	   616: 
01:0020452C 7E24            	   617: 	MOVEQ		#$24,d7			* error code $24 "undefined variable" error
01:0020452E 6046            	   618: 	BRA.s		LAB_XERR			* do error #d7, then warm start
                            	   619: 
                            	   620:  endc
                            	   621: 
                            	   622: * if you want a non existant variable to return a null value then set the novar
                            	   623: * value at the top of this file to some non zero value
                            	   624: 
                            	   625:  ifne	novar
                            	   626: 
                            	   627: 	ADD.l		d0,d0				* .......$ .......& ........ .......0
                            	   628: 	SWAP		d0				* ........ .......0 .......$ .......&
                            	   629: 	ROR.b		#1,d0				* ........ .......0 .......$ &.......
                            	   630: 	LSR.w		#1,d0				* ........ .......0 0....... $&.....�.
                            	   631: 	AND.b		#$C0,d0			* mask the type bits
                            	   632: 	MOVE.b	d0,Dtypef(a3)		* save the data type
                            	   633: 
                            	   634: 	MOVEQ		#0,d0				* clear d0 and set the zero flag
                            	   635: 	MOVEA.l	d0,a0				* return a null address
                            	   636: 	RTS
                            	   637: 
                            	   638:  endc
                            	   639: 
                            	   640: 
                            	   641: *************************************************************************************
                            	   642: *
                            	   643: * do loop without do error
                            	   644: 
                            	   645: LAB_LDER
01:00204530 7E22            	   646: 	MOVEQ		#$22,d7			* error code $22 "LOOP without DO" error
01:00204532 6042            	   647: 	BRA.s		LAB_XERR			* do error #d7, then warm start
                            	   648: 
                            	   649: 
                            	   650: *************************************************************************************
                            	   651: *
                            	   652: * do undefined function error
                            	   653: 
                            	   654: LAB_UFER
01:00204534 7E20            	   655: 	MOVEQ		#$20,d7			* error code $20 "Undefined function" error
01:00204536 603E            	   656: 	BRA.s		LAB_XERR			* do error #d7, then warm start
                            	   657: 
                            	   658: 
                            	   659: *************************************************************************************
                            	   660: *
                            	   661: * do can't continue error
                            	   662: 
                            	   663: LAB_CCER
01:00204538 7E1E            	   664: 	MOVEQ		#$1E,d7			* error code $1E "Can't continue" error
01:0020453A 603A            	   665: 	BRA.s		LAB_XERR			* do error #d7, then warm start
                            	   666: 
                            	   667: 
                            	   668: *************************************************************************************
                            	   669: *
                            	   670: * do string too complex error
                            	   671: 
                            	   672: LAB_SCER
01:0020453C 7E1C            	   673: 	MOVEQ		#$1C,d7			* error code $1C "String too complex" error
01:0020453E 6036            	   674: 	BRA.s		LAB_XERR			* do error #d7, then warm start
                            	   675: 
                            	   676: 
                            	   677: *************************************************************************************
                            	   678: *
                            	   679: * do string too long error
                            	   680: 
                            	   681: LAB_SLER
01:00204540 7E1A            	   682: 	MOVEQ		#$1A,d7			* error code $1A "String too long" error
01:00204542 6032            	   683: 	BRA.s		LAB_XERR			* do error #d7, then warm start
                            	   684: 
                            	   685: 
                            	   686: *************************************************************************************
                            	   687: *
                            	   688: * do type missmatch error
                            	   689: 
                            	   690: LAB_TMER
01:00204544 7E18            	   691: 	MOVEQ		#$18,d7			* error code $18 "Type mismatch" error
01:00204546 602E            	   692: 	BRA.s		LAB_XERR			* do error #d7, then warm start
                            	   693: 
                            	   694: 
                            	   695: *************************************************************************************
                            	   696: *
                            	   697: * do illegal direct error
                            	   698: 
                            	   699: LAB_IDER
01:00204548 7E16            	   700: 	MOVEQ		#$16,d7			* error code $16 "Illegal direct" error
01:0020454A 602A            	   701: 	BRA.s		LAB_XERR			* do error #d7, then warm start
                            	   702: 
                            	   703: 
                            	   704: *************************************************************************************
                            	   705: *
                            	   706: * do divide by zero error
                            	   707: 
                            	   708: LAB_DZER
01:0020454C 7E14            	   709: 	MOVEQ		#$14,d7			* error code $14 "Divide by zero" error
01:0020454E 6026            	   710: 	BRA.s		LAB_XERR			* do error #d7, then warm start
                            	   711: 
                            	   712: 
                            	   713: *************************************************************************************
                            	   714: *
                            	   715: * do double dimension error
                            	   716: 
                            	   717: LAB_DDER
01:00204550 7E12            	   718: 	MOVEQ		#$12,d7			* error code $12 "Double dimension" error
01:00204552 6022            	   719: 	BRA.s		LAB_XERR			* do error #d7, then warm start
                            	   720: 
                            	   721: 
                            	   722: *************************************************************************************
                            	   723: *
                            	   724: * do array bounds error
                            	   725: 
                            	   726: LAB_ABER
01:00204554 7E10            	   727: 	MOVEQ		#$10,d7			* error code $10 "Array bounds" error
01:00204556 601E            	   728: 	BRA.s		LAB_XERR			* do error #d7, then warm start
                            	   729: 
                            	   730: 
                            	   731: *************************************************************************************
                            	   732: *
                            	   733: * do undefined satement error
                            	   734: 
                            	   735: LAB_USER
01:00204558 7E0E            	   736: 	MOVEQ		#$0E,d7			* error code $0E "Undefined statement" error
01:0020455A 601A            	   737: 	BRA.s		LAB_XERR			* do error #d7, then warm start
                            	   738: 
                            	   739: 
                            	   740: *************************************************************************************
                            	   741: *
                            	   742: * do out of memory error
                            	   743: 
                            	   744: LAB_OMER
01:0020455C 7E0C            	   745: 	MOVEQ		#$0C,d7			* error code $0C "Out of memory" error
01:0020455E 6016            	   746: 	BRA.s		LAB_XERR			* do error #d7, then warm start
                            	   747: 
                            	   748: 
                            	   749: *************************************************************************************
                            	   750: *
                            	   751: * do overflow error
                            	   752: 
                            	   753: LAB_OFER
01:00204560 7E0A            	   754: 	MOVEQ		#$0A,d7			* error code $0A "Overflow" error
01:00204562 6012            	   755: 	BRA.s		LAB_XERR			* do error #d7, then warm start
                            	   756: 
                            	   757: 
                            	   758: *************************************************************************************
                            	   759: *
                            	   760: * do function call error
                            	   761: 
                            	   762: LAB_FCER
01:00204564 7E08            	   763: 	MOVEQ		#$08,d7			* error code $08 "Function call" error
01:00204566 600E            	   764: 	BRA.s		LAB_XERR			* do error #d7, then warm start
                            	   765: 
                            	   766: 
                            	   767: *************************************************************************************
                            	   768: *
                            	   769: * do out of data error
                            	   770: 
                            	   771: LAB_ODER
01:00204568 7E06            	   772: 	MOVEQ		#$06,d7			* error code $06 "Out of DATA" error
01:0020456A 600A            	   773: 	BRA.s		LAB_XERR			* do error #d7, then warm start
                            	   774: 
                            	   775: 
                            	   776: *************************************************************************************
                            	   777: *
                            	   778: * do return without gosub error
                            	   779: 
                            	   780: LAB_RGER
01:0020456C 7E04            	   781: 	MOVEQ		#$04,d7			* error code $04 "RETURN without GOSUB" error
01:0020456E 6006            	   782: 	BRA.s		LAB_XERR			* do error #d7, then warm start
                            	   783: 
                            	   784: 
                            	   785: *************************************************************************************
                            	   786: *
                            	   787: * do syntax error
                            	   788: 
                            	   789: LAB_SNER
01:00204570 7E02            	   790: 	MOVEQ		#$02,d7			* error code $02 "Syntax" error
01:00204572 6002            	   791: 	BRA.s		LAB_XERR			* do error #d7, then warm start
                            	   792: 
                            	   793: 
                            	   794: *************************************************************************************
                            	   795: *
                            	   796: * do next without for error
                            	   797: 
                            	   798: LAB_NFER
01:00204574 7E00            	   799: 	MOVEQ		#$00,d7			* error code $00 "NEXT without FOR" error
                            	   800: 
                            	   801: 
                            	   802: *************************************************************************************
                            	   803: *
                            	   804: * do error #d7, then warm start
                            	   805: 
                            	   806: LAB_XERR
01:00204576 610002CA        	   807: 	BSR		LAB_1491			* flush stack & clear continue flag
01:0020457A 61000808        	   808: 	BSR		LAB_CRLF			* print CR/LF
01:0020457E 43FA2FCC        	   809: 	LEA		LAB_BAER(pc),a1		* start of error message pointer table
01:00204582 3E317000        	   810: 	MOVE.w	(a1,d7.w),d7		* get error message offset
01:00204586 41F17000        	   811: 	LEA		(a1,d7.w),a0		* get error message address
01:0020458A 61000856        	   812: 	BSR		LAB_18C3			* print null terminated string from memory
01:0020458E 41FA3307        	   813: 	LEA		LAB_EMSG(pc),a0		* point to " Error" message
                            	   814: LAB_1269
01:00204592 6100084E        	   815: 	BSR		LAB_18C3			* print null terminated string from memory
01:00204596 202B0452        	   816: 	MOVE.l	Clinel(a3),d0		* get current line
01:0020459A 6B04            	   817: 	BMI.s		LAB_1274			* go do warm start if -ve # (was immediate mode)
                            	   818: 
                            	   819: 							* else print line number
01:0020459C 61001B0E        	   820: 	BSR		LAB_2953			* print " in line [LINE #]"
                            	   821: 
                            	   822: * BASIC warm start entry point, wait for Basic command
                            	   823: 
                            	   824: LAB_1274
01:002045A0 41FA3328        	   825: 	LEA		LAB_RMSG(pc),a0		* point to "Ready" message
01:002045A4 6100083C        	   826: 	BSR		LAB_18C3			* go do print string
                            	   827: 
                            	   828: * wait for Basic command - no "Ready"
                            	   829: 
                            	   830: LAB_127D
01:002045A8 72FF            	   831: 	MOVEQ		#-1,d1			* set to -1
01:002045AA 27410452        	   832: 	MOVE.l	d1,Clinel(a3)		* set current line #
01:002045AE 174105DC        	   833: 	MOVE.b	d1,Breakf(a3)		* set break flag
01:002045B2 4BEB0490        	   834: 	LEA		Ibuffs(a3),a5		* set basic execute pointer ready for new line
                            	   835: LAB_127E
01:002045B6 610000EC        	   836: 	BSR		LAB_1357			* call for BASIC input
01:002045BA 61000BF2        	   837: 	BSR		LAB_GBYT			* scan memory
01:002045BE 67F6            	   838: 	BEQ.s		LAB_127E			* loop while null
                            	   839: 
                            	   840: * got to interpret input line now ....
                            	   841: 
01:002045C0 6508            	   842: 	BCS.s		LAB_1295			* branch if numeric character, handle new
                            	   843: 							* BASIC line
                            	   844: 
                            	   845: 							* no line number so do immediate mode, a5
                            	   846: 							* points to the buffer start
01:002045C2 61000156        	   847: 	BSR		LAB_13A6			* crunch keywords into Basic tokens
                            	   848: 							* crunch from (a5), output to (a0)
                            	   849: 							* returns ..
                            	   850: 							* d2 is length, d1 trashed, d0 trashed,
                            	   851: 							* a1 trashed
01:002045C6 600003C2        	   852: 	BRA		LAB_15F6			* go scan & interpret code
                            	   853: 
                            	   854: 
                            	   855: *************************************************************************************
                            	   856: *
                            	   857: * handle a new BASIC line
                            	   858: 
                            	   859: LAB_1295
01:002045CA 61000638        	   860: 	BSR		LAB_GFPN			* get fixed-point number into temp integer & d1
01:002045CE 6100014A        	   861: 	BSR		LAB_13A6			* crunch keywords into Basic tokens
                            	   862: 							* crunch from (a5), output to (a0)
                            	   863: 							* returns .. d2 is length,
                            	   864: 							* d1 trashed, d0 trashed, a1 trashed
01:002045D2 222B042A        	   865: 	MOVE.l	Itemp(a3),d1		* get required line #
01:002045D6 61000218        	   866: 	BSR		LAB_SSLN			* search BASIC for d1 line number
                            	   867: 							* returns pointer in a0
01:002045DA 6532            	   868: 	BCS.s		LAB_12E6			* branch if not found
                            	   869: 
                            	   870: 							* aroooogah! line # already exists! delete it
01:002045DC 2250            	   871: 	MOVEA.l	(a0),a1			* get start of block (next line pointer)
01:002045DE 202B0432        	   872: 	MOVE.l	Sfncl(a3),d0		* get end of block (start of functions)
01:002045E2 9089            	   873: 	SUB.l		a1,d0				* subtract start of block ( = bytes to move)
01:002045E4 E288            	   874: 	LSR.l		#1,d0				* /2 (word move)
01:002045E6 5380            	   875: 	SUBQ.l	#1,d0				* adjust for DBF loop
01:002045E8 4840            	   876: 	SWAP		d0				* swap high word to low word
01:002045EA 2448            	   877: 	MOVEA.l	a0,a2				* copy destination
                            	   878: LAB_12AE
01:002045EC 4840            	   879: 	SWAP		d0				* swap high word to low word
                            	   880: LAB_12B0
01:002045EE 34D9            	   881: 	MOVE.w	(a1)+,(a2)+			* copy word
01:002045F0 51C8FFFC        	   882: 	DBF		d0,LAB_12B0			* decrement low count and loop until done
                            	   883: 
01:002045F4 4840            	   884: 	SWAP		d0				* swap high word to low word
01:002045F6 51C8FFF4        	   885: 	DBF		d0,LAB_12AE			* decrement high count and loop until done
                            	   886: 
01:002045FA 274A0432        	   887: 	MOVE.l	a2,Sfncl(a3)		* start of functions
01:002045FE 274A0436        	   888: 	MOVE.l	a2,Svarl(a3)		* save start of variables
01:00204602 274A043A        	   889: 	MOVE.l	a2,Sstrl(a3)		* start of strings
01:00204606 274A043E        	   890: 	MOVE.l	a2,Sarryl(a3)		* save start of arrays
01:0020460A 274A0442        	   891: 	MOVE.l	a2,Earryl(a3)		* save end of arrays
                            	   892: 
                            	   893: 							* got new line in buffer and no existing same #
                            	   894: LAB_12E6
01:0020460E 102B0490        	   895: 	MOVE.b	Ibuffs(a3),d0		* get byte from start of input buffer
01:00204612 6764            	   896: 	BEQ.s		LAB_1325			* if null line go do line chaining
                            	   897: 
                            	   898: 							* got new line and it isn't empty line
01:00204614 226B0432        	   899: 	MOVEA.l	Sfncl(a3),a1		* get start of functions (end of block to move)
01:00204618 45F12008        	   900: 	LEA		8(a1,d2),a2			* copy it, add line length and add room for
                            	   901: 							* pointer and line number
                            	   902: 
01:0020461C 274A0432        	   903: 	MOVE.l	a2,Sfncl(a3)		* start of functions
01:00204620 274A0436        	   904: 	MOVE.l	a2,Svarl(a3)		* save start of variables
01:00204624 274A043A        	   905: 	MOVE.l	a2,Sstrl(a3)		* start of strings
01:00204628 274A043E        	   906: 	MOVE.l	a2,Sarryl(a3)		* save start of arrays
01:0020462C 274A0442        	   907: 	MOVE.l	a2,Earryl(a3)		* save end of arrays
01:00204630 276B044A0446    	   908: 	MOVE.l	Ememl(a3),Sstorl(a3)	* copy end of mem to start of strings, clear
                            	   909: 							* strings
                            	   910: 
01:00204636 2209            	   911: 	MOVE.l	a1,d1				* copy end of block to move
01:00204638 9288            	   912: 	SUB.l		a0,d1				* subtract start of block to move
01:0020463A E289            	   913: 	LSR.l		#1,d1				* /2 (word copy)
01:0020463C 5381            	   914: 	SUBQ.l	#1,d1				* correct for loop end on -1
01:0020463E 4841            	   915: 	SWAP		d1				* swap high word to low word
                            	   916: LAB_12FF
01:00204640 4841            	   917: 	SWAP		d1				* swap high word to low word
                            	   918: LAB_1301
01:00204642 3521            	   919: 	MOVE.w	-(a1),-(a2)			* decrement pointers and copy word
01:00204644 51C9FFFC        	   920: 	DBF		d1,LAB_1301			* decrement & loop
                            	   921: 
01:00204648 4841            	   922: 	SWAP		d1				* swap high word to low word
01:0020464A 51C9FFF4        	   923: 	DBF		d1,LAB_12FF			* decrement high count and loop until done
                            	   924: 
                            	   925: * space is opened up, now copy the crunched line from the input buffer into the space
                            	   926: 
01:0020464E 43EB0490        	   927: 	LEA		Ibuffs(a3),a1		* source is input buffer
01:00204652 2448            	   928: 	MOVEA.l	a0,a2				* copy destination
01:00204654 72FF            	   929: 	MOVEQ		#-1,d1			* set to allow re-chaining
01:00204656 24C1            	   930: 	MOVE.l	d1,(a2)+			* set next line pointer (allow re-chaining)
01:00204658 24EB042A        	   931: 	MOVE.l	Itemp(a3),(a2)+		* save line number
01:0020465C E24A            	   932: 	LSR.w		#1,d2				* /2 (word copy)
01:0020465E 5342            	   933: 	SUBQ.w	#1,d2				* correct for loop end on -1
                            	   934: LAB_1303
01:00204660 34D9            	   935: 	MOVE.w	(a1)+,(a2)+			* copy word
01:00204662 51CAFFFC        	   936: 	DBF		d2,LAB_1303			* decrement & loop
                            	   937: 
01:00204666 6010            	   938: 	BRA.s		LAB_1325			* go test for end of prog
                            	   939: 
                            	   940: * rebuild chaining of BASIC lines
                            	   941: 
                            	   942: LAB_132E
01:00204668 5048            	   943: 	ADDQ.w	#8,a0				* point to first code byte of line, there is
                            	   944: 							* always 1 byte + [EOL] as null entries are
                            	   945: 							* deleted
                            	   946: LAB_1330
01:0020466A 4A18            	   947: 	TST.b		(a0)+				* test byte	
01:0020466C 66FC            	   948: 	BNE.s		LAB_1330			* loop if not [EOL]
                            	   949: 
                            	   950: 							* was [EOL] so get next line start
01:0020466E 3208            	   951: 	MOVE.w	a0,d1				* past pad byte(s)
01:00204670 02410001        	   952: 	ANDI.w	#1,d1				* mask odd bit
01:00204674 D0C1            	   953: 	ADD.w		d1,a0				* add back to ensure even
01:00204676 2288            	   954: 	MOVE.l	a0,(a1)			* save next line pointer to current line
                            	   955: LAB_1325
01:00204678 2248            	   956: 	MOVEA.l	a0,a1				* copy pointer for this line
01:0020467A 4A90            	   957: 	TST.l		(a0)				* test pointer to next line
01:0020467C 66EA            	   958: 	BNE.s		LAB_132E			* not end of program yet so we must
                            	   959: 							* go and fix the pointers
                            	   960: 
01:0020467E 61000198        	   961: 	BSR		LAB_1477			* reset execution to start, clear variables
                            	   962: 							* and flush stack
01:00204682 6000FF24        	   963: 	BRA		LAB_127D			* now we just wait for Basic command, no "Ready"
                            	   964: 
                            	   965: 
                            	   966: *************************************************************************************
                            	   967: *
                            	   968: * receive a line from the keyboard
                            	   969: 							* character $08 as delete key, BACKSPACE on
                            	   970: 							* standard keyboard
                            	   971: LAB_134B
01:00204686 61000774        	   972: 	BSR		LAB_PRNA			* go print the character
01:0020468A 7020            	   973: 	MOVEQ		#' ',d0			* load [SPACE]
01:0020468C 6100076E        	   974: 	BSR		LAB_PRNA			* go print
01:00204690 7008            	   975: 	MOVEQ		#$08,d0			* load [BACKSPACE]
01:00204692 61000768        	   976: 	BSR		LAB_PRNA			* go print
01:00204696 5341            	   977: 	SUBQ.w	#$01,d1			* decrement the buffer index (delete)
01:00204698 6010            	   978: 	BRA.s		LAB_1359			* re-enter loop
                            	   979: 
                            	   980: * print "? " and get BASIC input
                            	   981: * return a0 pointing to the buffer start
                            	   982: 
                            	   983: LAB_INLN
01:0020469A 6100075E        	   984: 	BSR		LAB_18E3			* print "?" character
01:0020469E 7020            	   985: 	MOVEQ		#' ',d0			* load " "
01:002046A0 6100075A        	   986: 	BSR		LAB_PRNA			* go print
                            	   987: 
                            	   988: * call for BASIC input (main entry point)
                            	   989: * return a0 pointing to the buffer start
                            	   990: 
                            	   991: LAB_1357
01:002046A4 7200            	   992: 	MOVEQ		#$00,d1			* clear buffer index
01:002046A6 41EB0490        	   993: 	LEA		Ibuffs(a3),a0		* set buffer base pointer
                            	   994: LAB_1359
01:002046AA 4EAB040C        	   995: 	JSR		V_INPT(a3)			* call scan input device
01:002046AE 64FA            	   996: 	BCC.s		LAB_1359			* loop if no byte
                            	   997: 
01:002046B0 67F8            	   998: 	BEQ.s		LAB_1359			* loop if null byte
                            	   999: 
01:002046B2 B03C0007        	  1000: 	CMP.b		#$07,d0			* compare with [BELL]
01:002046B6 6718            	  1001: 	BEQ.s		LAB_1378			* branch if [BELL]
                            	  1002: 
01:002046B8 B03C000D        	  1003: 	CMP.b		#$0D,d0			* compare with [CR]
01:002046BC 670006C0        	  1004: 	BEQ		LAB_1866			* do CR/LF exit if [CR]
                            	  1005: 
01:002046C0 4A41            	  1006: 	TST.w		d1				* set flags on buffer index
01:002046C2 6606            	  1007: 	BNE.s		LAB_1374			* branch if not empty
                            	  1008: 
                            	  1009: * the next two lines ignore any non printing character and [SPACE] if the input buffer
                            	  1010: * is empty
                            	  1011: 
01:002046C4 B03C0020        	  1012: 	CMP.b		#' ',d0			* compare with [SP]+1
01:002046C8 63E0            	  1013: 	BLS.s		LAB_1359			* if < ignore character
                            	  1014: 
                            	  1015: *##	CMP.b		#' '+1,d0			* compare with [SP]+1
                            	  1016: *##	BCS.s		LAB_1359			* if < ignore character
                            	  1017: 
                            	  1018: LAB_1374
01:002046CA B03C0008        	  1019: 	CMP.b		#$08,d0			* compare with [BACKSPACE]
01:002046CE 67B6            	  1020: 	BEQ.s		LAB_134B			* go delete last character
                            	  1021: 
                            	  1022: LAB_1378
01:002046D0 B27C00FF        	  1023: 	CMP.w		#(Ibuffe-Ibuffs-1),d1	* compare character count with max-1
01:002046D4 640C            	  1024: 	BCC.s		LAB_138E			* skip store & do [BELL] if buffer full
                            	  1025: 
01:002046D6 11801000        	  1026: 	MOVE.b	d0,(a0,d1.w)		* else store in buffer
01:002046DA 5241            	  1027: 	ADDQ.w	#$01,d1			* increment index
                            	  1028: LAB_137F
01:002046DC 6100071E        	  1029: 	BSR		LAB_PRNA			* go print the character
01:002046E0 60C8            	  1030: 	BRA.s		LAB_1359			* always loop for next character
                            	  1031: 
                            	  1032: * announce buffer full
                            	  1033: 
                            	  1034: LAB_138E
01:002046E2 7007            	  1035: 	MOVEQ		#$07,d0			* [BELL] character into d0
01:002046E4 60F6            	  1036: 	BRA.s		LAB_137F			* go print the [BELL] but ignore input character
                            	  1037: 
                            	  1038: 
                            	  1039: *************************************************************************************
                            	  1040: *
                            	  1041: * copy a hex value without crunching
                            	  1042: 
                            	  1043: LAB_1392
01:002046E6 11802000        	  1044: 	MOVE.b	d0,(a0,d2.w)		* save the byte to the output
01:002046EA 5242            	  1045: 	ADDQ.w	#1,d2				* increment the buffer save index
                            	  1046: 
01:002046EC 5241            	  1047: 	ADDQ.w	#1,d1				* increment the buffer read index
01:002046EE 10351000        	  1048: 	MOVE.b	(a5,d1.w),d0		* get a byte from the input buffer
01:002046F2 67000094        	  1049: 	BEQ		LAB_13EC			* if [EOL] go save it without crunching
                            	  1050: 
01:002046F6 B03C0020        	  1051: 	CMP.b		#' ',d0			* compare the character with " "
01:002046FA 67EA            	  1052: 	BEQ.s		LAB_1392			* if [SPACE] just go save it and get another
                            	  1053: 
01:002046FC B03C0030        	  1054: 	CMP.b		#'0',d0			* compare the character with "0"
01:00204700 654A            	  1055: 	BCS.s		LAB_13C6			* if < "0" quit the hex save loop
                            	  1056: 
01:00204702 B03C0039        	  1057: 	CMP.b		#'9',d0			* compare with "9"
01:00204706 63DE            	  1058: 	BLS.s		LAB_1392			* if it is "0" to "9" save it and get another
                            	  1059: 
01:00204708 7ADF            	  1060: 	MOVEQ		#-33,d5			* mask xx0x xxxx, ASCII upper case
01:0020470A CA00            	  1061: 	AND.b		d0,d5				* mask the character
                            	  1062: 
01:0020470C BA3C0041        	  1063: 	CMP.b		#'A',d5			* compare with "A"
01:00204710 6540            	  1064: 	BCS.s		LAB_13CC			* if < "A" quit the hex save loop
                            	  1065: 
01:00204712 BA3C0046        	  1066: 	CMP.b		#'F',d5			* compare with "F"
01:00204716 63CE            	  1067: 	BLS.s		LAB_1392			* if it is "A" to "F" save it and get another
                            	  1068: 
01:00204718 6038            	  1069: 	BRA.s		LAB_13CC			* else continue crunching
                            	  1070: 
                            	  1071: * crunch keywords into Basic tokens
                            	  1072: * crunch from (a5), output to (a0)
                            	  1073: * returns ..
                            	  1074: * d4 trashed
                            	  1075: * d3 trashed
                            	  1076: * d2 is length
                            	  1077: * d1 trashed
                            	  1078: * d0 trashed
                            	  1079: * a1 trashed
                            	  1080: 
                            	  1081: * this is the improved BASIC crunch routine and is 10 to 100 times faster than the
                            	  1082: * old list search
                            	  1083: 
                            	  1084: LAB_13A6
01:0020471A 7200            	  1085: 	MOVEQ		#0,d1				* clear the read index
01:0020471C 2401            	  1086: 	MOVE.l	d1,d2				* clear the save index
01:0020471E 174105DD        	  1087: 	MOVE.b	d1,Oquote(a3)		* clear the open quote/DATA flag
                            	  1088: LAB_13AC
01:00204722 7000            	  1089: 	MOVEQ		#0,d0				* clear word
01:00204724 10351000        	  1090: 	MOVE.b	(a5,d1.w),d0		* get byte from input buffer
01:00204728 675E            	  1091: 	BEQ.s		LAB_13EC			* if null save byte then continue crunching
                            	  1092: 
01:0020472A B03C005F        	  1093: 	CMP.b		#'_',d0			* compare with "_"
01:0020472E 6458            	  1094: 	BCC.s		LAB_13EC			* if >= "_" save byte then continue crunching
                            	  1095: 
01:00204730 B03C003C        	  1096: 	CMP.b		#'<',d0			* compare with "<"
01:00204734 641C            	  1097: 	BCC.s		LAB_13CC			* if >= "<" go crunch
                            	  1098: 
01:00204736 B03C0030        	  1099: 	CMP.b		#'0',d0			* compare with "0"
01:0020473A 644C            	  1100: 	BCC.s		LAB_13EC			* if >= "0" save byte then continue crunching
                            	  1101: 
01:0020473C 174005DA        	  1102: 	MOVE.b	d0,Asrch(a3)		* save buffer byte as search character
01:00204740 B03C0022        	  1103: 	CMP.b		#$22,d0			* is it quote character?
01:00204744 6776            	  1104: 	BEQ.s		LAB_1410			* branch if so (copy quoted string)
                            	  1105: 
01:00204746 B03C0024        	  1106: 	CMP.b		#'$',d0			* is it the hex value character?
01:0020474A 679A            	  1107: 	BEQ.s		LAB_1392			* if so go copy a hex value
                            	  1108: 
                            	  1109: LAB_13C6
01:0020474C B03C002A        	  1110: 	CMP.b		#'*',d0			* compare with "*"
01:00204750 6536            	  1111: 	BCS.s		LAB_13EC			* if <= "*" save byte then continue crunching
                            	  1112: 
                            	  1113: 							* crunch rest
                            	  1114: LAB_13CC
01:00204752 082B000605DD    	  1115: 	BTST.b	#6,Oquote(a3)		* test open quote/DATA token flag
01:00204758 662E            	  1116: 	BNE.s		LAB_13EC			* branch if b6 of Oquote set (was DATA)
                            	  1117: 							* go save byte then continue crunching
                            	  1118: 
01:0020475A 903C002A        	  1119: 	SUB.b		#$2A,d0			* normalise byte
01:0020475E D040            	  1120: 	ADD.w		d0,d0				* *2 makes word offset (high byte=$00)
01:00204760 43FA2BEC        	  1121: 	LEA		TAB_CHRT(pc),a1		* get keyword offset table address
01:00204764 30310000        	  1122: 	MOVE.w	(a1,d0.w),d0		* get offset into keyword table
01:00204768 6B6E            	  1123: 	BMI.s		LAB_141F			* branch if no keywords for character
                            	  1124: 
01:0020476A 43FA2F78        	  1125: 	LEA		TAB_STAR(pc),a1		* get keyword table address
01:0020476E D2C0            	  1126: 	ADDA.w	d0,a1				* add keyword offset
01:00204770 76FF            	  1127: 	MOVEQ		#-1,d3			* clear index
01:00204772 3801            	  1128: 	MOVE.w	d1,d4				* copy read index
                            	  1129: LAB_13D6
01:00204774 5243            	  1130: 	ADDQ.w	#1,d3				* increment table index
01:00204776 10313000        	  1131: 	MOVE.b	(a1,d3.w),d0		* get byte from table
                            	  1132: LAB_13D8
01:0020477A 6B0A            	  1133: 	BMI.s		LAB_13EA			* branch if token, save token and continue
                            	  1134: 							* crunching
                            	  1135: 
01:0020477C 5244            	  1136: 	ADDQ.w	#1,d4				* increment read index
01:0020477E B0354000        	  1137: 	CMP.b		(a5,d4.w),d0		* compare byte from input buffer
01:00204782 67F0            	  1138: 	BEQ.s		LAB_13D6			* loop if character match
                            	  1139: 
01:00204784 6040            	  1140: 	BRA.s		LAB_1417			* branch if no match
                            	  1141: 
                            	  1142: LAB_13EA
01:00204786 3204            	  1143: 	MOVE.w	d4,d1				* update read index
                            	  1144: LAB_13EC
01:00204788 11802000        	  1145: 	MOVE.b	d0,(a0,d2.w)		* save byte to output
01:0020478C 5242            	  1146: 	ADDQ.w	#1,d2				* increment buffer save index
01:0020478E 5241            	  1147: 	ADDQ.w	#1,d1				* increment buffer read index
01:00204790 4A00            	  1148: 	TST.b		d0				* set flags
01:00204792 674A            	  1149: 	BEQ.s		LAB_142A			* branch if was null [EOL]
                            	  1150: 
                            	  1151: 							* d0 holds token or byte here
01:00204794 903C003A        	  1152: 	SUB.b		#$3A,d0			* subtract ":"
01:00204798 6706            	  1153: 	BEQ.s		LAB_13FF			* branch if it was ":" (is now $00)
                            	  1154: 
                            	  1155: 							* d0 now holds token-$3A
01:0020479A B03C0049        	  1156: 	CMP.b		#(TK_DATA-$3A),d0		* compare with DATA token - $3A
01:0020479E 6604            	  1157: 	BNE.s		LAB_1401			* branch if not DATA
                            	  1158: 
                            	  1159: 							* token was : or DATA
                            	  1160: LAB_13FF
01:002047A0 174005DD        	  1161: 	MOVE.b	d0,Oquote(a3)		* save token-$3A ($00 for ":", TK_DATA-$3A for
                            	  1162: 							* DATA)
                            	  1163: LAB_1401
01:002047A4 903C0055        	  1164: 	SUB.b		#(TK_REM-$3A),d0		* subtract REM token offset
01:002047A8 6600FF78        	  1165: 	BNE		LAB_13AC			* If wasn't REM then go crunch rest of line
                            	  1166: 
01:002047AC 174005DA        	  1167: 	MOVE.b	d0,Asrch(a3)		* else was REM so set search for [EOL]
                            	  1168: 
                            	  1169: 							* loop for REM, "..." etc.
                            	  1170: LAB_1408
01:002047B0 10351000        	  1171: 	MOVE.b	(a5,d1.w),d0		* get byte from input buffer
01:002047B4 67D2            	  1172: 	BEQ.s		LAB_13EC			* branch if null [EOL]
                            	  1173: 
01:002047B6 B02B05DA        	  1174: 	CMP.b		Asrch(a3),d0		* compare with stored character
01:002047BA 67CC            	  1175: 	BEQ.s		LAB_13EC			* branch if match (end quote, REM, :, or DATA)
                            	  1176: 
                            	  1177: 							* entry for copy string in quotes, don't crunch
                            	  1178: LAB_1410
01:002047BC 11802000        	  1179: 	MOVE.b	d0,(a0,d2.w)		* save byte to output
01:002047C0 5242            	  1180: 	ADDQ.w	#1,d2				* increment buffer save index
01:002047C2 5241            	  1181: 	ADDQ.w	#1,d1				* increment buffer read index
01:002047C4 60EA            	  1182: 	BRA.s		LAB_1408			* loop
                            	  1183: 
                            	  1184: * not found keyword this go so find the end of this word in the table
                            	  1185: 
                            	  1186: LAB_1417
01:002047C6 3801            	  1187: 	MOVE.w	d1,d4				* reset read pointer
                            	  1188: LAB_141B
01:002047C8 5243            	  1189: 	ADDQ.w	#1,d3				* increment keyword table pointer, flag
                            	  1190: 							* unchanged
01:002047CA 10313000        	  1191: 	MOVE.b	(a1,d3.w),d0		* get keyword table byte
01:002047CE 6AF8            	  1192: 	BPL.s		LAB_141B			* if not end of keyword go do next byte
                            	  1193: 
01:002047D0 5243            	  1194: 	ADDQ.w	#1,d3				* increment keyword table pointer flag
                            	  1195: 							* unchanged
01:002047D2 10313000        	  1196: 	MOVE.b	(a1,d3.w),d0		* get keyword table byte
01:002047D6 66A2            	  1197: 	BNE.s		LAB_13D8			* go test next word if not zero byte (table end)
                            	  1198: 
                            	  1199: 							* reached end of table with no match
                            	  1200: LAB_141F
01:002047D8 10351000        	  1201: 	MOVE.b	(a5,d1.w),d0		* restore byte from input buffer
01:002047DC 60AA            	  1202: 	BRA.s		LAB_13EC			* go save byte in output and continue crunching
                            	  1203: 
                            	  1204: 							* reached [EOL]
                            	  1205: LAB_142A
01:002047DE 7000            	  1206: 	MOVEQ		#0,d0				* ensure longword clear
01:002047E0 0102            	  1207: 	BTST		d0,d2				* test odd bit (fastest)
01:002047E2 6706            	  1208: 	BEQ.s		LAB_142C			* branch if no bytes to fill
                            	  1209: 
01:002047E4 11802000        	  1210: 	MOVE.b	d0,(a0,d2.w)		* clear next byte
01:002047E8 5242            	  1211: 	ADDQ.w	#1,d2				* increment buffer save index
                            	  1212: LAB_142C
01:002047EA 21802000        	  1213: 	MOVE.l	d0,(a0,d2.w)		* clear next line pointer, EOT in immediate mode
01:002047EE 4E75            	  1214: 	RTS
                            	  1215: 
                            	  1216: 
                            	  1217: *************************************************************************************
                            	  1218: *
                            	  1219: * search Basic for d1 line number from start of mem
                            	  1220: 
                            	  1221: LAB_SSLN
01:002047F0 206B042E        	  1222: 	MOVEA.l	Smeml(a3),a0		* get start of program mem
01:002047F4 6002            	  1223: 	BRA.s		LAB_SCLN			* go search for required line from a0
                            	  1224: 
                            	  1225: LAB_145F
01:002047F6 2040            	  1226: 	MOVEA.l	d0,a0				* copy next line pointer
                            	  1227: 
                            	  1228: * search Basic for d1 line number from a0
                            	  1229: * returns Cb=0 if found
                            	  1230: * returns a0 pointer to found or next higher (not found) line
                            	  1231: 
                            	  1232: LAB_SCLN
01:002047F8 2018            	  1233: 	MOVE.l	(a0)+,d0			* get next line pointer and point to line #
01:002047FA 6708            	  1234: 	BEQ.s		LAB_145E			* is end marker so we're done, do 'no line' exit
                            	  1235: 
01:002047FC B290            	  1236: 	CMP.l		(a0),d1			* compare this line # with required line #
01:002047FE 6EF6            	  1237: 	BGT.s		LAB_145F			* loop if required # > this #
                            	  1238: 
01:00204800 5948            	  1239: 	SUBQ.w	#4,a0				* adjust pointer, flags not changed
01:00204802 4E75            	  1240: 	RTS
                            	  1241: 
                            	  1242: LAB_145E
01:00204804 5948            	  1243: 	SUBQ.w	#4,a0				* adjust pointer, flags not changed
01:00204806 5380            	  1244: 	SUBQ.l	#1,d0				* make end program found = -1, set carry
01:00204808 4E75            	  1245: 	RTS
                            	  1246: 
                            	  1247: 
                            	  1248: *************************************************************************************
                            	  1249: *
                            	  1250: * perform NEW
                            	  1251: 
                            	  1252: LAB_NEW
01:0020480A 664C            	  1253: 	BNE.s		RTS_005			* exit if not end of statement (do syntax error)
                            	  1254: 
                            	  1255: LAB_1463
01:0020480C 206B042E        	  1256: 	MOVEA.l	Smeml(a3),a0		* point to start of program memory
01:00204810 7000            	  1257: 	MOVEQ		#0,d0				* clear longword
01:00204812 20C0            	  1258: 	MOVE.l	d0,(a0)+			* clear first line, next line pointer
01:00204814 27480432        	  1259: 	MOVE.l	a0,Sfncl(a3)		* set start of functions
                            	  1260: 
                            	  1261: * reset execution to start, clear variables and flush stack
                            	  1262: 
                            	  1263: LAB_1477
01:00204818 2A6B042E        	  1264: 	MOVEA.l	Smeml(a3),a5		* reset BASIC execute pointer
01:0020481C 534D            	  1265: 	SUBQ.w	#1,a5				* -1 (as end of previous line)
                            	  1266: 
                            	  1267: * "CLEAR" command gets here
                            	  1268: 
                            	  1269: LAB_147A
01:0020481E 276B044A0446    	  1270: 	MOVE.l	Ememl(a3),Sstorl(a3)	* save end of mem as bottom of string space
01:00204824 202B0432        	  1271: 	MOVE.l	Sfncl(a3),d0		* get start of functions
01:00204828 27400436        	  1272: 	MOVE.l	d0,Svarl(a3)		* start of variables
01:0020482C 2740043A        	  1273: 	MOVE.l	d0,Sstrl(a3)		* start of strings
01:00204830 2740043E        	  1274: 	MOVE.l	d0,Sarryl(a3)		* set start of arrays
01:00204834 27400442        	  1275: 	MOVE.l	d0,Earryl(a3)		* set end of arrays
                            	  1276: LAB_1480
01:00204838 7000            	  1277: 	MOVEQ		#0,d0				* set Zb
01:0020483A 174005EA        	  1278: 	MOVE.b	d0,ccnull(a3)		* clear get byte countdown
01:0020483E 610001CC        	  1279: 	BSR		LAB_RESTORE			* perform RESTORE command
                            	  1280: 
                            	  1281: * flush stack & clear continue flag
                            	  1282: 
                            	  1283: LAB_1491
01:00204842 49EB048E        	  1284: 	LEA		des_sk(a3),a4		* reset descriptor stack pointer
                            	  1285: 
01:00204846 201F            	  1286: 	MOVE.l	(sp)+,d0			* pull return address
01:00204848 4FEB0400        	  1287: 	LEA		ram_base(a3),sp		* set stack to RAM start + 1k, flush stack
01:0020484C 2F00            	  1288: 	MOVE.l	d0,-(sp)			* restore return address
                            	  1289: 
01:0020484E 7000            	  1290: 	MOVEQ		#0,d0				* clear longword
01:00204850 2740045A        	  1291: 	MOVE.l	d0,Cpntrl(a3)		* clear continue pointer
01:00204854 174005DF        	  1292: 	MOVE.b	d0,Sufnxf(a3)		* clear subscript/FNX flag
                            	  1293: RTS_005
01:00204858 4E75            	  1294: 	RTS
                            	  1295: 
                            	  1296: 
                            	  1297: *************************************************************************************
                            	  1298: *
                            	  1299: * perform CLEAR
                            	  1300: 
                            	  1301: LAB_CLEAR
01:0020485A 67C2            	  1302: 	BEQ.s		LAB_147A			* if no following byte go do "CLEAR"
                            	  1303: 
01:0020485C 4E75            	  1304: 	RTS						* was following byte (go do syntax error)
                            	  1305: 
                            	  1306: 
                            	  1307: *************************************************************************************
                            	  1308: *
                            	  1309: * perform LIST [n][-m]
                            	  1310: 
                            	  1311: LAB_LIST
01:0020485E 6512            	  1312: 	BCS.s		LAB_14BD			* branch if next character numeric (LIST n...)
                            	  1313: 
01:00204860 72FF            	  1314: 	MOVEQ		#-1,d1			* set end to $FFFFFFFF
01:00204862 2741042A        	  1315: 	MOVE.l	d1,Itemp(a3)		* save to Itemp
                            	  1316: 
01:00204866 7200            	  1317: 	MOVEQ		#0,d1				* set start to $00000000
01:00204868 4A00            	  1318: 	TST.b		d0				* test next byte
01:0020486A 670A            	  1319: 	BEQ.s		LAB_14C0			* branch if next character [NULL] (LIST)
                            	  1320: 
01:0020486C B03C00B3        	  1321: 	CMP.b		#TK_MINUS,d0		* compare with token for -
01:00204870 66E6            	  1322: 	BNE.s		RTS_005			* exit if not - (LIST -m)
                            	  1323: 
                            	  1324: 							* LIST [[n]-[m]] this sets the n, if present,
                            	  1325: 							* as the start and end
                            	  1326: LAB_14BD
01:00204872 61000390        	  1327: 	BSR		LAB_GFPN			* get fixed-point number into temp integer & d1
                            	  1328: LAB_14C0
01:00204876 6100FF78        	  1329: 	BSR		LAB_SSLN			* search BASIC for d1 line number
                            	  1330: 							* (pointer in a0)
01:0020487A 61000932        	  1331: 	BSR		LAB_GBYT			* scan memory
01:0020487E 6716            	  1332: 	BEQ.s		LAB_14D4			* branch if no more characters
                            	  1333: 
                            	  1334: 							* this bit checks the - is present
01:00204880 B03C00B3        	  1335: 	CMP.b		#TK_MINUS,d0		* compare with token for -
01:00204884 66D2            	  1336: 	BNE.s		RTS_005			* return if not "-" (will be Syntax error)
                            	  1337: 
01:00204886 72FF            	  1338: 	MOVEQ		#-1,d1			* set end to $FFFFFFFF
01:00204888 2741042A        	  1339: 	MOVE.l	d1,Itemp(a3)		* save Itemp
                            	  1340: 
                            	  1341: 							* LIST [n]-[m] the - was there so see if
                            	  1342: 							* there is an m to set as the end value
01:0020488C 6100091E        	  1343: 	BSR		LAB_IGBY			* increment & scan memory
01:00204890 6704            	  1344: 	BEQ.s		LAB_14D4			* branch if was [NULL] (LIST n-)
                            	  1345: 
01:00204892 61000370        	  1346: 	BSR		LAB_GFPN			* get fixed-point number into temp integer & d1
                            	  1347: LAB_14D4
01:00204896 177C000005DD    	  1348: 	MOVE.b	#$00,Oquote(a3)		* clear open quote flag
01:0020489C 610004E6        	  1349: 	BSR		LAB_CRLF			* print CR/LF
01:002048A0 2018            	  1350: 	MOVE.l	(a0)+,d0			* get next line pointer
01:002048A2 67B4            	  1351: 	BEQ.s		RTS_005			* if null all done so exit
                            	  1352: 
01:002048A4 2240            	  1353: 	MOVEA.l	d0,a1				* copy next line pointer
01:002048A6 6100012A        	  1354: 	BSR		LAB_1629			* do CRTL-C check vector
                            	  1355: 
01:002048AA 2018            	  1356: 	MOVE.l	(a0)+,d0			* get this line #
01:002048AC B0AB042A        	  1357: 	CMP.l		Itemp(a3),d0		* compare end line # with this line #
01:002048B0 62A6            	  1358: 	BHI.s		RTS_005			* if this line greater all done so exit
                            	  1359: 
                            	  1360: LAB_14E2
01:002048B2 48E700C0        	  1361: 	MOVEM.l	a0-a1,-(sp)			* save registers
01:002048B6 61001800        	  1362: 	BSR		LAB_295E			* print d0 as unsigned integer
01:002048BA 4CDF0300        	  1363: 	MOVEM.l	(sp)+,a0-a1			* restore registers
01:002048BE 7020            	  1364: 	MOVEQ		#$20,d0			* space is the next character
                            	  1365: LAB_150C
01:002048C0 6100053A        	  1366: 	BSR		LAB_PRNA			* go print the character
01:002048C4 B03C0022        	  1367: 	CMP.b		#$22,d0			* was it " character
01:002048C8 6604            	  1368: 	BNE.s		LAB_1519			* branch if not
                            	  1369: 
                            	  1370: 							* we're either entering or leaving quotes
01:002048CA 462B05DD        	  1371: 	EOR.b		#$FF,Oquote(a3)		* toggle open quote flag
                            	  1372: LAB_1519
01:002048CE 1018            	  1373: 	MOVE.b	(a0)+,d0			* get byte and increment pointer
01:002048D0 6608            	  1374: 	BNE.s		LAB_152E			* branch if not [EOL] (go print)
                            	  1375: 
                            	  1376: 							* was [EOL]
01:002048D2 2049            	  1377: 	MOVEA.l	a1,a0				* copy next line pointer
01:002048D4 2008            	  1378: 	MOVE.l	a0,d0				* copy to set flags
01:002048D6 66BE            	  1379: 	BNE.s		LAB_14D4			* go do next line if not [EOT]
                            	  1380: 
01:002048D8 4E75            	  1381: 	RTS
                            	  1382: 
                            	  1383: LAB_152E
01:002048DA 6AE4            	  1384: 	BPL.s		LAB_150C			* just go print it if not token byte
                            	  1385: 
                            	  1386: 							* else it was a token byte so maybe uncrunch it
01:002048DC 4A2B05DD        	  1387: 	TST.b		Oquote(a3)			* test the open quote flag
01:002048E0 6BDE            	  1388: 	BMI.s		LAB_150C			* just go print character if open quote set
                            	  1389: 
                            	  1390: 							* else uncrunch BASIC token
01:002048E2 45FA2AD4        	  1391: 	LEA		LAB_KEYT(pc),a2		* get keyword table address
01:002048E6 727F            	  1392: 	MOVEQ		#$7F,d1			* mask into d1
01:002048E8 C200            	  1393: 	AND.b		d0,d1				* copy and mask token
01:002048EA E549            	  1394: 	LSL.w		#2,d1				* *4
01:002048EC 45F21000        	  1395: 	LEA		(a2,d1.w),a2		* get keyword entry address
01:002048F0 101A            	  1396: 	MOVE.b	(a2)+,d0			* get byte from keyword table
01:002048F2 61000508        	  1397: 	BSR		LAB_PRNA			* go print the first character
01:002048F6 7200            	  1398: 	MOVEQ		#0,d1				* clear d1
01:002048F8 121A            	  1399: 	MOVE.b	(a2)+,d1			* get remaining length byte from keyword table
01:002048FA 6BD2            	  1400: 	BMI.s		LAB_1519			* if -ve done so go get next byte
                            	  1401: 
01:002048FC 3012            	  1402: 	MOVE.w	(a2),d0			* get offset to rest
01:002048FE 45FA2DE4        	  1403: 	LEA		TAB_STAR(pc),a2		* get keyword table address
01:00204902 45F20000        	  1404: 	LEA		(a2,d0.w),a2		* get address of rest
                            	  1405: LAB_1540
01:00204906 101A            	  1406: 	MOVE.b	(a2)+,d0			* get byte from keyword table
01:00204908 610004F2        	  1407: 	BSR		LAB_PRNA			* go print the character
01:0020490C 51C9FFF8        	  1408: 	DBF		d1,LAB_1540			* decrement and loop if more to do
                            	  1409: 
01:00204910 60BC            	  1410: 	BRA.s		LAB_1519			* go get next byte
                            	  1411: 
                            	  1412: 
                            	  1413: *************************************************************************************
                            	  1414: *
                            	  1415: * perform FOR
                            	  1416: 
                            	  1417: LAB_FOR
01:00204912 61000390        	  1418: 	BSR		LAB_LET			* go do LET
                            	  1419: 
01:00204916 202B0472        	  1420: 	MOVE.l	Lvarpl(a3),d0		* get the loop variable pointer
01:0020491A B0AB043A        	  1421: 	CMP.l		Sstrl(a3),d0		* compare it with the end of vars memory
01:0020491E 6C00FC24        	  1422: 	BGE		LAB_TMER			* if greater go do type mismatch error
                            	  1423: 
                            	  1424: * test for not less than the start of variables memory if needed
                            	  1425: *
                            	  1426: *	CMP.l		Svarl(a3),d0		* compare it with the start of variables memory
                            	  1427: *	BLT		LAB_TMER			* if not variables memory do type mismatch error
                            	  1428: 
                            	  1429: *	MOVEQ		#28,d0			* we need 28 bytes !
                            	  1430: *	BSR.s		LAB_1212			* check room on stack for d0 bytes
                            	  1431: 
01:00204922 61000214        	  1432: 	BSR		LAB_SNBS			* scan for next BASIC statement ([:] or [EOL])
                            	  1433: 							* returns a0 as pointer to [:] or [EOL]
01:00204926 2E88            	  1434: 	MOVE.l	a0,(sp)			* push onto stack (and dump the return address)
01:00204928 2F2B0452        	  1435: 	MOVE.l	Clinel(a3),-(sp)		* push current line onto stack
                            	  1436: 
01:0020492C 70AA            	  1437: 	MOVEQ		#TK_TO-$100,d0		* set "TO" token
01:0020492E 61000874        	  1438: 	BSR		LAB_SCCA			* scan for CHR$(d0) else syntax error/warm start
01:00204932 61000702        	  1439: 	BSR		LAB_CTNM			* check if source is numeric, else type mismatch
01:00204936 1F2B05B5        	  1440: 	MOVE.b	Dtypef(a3),-(sp)		* push the FOR variable data type onto stack
01:0020493A 610006F8        	  1441: 	BSR		LAB_EVNM			* evaluate expression and check is numeric else
                            	  1442: 							* do type mismatch
                            	  1443: 
01:0020493E 2F2B0590        	  1444: 	MOVE.l	FAC1_m(a3),-(sp)		* push TO value mantissa
01:00204942 3F2B0594        	  1445: 	MOVE.w	FAC1_e(a3),-(sp)		* push TO value exponent and sign
                            	  1446: 
01:00204946 277C800000000590	  1447: 	MOVE.l	#$80000000,FAC1_m(a3)	* set default STEP size mantissa
01:0020494E 377C81000594    	  1448: 	MOVE.w	#$8100,FAC1_e(a3)		* set default STEP size exponent and sign
                            	  1449: 
01:00204954 61000858        	  1450: 	BSR		LAB_GBYT			* scan memory
01:00204958 B03C00AF        	  1451: 	CMP.b		#TK_STEP,d0			* compare with STEP token
01:0020495C 6608            	  1452: 	BNE.s		LAB_15B3			* jump if not "STEP"
                            	  1453: 
                            	  1454: 							* was STEP token so ....
01:0020495E 6100084C        	  1455: 	BSR		LAB_IGBY			* increment & scan memory
01:00204962 610006D0        	  1456: 	BSR		LAB_EVNM			* evaluate expression & check is numeric
                            	  1457: 							* else do type mismatch
                            	  1458: LAB_15B3
01:00204966 2F2B0590        	  1459: 	MOVE.l	FAC1_m(a3),-(sp)		* push STEP value mantissa
01:0020496A 3F2B0594        	  1460: 	MOVE.w	FAC1_e(a3),-(sp)		* push STEP value exponent and sign
                            	  1461: 
01:0020496E 2F2B0472        	  1462: 	MOVE.l	Lvarpl(a3),-(sp)		* push variable pointer for FOR/NEXT
01:00204972 3F3C0081        	  1463: 	MOVE.w	#TK_FOR,-(sp)		* push FOR token on stack
                            	  1464: 
01:00204976 6018            	  1465: 	BRA.s		LAB_15C2			* go do interpreter inner loop
                            	  1466: 
                            	  1467: LAB_15DC						* have reached [EOL]+1
01:00204978 300D            	  1468: 	MOVE.w	a5,d0				* copy BASIC execute pointer
01:0020497A C07C0001        	  1469: 	AND.w		#1,d0				* and make line start address even
01:0020497E DAC0            	  1470: 	ADD.w		d0,a5				* add to BASIC execute pointer
01:00204980 201D            	  1471: 	MOVE.l	(a5)+,d0			* get next line pointer
01:00204982 6700FC1C        	  1472: 	BEQ		LAB_1274			* if null go to immediate mode, no "BREAK"
                            	  1473: 							* message (was immediate or [EOT] marker)
                            	  1474: 
01:00204986 275D0452        	  1475: 	MOVE.l	(a5)+,Clinel(a3)		* save (new) current line #
                            	  1476: LAB_15F6
01:0020498A 61000822        	  1477: 	BSR		LAB_GBYT			* get BASIC byte
01:0020498E 611A            	  1478: 	BSR.s		LAB_15FF			* go interpret BASIC code from (a5)
                            	  1479: 
                            	  1480: * interpreter inner loop (re)entry point
                            	  1481: 
                            	  1482: LAB_15C2
01:00204990 6140            	  1483: 	BSR.s		LAB_1629			* do CRTL-C check vector
01:00204992 4A2B0452        	  1484: 	TST.b		Clinel(a3)			* test current line #, is -ve for immediate mode
01:00204996 6B04            	  1485: 	BMI.s		LAB_15D1			* branch if immediate mode
                            	  1486: 
01:00204998 274D045A        	  1487: 	MOVE.l	a5,Cpntrl(a3)		* save BASIC execute pointer as continue pointer
                            	  1488: LAB_15D1
01:0020499C 101D            	  1489: 	MOVE.b	(a5)+,d0			* get this byte & increment pointer
01:0020499E 67D8            	  1490: 	BEQ.s		LAB_15DC			* loop if [EOL]
                            	  1491: 
01:002049A0 B03C003A        	  1492: 	CMP.b		#$3A,d0			* compare with ":"
01:002049A4 67E4            	  1493: 	BEQ.s		LAB_15F6			* loop if was statement separator
                            	  1494: 
01:002049A6 6000FBC8        	  1495: 	BRA		LAB_SNER			* else syntax error, then warm start
                            	  1496: 
                            	  1497: 
                            	  1498: *************************************************************************************
                            	  1499: *
                            	  1500: * interpret BASIC code from (a5)
                            	  1501: 
                            	  1502: LAB_15FF
01:002049AA 6700008C        	  1503: 	BEQ		RTS_006			* exit if zero [EOL]
                            	  1504: 
                            	  1505: LAB_1602
01:002049AE 0A000080        	  1506: 	EORI.b	#$80,d0			* normalise token
01:002049B2 6B0002F0        	  1507: 	BMI		LAB_LET			* if not token, go do implied LET
                            	  1508: 
01:002049B6 B03C0028        	  1509: 	CMP.b		#(TK_TAB-$80),d0		* compare normalised token with TAB
01:002049BA 6400FBB4        	  1510: 	BCC		LAB_SNER			* branch if d0>=TAB, syntax error/warm start
                            	  1511: 							* only tokens before TAB can start a statement
                            	  1512: 
01:002049BE 4880            	  1513: 	EXT.w		d0				* byte to word (clear high byte)
01:002049C0 D040            	  1514: 	ADD.w		d0,d0				* *2
01:002049C2 41FA2852        	  1515: 	LEA		LAB_CTBL(pc),a0		* get vector table base address
01:002049C6 30300000        	  1516: 	MOVE.w	(a0,d0.w),d0		* get offset to vector
01:002049CA 48700000        	  1517: 	PEA		(a0,d0.w)			* push vector
01:002049CE 600007DC        	  1518: 	BRA		LAB_IGBY			* get following byte & execute vector
                            	  1519: 
                            	  1520: 
                            	  1521: *************************************************************************************
                            	  1522: *
                            	  1523: * CTRL-C check jump. this is called as a subroutine but exits back via a jump if a
                            	  1524: * key press is detected.
                            	  1525: 
                            	  1526: LAB_1629
01:002049D2 4EEB0424        	  1527: 	JMP		V_CTLC(a3)			* ctrl c check vector
                            	  1528: 
                            	  1529: * if there was a key press it gets back here .....
                            	  1530: 
                            	  1531: LAB_1636
01:002049D6 B03C0003        	  1532: 	CMP.b		#$03,d0			* compare with CTRL-C
01:002049DA 670C            	  1533: 	BEQ.s		LAB_163B			* STOP if was CTRL-C
                            	  1534: 
                            	  1535: LAB_1639
01:002049DC 4E75            	  1536: 	RTS						*
                            	  1537: 
                            	  1538: 
                            	  1539: *************************************************************************************
                            	  1540: *
                            	  1541: * perform END
                            	  1542: 
                            	  1543: LAB_END
01:002049DE 66FC            	  1544: 	BNE.s		LAB_1639			* exit if something follows STOP
01:002049E0 177C000005DC    	  1545: 	MOVE.b	#0,Breakf(a3)		* clear break flag, indicate program end
                            	  1546: 
                            	  1547: 
                            	  1548: *************************************************************************************
                            	  1549: *
                            	  1550: * perform STOP
                            	  1551: 
                            	  1552: LAB_STOP
01:002049E6 66F4            	  1553: 	BNE.s		LAB_1639			* exit if something follows STOP
                            	  1554: 
                            	  1555: LAB_163B
01:002049E8 43EB0590        	  1556: 	LEA		Ibuffe(a3),a1		* get buffer end
01:002049EC BBC9            	  1557: 	CMPA.l	a1,a5				* compare execute address with buffer end
01:002049EE 650A            	  1558: 	BCS.s		LAB_164F			* branch if BASIC pointer is in buffer
                            	  1559: 							* can't continue in immediate mode
                            	  1560: 
                            	  1561: 							* else...
01:002049F0 274D045A        	  1562: 	MOVE.l	a5,Cpntrl(a3)		* save BASIC execute pointer as continue pointer
                            	  1563: LAB_1647
01:002049F4 276B04520456    	  1564: 	MOVE.l	Clinel(a3),Blinel(a3)	* save break line
                            	  1565: LAB_164F
01:002049FA 584F            	  1566: 	ADDQ.w	#4,sp				* dump return address, don't return to execute
                            	  1567: 							* loop
01:002049FC 102B05DC        	  1568: 	MOVE.b	Breakf(a3),d0		* get break flag
01:00204A00 6700FB9E        	  1569: 	BEQ		LAB_1274			* go do warm start if was program end
                            	  1570: 
01:00204A04 41FA2E89        	  1571: 	LEA		LAB_BMSG(pc),a0		* point to "Break"
01:00204A08 6000FB88        	  1572: 	BRA		LAB_1269			* print "Break" and do warm start
                            	  1573: 
                            	  1574: 
                            	  1575: *************************************************************************************
                            	  1576: *
                            	  1577: * perform RESTORE
                            	  1578: 
                            	  1579: LAB_RESTORE
01:00204A0C 206B042E        	  1580: 	MOVEA.l	Smeml(a3),a0		* copy start of memory
01:00204A10 6720            	  1581: 	BEQ.s		LAB_1624			* branch if next character null (RESTORE)
                            	  1582: 
01:00204A12 610001F0        	  1583: 	BSR		LAB_GFPN			* get fixed-point number into temp integer & d1
01:00204A16 B2AB0452        	  1584: 	CMP.l		Clinel(a3),d1		* compare current line # with required line #
01:00204A1A 630E            	  1585: 	BLS.s		LAB_GSCH			* branch if >= (start search from beginning)
                            	  1586: 
01:00204A1C 204D            	  1587: 	MOVEA.l	a5,a0				* copy BASIC execute pointer
                            	  1588: LAB_RESs
01:00204A1E 4A18            	  1589: 	TST.b		(a0)+				* test next byte & increment pointer
01:00204A20 66FC            	  1590: 	BNE.s		LAB_RESs			* loop if not EOL
                            	  1591: 
01:00204A22 3008            	  1592: 	MOVE.w	a0,d0				* copy pointer
01:00204A24 C07C0001        	  1593: 	AND.w		#1,d0				* mask odd bit
01:00204A28 D0C0            	  1594: 	ADD.w		d0,a0				* add pointer
                            	  1595: 							* search for line in Itemp from (a0)
                            	  1596: LAB_GSCH
01:00204A2A 6100FDCC        	  1597: 	BSR		LAB_SCLN			* search for d1 line number from a0
                            	  1598: 							* returns Cb=0 if found
01:00204A2E 6500FB28        	  1599: 	BCS		LAB_USER			* go do "Undefined statement" error if not found
                            	  1600: 
                            	  1601: LAB_1624
01:00204A32 4A20            	  1602: 	TST.b		-(a0)				* decrement pointer (faster)
01:00204A34 27480462        	  1603: 	MOVE.l	a0,Dptrl(a3)		* save DATA pointer
                            	  1604: RTS_006
01:00204A38 4E75            	  1605: 	RTS
                            	  1606: 
                            	  1607: 
                            	  1608: *************************************************************************************
                            	  1609: *
                            	  1610: * perform NULL
                            	  1611: 
                            	  1612: LAB_NULL
01:00204A3A 610010D0        	  1613: 	BSR		LAB_GTBY			* get byte parameter, result in d0 and Itemp
01:00204A3E 174005E4        	  1614: 	MOVE.b	d0,Nullct(a3)		* save new NULL count
01:00204A42 4E75            	  1615: 	RTS
                            	  1616: 
                            	  1617: 
                            	  1618: *************************************************************************************
                            	  1619: *
                            	  1620: * perform CONT
                            	  1621: 
                            	  1622: LAB_CONT
01:00204A44 6600FB2A        	  1623: 	BNE		LAB_SNER			* if following byte exit to do syntax error
                            	  1624: 
01:00204A48 4A2B0452        	  1625: 	TST.b		Clinel(a3)			* test current line #, is -ve for immediate mode
01:00204A4C 6A00FAEA        	  1626: 	BPL		LAB_CCER			* if running go do can't continue error
                            	  1627: 
01:00204A50 202B045A        	  1628: 	MOVE.l	Cpntrl(a3),d0		* get continue pointer
01:00204A54 6700FAE2        	  1629: 	BEQ		LAB_CCER			* go do can't continue error if we can't
                            	  1630: 
                            	  1631: 							* we can continue so ...
01:00204A58 2A40            	  1632: 	MOVEA.l	d0,a5				* save continue pointer as BASIC execute pointer
01:00204A5A 276B04560452    	  1633: 	MOVE.l	Blinel(a3),Clinel(a3)	* set break line as current line
01:00204A60 4E75            	  1634: 	RTS
                            	  1635: 
                            	  1636: 
                            	  1637: *************************************************************************************
                            	  1638: *
                            	  1639: * perform RUN
                            	  1640: 
                            	  1641: LAB_RUN
01:00204A62 660C            	  1642: 	BNE.s		LAB_RUNn			* if following byte do RUN n
                            	  1643: 
01:00204A64 6100FDB2        	  1644: 	BSR		LAB_1477			* execution to start, clear vars & flush stack
01:00204A68 274D045A        	  1645: 	MOVE.l	a5,Cpntrl(a3)		* save as continue pointer
01:00204A6C 6000FF22        	  1646: 	BRA		LAB_15C2			* go do interpreter inner loop
                            	  1647: 							* (can't RTS, we flushed the stack!)
                            	  1648: 
                            	  1649: LAB_RUNn
01:00204A70 6100FDAC        	  1650: 	BSR		LAB_147A			* go do "CLEAR"
01:00204A74 601C            	  1651: 	BRA.s		LAB_16B0			* get n and do GOTO n
                            	  1652: 
                            	  1653: 
                            	  1654: *************************************************************************************
                            	  1655: *
                            	  1656: * perform DO
                            	  1657: 
                            	  1658: LAB_DO
                            	  1659: *	MOVE.l	#$05,d0			* need 5 bytes for DO
                            	  1660: *	BSR.s		LAB_1212			* check room on stack for A bytes
01:00204A76 2F0D            	  1661: 	MOVE.l	a5,-(sp)			* push BASIC execute pointer on stack
01:00204A78 2F2B0452        	  1662: 	MOVE.l	Clinel(a3),-(sp)		* push current line on stack
01:00204A7C 3F3C009C        	  1663: 	MOVE.w	#TK_DO,-(sp)		* push token for DO on stack
01:00204A80 487AFF0E        	  1664: 	PEA		LAB_15C2(pc)		* set return address
01:00204A84 60000728        	  1665: 	BRA		LAB_GBYT			* scan memory & return to interpreter inner loop
                            	  1666: 
                            	  1667: 
                            	  1668: *************************************************************************************
                            	  1669: *
                            	  1670: * perform GOSUB
                            	  1671: 
                            	  1672: LAB_GOSUB
                            	  1673: *	MOVE.l	#10,d0			* need 10 bytes for GOSUB
                            	  1674: *	BSR.s		LAB_1212			* check room on stack for d0 bytes
01:00204A88 2F0D            	  1675: 	MOVE.l	a5,-(sp)			* push BASIC execute pointer
01:00204A8A 2F2B0452        	  1676: 	MOVE.l	Clinel(a3),-(sp)		* push current line
01:00204A8E 3F3C008D        	  1677: 	MOVE.w	#TK_GOSUB,-(sp)		* push token for GOSUB
                            	  1678: LAB_16B0
01:00204A92 6100071A        	  1679: 	BSR		LAB_GBYT			* scan memory
01:00204A96 487AFEF8        	  1680: 	PEA		LAB_15C2(pc)		* return to interpreter inner loop after GOTO n
                            	  1681: 
                            	  1682: * this PEA is needed because either we just cleared the stack and have nowhere to return
                            	  1683: * to or, in the case of GOSUB, we have just dropped a load on the stack and the address
                            	  1684: * we whould have returned to is buried. This burried return address will be unstacked by
                            	  1685: * the corresponding RETURN command
                            	  1686: 
                            	  1687: 
                            	  1688: *************************************************************************************
                            	  1689: *
                            	  1690: * perform GOTO
                            	  1691: 
                            	  1692: LAB_GOTO
01:00204A9A 61000168        	  1693: 	BSR		LAB_GFPN			* get fixed-point number into temp integer & d1
01:00204A9E 206B042E        	  1694: 	MOVEA.l	Smeml(a3),a0		* get start of memory
01:00204AA2 B2AB0452        	  1695: 	CMP.l		Clinel(a3),d1		* compare current line with wanted #
01:00204AA6 630E            	  1696: 	BLS.s		LAB_16D0			* branch if current # => wanted #
                            	  1697: 
01:00204AA8 204D            	  1698: 	MOVEA.l	a5,a0				* copy BASIC execute pointer
                            	  1699: LAB_GOTs
01:00204AAA 4A18            	  1700: 	TST.b		(a0)+				* test next byte & increment pointer
01:00204AAC 66FC            	  1701: 	BNE.s		LAB_GOTs			* loop if not EOL
                            	  1702: 
01:00204AAE 3008            	  1703: 	MOVE.w	a0,d0				* past pad byte(s)
01:00204AB0 C07C0001        	  1704: 	AND.w		#1,d0				* mask odd bit
01:00204AB4 D0C0            	  1705: 	ADD.w		d0,a0				* add to pointer
                            	  1706: 
                            	  1707: LAB_16D0
01:00204AB6 6100FD40        	  1708: 	BSR		LAB_SCLN			* search for d1 line number from a0
                            	  1709: 							* returns Cb=0 if found
01:00204ABA 6500FA9C        	  1710: 	BCS		LAB_USER			* if carry set go do "Undefined statement" error
                            	  1711: 
01:00204ABE 2A48            	  1712: 	MOVEA.l	a0,a5				* copy to basic execute pointer
01:00204AC0 534D            	  1713: 	SUBQ.w	#1,a5				* decrement pointer
01:00204AC2 274D045A        	  1714: 	MOVE.l	a5,Cpntrl(a3)		* save as continue pointer
01:00204AC6 4E75            	  1715: 	RTS
                            	  1716: 
                            	  1717: 
                            	  1718: *************************************************************************************
                            	  1719: *
                            	  1720: * perform LOOP
                            	  1721: 
                            	  1722: LAB_LOOP
01:00204AC8 0C6F009C0004    	  1723: 	CMP.w		#TK_DO,4(sp)		* compare token on stack with DO token
01:00204ACE 6600FA60        	  1724: 	BNE		LAB_LDER			* branch if no matching DO
                            	  1725: 
01:00204AD2 1E00            	  1726: 	MOVE.b	d0,d7				* copy following token (byte)
01:00204AD4 672E            	  1727: 	BEQ.s		LoopAlways			* if no following token loop forever
                            	  1728: 
01:00204AD6 BE3C003A        	  1729: 	CMP.b		#':',d7			* compare with ":"
01:00204ADA 6728            	  1730: 	BEQ.s		LoopAlways			* if no following token loop forever
                            	  1731: 
01:00204ADC 9E3C00B0        	  1732: 	SUB.b		#TK_UNTIL,d7		* subtract token for UNTIL
01:00204AE0 6708            	  1733: 	BEQ.s		DoRest			* branch if was UNTIL
                            	  1734: 
01:00204AE2 5307            	  1735: 	SUBQ.b	#1,d7				* decrement result
01:00204AE4 6600FA8A        	  1736: 	BNE		LAB_SNER			* if not WHILE go do syntax error & warm start
                            	  1737: 							* only if the token was WHILE will this fail
                            	  1738: 
01:00204AE8 7EFF            	  1739: 	MOVEQ		#-1,d7			* set invert result longword
                            	  1740: DoRest
01:00204AEA 610006C0        	  1741: 	BSR		LAB_IGBY			* increment & scan memory
01:00204AEE 6100055C        	  1742: 	BSR		LAB_EVEX			* evaluate expression
01:00204AF2 4A2B0594        	  1743: 	TST.b		FAC1_e(a3)			* test FAC1 exponent
01:00204AF6 6706            	  1744: 	BEQ.s		DoCmp				* if = 0 go do straight compare
                            	  1745: 
01:00204AF8 177C00FF0594    	  1746: 	MOVE.b	#$FF,FAC1_e(a3)		* else set all bits
                            	  1747: DoCmp
01:00204AFE BF2B0594        	  1748: 	EOR.b		d7,FAC1_e(a3)		* EOR with invert byte
01:00204B02 6614            	  1749: 	BNE.s		LoopDone			* if <> 0 clear stack & back to interpreter loop
                            	  1750: 
                            	  1751: 							* loop condition wasn't met so do it again
                            	  1752: LoopAlways
01:00204B04 276F00060452    	  1753: 	MOVE.l	6(sp),Clinel(a3)		* copy DO current line
01:00204B0A 2A6F000A        	  1754: 	MOVE.l	10(sp),a5			* save BASIC execute pointer
                            	  1755: 
01:00204B0E 41FAFE80        	  1756: 	LEA		LAB_15C2(pc),a0		* get return address
01:00204B12 2E88            	  1757: 	MOVE.l	a0,(sp)			* dump the call to this routine and set the
                            	  1758: 							* return address
01:00204B14 60000698        	  1759: 	BRA		LAB_GBYT			* scan memory and return to interpreter inner
                            	  1760: 							* loop
                            	  1761: 
                            	  1762: 							* clear stack & back to interpreter loop
                            	  1763: LoopDone
01:00204B18 4FEF000E        	  1764: 	LEA		14(sp),sp			* dump structure and call from stack
01:00204B1C 6014            	  1765: 	BRA.s		LAB_DATA			* go perform DATA (find : or [EOL])
                            	  1766: 
                            	  1767: 
                            	  1768: *************************************************************************************
                            	  1769: *
                            	  1770: * perform RETURN
                            	  1771: 
                            	  1772: LAB_RETURN
01:00204B1E 6616            	  1773: 	BNE.s		RTS_007			* exit if following token to allow syntax error
                            	  1774: 
01:00204B20 0C6F008D0004    	  1775: 	CMP.w		#TK_GOSUB,4(sp)		* compare token from stack with GOSUB
01:00204B26 6600FA44        	  1776: 	BNE		LAB_RGER			* do RETURN without GOSUB error if no matching
                            	  1777: 							* GOSUB
                            	  1778: 
01:00204B2A 5C4F            	  1779: 	ADDQ.w	#6,sp				* dump calling address & token
01:00204B2C 275F0452        	  1780: 	MOVE.l	(sp)+,Clinel(a3)		* pull current line
01:00204B30 2A5F            	  1781: 	MOVE.l	(sp)+,a5			* pull BASIC execute pointer
                            	  1782: 							* now do perform "DATA" statement as we could be
                            	  1783: 							* returning into the middle of an ON <var> GOSUB
                            	  1784: 							* n,m,p,q line (the return address used by the
                            	  1785: 							* DATA statement is the one pushed before the
                            	  1786: 							* GOSUB was executed!)
                            	  1787: 
                            	  1788: 
                            	  1789: *************************************************************************************
                            	  1790: *
                            	  1791: * perform DATA
                            	  1792: 
                            	  1793: LAB_DATA
01:00204B32 6104            	  1794: 	BSR.s		LAB_SNBS			* scan for next BASIC statement ([:] or [EOL])
                            	  1795: 							* returns a0 as pointer to [:] or [EOL]
01:00204B34 2A48            	  1796: 	MOVEA.l	a0,a5				* skip rest of statement
                            	  1797: RTS_007
01:00204B36 4E75            	  1798: 	RTS
                            	  1799: 
                            	  1800: 
                            	  1801: *************************************************************************************
                            	  1802: *
                            	  1803: * scan for next BASIC statement ([:] or [EOL])
                            	  1804: * returns a0 as pointer to [:] or [EOL]
                            	  1805: 
                            	  1806: LAB_SNBS
01:00204B38 204D            	  1807: 	MOVEA.l	a5,a0				* copy BASIC execute pointer
01:00204B3A 7222            	  1808: 	MOVEQ		#$22,d1			* set string quote character
01:00204B3C 743A            	  1809: 	MOVEQ		#$3A,d2			* set look for character = ":"
01:00204B3E 6008            	  1810: 	BRA.s		LAB_172D			* go do search
                            	  1811: 
                            	  1812: LAB_172C
01:00204B40 B400            	  1813: 	CMP.b		d0,d2				* compare with ":"
01:00204B42 6708            	  1814: 	BEQ.s		RTS_007a			* exit if found
                            	  1815: 
01:00204B44 B200            	  1816: 	CMP.b		d0,d1				* compare with '"'
01:00204B46 670C            	  1817: 	BEQ.s		LAB_1725			* if found go search for [EOL]
                            	  1818: 
                            	  1819: LAB_172D
01:00204B48 1018            	  1820: 	MOVE.b	(a0)+,d0			* get next byte
01:00204B4A 66F4            	  1821: 	BNE.s		LAB_172C			* loop if not null [EOL]
                            	  1822: 
                            	  1823: RTS_007a
01:00204B4C 5348            	  1824: 	SUBQ.w	#1,a0				* correct pointer
01:00204B4E 4E75            	  1825: 	RTS
                            	  1826: 
                            	  1827: LAB_1723
01:00204B50 B200            	  1828: 	CMP.b		d0,d1				* compare with '"'
01:00204B52 67F4            	  1829: 	BEQ.s		LAB_172D			* if found go search for ":" or [EOL]
                            	  1830: 
                            	  1831: LAB_1725
01:00204B54 1018            	  1832: 	MOVE.b	(a0)+,d0			* get next byte
01:00204B56 66F8            	  1833: 	BNE.s		LAB_1723			* loop if not null [EOL]
                            	  1834: 
01:00204B58 60F2            	  1835: 	BRA.s		RTS_007a			* correct pointer & return
                            	  1836: 
                            	  1837: 
                            	  1838: *************************************************************************************
                            	  1839: *
                            	  1840: * perform IF
                            	  1841: 
                            	  1842: LAB_IF
01:00204B5A 610004F0        	  1843: 	BSR		LAB_EVEX			* evaluate expression
01:00204B5E 6100064E        	  1844: 	BSR		LAB_GBYT			* scan memory
01:00204B62 B03C00AD        	  1845: 	CMP.b		#TK_THEN,d0			* compare with THEN token
01:00204B66 6714            	  1846: 	BEQ.s		LAB_174B			* if it was THEN then continue
                            	  1847: 
                            	  1848: 							* wasn't IF .. THEN so must be IF .. GOTO
01:00204B68 B03C0089        	  1849: 	CMP.b		#TK_GOTO,d0			* compare with GOTO token
01:00204B6C 6600FA02        	  1850: 	BNE		LAB_SNER			* if not GOTO token do syntax error/warm start
                            	  1851: 
                            	  1852: 							* was GOTO so check for GOTO <n>
01:00204B70 204D            	  1853: 	MOVE.l	a5,a0				* save the execute pointer
01:00204B72 61000638        	  1854: 	BSR		LAB_IGBY			* scan memory, test for a numeric character
01:00204B76 2A48            	  1855: 	MOVE.l	a0,a5				* restore the execute pointer
01:00204B78 6400F9F6        	  1856: 	BCC		LAB_SNER			* if not numeric do syntax error/warm start
                            	  1857: 
                            	  1858: LAB_174B
01:00204B7C 102B0594        	  1859: 	MOVE.b	FAC1_e(a3),d0		* get FAC1 exponent
01:00204B80 671E            	  1860: 	BEQ.s		LAB_174E			* if result was zero go look for an ELSE
                            	  1861: 
01:00204B82 61000628        	  1862: 	BSR		LAB_IGBY			* increment & scan memory
01:00204B86 6500FF12        	  1863: 	BCS		LAB_GOTO			* if numeric do GOTO n
                            	  1864: 							* a GOTO <n> will never return to the IF
                            	  1865: 							* statement so there is no need to return
                            	  1866: 							* to this code
                            	  1867: 
01:00204B8A B03C008E        	  1868: 	CMP.b		#TK_RETURN,d0		* compare with RETURN token
01:00204B8E 6700FE1E        	  1869: 	BEQ		LAB_1602			* if RETURN then interpret BASIC code from (a5)
                            	  1870: 							* and don't return here
                            	  1871: 
01:00204B92 6100FE16        	  1872: 	BSR		LAB_15FF			* else interpret BASIC code from (a5)
                            	  1873: 
                            	  1874: * the IF was executed and there may be a following ELSE so the code needs to return
                            	  1875: * here to check and ignore the ELSE if present
                            	  1876: 
01:00204B96 1015            	  1877: 	MOVE.b	(a5),d0			* get the next basic byte
01:00204B98 B03C00A9        	  1878: 	CMP.b		#TK_ELSE,d0			* compare it with the token for ELSE
01:00204B9C 6794            	  1879: 	BEQ		LAB_DATA			* if ELSE ignore the following statement
                            	  1880: 
                            	  1881: * there was no ELSE so continue execution of IF <expr> THEN <stat> [: <stat>]. any
                            	  1882: * following ELSE will, correctly, cause a syntax error
                            	  1883: 
01:00204B9E 4E75            	  1884: 	RTS						* else return to interpreter inner loop
                            	  1885: 
                            	  1886: * perform ELSE after IF
                            	  1887: 
                            	  1888: LAB_174E
01:00204BA0 101D            	  1889: 	MOVE.b	(a5)+,d0			* faster increment past THEN
01:00204BA2 76A9            	  1890: 	MOVEQ		#-87,d3			* set search for ELSE token
01:00204BA4 788B            	  1891: 	MOVEQ		#-117,d4			* set search for IF token
01:00204BA6 7A00            	  1892: 	MOVEQ		#0,d5				* clear the nesting depth
                            	  1893: LAB_1750
01:00204BA8 101D            	  1894: 	MOVE.b	(a5)+,d0			* get next BASIC byte & increment ptr
01:00204BAA 6720            	  1895: 	BEQ.s		LAB_1754			* if EOL correct the pointer and return
                            	  1896: 
01:00204BAC B004            	  1897: 	CMP.b		d4,d0				* compare with "IF" token
01:00204BAE 6604            	  1898: 	BNE.s		LAB_1752			* skip if not nested IF
                            	  1899: 
01:00204BB0 5245            	  1900: 	ADDQ.w	#1,d5				* else increment the nesting depth ..
01:00204BB2 60F4            	  1901: 	BRA.s		LAB_1750			* .. and continue looking
                            	  1902: 
                            	  1903: LAB_1752
01:00204BB4 B003            	  1904: 	CMP.b		d3,d0				* compare with ELSE token
01:00204BB6 66F0            	  1905: 	BNE.s		LAB_1750			* if not ELSE continue looking
                            	  1906: 
                            	  1907: LAB_1756
01:00204BB8 51CDFFEE        	  1908: 	DBF		d5,LAB_1750			* loop if still nested
                            	  1909: 
                            	  1910: * found the matching ELSE, now do <{n|statement}>
                            	  1911: 
01:00204BBC 610005F0        	  1912: 	BSR		LAB_GBYT			* scan memory
01:00204BC0 6500FED8        	  1913: 	BCS		LAB_GOTO			* if numeric do GOTO n
                            	  1914: 							* code will return to the interpreter loop
                            	  1915: 							* at the tail end of the GOTO <n>
                            	  1916: 
01:00204BC4 6000FDE4        	  1917: 	BRA		LAB_15FF			* else interpret BASIC code from (a5)
                            	  1918: 							* code will return to the interpreter loop
                            	  1919: 							* at the tail end of the <statement>
                            	  1920: 
                            	  1921: 
                            	  1922: *************************************************************************************
                            	  1923: *
                            	  1924: * perform REM, skip (rest of) line
                            	  1925: 
                            	  1926: LAB_REM
01:00204BC8 4A1D            	  1927: 	TST.b		(a5)+				* test byte & increment pointer
01:00204BCA 66FC            	  1928: 	BNE.s		LAB_REM			* loop if not EOL
                            	  1929: 
                            	  1930: LAB_1754
01:00204BCC 534D            	  1931: 	SUBQ.w	#1,a5				* correct the execute pointer
01:00204BCE 4E75            	  1932: 	RTS
                            	  1933: 
                            	  1934: 
                            	  1935: *************************************************************************************
                            	  1936: *
                            	  1937: * perform ON
                            	  1938: 
                            	  1939: LAB_ON
01:00204BD0 61000F3A        	  1940: 	BSR		LAB_GTBY			* get byte parameter, result in d0 and Itemp
01:00204BD4 1400            	  1941: 	MOVE.b	d0,d2				* copy byte
01:00204BD6 610005D6        	  1942: 	BSR		LAB_GBYT			* restore BASIC byte
01:00204BDA 3F00            	  1943: 	MOVE.w	d0,-(sp)			* push GOTO/GOSUB token
01:00204BDC B03C008D        	  1944: 	CMP.b		#TK_GOSUB,d0		* compare with GOSUB token
01:00204BE0 6708            	  1945: 	BEQ.s		LAB_176C			* branch if GOSUB
                            	  1946: 
01:00204BE2 B03C0089        	  1947: 	CMP.b		#TK_GOTO,d0			* compare with GOTO token
01:00204BE6 6600F988        	  1948: 	BNE		LAB_SNER			* if not GOTO do syntax error, then warm start
                            	  1949: 
                            	  1950: * next character was GOTO or GOSUB
                            	  1951: 
                            	  1952: LAB_176C
01:00204BEA 5302            	  1953: 	SUBQ.b	#1,d2				* decrement index (byte value)
01:00204BEC 6606            	  1954: 	BNE.s		LAB_1773			* branch if not zero
                            	  1955: 
01:00204BEE 301F            	  1956: 	MOVE.w	(sp)+,d0			* pull GOTO/GOSUB token
01:00204BF0 6000FDBC        	  1957: 	BRA		LAB_1602			* go execute it
                            	  1958: 
                            	  1959: LAB_1773
01:00204BF4 610005B6        	  1960: 	BSR		LAB_IGBY			* increment & scan memory
01:00204BF8 610A            	  1961: 	BSR.s		LAB_GFPN			* get fixed-point number into temp integer & d1
                            	  1962: 							* (skip this n)
01:00204BFA B03C002C        	  1963: 	CMP.b		#$2C,d0			* compare next character with ","
01:00204BFE 67EA            	  1964: 	BEQ.s		LAB_176C			* loop if ","
                            	  1965: 
01:00204C00 301F            	  1966: 	MOVE.w	(sp)+,d0			* pull GOTO/GOSUB token (run out of options)
01:00204C02 4E75            	  1967: 	RTS						* and exit
                            	  1968: 
                            	  1969: 
                            	  1970: *************************************************************************************
                            	  1971: *
                            	  1972: * get fixed-point number into temp integer & d1
                            	  1973: * interpret number from (a5), leave (a5) pointing to byte after #
                            	  1974: 
                            	  1975: LAB_GFPN
01:00204C04 7200            	  1976: 	MOVEQ		#$00,d1			* clear integer register
01:00204C06 2001            	  1977: 	MOVE.l	d1,d0				* clear d0
01:00204C08 610005A4        	  1978: 	BSR		LAB_GBYT			* scan memory, Cb=1 if "0"-"9", & get byte
01:00204C0C 642E            	  1979: 	BCC.s		LAB_1786			* return if carry clear, chr was not "0"-"9"
                            	  1980: 
01:00204C0E 2F02            	  1981: 	MOVE.l	d2,-(sp)			* save d2
                            	  1982: LAB_1785
01:00204C10 2401            	  1983: 	MOVE.l	d1,d2				* copy integer register
01:00204C12 D281            	  1984: 	ADD.l		d1,d1				* *2
01:00204C14 6500F95A        	  1985: 	BCS		LAB_SNER			* if overflow do syntax error, then warm start
                            	  1986: 
01:00204C18 D281            	  1987: 	ADD.l		d1,d1				* *4
01:00204C1A 6500F954        	  1988: 	BCS		LAB_SNER			* if overflow do syntax error, then warm start
                            	  1989: 
01:00204C1E D282            	  1990: 	ADD.l		d2,d1				* *1 + *4
01:00204C20 6500F94E        	  1991: 	BCS		LAB_SNER			* if overflow do syntax error, then warm start
                            	  1992: 
01:00204C24 D281            	  1993: 	ADD.l		d1,d1				* *10
01:00204C26 6500F948        	  1994: 	BCS		LAB_SNER			* if overflow do syntax error, then warm start
                            	  1995: 
01:00204C2A 903C0030        	  1996: 	SUB.b		#$30,d0			* subtract $30 from byte
01:00204C2E D280            	  1997: 	ADD.l		d0,d1				* add to integer register, the top 24 bits are
                            	  1998: 							* always clear
01:00204C30 6900F93E        	  1999: 	BVS		LAB_SNER			* if overflow do syntax error, then warm start
                            	  2000: 							* this makes the maximum line number 2147483647
01:00204C34 61000576        	  2001: 	BSR		LAB_IGBY			* increment & scan memory
01:00204C38 65D6            	  2002: 	BCS.s		LAB_1785			* loop for next character if "0"-"9"
                            	  2003: 
01:00204C3A 241F            	  2004: 	MOVE.l	(sp)+,d2			* restore d2
                            	  2005: LAB_1786
01:00204C3C 2741042A        	  2006: 	MOVE.l	d1,Itemp(a3)		* save Itemp
01:00204C40 4E75            	  2007: 	RTS
                            	  2008: 
                            	  2009: 
                            	  2010: *************************************************************************************
                            	  2011: *
                            	  2012: * perform DEC
                            	  2013: 
                            	  2014: LAB_DEC
01:00204C42 3F3C8180        	  2015: 	MOVE.w	#$8180,-(sp)		* set -1 sign/exponent
01:00204C46 600A            	  2016: 	BRA.s		LAB_17B7			* go do DEC
                            	  2017: 
                            	  2018: 
                            	  2019: *************************************************************************************
                            	  2020: *
                            	  2021: * perform INC
                            	  2022: 
                            	  2023: LAB_INC
01:00204C48 3F3C8100        	  2024: 	MOVE.w	#$8100,-(sp)		* set 1 sign/exponent
01:00204C4C 6004            	  2025: 	BRA.s		LAB_17B7			* go do INC
                            	  2026: 
                            	  2027: 							* was "," so another INCR variable to do
                            	  2028: LAB_17B8
01:00204C4E 6100055C        	  2029: 	BSR		LAB_IGBY			* increment and scan memory
                            	  2030: LAB_17B7
01:00204C52 61000766        	  2031: 	BSR		LAB_GVAR			* get variable address in a0
                            	  2032: 
                            	  2033: * if you want a non existant variable to return a null value then set the novar
                            	  2034: * value at the top of this file to some non zero value
                            	  2035: 
                            	  2036:  ifne	novar
                            	  2037: 
                            	  2038: 	BEQ.s		LAB_INCT			* if variable not found skip the inc/dec
                            	  2039: 
                            	  2040:  endc
                            	  2041: 
01:00204C56 4A2B05B5        	  2042: 	TST.b		Dtypef(a3)			* test data type, $80=string, $40=integer,
                            	  2043: 							* $00=float
01:00204C5A 6B00F8E8        	  2044: 	BMI		LAB_TMER			* if string do "Type mismatch" error/warm start
                            	  2045: 
01:00204C5E 6636            	  2046: 	BNE.s		LAB_INCI			* go do integer INC/DEC
                            	  2047: 
01:00204C60 27480472        	  2048: 	MOVE.l	a0,Lvarpl(a3)		* save var address
01:00204C64 610012FE        	  2049: 	BSR		LAB_UFAC			* unpack memory (a0) into FAC1
01:00204C68 277C800000000598	  2050: 	MOVE.l	#$80000000,FAC2_m(a3)	* set FAC2 mantissa for 1
01:00204C70 3017            	  2051: 	MOVE.w	(sp),d0			* move exponent & sign to d0
01:00204C72 3740059C        	  2052: 	MOVE.w	d0,FAC2_e(a3)		* move exponent & sign to FAC2
01:00204C76 176B0595059E    	  2053: 	MOVE.b	FAC1_s(a3),FAC_sc(a3)	* make sign compare = FAC1 sign
01:00204C7C B12B059E        	  2054: 	EOR.b		d0,FAC_sc(a3)		* make sign compare (FAC1_s EOR FAC2_s)
01:00204C80 61001000        	  2055: 	BSR		LAB_ADD			* add FAC2 to FAC1
01:00204C84 610012FA        	  2056: 	BSR		LAB_PFAC			* pack FAC1 into variable (Lvarpl)
                            	  2057: LAB_INCT
01:00204C88 61000524        	  2058: 	BSR		LAB_GBYT			* scan memory
01:00204C8C 0C00002C        	  2059: 	CMPI.b	#$2C,d0			* compare with ","
01:00204C90 67BC            	  2060: 	BEQ.s		LAB_17B8			* continue if "," (another variable to do)
                            	  2061: 
01:00204C92 544F            	  2062: 	ADDQ.w	#2,sp				* else dump sign & exponent
01:00204C94 4E75            	  2063: 	RTS
                            	  2064: 
                            	  2065: LAB_INCI
01:00204C96 4A2F0001        	  2066: 	TST.b		1(sp)				* test sign
01:00204C9A 6604            	  2067: 	BNE.s		LAB_DECI			* branch if DEC
                            	  2068: 
01:00204C9C 5290            	  2069: 	ADDQ.l	#1,(a0)			* increment variable
01:00204C9E 60E8            	  2070: 	BRA.s		LAB_INCT			* go scan for more
                            	  2071: 
                            	  2072: LAB_DECI
01:00204CA0 5390            	  2073: 	SUBQ.l	#1,(a0)			* decrement variable
01:00204CA2 60E4            	  2074: 	BRA.s		LAB_INCT			* go scan for more
                            	  2075: 
                            	  2076: 
                            	  2077: *************************************************************************************
                            	  2078: *
                            	  2079: * perform LET
                            	  2080: 
                            	  2081: LAB_LET
01:00204CA4 61000710        	  2082: 	BSR		LAB_SVAR			* search for or create a variable
                            	  2083: 							* return the variable address in a0
01:00204CA8 27480472        	  2084: 	MOVE.l	a0,Lvarpl(a3)		* save variable address
01:00204CAC 1F2B05B5        	  2085: 	MOVE.b	Dtypef(a3),-(sp)		* push var data type, $80=string, $40=integer,
                            	  2086: 							* $00=float
01:00204CB0 70BD            	  2087: 	MOVEQ		#TK_EQUAL-$100,d0		* get = token
01:00204CB2 610004F0        	  2088: 	BSR		LAB_SCCA			* scan for CHR$(d0), else do syntax error/warm
                            	  2089: 							* start
01:00204CB6 61000394        	  2090: 	BSR		LAB_EVEX			* evaluate expression
01:00204CBA 102B05B5        	  2091: 	MOVE.b	Dtypef(a3),d0		* copy expression data type
01:00204CBE 175F05B5        	  2092: 	MOVE.b	(sp)+,Dtypef(a3)		* pop variable data type
01:00204CC2 E318            	  2093: 	ROL.b		#1,d0				* set carry if expression type = string
01:00204CC4 61000372        	  2094: 	BSR		LAB_CKTM			* type match check, set C for string
01:00204CC8 670012B6        	  2095: 	BEQ		LAB_PFAC			* if number pack FAC1 into variable Lvarpl & RET
                            	  2096: 
                            	  2097: * string LET
                            	  2098: 
                            	  2099: LAB_17D5
01:00204CCC 246B0472        	  2100: 	MOVEA.l	Lvarpl(a3),a2		* get pointer to variable
                            	  2101: LAB_17D6
01:00204CD0 206B0590        	  2102: 	MOVEA.l	FAC1_m(a3),a0		* get descriptor pointer
01:00204CD4 2250            	  2103: 	MOVEA.l	(a0),a1			* get string pointer
01:00204CD6 B3EB0446        	  2104: 	CMP.l		Sstorl(a3),a1		* compare string memory start with string
                            	  2105: 							* pointer
01:00204CDA 6516            	  2106: 	BCS.s		LAB_1811			* if it was in program memory assign the value
                            	  2107: 							* and exit
                            	  2108: 
01:00204CDC B1EB0432        	  2109: 	CMPA.l	Sfncl(a3),a0		* compare functions start with descriptor
                            	  2110: 							* pointer
01:00204CE0 6510            	  2111: 	BCS.s		LAB_1811			* branch if >= (string is on stack)
                            	  2112: 
                            	  2113: 							* string is variable$ make space and copy string
                            	  2114: LAB_1810
01:00204CE2 7200            	  2115: 	MOVEQ		#0,d1				* clear length
01:00204CE4 32280004        	  2116: 	MOVE.w	4(a0),d1			* get string length
01:00204CE8 2050            	  2117: 	MOVEA.l	(a0),a0			* get string pointer
01:00204CEA 61000B02        	  2118: 	BSR		LAB_20C9			* copy string
01:00204CEE 206B0590        	  2119: 	MOVEA.l	FAC1_m(a3),a0		* get descriptor pointer back
                            	  2120: 							* clean stack & assign value to string variable
                            	  2121: LAB_1811
01:00204CF2 B9C8            	  2122: 	CMPA.l	a0,a4				* is string on the descriptor stack
01:00204CF4 6602            	  2123: 	BNE.s		LAB_1813			* skip pop if not
                            	  2124: 
01:00204CF6 5C4C            	  2125: 	ADDQ.w	#$06,a4			* else update stack pointer
                            	  2126: LAB_1813
01:00204CF8 24D8            	  2127: 	MOVE.l	(a0)+,(a2)+			* save pointer to variable
01:00204CFA 3490            	  2128: 	MOVE.w	(a0),(a2)			* save length to variable
                            	  2129: RTS_008
01:00204CFC 4E75            	  2130: 	RTS
                            	  2131: 
                            	  2132: 
                            	  2133: *************************************************************************************
                            	  2134: *
                            	  2135: * perform GET
                            	  2136: 
                            	  2137: LAB_GET
01:00204CFE 610006B6        	  2138: 	BSR		LAB_SVAR			* search for or create a variable
                            	  2139: 							* return the variable address in a0
01:00204D02 27480472        	  2140: 	MOVE.l	a0,Lvarpl(a3)		* save variable address as GET variable
01:00204D06 4A2B05B5        	  2141: 	TST.b		Dtypef(a3)			* test data type, $80=string, $40=integer,
                            	  2142: 							* $00=float
01:00204D0A 6B0C            	  2143: 	BMI.s		LAB_GETS			* go get string character
                            	  2144: 
                            	  2145: 							* was numeric get
01:00204D0C 61001DD0        	  2146: 	BSR		INGET				* get input byte
01:00204D10 610009B8        	  2147: 	BSR		LAB_1FD0			* convert d0 to unsigned byte in FAC1
01:00204D14 6000126A        	  2148: 	BRA		LAB_PFAC			* pack FAC1 into variable (Lvarpl) & return
                            	  2149: 
                            	  2150: LAB_GETS
01:00204D18 7200            	  2151: 	MOVEQ		#$00,d1			* assume no byte
01:00204D1A 2041            	  2152: 	MOVE.l	d1,a0				* assume null string
01:00204D1C 61001DC0        	  2153: 	BSR		INGET				* get input byte
01:00204D20 6408            	  2154: 	BCC.s		LAB_NoSt			* branch if no byte received
                            	  2155: 
01:00204D22 7201            	  2156: 	MOVEQ		#$01,d1			* string is single byte
01:00204D24 61000AFA        	  2157: 	BSR		LAB_2115			* make string space d1 bytes long
                            	  2158: 							* return a0 = pointer, other registers unchanged
                            	  2159: 
01:00204D28 1080            	  2160: 	MOVE.b	d0,(a0)			* save byte in string (byte IS string!)
                            	  2161: LAB_NoSt
01:00204D2A 61000ADA        	  2162: 	BSR		LAB_RTST			* push string on descriptor stack
                            	  2163: 							* a0 = pointer, d1 = length
                            	  2164: 
01:00204D2E 609C            	  2165: 	BRA.s		LAB_17D5			* do string LET & return
                            	  2166: 
                            	  2167: 
                            	  2168: *************************************************************************************
                            	  2169: *
                            	  2170: * PRINT
                            	  2171: 
                            	  2172: LAB_1829
01:00204D30 610000B4        	  2173: 	BSR		LAB_18C6			* print string from stack
                            	  2174: LAB_182C
01:00204D34 61000478        	  2175: 	BSR		LAB_GBYT			* scan memory
                            	  2176: 
                            	  2177: * perform PRINT
                            	  2178: 
                            	  2179: LAB_PRINT
01:00204D38 674A            	  2180: 	BEQ.s		LAB_CRLF			* if nothing following just print CR/LF
                            	  2181: 
                            	  2182: LAB_1831
01:00204D3A B03C00A8        	  2183: 	CMP.b		#TK_TAB,d0			* compare with TAB( token
01:00204D3E 6764            	  2184: 	BEQ.s		LAB_18A2			* go do TAB/SPC
                            	  2185: 
01:00204D40 B03C00AC        	  2186: 	CMP.b		#TK_SPC,d0			* compare with SPC( token
01:00204D44 675E            	  2187: 	BEQ.s		LAB_18A2			* go do TAB/SPC
                            	  2188: 
01:00204D46 B03C002C        	  2189: 	CMP.b		#',',d0			* compare with ","
01:00204D4A 6740            	  2190: 	BEQ.s		LAB_188B			* go do move to next TAB mark
                            	  2191: 
01:00204D4C B03C003B        	  2192: 	CMP.b		#';',d0			* compare with ";"
01:00204D50 67000086        	  2193: 	BEQ		LAB_18BD			* if ";" continue with PRINT processing
                            	  2194: 
01:00204D54 610002F6        	  2195: 	BSR		LAB_EVEX			* evaluate expression
01:00204D58 4A2B05B5        	  2196: 	TST.b		Dtypef(a3)			* test data type, $80=string, $40=integer,
                            	  2197: 							* $00=float
01:00204D5C 6BD2            	  2198: 	BMI.s		LAB_1829			* branch if string
                            	  2199: 
                            	  2200: ** replace the two lines above with this code
                            	  2201: 
                            	  2202: **	MOVE.b	Dtypef(a3),d0		* get data type flag, $80=string, $00=numeric
                            	  2203: **	BMI.s		LAB_1829			* branch if string
                            	  2204: 
01:00204D5E 6100139E        	  2205: 	BSR		LAB_2970			* convert FAC1 to string
01:00204D62 61000A5C        	  2206: 	BSR		LAB_20AE			* print " terminated string to FAC1 stack
                            	  2207: 
                            	  2208: * don't check fit if terminal width byte is zero
                            	  2209: 
01:00204D66 7000            	  2210: 	MOVEQ		#0,d0				* clear d0
01:00204D68 102B05E6        	  2211: 	MOVE.b	TWidth(a3),d0		* get terminal width byte
01:00204D6C 670C            	  2212: 	BEQ.s		LAB_185E			* skip check if zero
                            	  2213: 
01:00204D6E 902C0007        	  2214: 	SUB.b		7(a4),d0			* subtract string length
01:00204D72 902B05E5        	  2215: 	SUB.b		TPos(a3),d0			* subtract terminal position
01:00204D76 6402            	  2216: 	BCC.s		LAB_185E			* branch if less than terminal width
                            	  2217: 
01:00204D78 610A            	  2218: 	BSR.s		LAB_CRLF			* else print CR/LF
                            	  2219: LAB_185E
01:00204D7A 616A            	  2220: 	BSR.s		LAB_18C6			* print string from stack
01:00204D7C 60B6            	  2221: 	BRA.s		LAB_182C			* always go continue processing line
                            	  2222: 
                            	  2223: 
                            	  2224: *************************************************************************************
                            	  2225: *
                            	  2226: * CR/LF return to BASIC from BASIC input handler
                            	  2227: * leaves a0 pointing to the buffer start
                            	  2228: 
                            	  2229: LAB_1866
01:00204D7E 11BC00001000    	  2230: 	MOVE.b	#$00,(a0,d1.w)		* null terminate input
                            	  2231: 
                            	  2232: * print CR/LF
                            	  2233: 
                            	  2234: LAB_CRLF
01:00204D84 700D            	  2235: 	MOVEQ		#$0D,d0			* load [CR]
01:00204D86 6174            	  2236: 	BSR.s		LAB_PRNA			* go print the character
01:00204D88 700A            	  2237: 	MOVEQ		#$0A,d0			* load [LF]
01:00204D8A 6070            	  2238: 	BRA.s		LAB_PRNA			* go print the character & return
                            	  2239: 
                            	  2240: LAB_188B
01:00204D8C 142B05E5        	  2241: 	MOVE.b	TPos(a3),d2			* get terminal position
01:00204D90 B42B05E7        	  2242: 	CMP.b		Iclim(a3),d2		* compare with input column limit
01:00204D94 6504            	  2243: 	BCS.s		LAB_1898			* branch if less than Iclim
                            	  2244: 
01:00204D96 61EC            	  2245: 	BSR.s		LAB_CRLF			* else print CR/LF (next line)
01:00204D98 603E            	  2246: 	BRA.s		LAB_18BD			* continue with PRINT processing
                            	  2247: 
                            	  2248: LAB_1898
01:00204D9A 942B05E2        	  2249: 	SUB.b		TabSiz(a3),d2		* subtract TAB size
01:00204D9E 64FA            	  2250: 	BCC.s		LAB_1898			* loop if result was >= 0
                            	  2251: 
01:00204DA0 4402            	  2252: 	NEG.b		d2				* twos complement it
01:00204DA2 6022            	  2253: 	BRA.s		LAB_18B7			* print d2 spaces
                            	  2254: 
                            	  2255: 							* do TAB/SPC
                            	  2256: LAB_18A2
01:00204DA4 3F00            	  2257: 	MOVE.w	d0,-(sp)			* save token
01:00204DA6 61000D60        	  2258: 	BSR		LAB_SGBY			* increment and get byte, result in d0 and Itemp
01:00204DAA 3400            	  2259: 	MOVE.w	d0,d2				* copy byte
01:00204DAC 61000400        	  2260: 	BSR		LAB_GBYT			* get basic byte back
01:00204DB0 B03C0029        	  2261: 	CMP.b		#$29,d0			* is next character ")"
01:00204DB4 6600F7BA        	  2262: 	BNE		LAB_SNER			* if not do syntax error, then warm start
                            	  2263: 
01:00204DB8 301F            	  2264: 	MOVE.w	(sp)+,d0			* get token back
01:00204DBA B03C00A8        	  2265: 	CMP.b		#TK_TAB,d0			* was it TAB ?
01:00204DBE 6606            	  2266: 	BNE.s		LAB_18B7			* branch if not (was SPC)
                            	  2267: 
                            	  2268: 							* calculate TAB offset
01:00204DC0 942B05E5        	  2269: 	SUB.b		TPos(a3),d2			* subtract terminal position
01:00204DC4 6312            	  2270: 	BLS.s		LAB_18BD			* branch if result was <= 0
                            	  2271: 							* can't TAB backwards or already there
                            	  2272: 
                            	  2273: 							* print d2.b spaces
                            	  2274: LAB_18B7
01:00204DC6 7000            	  2275: 	MOVEQ		#0,d0				* clear longword
01:00204DC8 5300            	  2276: 	SUBQ.b	#1,d0				* make d0 = $FF
01:00204DCA C480            	  2277: 	AND.l		d0,d2				* mask for byte only
01:00204DCC 670A            	  2278: 	BEQ.s		LAB_18BD			* branch if zero
                            	  2279: 
01:00204DCE 7020            	  2280: 	MOVEQ		#$20,d0			* load " "
01:00204DD0 5302            	  2281: 	SUBQ.b	#1,d2				* adjust for DBF loop
                            	  2282: LAB_18B8
01:00204DD2 6128            	  2283: 	BSR.s		LAB_PRNA			* go print
01:00204DD4 51CAFFFC        	  2284: 	DBF		d2,LAB_18B8			* decrement count and loop if not all done
                            	  2285: 
                            	  2286: 							* continue with PRINT processing
                            	  2287: LAB_18BD
01:00204DD8 610003D2        	  2288: 	BSR		LAB_IGBY			* increment & scan memory
01:00204DDC 6600FF5C        	  2289: 	BNE		LAB_1831			* if byte continue executing PRINT
                            	  2290: 
01:00204DE0 4E75            	  2291: 	RTS						* exit if nothing more to print
                            	  2292: 
                            	  2293: 
                            	  2294: *************************************************************************************
                            	  2295: *
                            	  2296: * print null terminated string from a0
                            	  2297: 
                            	  2298: LAB_18C3
01:00204DE2 610009DC        	  2299: 	BSR		LAB_20AE			* print terminated string to FAC1/stack
                            	  2300: 
                            	  2301: * print string from stack
                            	  2302: 
                            	  2303: LAB_18C6
01:00204DE6 61000BC4        	  2304: 	BSR		LAB_22B6			* pop string off descriptor stack or from memory
                            	  2305: 							* returns with d0 = length, a0 = pointer
01:00204DEA 670C            	  2306: 	BEQ.s		RTS_009			* exit (RTS) if null string
                            	  2307: 
01:00204DEC 3200            	  2308: 	MOVE.w	d0,d1				* copy length & set Z flag
01:00204DEE 5341            	  2309: 	SUBQ.w	#1,d1				* -1 for BF loop
                            	  2310: LAB_18CD
01:00204DF0 1018            	  2311: 	MOVE.b	(a0)+,d0			* get byte from string
01:00204DF2 6108            	  2312: 	BSR.s		LAB_PRNA			* go print the character
01:00204DF4 51C9FFFA        	  2313: 	DBF		d1,LAB_18CD			* decrement count and loop if not done yet
                            	  2314: 
                            	  2315: RTS_009
01:00204DF8 4E75            	  2316: 	RTS
                            	  2317: 
                            	  2318: 
                            	  2319: *************************************************************************************
                            	  2320: *
                            	  2321: * print "?" character
                            	  2322: 
                            	  2323: LAB_18E3
01:00204DFA 703F            	  2324: 	MOVEQ		#$3F,d0			* load "?" character
                            	  2325: 
                            	  2326: 
                            	  2327: *************************************************************************************
                            	  2328: *
                            	  2329: * print character in d0, includes the null handler and infinite line length code
                            	  2330: * changes no registers
                            	  2331: 
                            	  2332: LAB_PRNA
01:00204DFC 2F01            	  2333: 	MOVE.l	d1,-(sp)			* save d1
01:00204DFE B03C0020        	  2334: 	CMP.b		#$20,d0			* compare with " "
01:00204E02 6528            	  2335: 	BCS.s		LAB_18F9			* branch if less, non printing character
                            	  2336: 
                            	  2337: 							* don't check fit if terminal width byte is zero
01:00204E04 122B05E6        	  2338: 	MOVE.b	TWidth(a3),d1		* get terminal width
01:00204E08 6610            	  2339: 	BNE.s		LAB_18F0			* branch if not zero (not infinite length)
                            	  2340: 
                            	  2341: 							* is "infinite line" so check TAB position
01:00204E0A 122B05E5        	  2342: 	MOVE.b	TPos(a3),d1			* get position
01:00204E0E 922B05E2        	  2343: 	SUB.b		TabSiz(a3),d1		* subtract TAB size
01:00204E12 6614            	  2344: 	BNE.s		LAB_18F7			* skip reset if different
                            	  2345: 
01:00204E14 174105E5        	  2346: 	MOVE.b	d1,TPos(a3)			* else reset position
01:00204E18 600E            	  2347: 	BRA.s		LAB_18F7			* go print character
                            	  2348: 
                            	  2349: LAB_18F0
01:00204E1A B22B05E5        	  2350: 	CMP.b		TPos(a3),d1			* compare with terminal character position
01:00204E1E 6608            	  2351: 	BNE.s		LAB_18F7			* branch if not at end of line
                            	  2352: 
01:00204E20 2F00            	  2353: 	MOVE.l	d0,-(sp)			* save d0
01:00204E22 6100FF60        	  2354: 	BSR		LAB_CRLF			* else print CR/LF
01:00204E26 201F            	  2355: 	MOVE.l	(sp)+,d0			* restore d0
                            	  2356: LAB_18F7
01:00204E28 522B05E5        	  2357: 	ADDQ.b	#$01,TPos(a3)		* increment terminal position
                            	  2358: LAB_18F9
01:00204E2C 4EAB0412        	  2359: 	JSR		V_OUTP(a3)			* output byte via output vector
01:00204E30 B03C000D        	  2360: 	CMP.b		#$0D,d0			* compare with [CR]
01:00204E34 6618            	  2361: 	BNE.s		LAB_188A			* branch if not [CR]
                            	  2362: 
                            	  2363: 							* else print nullct nulls after the [CR]
01:00204E36 7200            	  2364: 	MOVEQ		#$00,d1			* clear d1
01:00204E38 122B05E4        	  2365: 	MOVE.b	Nullct(a3),d1		* get null count
01:00204E3C 670C            	  2366: 	BEQ.s		LAB_1886			* branch if no nulls
                            	  2367: 
01:00204E3E 7000            	  2368: 	MOVEQ		#$00,d0			* load [NULL]
                            	  2369: LAB_1880
01:00204E40 4EAB0412        	  2370: 	JSR		V_OUTP(a3)			* go print the character
01:00204E44 51C9FFFA        	  2371: 	DBF		d1,LAB_1880			* decrement count and loop if not all done
                            	  2372: 
01:00204E48 700D            	  2373: 	MOVEQ		#$0D,d0			* restore the character
                            	  2374: LAB_1886
01:00204E4A 174105E5        	  2375: 	MOVE.b	d1,TPos(a3)			* clear terminal position
                            	  2376: LAB_188A
01:00204E4E 221F            	  2377: 	MOVE.l	(sp)+,d1			* restore d1
01:00204E50 4E75            	  2378: 	RTS
                            	  2379: 
                            	  2380: 
                            	  2381: *************************************************************************************
                            	  2382: *
                            	  2383: * handle bad input data
                            	  2384: 
                            	  2385: LAB_1904
01:00204E52 2A5F            	  2386: 	MOVEA.l	(sp)+,a5			* restore execute pointer
01:00204E54 4A2B05E0        	  2387: 	TST.b		Imode(a3)			* test input mode flag, $00=INPUT, $98=READ
01:00204E58 6A0A            	  2388: 	BPL.s		LAB_1913			* branch if INPUT (go do redo)
                            	  2389: 
01:00204E5A 276B045E0452    	  2390: 	MOVE.l	Dlinel(a3),Clinel(a3)	* save DATA line as current line
01:00204E60 6000F6E2        	  2391: 	BRA		LAB_TMER			* do type mismatch error, then warm start
                            	  2392: 
                            	  2393: 							* mode was INPUT
                            	  2394: LAB_1913
01:00204E64 41FA2A52        	  2395: 	LEA		LAB_REDO(pc),a0		* point to redo message
01:00204E68 6100FF78        	  2396: 	BSR		LAB_18C3			* print null terminated string from memory
01:00204E6C 2A6B045A        	  2397: 	MOVEA.l	Cpntrl(a3),a5		* save continue pointer as BASIC execute pointer
01:00204E70 4E75            	  2398: 	RTS
                            	  2399: 
                            	  2400: 
                            	  2401: *************************************************************************************
                            	  2402: *
                            	  2403: * perform INPUT
                            	  2404: 
                            	  2405: LAB_INPUT
01:00204E72 6100085E        	  2406: 	BSR		LAB_CKRN			* check not direct (back here if ok)
01:00204E76 B03C0022        	  2407: 	CMP.b		#'"',d0			* compare the next byte with open quote
01:00204E7A 660E            	  2408: 	BNE.s		LAB_1934			* if no prompt string just go get the input
                            	  2409: 
01:00204E7C 61000306        	  2410: 	BSR		LAB_1BC1			* print "..." string
01:00204E80 703B            	  2411: 	MOVEQ		#';',d0			* set the search character to ";"
01:00204E82 61000320        	  2412: 	BSR		LAB_SCCA			* scan for CHR$(d0), else do syntax error/warm
                            	  2413: 							* start
01:00204E86 6100FF5E        	  2414: 	BSR		LAB_18C6			* print string from Sutill/Sutilh
                            	  2415: 							* finished the prompt, now read the data
                            	  2416: LAB_1934
01:00204E8A 6100F80E        	  2417: 	BSR		LAB_INLN			* print "? " and get BASIC input
                            	  2418: 							* return a0 pointing to the buffer start
01:00204E8E 7000            	  2419: 	MOVEQ		#0,d0				* flag INPUT
                            	  2420: 
                            	  2421: * if you don't want a null response to INPUT to break the program then set the nobrk
                            	  2422: * value at the top of this file to some non zero value
                            	  2423: 
                            	  2424:  ifne	nobrk
                            	  2425: 
                            	  2426: 	BRA.s		LAB_1953			* go handle the input
                            	  2427: 
                            	  2428:  endc
                            	  2429: 
                            	  2430: * if you do want a null response to INPUT to break the program then leave the nobrk
                            	  2431: * value at the top of this file set to zero
                            	  2432: 
                            	  2433:  ifeq	nobrk
                            	  2434: 
01:00204E90 4A10            	  2435: 	TST.b		(a0)				* test first byte from buffer
01:00204E92 660A            	  2436: 	BNE.s		LAB_1953			* branch if not null input
                            	  2437: 
01:00204E94 6000FB5E        	  2438: 	BRA		LAB_1647			* go do BREAK exit
                            	  2439: 
                            	  2440:  endc
                            	  2441: 
                            	  2442: 
                            	  2443: *************************************************************************************
                            	  2444: *
                            	  2445: * perform READ
                            	  2446: 
                            	  2447: LAB_READ
01:00204E98 206B0462        	  2448: 	MOVEA.l	Dptrl(a3),a0		* get the DATA pointer
01:00204E9C 7098            	  2449: 	MOVEQ		#$98-$100,d0		* flag READ
                            	  2450: LAB_1953
01:00204E9E 174005E0        	  2451: 	MOVE.b	d0,Imode(a3)		* set input mode flag, $00=INPUT, $98=READ
01:00204EA2 27480466        	  2452: 	MOVE.l	a0,Rdptrl(a3)		* save READ pointer
                            	  2453: 
                            	  2454: 							* READ or INPUT the next variable from list
                            	  2455: LAB_195B
01:00204EA6 6100050E        	  2456: 	BSR		LAB_SVAR			* search for or create a variable
                            	  2457: 							* return the variable address in a0
01:00204EAA 27480472        	  2458: 	MOVE.l	a0,Lvarpl(a3)		* save variable address as LET variable
01:00204EAE 2F0D            	  2459: 	MOVE.l	a5,-(sp)			* save BASIC execute pointer
                            	  2460: LAB_1961
01:00204EB0 2A6B0466        	  2461: 	MOVEA.l	Rdptrl(a3),a5		* set READ pointer as BASIC execute pointer
01:00204EB4 610002F8        	  2462: 	BSR		LAB_GBYT			* scan memory
01:00204EB8 661E            	  2463: 	BNE.s		LAB_1986			* if not null go get the value
                            	  2464: 
                            	  2465: 							* the pointer was to a null entry
01:00204EBA 4A2B05E0        	  2466: 	TST.b		Imode(a3)			* test input mode flag, $00=INPUT, $98=READ
01:00204EBE 6B72            	  2467: 	BMI.s		LAB_19DD			* branch if READ (go find the next statement)
                            	  2468: 
                            	  2469: 							* else the mode was INPUT so get more
01:00204EC0 6100FF38        	  2470: 	BSR		LAB_18E3			* print a "?" character
01:00204EC4 6100F7D4        	  2471: 	BSR		LAB_INLN			* print "? " and get BASIC input
                            	  2472: 							* return a0 pointing to the buffer start
                            	  2473: 
                            	  2474: * if you don't want a null response to INPUT to break the program then set the nobrk
                            	  2475: * value at the top of this file to some non zero value
                            	  2476: 
                            	  2477:  ifne	nobrk
                            	  2478: 
                            	  2479: 	MOVE.l	a0,Rdptrl(a3)		* save the READ pointer
                            	  2480: 	BRA.s		LAB_1961			* go handle the input
                            	  2481: 
                            	  2482:  endc
                            	  2483: 
                            	  2484: * if you do want a null response to INPUT to break the program then leave the nobrk
                            	  2485: * value at the top of this file set to zero
                            	  2486: 
                            	  2487:  ifeq	nobrk
                            	  2488: 
01:00204EC8 4A10            	  2489: 	TST.b		(a0)				* test the first byte from the buffer
01:00204ECA 6604            	  2490: 	BNE.s		LAB_1984			* if not null input go handle it
                            	  2491: 
01:00204ECC 6000FB26        	  2492: 	BRA		LAB_1647			* else go do the BREAK exit
                            	  2493: 
                            	  2494: LAB_1984
01:00204ED0 2A48            	  2495: 	MOVEA.l	a0,a5				* set the execute pointer to the buffer
01:00204ED2 534D            	  2496: 	SUBQ.w	#1,a5				* decrement the execute pointer
                            	  2497: 
                            	  2498:  endc
                            	  2499: 
                            	  2500: LAB_1985
01:00204ED4 610002D6        	  2501: 	BSR		LAB_IGBY			* increment & scan memory
                            	  2502: LAB_1986
01:00204ED8 4A2B05B5        	  2503: 	TST.b		Dtypef(a3)			* test data type, $80=string, $40=integer,
                            	  2504: 							* $00=float
01:00204EDC 6A20            	  2505: 	BPL.s		LAB_19B0			* branch if numeric
                            	  2506: 
                            	  2507: 							* else get string
01:00204EDE 1400            	  2508: 	MOVE.b	d0,d2				* save search character
01:00204EE0 B03C0022        	  2509: 	CMP.b		#$22,d0			* was it " ?
01:00204EE4 6706            	  2510: 	BEQ.s		LAB_1999			* branch if so
                            	  2511: 
01:00204EE6 743A            	  2512: 	MOVEQ		#':',d2			* set new search character
01:00204EE8 702C            	  2513: 	MOVEQ		#',',d0			* other search character is ","
01:00204EEA 534D            	  2514: 	SUBQ.w	#1,a5				* decrement BASIC execute pointer
                            	  2515: LAB_1999
01:00204EEC 524D            	  2516: 	ADDQ.w	#1,a5				* increment BASIC execute pointer
01:00204EEE 1600            	  2517: 	MOVE.b	d0,d3				* set second search character
01:00204EF0 204D            	  2518: 	MOVEA.l	a5,a0				* BASIC execute pointer is source
                            	  2519: 
01:00204EF2 610008D0        	  2520: 	BSR		LAB_20B4			* print d2/d3 terminated string to FAC1 stack
                            	  2521: 							* d2 = Srchc, d3 = Asrch, a0 is source
01:00204EF6 2A4A            	  2522: 	MOVEA.l	a2,a5				* copy end of string to BASIC execute pointer
01:00204EF8 6100FDD2        	  2523: 	BSR		LAB_17D5			* go do string LET
01:00204EFC 6010            	  2524: 	BRA.s		LAB_19B6			* go check string terminator
                            	  2525: 
                            	  2526: 							* get numeric INPUT
                            	  2527: LAB_19B0
01:00204EFE 1F2B05B5        	  2528: 	MOVE.b	Dtypef(a3),-(sp)		* save variable data type
01:00204F02 61001D82        	  2529: 	BSR		LAB_2887			* get FAC1 from string
01:00204F06 175F05B5        	  2530: 	MOVE.b	(sp)+,Dtypef(a3)		* restore variable data type
01:00204F0A 61001074        	  2531: 	BSR		LAB_PFAC			* pack FAC1 into (Lvarpl)
                            	  2532: LAB_19B6
01:00204F0E 6100029E        	  2533: 	BSR		LAB_GBYT			* scan memory
01:00204F12 670A            	  2534: 	BEQ.s		LAB_19C2			* branch if null (last entry)
                            	  2535: 
01:00204F14 B03C002C        	  2536: 	CMP.b		#',',d0			* else compare with ","
01:00204F18 6600FF38        	  2537: 	BNE		LAB_1904			* if not "," go handle bad input data
                            	  2538: 
01:00204F1C 524D            	  2539: 	ADDQ.w	#1,a5				* else was "," so point to next chr
                            	  2540: 							* got good input data
                            	  2541: LAB_19C2
01:00204F1E 274D0466        	  2542: 	MOVE.l	a5,Rdptrl(a3)		* save the read pointer for now
01:00204F22 2A5F            	  2543: 	MOVEA.l	(sp)+,a5			* restore the execute pointer
01:00204F24 61000288        	  2544: 	BSR		LAB_GBYT			* scan the memory
01:00204F28 6736            	  2545: 	BEQ.s		LAB_1A03			* if null go do extra ignored message
                            	  2546: 
01:00204F2A 487AFF7A        	  2547: 	PEA		LAB_195B(pc)		* set return address
01:00204F2E 60000272        	  2548: 	BRA		LAB_1C01			* scan for "," else do syntax error/warm start
                            	  2549: 							* then go INPUT next variable from list
                            	  2550: 
                            	  2551: 							* find next DATA statement or do "Out of Data"
                            	  2552: 							* error
                            	  2553: LAB_19DD
01:00204F32 6100FC04        	  2554: 	BSR		LAB_SNBS			* scan for next BASIC statement ([:] or [EOL])
                            	  2555: 							* returns a0 as pointer to [:] or [EOL]
01:00204F36 2A48            	  2556: 	MOVEA.l	a0,a5				* add index, now = pointer to [EOL]/[EOS]
01:00204F38 524D            	  2557: 	ADDQ.w	#1,a5				* pointer to next character
01:00204F3A B03C003A        	  2558: 	CMP.b		#':',d0			* was it statement end?
01:00204F3E 6712            	  2559: 	BEQ.s		LAB_19F6			* branch if [:]
                            	  2560: 
                            	  2561: 							* was [EOL] so find next line
                            	  2562: 
01:00204F40 320D            	  2563: 	MOVE.w	a5,d1				* past pad byte(s)
01:00204F42 C27C0001        	  2564: 	AND.w		#1,d1				* mask odd bit
01:00204F46 DAC1            	  2565: 	ADD.w		d1,a5				* add pointer
01:00204F48 241D            	  2566: 	MOVE.l	(a5)+,d2			* get next line pointer
01:00204F4A 6700F61C        	  2567: 	BEQ		LAB_ODER			* branch if end of program
                            	  2568: 
01:00204F4E 275D045E        	  2569: 	MOVE.l	(a5)+,Dlinel(a3)		* save current DATA line
                            	  2570: LAB_19F6
01:00204F52 6100025A        	  2571: 	BSR		LAB_GBYT			* scan memory
01:00204F56 B03C0083        	  2572: 	CMP.b		#TK_DATA,d0			* compare with "DATA" token
01:00204F5A 6700FF78        	  2573: 	BEQ		LAB_1985			* was "DATA" so go do next READ
                            	  2574: 
01:00204F5E 60D2            	  2575: 	BRA.s		LAB_19DD			* go find next statement if not "DATA"
                            	  2576: 
                            	  2577: * end of INPUT/READ routine
                            	  2578: 
                            	  2579: LAB_1A03
01:00204F60 206B0466        	  2580: 	MOVEA.l	Rdptrl(a3),a0		* get temp READ pointer
01:00204F64 4A2B05E0        	  2581: 	TST.b		Imode(a3)			* get input mode flag, $00=INPUT, $98=READ
01:00204F68 6A06            	  2582: 	BPL.s		LAB_1A0E			* branch if INPUT
                            	  2583: 
01:00204F6A 27480462        	  2584: 	MOVE.l	a0,Dptrl(a3)		* else save temp READ pointer as DATA pointer
01:00204F6E 4E75            	  2585: 	RTS
                            	  2586: 
                            	  2587: 							* we were getting INPUT
                            	  2588: LAB_1A0E
01:00204F70 4A10            	  2589: 	TST.b		(a0)				* test next byte
01:00204F72 6602            	  2590: 	BNE.s		LAB_1A1B			* error if not end of INPUT
                            	  2591: 
01:00204F74 4E75            	  2592: 	RTS
                            	  2593: 							* user typed too much
                            	  2594: LAB_1A1B
01:00204F76 41FA2930        	  2595: 	LEA		LAB_IMSG(pc),a0		* point to extra ignored message
01:00204F7A 6000FE66        	  2596: 	BRA		LAB_18C3			* print null terminated string from memory & RTS
                            	  2597: 
                            	  2598: 
                            	  2599: *************************************************************************************
                            	  2600: *
                            	  2601: * perform NEXT
                            	  2602: 
                            	  2603: LAB_NEXT
01:00204F7E 6610            	  2604: 	BNE.s		LAB_1A46			* branch if NEXT var
                            	  2605: 
01:00204F80 584F            	  2606: 	ADDQ.w	#4,sp				* back past return address
01:00204F82 0C570081        	  2607: 	CMP.w		#TK_FOR,(sp)		* is FOR token on stack?
01:00204F86 6600F5EC        	  2608: 	BNE		LAB_NFER			* if not do NEXT without FOR err/warm start
                            	  2609: 
01:00204F8A 206F0002        	  2610: 	MOVEA.l	2(sp),a0			* get stacked FOR variable pointer
01:00204F8E 601C            	  2611: 	BRA.s		LAB_11BD			* branch always (no variable to search for)
                            	  2612: 
                            	  2613: * NEXT var
                            	  2614: 
                            	  2615: LAB_1A46
01:00204F90 61000428        	  2616: 	BSR		LAB_GVAR			* get variable address in a0
01:00204F94 584F            	  2617: 	ADDQ.w	#4,sp				* back past return address
01:00204F96 303C0081        	  2618: 	MOVE.w	#TK_FOR,d0			* set for FOR token
01:00204F9A 721C            	  2619: 	MOVEQ		#$1C,d1			* set for FOR use size
01:00204F9C 6002            	  2620: 	BRA.s		LAB_11A6			* enter loop for next variable search
                            	  2621: 
                            	  2622: LAB_11A5
01:00204F9E DFC1            	  2623: 	ADDA.l	d1,sp				* add FOR stack use size
                            	  2624: LAB_11A6
01:00204FA0 B057            	  2625: 	CMP.w		(sp),d0			* is FOR token on stack?
01:00204FA2 6600F5D0        	  2626: 	BNE		LAB_NFER			* if not found do NEXT without FOR error and
                            	  2627: 							* warm start
                            	  2628: 
                            	  2629: 							* was FOR token
01:00204FA6 B1EF0002        	  2630: 	CMPA.l	2(sp),a0			* compare var pointer with stacked var pointer
01:00204FAA 66F2            	  2631: 	BNE.s		LAB_11A5			* loop if no match found
                            	  2632: 
                            	  2633: LAB_11BD
01:00204FAC 376F0006059C    	  2634: 	MOVE.w	6(sp),FAC2_e(a3)		* get STEP value exponent and sign
01:00204FB2 276F00080598    	  2635: 	MOVE.l	8(sp),FAC2_m(a3)		* get STEP value mantissa
                            	  2636: 
01:00204FB8 176F001205B5    	  2637: 	MOVE.b	18(sp),Dtypef(a3)		* restore FOR variable data type
01:00204FBE 6100021A        	  2638: 	BSR		LAB_1C19			* check type and unpack (a0)
                            	  2639: 
01:00204FC2 176B059D059E    	  2640: 	MOVE.b	FAC2_s(a3),FAC_sc(a3)	* save FAC2 sign as sign compare
01:00204FC8 102B0595        	  2641: 	MOVE.b	FAC1_s(a3),d0		* get FAC1 sign
01:00204FCC B12B059E        	  2642: 	EOR.b		d0,FAC_sc(a3)		* EOR to create sign compare
                            	  2643: 
01:00204FD0 27480472        	  2644: 	MOVE.l	a0,Lvarpl(a3)		* save variable pointer
01:00204FD4 61000CAC        	  2645: 	BSR		LAB_ADD			* add STEP value to FOR variable
01:00204FD8 176F001205B5    	  2646: 	MOVE.b	18(sp),Dtypef(a3)		* restore FOR variable data type (again)
01:00204FDE 61000FA0        	  2647: 	BSR		LAB_PFAC			* pack FAC1 into FOR variable (Lvarpl)
                            	  2648: 
01:00204FE2 376F000C059C    	  2649: 	MOVE.w	12(sp),FAC2_e(a3)		* get TO value exponent and sign
01:00204FE8 276F000E0598    	  2650: 	MOVE.l	14(sp),FAC2_m(a3)		* get TO value mantissa
                            	  2651: 
01:00204FEE 176B059D059E    	  2652: 	MOVE.b	FAC2_s(a3),FAC_sc(a3)	* save FAC2 sign as sign compare
01:00204FF4 102B0595        	  2653: 	MOVE.b	FAC1_s(a3),d0		* get FAC1 sign
01:00204FF8 B12B059E        	  2654: 	EOR.b		d0,FAC_sc(a3)		* EOR to create sign compare
                            	  2655: 
01:00204FFC 6100102C        	  2656: 	BSR		LAB_27FA			* compare FAC1 with FAC2 (TO value)
                            	  2657: 							* returns d0=+1 if FAC1 > FAC2
                            	  2658: 							* returns d0= 0 if FAC1 = FAC2
                            	  2659: 							* returns d0=-1 if FAC1 < FAC2
                            	  2660: 
01:00205000 322F0006        	  2661: 	MOVE.w	6(sp),d1			* get STEP value exponent and sign
01:00205004 B141            	  2662: 	EOR.w		d0,d1				* EOR compare result with STEP exponent and sign
                            	  2663: 
01:00205006 4A00            	  2664: 	TST.b		d0				* test for =
01:00205008 6704            	  2665: 	BEQ.s		LAB_1A90			* branch if = (loop INcomplete)
                            	  2666: 
01:0020500A 4A01            	  2667: 	TST.b		d1				* test result
01:0020500C 6A0E            	  2668: 	BPL.s		LAB_1A9B			* branch if > (loop complete)
                            	  2669: 
                            	  2670: 							* loop back and do it all again
                            	  2671: LAB_1A90
01:0020500E 276F00140452    	  2672: 	MOVE.l	20(sp),Clinel(a3)		* reset current line
01:00205014 2A6F0018        	  2673: 	MOVE.l	24(sp),a5			* reset BASIC execute pointer
01:00205018 6000F976        	  2674: 	BRA		LAB_15C2			* go do interpreter inner loop
                            	  2675: 
                            	  2676: 							* loop complete so carry on
                            	  2677: LAB_1A9B
01:0020501C 4FEF001C        	  2678: 	ADDA.w	#28,sp			* add 28 to dump FOR structure
01:00205020 6100018C        	  2679: 	BSR		LAB_GBYT			* scan memory
01:00205024 B03C002C        	  2680: 	CMP.b		#$2C,d0			* compare with ","
01:00205028 6600F966        	  2681: 	BNE		LAB_15C2			* if not "," go do interpreter inner loop
                            	  2682: 
                            	  2683: 							* was "," so another NEXT variable to do
01:0020502C 6100017E        	  2684: 	BSR		LAB_IGBY			* else increment & scan memory
01:00205030 6100FF5E        	  2685: 	BSR		LAB_1A46			* do NEXT (var)
                            	  2686: 
                            	  2687: 
                            	  2688: *************************************************************************************
                            	  2689: *
                            	  2690: * evaluate expression & check is numeric, else do type mismatch
                            	  2691: 
                            	  2692: LAB_EVNM
01:00205034 6116            	  2693: 	BSR.s		LAB_EVEX			* evaluate expression
                            	  2694: 
                            	  2695: 
                            	  2696: *************************************************************************************
                            	  2697: *
                            	  2698: * check if source is numeric, else do type mismatch
                            	  2699: 
                            	  2700: LAB_CTNM
01:00205036 B040            	  2701: 	CMP.w		d0,d0				* required type is numeric so clear carry
                            	  2702: 
                            	  2703: 
                            	  2704: *************************************************************************************
                            	  2705: *
                            	  2706: * type match check, set C for string, clear C for numeric
                            	  2707: 
                            	  2708: LAB_CKTM
01:00205038 082B000705B5    	  2709: 	BTST.b	#7,Dtypef(a3)		* test data type flag, don't change carry
01:0020503E 6606            	  2710: 	BNE.s		LAB_1ABA			* branch if data type is string
                            	  2711: 
                            	  2712: 							* else data type was numeric
01:00205040 6500F502        	  2713: 	BCS		LAB_TMER			* if required type is string do type mismatch
                            	  2714: 							* error
                            	  2715: 
01:00205044 4E75            	  2716: 	RTS
                            	  2717: 							* data type was string, now check required type
                            	  2718: LAB_1ABA
01:00205046 6400F4FC        	  2719: 	BCC		LAB_TMER			* if required type is numeric do type mismatch
                            	  2720: 							* error
01:0020504A 4E75            	  2721: 	RTS
                            	  2722: 
                            	  2723: 
                            	  2724: *************************************************************************************
                            	  2725: *
                            	  2726: * this routine evaluates any type of expression. first it pushes an end marker so
                            	  2727: * it knows when the expression has been evaluated, this is a precedence value of zero.
                            	  2728: * next the first value is evaluated, this can be an in line value, either numeric or
                            	  2729: * string, a variable or array element of any type, a function or even an expression
                            	  2730: * in parenthesis. this value is kept in FAC_1
                            	  2731: * after the value is evaluated a test is made on the next BASIC program byte, if it
                            	  2732: * is a comparrison operator i.e. "<", "=" or ">", then the corresponding bit is set
                            	  2733: * in the comparison evaluation flag. this test loops until no more comparrison operators
                            	  2734: * are found or more than one of any type is found. in the last case an error is generated
                            	  2735: 
                            	  2736: * evaluate expression
                            	  2737: 
                            	  2738: LAB_EVEX
01:0020504C 534D            	  2739: 	SUBQ.w	#1,a5				* decrement BASIC execute pointer
                            	  2740: LAB_EVEZ
01:0020504E 7200            	  2741: 	MOVEQ		#0,d1				* clear precedence word
01:00205050 174105B5        	  2742: 	MOVE.b	d1,Dtypef(a3)		* clear the data type, $80=string, $40=integer,
                            	  2743: 							* $00=float
01:00205054 601C            	  2744: 	BRA.s		LAB_1ACD			* enter loop
                            	  2745: 
                            	  2746: * get vector, set up operator then continue evaluation
                            	  2747: 
                            	  2748: LAB_1B43						*
01:00205056 41FA22A6        	  2749: 	LEA		LAB_OPPT(pc),a0		* point to operator vector table
01:0020505A 30301002        	  2750: 	MOVE.w	2(a0,d1.w),d0		* get vector offset
01:0020505E 48700000        	  2751: 	PEA		(a0,d0.w)			* push vector
                            	  2752: 
01:00205062 2F2B0590        	  2753: 	MOVE.l	FAC1_m(a3),-(sp)		* push FAC1 mantissa
01:00205066 3F2B0594        	  2754: 	MOVE.w	FAC1_e(a3),-(sp)		* push sign and exponent
01:0020506A 1F2B05E3        	  2755: 	MOVE.b	comp_f(a3),-(sp)		* push comparison evaluation flag
                            	  2756: 
01:0020506E 32301000        	  2757: 	MOVE.w	(a0,d1.w),d1		* get precedence value
                            	  2758: LAB_1ACD
01:00205072 3F01            	  2759: 	MOVE.w	d1,-(sp)			* push precedence value
01:00205074 610000E4        	  2760: 	BSR		LAB_GVAL			* get value from line
01:00205078 177C000005E3    	  2761: 	MOVE.b	#$00,comp_f(a3)		* clear compare function flag
                            	  2762: LAB_1ADB
01:0020507E 6100012E        	  2763: 	BSR		LAB_GBYT			* scan memory
                            	  2764: LAB_1ADE
01:00205082 903C00BC        	  2765: 	SUB.b		#TK_GT,d0			* subtract token for > (lowest compare function)
01:00205086 652A            	  2766: 	BCS.s		LAB_1AFA			* branch if < TK_GT
                            	  2767: 
01:00205088 B03C0003        	  2768: 	CMP.b		#$03,d0			* compare with ">" to "<" tokens
01:0020508C 650A            	  2769: 	BCS.s		LAB_1AE0			* branch if <= TK_SGN (is compare function)
                            	  2770: 
01:0020508E 4A2B05E3        	  2771: 	TST.b		comp_f(a3)			* test compare function flag
01:00205092 6660            	  2772: 	BNE.s		LAB_1B2A			* branch if compare function
                            	  2773: 
01:00205094 60000086        	  2774: 	BRA		LAB_1B78			* go do functions
                            	  2775: 
                            	  2776: 							* was token for > = or < (d0 = 0, 1 or 2)
                            	  2777: LAB_1AE0
01:00205098 7201            	  2778: 	MOVEQ		#1,d1				* set to 0000 0001
01:0020509A E121            	  2779: 	ASL.b		d0,d1				* 1 if >, 2 if =, 4 if <
01:0020509C 102B05E3        	  2780: 	MOVE.b	comp_f(a3),d0		* copy old compare function flag
01:002050A0 B32B05E3        	  2781: 	EOR.b		d1,comp_f(a3)		* EOR in this compare function bit
01:002050A4 B02B05E3        	  2782: 	CMP.b		comp_f(a3),d0		* compare old with new compare function flag
01:002050A8 6400F4C6        	  2783: 	BCC		LAB_SNER			* if new <= old comp_f do syntax error and warm
                            	  2784: 							* start, there was more than one <, = or >
01:002050AC 610000FE        	  2785: 	BSR		LAB_IGBY			* increment & scan memory
01:002050B0 60D0            	  2786: 	BRA.s		LAB_1ADE			* go do next character
                            	  2787: 
                            	  2788: 							* token is < ">" or > "<" tokens
                            	  2789: LAB_1AFA
01:002050B2 4A2B05E3        	  2790: 	TST.b		comp_f(a3)			* test compare function flag
01:002050B6 663C            	  2791: 	BNE.s		LAB_1B2A			* branch if compare function
                            	  2792: 
                            	  2793: 							* was < TK_GT so is operator or lower
01:002050B8 D03C000A        	  2794: 	ADD.b	#(TK_GT-TK_PLUS),d0		* add # of operators (+ - * / ^ AND OR EOR)
01:002050BC 645E            	  2795: 	BCC.s		LAB_1B78			* branch if < + operator
                            	  2796: 
01:002050BE 6608            	  2797: 	BNE.s		LAB_1B0B			* branch if not + token
                            	  2798: 
01:002050C0 4A2B05B5        	  2799: 	TST.b		Dtypef(a3)			* test data type, $80=string, $40=integer,
                            	  2800: 							* $00=float
01:002050C4 6B000872        	  2801: 	BMI		LAB_224D			* type is string & token was +
                            	  2802: 
                            	  2803: LAB_1B0B
01:002050C8 7200            	  2804: 	MOVEQ		#0,d1				* clear longword
01:002050CA D000            	  2805: 	ADD.b		d0,d0				* *2
01:002050CC D000            	  2806: 	ADD.b		d0,d0				* *4
01:002050CE 1200            	  2807: 	MOVE.b	d0,d1				* copy to index
                            	  2808: LAB_1B13
01:002050D0 301F            	  2809: 	MOVE.w	(sp)+,d0			* pull previous precedence
01:002050D2 41FA222A        	  2810: 	LEA		LAB_OPPT(pc),a0		* set pointer to operator table
01:002050D6 B0701000        	  2811: 	CMP.w		(a0,d1.w),d0		* compare with this opperator precedence
01:002050DA 6446            	  2812: 	BCC.s		LAB_1B7D			* branch if previous precedence (d0) >=
                            	  2813: 
01:002050DC 6100FF58        	  2814: 	BSR		LAB_CTNM			* check if source is numeric, else type mismatch
                            	  2815: LAB_1B1C
01:002050E0 3F00            	  2816: 	MOVE.w	d0,-(sp)			* save precedence
                            	  2817: LAB_1B1D
01:002050E2 6100FF72        	  2818: 	BSR		LAB_1B43			* get vector, set-up operator and continue
                            	  2819: 							* evaluation
01:002050E6 301F            	  2820: 	MOVE.w	(sp)+,d0			* restore precedence
01:002050E8 222B05D8        	  2821: 	MOVE.l	prstk(a3),d1		* get stacked function pointer
01:002050EC 6A22            	  2822: 	BPL.s		LAB_1B3C			* branch if stacked values
                            	  2823: 
01:002050EE 3000            	  2824: 	MOVE.w	d0,d0				* copy precedence (set flags)
01:002050F0 672E            	  2825: 	BEQ.s		LAB_1B7B			* exit if done
                            	  2826: 
01:002050F2 603C            	  2827: 	BRA.s		LAB_1B86			* else pop FAC2 & return (do function)
                            	  2828: 
                            	  2829: 							* was compare function (< = >)
                            	  2830: LAB_1B2A
01:002050F4 102B05B5        	  2831: 	MOVE.b	Dtypef(a3),d0		* get data type flag
01:002050F8 122B05E3        	  2832: 	MOVE.b	comp_f(a3),d1		* get compare function flag
01:002050FC D000            	  2833: 	ADD.b		d0,d0				* string bit flag into X bit
01:002050FE D301            	  2834: 	ADDX.b	d1,d1				* shift compare function flag
                            	  2835: 
01:00205100 177C000005B5    	  2836: 	MOVE.b	#0,Dtypef(a3)		* clear data type flag, $00=float
01:00205106 174105E3        	  2837: 	MOVE.b	d1,comp_f(a3)		* save new compare function flag
01:0020510A 534D            	  2838: 	SUBQ.w	#1,a5				* decrement BASIC execute pointer
01:0020510C 7230            	  2839: 	MOVEQ		#(TK_LT-TK_PLUS)*4,d1	* set offset to last operator entry
01:0020510E 60C0            	  2840: 	BRA.s		LAB_1B13			* branch always
                            	  2841: 
                            	  2842: LAB_1B3C
01:00205110 41FA21EC        	  2843: 	LEA		LAB_OPPT(pc),a0		* point to function vector table
01:00205114 B0701000        	  2844: 	CMP.w		(a0,d1.w),d0		* compare with this opperator precedence
01:00205118 6416            	  2845: 	BCC.s		LAB_1B86			* branch if d0 >=, pop FAC2 & return
                            	  2846: 
01:0020511A 60C4            	  2847: 	BRA.s		LAB_1B1C			* branch always
                            	  2848: 
                            	  2849: * do functions
                            	  2850: 
                            	  2851: LAB_1B78
01:0020511C 72FF            	  2852: 	MOVEQ		#-1,d1			* flag all done
01:0020511E 301F            	  2853: 	MOVE.w	(sp)+,d0			* pull precedence word
                            	  2854: LAB_1B7B
01:00205120 6732            	  2855: 	BEQ.s		LAB_1B9D			* exit if done
                            	  2856: 
                            	  2857: LAB_1B7D
01:00205122 B07C0064        	  2858: 	CMP.w		#$64,d0			* compare previous precedence with $64
01:00205126 6704            	  2859: 	BEQ.s		LAB_1B84			* branch if was $64 (< function can be string)
                            	  2860: 
01:00205128 6100FF0C        	  2861: 	BSR		LAB_CTNM			* check if source is numeric, else type mismatch
                            	  2862: LAB_1B84
01:0020512C 274105D8        	  2863: 	MOVE.l	d1,prstk(a3)		* save current operator index
                            	  2864: 
                            	  2865: 							* pop FAC2 & return
                            	  2866: LAB_1B86
01:00205130 101F            	  2867: 	MOVE.b	(sp)+,d0			* pop comparison evaluation flag
01:00205132 1200            	  2868: 	MOVE.b	d0,d1				* copy comparison evaluation flag
01:00205134 E208            	  2869: 	LSR.b		#1,d0				* shift out comparison evaluation lowest bit
01:00205136 174005E1        	  2870: 	MOVE.b	d0,Cflag(a3)		* save comparison evaluation flag
01:0020513A 375F059C        	  2871: 	MOVE.w	(sp)+,FAC2_e(a3)		* pop exponent and sign
01:0020513E 275F0598        	  2872: 	MOVE.l	(sp)+,FAC2_m(a3)		* pop mantissa
01:00205142 176B059D059E    	  2873: 	MOVE.b	FAC2_s(a3),FAC_sc(a3)	* copy FAC2 sign
01:00205148 102B0595        	  2874: 	MOVE.b	FAC1_s(a3),d0		* get FAC1 sign
01:0020514C B12B059E        	  2875: 	EOR.b		d0,FAC_sc(a3)		* EOR FAC1 sign and set sign compare
                            	  2876: 
01:00205150 E209            	  2877: 	LSR.b		#1,d1				* type bit into X and C
01:00205152 4E75            	  2878: 	RTS
                            	  2879: 
                            	  2880: LAB_1B9D
01:00205154 102B0594        	  2881: 	MOVE.b	FAC1_e(a3),d0		* get FAC1 exponent
01:00205158 4E75            	  2882: 	RTS
                            	  2883: 
                            	  2884: 
                            	  2885: *************************************************************************************
                            	  2886: *
                            	  2887: * get a value from the BASIC line
                            	  2888: 
                            	  2889: LAB_GVAL
01:0020515A 6150            	  2890: 	BSR.s		LAB_IGBY			* increment & scan memory
01:0020515C 65001B28        	  2891: 	BCS		LAB_2887			* if numeric get FAC1 from string & return
                            	  2892: 
01:00205160 4A00            	  2893: 	TST.b		d0				* test byte
01:00205162 6B00008C        	  2894: 	BMI		LAB_1BD0			* if -ve go test token values
                            	  2895: 
                            	  2896: 							* else it is either a string, number, variable
                            	  2897: 							* or (<expr>)
01:00205166 B03C0024        	  2898: 	CMP.b		#'$',d0			* compare with "$"
01:0020516A 67001B1A        	  2899: 	BEQ		LAB_2887			* if "$" get hex number from string & return
                            	  2900: 
01:0020516E B03C0025        	  2901: 	CMP.b		#'%',d0			* else compare with "%"
01:00205172 67001B12        	  2902: 	BEQ		LAB_2887			* if "%" get binary number from string & return
                            	  2903: 
01:00205176 B03C002E        	  2904: 	CMP.b		#$2E,d0			* compare with "."
01:0020517A 67001B0A        	  2905: 	BEQ		LAB_2887			* if so get FAC1 from string and return
                            	  2906: 							* (e.g. .123)
                            	  2907: 
                            	  2908: 							* wasn't a number so ...
01:0020517E B03C0022        	  2909: 	CMP.b		#$22,d0			* compare with "
01:00205182 660C            	  2910: 	BNE.s		LAB_1BF3			* if not open quote it must be a variable or
                            	  2911: 							* open bracket
                            	  2912: 
                            	  2913: 							* was open quote so get the enclosed string
                            	  2914: 
                            	  2915: * print "..." string to string stack
                            	  2916: 
                            	  2917: LAB_1BC1
01:00205184 101D            	  2918: 	MOVE.b	(a5)+,d0			* increment BASIC execute pointer (past ")
                            	  2919: 							* fastest/shortest method
01:00205186 204D            	  2920: 	MOVEA.l	a5,a0				* copy basic execute pointer (string start)
01:00205188 61000636        	  2921: 	BSR		LAB_20AE			* print " terminated string to stack
01:0020518C 2A4A            	  2922: 	MOVEA.l	a2,a5				* restore BASIC execute pointer from temp
01:0020518E 4E75            	  2923: 	RTS
                            	  2924: 
                            	  2925: * get value from line .. continued
                            	  2926: 							* wasn't any sort of number so ...
                            	  2927: LAB_1BF3
01:00205190 B03C0028        	  2928: 	CMP.b		#'(',d0			* compare with "("
01:00205194 6640            	  2929: 	BNE.s		LAB_1C18			* if not "(" get (var) and return value in FAC1
                            	  2930: 							* and $ flag
                            	  2931: 
                            	  2932: 
                            	  2933: *************************************************************************************
                            	  2934: *
                            	  2935: * evaluate expression within parentheses
                            	  2936: 
                            	  2937: LAB_1BF7
01:00205196 6100FEB6        	  2938: 	BSR		LAB_EVEZ			* evaluate expression (no decrement)
                            	  2939: 
                            	  2940: 
                            	  2941: *************************************************************************************
                            	  2942: *
                            	  2943: * all the 'scan for' routines return the character after the sought character
                            	  2944: 
                            	  2945: * scan for ")", else do syntax error, then warm start
                            	  2946: 
                            	  2947: LAB_1BFB
01:0020519A 7029            	  2948: 	MOVEQ		#$29,d0			* load d0 with ")"
01:0020519C 6006            	  2949: 	BRA.s		LAB_SCCA
                            	  2950: 
                            	  2951: 
                            	  2952: *************************************************************************************
                            	  2953: *
                            	  2954: * scan for "," and get byte, else do Syntax error then warm start
                            	  2955: 
                            	  2956: LAB_SCGB
01:0020519E 487A096C        	  2957: 	PEA		LAB_GTBY(pc)		* return address is to get byte parameter
                            	  2958: 
                            	  2959: 
                            	  2960: *************************************************************************************
                            	  2961: *
                            	  2962: * scan for ",", else do syntax error, then warm start
                            	  2963: 
                            	  2964: LAB_1C01
01:002051A2 702C            	  2965: 	MOVEQ		#$2C,d0			* load d0 with ","
                            	  2966: 
                            	  2967: 
                            	  2968: *************************************************************************************
                            	  2969: *
                            	  2970: * scan for CHR$(d0) , else do syntax error, then warm start
                            	  2971: 
                            	  2972: LAB_SCCA
01:002051A4 B01D            	  2973: 	CMP.b		(a5)+,d0			* check next byte is = d0
01:002051A6 6706            	  2974: 	BEQ.s		LAB_GBYT			* if so go get next
                            	  2975: 
01:002051A8 6000F3C6        	  2976: 	BRA		LAB_SNER			* else do syntax error/warm start
                            	  2977: 
                            	  2978: 
                            	  2979: *************************************************************************************
                            	  2980: *
                            	  2981: * BASIC increment and scan memory routine
                            	  2982: 
                            	  2983: LAB_IGBY
01:002051AC 101D            	  2984: 	MOVE.b	(a5)+,d0			* get byte & increment pointer
                            	  2985: 
                            	  2986: * scan memory routine, exit with Cb = 1 if numeric character
                            	  2987: * also skips any spaces encountered
                            	  2988: 
                            	  2989: LAB_GBYT
01:002051AE 1015            	  2990: 	MOVE.b	(a5),d0			* get byte
                            	  2991: 
01:002051B0 B03C0020        	  2992: 	CMP.b		#$20,d0			* compare with " "
01:002051B4 67F6            	  2993: 	BEQ.s		LAB_IGBY			* if " " go do next
                            	  2994: 
                            	  2995: * test current BASIC byte, exit with Cb = 1 if numeric character
                            	  2996: 
01:002051B6 B03C00A9        	  2997: 	CMP.b		#TK_ELSE,d0			* compare with the token for ELSE
01:002051BA 640C            	  2998: 	BCC.s		RTS_001			* exit if >= (not numeric, carry clear)
                            	  2999: 
01:002051BC B03C003A        	  3000: 	CMP.b		#$3A,d0			* compare with ":"
01:002051C0 6406            	  3001: 	BCC.s		RTS_001			* exit if >= (not numeric, carry clear)
                            	  3002: 
01:002051C2 7CD0            	  3003: 	MOVEQ		#-48,d6			* set -"0"
01:002051C4 D006            	  3004: 	ADD.b		d6,d0				* add -"0"
01:002051C6 9006            	  3005: 	SUB.b		d6,d0				* subtract -"0"
                            	  3006: RTS_001						* carry set if byte = "0"-"9"
01:002051C8 4E75            	  3007: 	RTS
                            	  3008: 
                            	  3009: 
                            	  3010: *************************************************************************************
                            	  3011: *
                            	  3012: * set-up for - operator
                            	  3013: 
                            	  3014: LAB_1C11
01:002051CA 6100FE6A        	  3015: 	BSR		LAB_CTNM			* check if source is numeric, else type mismatch
01:002051CE 7228            	  3016: 	MOVEQ	#(TK_GT-TK_PLUS)*4,d1		* set offset from base to - operator
                            	  3017: LAB_1C13
01:002051D0 588F            	  3018: 	LEA		4(sp),sp			* dump GVAL return address
01:002051D2 6000FF0E        	  3019: 	BRA		LAB_1B1D			* continue evaluating expression
                            	  3020: 
                            	  3021: 
                            	  3022: *************************************************************************************
                            	  3023: *
                            	  3024: * variable name set-up
                            	  3025: * get (var), return value in FAC_1 & data type flag
                            	  3026: 
                            	  3027: LAB_1C18
01:002051D6 610001E2        	  3028: 	BSR		LAB_GVAR			* get variable address in a0
                            	  3029: 
                            	  3030: * if you want a non existant variable to return a null value then set the novar
                            	  3031: * value at the top of this file to some non zero value
                            	  3032: 
                            	  3033:  ifne	novar
                            	  3034: 
                            	  3035: 	BNE.s		LAB_1C19			* if it exists return it
                            	  3036: 
                            	  3037: 	LEA.l		LAB_1D96(pc),a0		* else return a null descriptor/pointer
                            	  3038: 
                            	  3039:  endc
                            	  3040: 
                            	  3041: * return existing variable value
                            	  3042: 
                            	  3043: LAB_1C19
01:002051DA 4A2B05B5        	  3044: 	TST.b		Dtypef(a3)			* test data type, $80=string, $40=integer,
                            	  3045: 							* $00=float
01:002051DE 67000D84        	  3046: 	BEQ		LAB_UFAC			* if float unpack memory (a0) into FAC1 and
                            	  3047: 							* return
                            	  3048: 
01:002051E2 6A06            	  3049: 	BPL.s		LAB_1C1A			* if integer unpack memory (a0) into FAC1
                            	  3050: 							* and return
                            	  3051: 
01:002051E4 27480590        	  3052: 	MOVE.l	a0,FAC1_m(a3)		* else save descriptor pointer in FAC1
01:002051E8 4E75            	  3053: 	RTS
                            	  3054: 
                            	  3055: LAB_1C1A
01:002051EA 2010            	  3056: 	MOVE.l	(a0),d0			* get integer value
01:002051EC 600004BC        	  3057: 	BRA		LAB_AYFC			* convert d0 to signed longword in FAC1 & return
                            	  3058: 
                            	  3059: 
                            	  3060: *************************************************************************************
                            	  3061: *
                            	  3062: * get value from line .. continued
                            	  3063: * do tokens
                            	  3064: 
                            	  3065: LAB_1BD0
01:002051F0 B03C00B3        	  3066: 	CMP.b		#TK_MINUS,d0		* compare with token for -
01:002051F4 67D4            	  3067: 	BEQ.s		LAB_1C11			* branch if - token (do set-up for - operator)
                            	  3068: 
                            	  3069: 							* wasn't -123 so ...
01:002051F6 B03C00B2        	  3070: 	CMP.b		#TK_PLUS,d0			* compare with token for +
01:002051FA 6700FF5E        	  3071: 	BEQ		LAB_GVAL			* branch if + token (+n = n so ignore leading +)
                            	  3072: 
01:002051FE B03C00AE        	  3073: 	CMP.b		#TK_NOT,d0			* compare with token for NOT
01:00205202 6606            	  3074: 	BNE.s		LAB_1BE7			* branch if not token for NOT
                            	  3075: 
                            	  3076: 							* was NOT token
01:00205204 323C002C        	  3077: 	MOVE.w	#(TK_EQUAL-TK_PLUS)*4,d1	* offset to NOT function
01:00205208 60C6            	  3078: 	BRA.s		LAB_1C13			* do set-up for function then execute
                            	  3079: 
                            	  3080: 							* wasn't +, - or NOT so ...
                            	  3081: LAB_1BE7
01:0020520A B03C00AB        	  3082: 	CMP.b		#TK_FN,d0			* compare with token for FN
01:0020520E 67000514        	  3083: 	BEQ		LAB_201E			* if FN go evaluate FNx
                            	  3084: 
                            	  3085: 							* wasn't +, -, NOT or FN so ...
01:00205212 903C00BF        	  3086: 	SUB.b		#TK_SGN,d0			* compare with token for SGN & normalise
01:00205216 6500F358        	  3087: 	BCS		LAB_SNER			* if < SGN token then do syntax error
                            	  3088: 
                            	  3089: * get value from line .. continued
                            	  3090: * only functions left so set up function references
                            	  3091: 
                            	  3092: * new for V2.0+ this replaces a lot of IF .. THEN .. ELSEIF .. THEN .. that was needed
                            	  3093: * to process function calls. now the function vector is computed and pushed on the stack
                            	  3094: * and the preprocess offset is read. if the preprocess offset is non zero then the vector
                            	  3095: * is calculated and the routine called, if not this routine just does RTS. whichever
                            	  3096: * happens the RTS at the end of this routine, or the preprocess routine calls, the
                            	  3097: * function code
                            	  3098: 
                            	  3099: * this also removes some less than elegant code that was used to bypass type checking
                            	  3100: * for functions that returned strings
                            	  3101: 
01:0020521A C07C007F        	  3102: 	AND.w		#$7F,d0			* mask byte
01:0020521E D040            	  3103: 	ADD.w		d0,d0				* *2 (2 bytes per function offset)
                            	  3104: 
01:00205220 41FA2090        	  3105: 	LEA		LAB_FTBL(pc),a0		* pointer to functions vector table
01:00205224 32300000        	  3106: 	MOVE.w	(a0,d0.w),d1		* get function vector offset
01:00205228 48701000        	  3107: 	PEA		(a0,d1.w)			* push function vector
                            	  3108: 
01:0020522C 41FA2038        	  3109: 	LEA		LAB_FTPP(pc),a0		* pointer to functions preprocess vector table
01:00205230 30300000        	  3110: 	MOVE.w	(a0,d0.w),d0		* get function preprocess vector offset
01:00205234 6712            	  3111: 	BEQ.s		LAB_1C2A			* no preprocess vector so go do function
                            	  3112: 
01:00205236 41F00000        	  3113: 	LEA		(a0,d0.w),a0		* get function preprocess vector
01:0020523A 4ED0            	  3114: 	JMP		(a0)				* go do preprocess routine then function
                            	  3115: 
                            	  3116: 
                            	  3117: *************************************************************************************
                            	  3118: *
                            	  3119: * process string expression in parenthesis
                            	  3120: 
                            	  3121: LAB_PPFS
01:0020523C 6100FF58        	  3122: 	BSR		LAB_1BF7			* process expression in parenthesis
01:00205240 4A2B05B5        	  3123: 	TST.b		Dtypef(a3)			* test data type
01:00205244 6A00F2FE        	  3124: 	BPL		LAB_TMER			* if numeric do Type missmatch Error/warm start
                            	  3125: 
                            	  3126: LAB_1C2A
01:00205248 4E75            	  3127: 	RTS						* else do function
                            	  3128: 
                            	  3129: 
                            	  3130: *************************************************************************************
                            	  3131: *
                            	  3132: * process numeric expression in parenthesis
                            	  3133: 
                            	  3134: LAB_PPFN
01:0020524A 6100FF4A        	  3135: 	BSR		LAB_1BF7			* process expression in parenthesis
01:0020524E 4A2B05B5        	  3136: 	TST.b		Dtypef(a3)			* test data type
01:00205252 6B00F2F0        	  3137: 	BMI		LAB_TMER			* if string do Type missmatch Error/warm start
                            	  3138: 
01:00205256 4E75            	  3139: 	RTS						* else do function
                            	  3140: 
                            	  3141: 
                            	  3142: *************************************************************************************
                            	  3143: *
                            	  3144: * set numeric data type and increment BASIC execute pointer
                            	  3145: 
                            	  3146: LAB_PPBI
01:00205258 177C000005B5    	  3147: 	MOVE.b	#$00,Dtypef(a3)		* clear data type flag, $00=float
01:0020525E 101D            	  3148: 	MOVE.b	(a5)+,d0			* get next BASIC byte
01:00205260 4E75            	  3149: 	RTS						* do function
                            	  3150: 
                            	  3151: 
                            	  3152: *************************************************************************************
                            	  3153: *
                            	  3154: * process string for LEFT$, RIGHT$ or MID$
                            	  3155: 
                            	  3156: LAB_LRMS
01:00205262 6100FDEA        	  3157: 	BSR		LAB_EVEZ			* evaluate (should be string) expression
01:00205266 4A2B05B5        	  3158: 	TST.b		Dtypef(a3)			* test data type flag
01:0020526A 6A00F2D8        	  3159: 	BPL		LAB_TMER			* if type is not string do type mismatch error
                            	  3160: 
01:0020526E 141D            	  3161: 	MOVE.b	(a5)+,d2			* get BASIC byte
01:00205270 B43C002C        	  3162: 	CMP.b		#',',d2			* compare with comma
01:00205274 6600F2FA        	  3163: 	BNE		LAB_SNER			* if not "," go do syntax error/warm start
                            	  3164: 
01:00205278 2F2B0590        	  3165: 	MOVE.l	FAC1_m(a3),-(sp)		* save descriptor pointer
01:0020527C 610008A2        	  3166: 	BSR		LAB_GTWO			* get word parameter, result in d0 and Itemp
01:00205280 205F            	  3167: 	MOVEA.l	(sp)+,a0			* restore descriptor pointer
01:00205282 4E75            	  3168: 	RTS						* do function
                            	  3169: 
                            	  3170: 
                            	  3171: *************************************************************************************
                            	  3172: *
                            	  3173: * process numeric expression(s) for BIN$ or HEX$
                            	  3174: 
                            	  3175: LAB_BHSS
01:00205284 6100FDC8        	  3176: 	BSR		LAB_EVEZ			* evaluate expression (no decrement)
01:00205288 4A2B05B5        	  3177: 	TST.b		Dtypef(a3)			* test data type
01:0020528C 6B00F2B6        	  3178: 	BMI		LAB_TMER			* if string do Type missmatch Error/warm start
                            	  3179: 
01:00205290 61000DC4        	  3180: 	BSR		LAB_2831			* convert FAC1 floating to fixed
                            	  3181: 							* result in d0 and Itemp
01:00205294 7200            	  3182: 	MOVEQ		#0,d1				* set default to no leading "0"s
01:00205296 141D            	  3183: 	MOVE.b	(a5)+,d2			* get BASIC byte
01:00205298 B43C002C        	  3184: 	CMP.b		#',',d2			* compare with comma
01:0020529C 660C            	  3185: 	BNE.s		LAB_BHCB			* if not "," go check close bracket
                            	  3186: 
01:0020529E 2F00            	  3187: 	MOVE.l	d0,-(sp)			* copy number to stack
01:002052A0 6100086A        	  3188: 	BSR		LAB_GTBY			* get byte value
01:002052A4 2200            	  3189: 	MOVE.l	d0,d1				* copy leading 0s #
01:002052A6 201F            	  3190: 	MOVE.l	(sp)+,d0			* restore number from stack
01:002052A8 141D            	  3191: 	MOVE.b	(a5)+,d2			* get BASIC byte
                            	  3192: LAB_BHCB
01:002052AA B43C0029        	  3193: 	CMP.b		#')',d2			* compare with close bracket
01:002052AE 6600F2C0        	  3194: 	BNE		LAB_SNER			* if not ")" do Syntax Error/warm start
                            	  3195: 
01:002052B2 4E75            	  3196: 	RTS						* go do function
                            	  3197: 
                            	  3198: 
                            	  3199: *************************************************************************************
                            	  3200: *
                            	  3201: * perform EOR
                            	  3202: 
                            	  3203: LAB_EOR
01:002052B4 6116            	  3204: 	BSR.s		GetFirst			* get two values for OR, AND or EOR
                            	  3205: 							* first in d0, and Itemp, second in d2
01:002052B6 B580            	  3206: 	EOR.l		d2,d0				* EOR values
01:002052B8 600003F0        	  3207: 	BRA		LAB_AYFC			* convert d0 to signed longword in FAC1 & RET
                            	  3208: 
                            	  3209: 
                            	  3210: *************************************************************************************
                            	  3211: *
                            	  3212: * perform OR
                            	  3213: 
                            	  3214: LAB_OR
01:002052BC 610E            	  3215: 	BSR.s		GetFirst			* get two values for OR, AND or EOR
                            	  3216: 							* first in d0, and Itemp, second in d2
01:002052BE 8082            	  3217: 	OR.l		d2,d0				* do OR
01:002052C0 600003E8        	  3218: 	BRA		LAB_AYFC			* convert d0 to signed longword in FAC1 & RET
                            	  3219: 
                            	  3220: 
                            	  3221: *************************************************************************************
                            	  3222: *
                            	  3223: * perform AND
                            	  3224: 
                            	  3225: LAB_AND
01:002052C4 6106            	  3226: 	BSR.s		GetFirst			* get two values for OR, AND or EOR
                            	  3227: 							* first in d0, and Itemp, second in d2
01:002052C6 C082            	  3228: 	AND.l		d2,d0				* do AND
01:002052C8 600003E0        	  3229: 	BRA		LAB_AYFC			* convert d0 to signed longword in FAC1 & RET
                            	  3230: 
                            	  3231: 
                            	  3232: *************************************************************************************
                            	  3233: *
                            	  3234: * get two values for OR, AND, EOR
                            	  3235: * first in d0, second in d2
                            	  3236: 
                            	  3237: GetFirst
01:002052CC 61000228        	  3238: 	BSR		LAB_EVIR			* evaluate integer expression (no sign check)
                            	  3239: 							* result in d0 and Itemp
01:002052D0 2400            	  3240: 	MOVE.l	d0,d2				* copy second value
01:002052D2 61000CEA        	  3241: 	BSR		LAB_279B			* copy FAC2 to FAC1, get first value in
                            	  3242: 							* expression
01:002052D6 6000021E        	  3243: 	BRA		LAB_EVIR			* evaluate integer expression (no sign check)
                            	  3244: 							* result in d0 and Itemp & return
                            	  3245: 
                            	  3246: 
                            	  3247: *************************************************************************************
                            	  3248: *
                            	  3249: * perform NOT
                            	  3250: 
                            	  3251: LAB_EQUAL
01:002052DA 6100021A        	  3252: 	BSR		LAB_EVIR			* evaluate integer expression (no sign check)
                            	  3253: 							* result in d0 and Itemp
01:002052DE 4680            	  3254: 	NOT.l		d0				* bitwise invert
01:002052E0 600003C8        	  3255: 	BRA		LAB_AYFC			* convert d0 to signed longword in FAC1 & RET
                            	  3256: 
                            	  3257: 
                            	  3258: *************************************************************************************
                            	  3259: *
                            	  3260: * perform comparisons
                            	  3261: * do < compare
                            	  3262: 
                            	  3263: LAB_LTHAN
01:002052E4 6100FD52        	  3264: 	BSR		LAB_CKTM			* type match check, set C for string
01:002052E8 6506            	  3265: 	BCS.s		LAB_1CAE			* branch if string
                            	  3266: 
                            	  3267: 							* do numeric < compare
01:002052EA 61000D3E        	  3268: 	BSR		LAB_27FA			* compare FAC1 with FAC2
                            	  3269: 							* returns d0=+1 if FAC1 > FAC2
                            	  3270: 							* returns d0= 0 if FAC1 = FAC2
                            	  3271: 							* returns d0=-1 if FAC1 < FAC2
01:002052EE 6042            	  3272: 	BRA.s		LAB_1CF2			* process result
                            	  3273: 
                            	  3274: 							* do string < compare
                            	  3275: LAB_1CAE
01:002052F0 177C000005B5    	  3276: 	MOVE.b	#$00,Dtypef(a3)		* clear data type, $80=string, $40=integer,
                            	  3277: 							* $00=float
01:002052F6 610006B4        	  3278: 	BSR		LAB_22B6			* pop string off descriptor stack, or from top
                            	  3279: 							* of string space returns d0 = length,
                            	  3280: 							* a0 = pointer
01:002052FA 2248            	  3281: 	MOVEA.l	a0,a1				* copy string 2 pointer
01:002052FC 2200            	  3282: 	MOVE.l	d0,d1				* copy string 2 length
01:002052FE 206B0598        	  3283: 	MOVEA.l	FAC2_m(a3),a0		* get string 1 descriptor pointer
01:00205302 610006AC        	  3284: 	BSR		LAB_22BA			* pop (a0) descriptor, returns with ..
                            	  3285: 							* d0 = length, a0 = pointer
01:00205306 2400            	  3286: 	MOVE.l	d0,d2				* copy length
01:00205308 6604            	  3287: 	BNE.s		LAB_1CB5			* branch if not null string
                            	  3288: 
01:0020530A 4A81            	  3289: 	TST.l		d1				* test if string 2 is null also
01:0020530C 6724            	  3290: 	BEQ.s		LAB_1CF2			* if so do string 1 = string 2
                            	  3291: 
                            	  3292: LAB_1CB5
01:0020530E 9481            	  3293: 	SUB.l		d1,d2				* subtract string 2 length
01:00205310 670C            	  3294: 	BEQ.s		LAB_1CD5			* branch if strings = length
                            	  3295: 
01:00205312 6504            	  3296: 	BCS.s		LAB_1CD4			* branch if string 1 < string 2
                            	  3297: 
01:00205314 70FF            	  3298: 	MOVEQ		#-1,d0			* set for string 1 > string 2
01:00205316 6008            	  3299: 	BRA.s		LAB_1CD6			* go do character comapare
                            	  3300: 
                            	  3301: LAB_1CD4
01:00205318 2200            	  3302: 	MOVE.l	d0,d1				* string 1 length is compare length
01:0020531A 7001            	  3303: 	MOVEQ		#1,d0				* and set for string 1 < string 2
01:0020531C 6002            	  3304: 	BRA.s		LAB_1CD6			* go do character comapare
                            	  3305: 
                            	  3306: LAB_1CD5
01:0020531E 2002            	  3307: 	MOVE.l	d2,d0				* set for string 1 = string 2
                            	  3308: LAB_1CD6
01:00205320 5381            	  3309: 	SUBQ.l	#1,d1				* adjust length for DBcc loop
                            	  3310: 
                            	  3311: 							* d1 is length to compare, d0 is <=> for length
                            	  3312: 							* a0 is string 1 pointer, a1 is string 2 pointer
                            	  3313: LAB_1CE6
01:00205322 B308            	  3314: 	CMPM.b	(a0)+,(a1)+			* compare string bytes (1 with 2)
01:00205324 56C9FFFC        	  3315: 	DBNE		d1,LAB_1CE6			* loop if same and not end yet
                            	  3316: 
01:00205328 6708            	  3317: 	BEQ.s		LAB_1CF2			* if = to here, then go use length compare
                            	  3318: 
01:0020532A 6404            	  3319: 	BCC.s		LAB_1CDB			* else branch if string 1 > string 2
                            	  3320: 
01:0020532C 70FF            	  3321: 	MOVEQ		#-1,d0			* else set for string 1 < string 2
01:0020532E 6002            	  3322: 	BRA.s		LAB_1CF2			* go set result
                            	  3323: 
                            	  3324: LAB_1CDB
01:00205330 7001            	  3325: 	MOVEQ		#1,d0				* and set for string 1 > string 2
                            	  3326: 
                            	  3327: LAB_1CF2
01:00205332 5200            	  3328: 	ADDQ.b	#1,d0				* make result 0, 1 or 2
01:00205334 1200            	  3329: 	MOVE.b	d0,d1				* copy to d1
01:00205336 7001            	  3330: 	MOVEQ		#1,d0				* set d0 longword
01:00205338 E338            	  3331: 	ROL.b		d1,d0				* make 1, 2 or 4 (result = flag bit)
01:0020533A C02B05E1        	  3332: 	AND.b		Cflag(a3),d0		* AND with comparison evaluation flag
01:0020533E 67000CD2        	  3333: 	BEQ		LAB_27DB			* exit if not a wanted result (i.e. false)
                            	  3334: 
01:00205342 70FF            	  3335: 	MOVEQ		#-1,d0			* else set -1 (true)
01:00205344 60000CCC        	  3336: 	BRA		LAB_27DB			* save d0 as integer & return
                            	  3337: 
                            	  3338: 
                            	  3339: LAB_1CFE
01:00205348 6100FE58        	  3340: 	BSR		LAB_1C01			* scan for ",", else do syntax error/warm start
                            	  3341: 
                            	  3342: 
                            	  3343: *************************************************************************************
                            	  3344: *
                            	  3345: * perform DIM
                            	  3346: 
                            	  3347: LAB_DIM
01:0020534C 72FF            	  3348: 	MOVEQ		#-1,d1			* set "DIM" flag
01:0020534E 6170            	  3349: 	BSR.s		LAB_1D10			* search for or dimension a variable
01:00205350 6100FE5C        	  3350: 	BSR		LAB_GBYT			* scan memory
01:00205354 66F2            	  3351: 	BNE.s		LAB_1CFE			* loop and scan for "," if not null
                            	  3352: 
01:00205356 4E75            	  3353: 	RTS
                            	  3354: 
                            	  3355: 
                            	  3356: *************************************************************************************
                            	  3357: *
                            	  3358: * perform << (left shift)
                            	  3359: 
                            	  3360: LAB_LSHIFT
01:00205358 612E            	  3361: 	BSR.s		GetPair			* get an integer and byte pair
                            	  3362: 							* byte is in d2, integer is in d0 and Itemp
01:0020535A 6708            	  3363: 	BEQ.s		NoShift			* branch if byte zero
                            	  3364: 
01:0020535C B43C0020        	  3365: 	CMP.b		#$20,d2			* compare bit count with 32d
01:00205360 6420            	  3366: 	BCC.s		TooBig			* branch if >=
                            	  3367: 
01:00205362 E5A0            	  3368: 	ASL.l		d2,d0				* shift longword
                            	  3369: NoShift
01:00205364 60000344        	  3370: 	BRA		LAB_AYFC			* convert d0 to signed longword in FAC1 & RET
                            	  3371: 
                            	  3372: 
                            	  3373: *************************************************************************************
                            	  3374: *
                            	  3375: * perform >> (right shift)
                            	  3376: 
                            	  3377: LAB_RSHIFT
01:00205368 611E            	  3378: 	BSR.s		GetPair			* get an integer and byte pair
                            	  3379: 							* byte is in d2, integer is in d0 and Itemp
01:0020536A 67F8            	  3380: 	BEQ.s		NoShift			* branch if byte zero
                            	  3381: 
01:0020536C B43C0020        	  3382: 	CMP.b		#$20,d2			* compare bit count with 32d
01:00205370 650A            	  3383: 	BCS.s		Not2Big			* branch if >= (return shift)
                            	  3384: 
01:00205372 4A80            	  3385: 	TST.l		d0				* test sign bit
01:00205374 6A0C            	  3386: 	BPL.s		TooBig			* branch if +ve
                            	  3387: 
01:00205376 70FF            	  3388: 	MOVEQ		#-1,d0			* set longword
01:00205378 60000330        	  3389: 	BRA		LAB_AYFC			* convert d0 to longword in FAC1 & RET
                            	  3390: 
                            	  3391: Not2Big
01:0020537C E4A0            	  3392: 	ASR.l		d2,d0				* shift longword
01:0020537E 6000032A        	  3393: 	BRA		LAB_AYFC			* convert d0 to longword in FAC1 & RET
                            	  3394: 
                            	  3395: TooBig
01:00205382 7000            	  3396: 	MOVEQ		#0,d0				* clear longword
01:00205384 60000324        	  3397: 	BRA		LAB_AYFC			* convert d0 to longword in FAC1 & RET
                            	  3398: 
                            	  3399: 
                            	  3400: *************************************************************************************
                            	  3401: *
                            	  3402: * get an integer and byte pair
                            	  3403: * byte is in d2, integer is in d0 and Itemp
                            	  3404: 
                            	  3405: GetPair
01:00205388 61000786        	  3406: 	BSR		LAB_EVBY			* evaluate byte expression, result in d0 and
                            	  3407: 							* Itemp
01:0020538C 1400            	  3408: 	MOVE.b	d0,d2				* save it
01:0020538E 61000C2E        	  3409: 	BSR		LAB_279B			* copy FAC2 to FAC1, get first value in
                            	  3410: 							* expression
01:00205392 61000162        	  3411: 	BSR		LAB_EVIR			* evaluate integer expression (no sign check)
                            	  3412: 							* result in d0 and Itemp
01:00205396 4A02            	  3413: 	TST.b		d2				* test byte value
01:00205398 4E75            	  3414: 	RTS
                            	  3415: 
                            	  3416: 
                            	  3417: *************************************************************************************
                            	  3418: *
                            	  3419: * check alpha, return C=0 if<"A" or >"Z" or <"a" to "z">
                            	  3420: 
                            	  3421: LAB_CASC
01:0020539A B03C0061        	  3422: 	CMP.b		#$61,d0			* compare with "a"
01:0020539E 6410            	  3423: 	BCC.s		LAB_1D83			* if >="a" go check =<"z"
                            	  3424: 
                            	  3425: 
                            	  3426: *************************************************************************************
                            	  3427: *
                            	  3428: * check alpha upper case, return C=0 if<"A" or >"Z"
                            	  3429: 
                            	  3430: LAB_CAUC
01:002053A0 B03C0041        	  3431: 	CMP.b		#$41,d0			* compare with "A"
01:002053A4 6404            	  3432: 	BCC.s		LAB_1D8A			* if >="A" go check =<"Z"
                            	  3433: 
01:002053A6 8040            	  3434: 	OR		d0,d0				* make C=0
01:002053A8 4E75            	  3435: 	RTS
                            	  3436: 
                            	  3437: LAB_1D8A
01:002053AA B03C005B        	  3438: 	CMP.b		#$5B,d0			* compare with "Z"+1
                            	  3439: 							* carry set if byte<="Z"
01:002053AE 4E75            	  3440: 	RTS
                            	  3441: 
                            	  3442: LAB_1D83
01:002053B0 B03C007B        	  3443: 	CMP.b		#$7B,d0			* compare with "z"+1
                            	  3444: 							* carry set if byte<="z"
01:002053B4 4E75            	  3445: 	RTS
                            	  3446: 
                            	  3447: 
                            	  3448: *************************************************************************************
                            	  3449: *
                            	  3450: * search for or create variable. this is used to automatically create a variable if
                            	  3451: * it is not found. any routines that need to create the variable call LAB_GVAR via
                            	  3452: * this point and error generation is supressed and the variable will be created
                            	  3453: *
                            	  3454: * return pointer to variable in Cvaral and a0
                            	  3455: * set data type to variable type
                            	  3456: 
                            	  3457: LAB_SVAR
01:002053B6 6102            	  3458: 	BSR.s		LAB_GVAR			* search for variable
                            	  3459: LAB_FVAR
01:002053B8 4E75            	  3460: 	RTS
                            	  3461: 
                            	  3462: 
                            	  3463: *************************************************************************************
                            	  3464: *
                            	  3465: * search for variable. if this routine is called from anywhere but the above call and
                            	  3466: * the variable searched for does not exist then an error will be returned
                            	  3467: *
                            	  3468: * DIM flag is in d1.b
                            	  3469: * return pointer to variable in Cvaral and a0
                            	  3470: * set data type to variable type
                            	  3471: 
                            	  3472: LAB_GVAR
01:002053BA 7200            	  3473: 	MOVEQ		#$00,d1			* set DIM flag = $00
01:002053BC 6100FDF0        	  3474: 	BSR		LAB_GBYT			* scan memory (1st character)
                            	  3475: LAB_1D10
01:002053C0 174105B4        	  3476: 	MOVE.b	d1,Defdim(a3)		* save DIM flag
                            	  3477: 
                            	  3478: * search for FN name entry point
                            	  3479: 
                            	  3480: LAB_1D12
01:002053C4 61D4            	  3481: 	BSR.s		LAB_CASC			* check byte, return C=0 if<"A" or >"Z"
01:002053C6 6400F1A8        	  3482: 	BCC		LAB_SNER			* if not, syntax error then warm start
                            	  3483: 
                            	  3484: 							* it is a variable name so ...
01:002053CA 7200            	  3485: 	MOVEQ		#$0,d1			* set index for name byte
01:002053CC 41EB046A        	  3486: 	LEA		Varname(a3),a0		* pointer to variable name
01:002053D0 2081            	  3487: 	MOVE.l	d1,(a0)			* clear the variable name
01:002053D2 174105B5        	  3488: 	MOVE.b	d1,Dtypef(a3)		* clear the data type, $80=string, $40=integer,
                            	  3489: 							* $00=float
                            	  3490: 
                            	  3491: LAB_1D2D
01:002053D6 B27C0004        	  3492: 	CMP.w		#$04,d1			* done all significant characters?
01:002053DA 6406            	  3493: 	BCC.s		LAB_1D2E			* if so go ignore any more
                            	  3494: 
01:002053DC 11801000        	  3495: 	MOVE.b	d0,(a0,d1.w)		* save the character
01:002053E0 5241            	  3496: 	ADDQ.w	#1,d1				* increment index
                            	  3497: LAB_1D2E
01:002053E2 6100FDC8        	  3498: 	BSR		LAB_IGBY			* increment & scan memory (next character)
01:002053E6 65EE            	  3499: 	BCS.s		LAB_1D2D			* branch if character = "0"-"9" (ok)
                            	  3500: 
                            	  3501: 							* character wasn't "0" to "9" so ...
01:002053E8 61B0            	  3502: 	BSR.s		LAB_CASC			* check byte, return C=0 if<"A" or >"Z"
01:002053EA 65EA            	  3503: 	BCS.s		LAB_1D2D			* branch if = "A"-"Z" (ok)
                            	  3504: 
                            	  3505: 							* check if string variable
01:002053EC B03C0024        	  3506: 	CMP.b		#'$',d0			* compare with "$"
01:002053F0 660C            	  3507: 	BNE.s		LAB_1D44			* branch if not string
                            	  3508: 
                            	  3509: 							* type is string
01:002053F2 002B0080046B    	  3510: 	OR.b		#$80,Varname+1(a3)	* set top bit of 2nd character, indicate string
01:002053F8 6100FDB2        	  3511: 	BSR		LAB_IGBY			* increment & scan memory
01:002053FC 6010            	  3512: 	BRA.s		LAB_1D45			* skip integer check
                            	  3513: 
                            	  3514: 							* check if integer variable
                            	  3515: LAB_1D44
01:002053FE B03C0026        	  3516: 	CMP.b		#'&',d0			* compare with "&"
01:00205402 660A            	  3517: 	BNE.s		LAB_1D45			* branch if not integer
                            	  3518: 
                            	  3519: 							* type is integer
01:00205404 002B0080046C    	  3520: 	OR.b		#$80,Varname+2(a3)	* set top bit of 3rd character, indicate integer
01:0020540A 6100FDA0        	  3521: 	BSR		LAB_IGBY			* increment & scan memory
                            	  3522: 
                            	  3523: * after we have determined the variable type we need to determine
                            	  3524: * if it's an array of type
                            	  3525: 
                            	  3526: 							* gets here with character after var name in d0
                            	  3527: LAB_1D45
01:0020540E 4A2B05DF        	  3528: 	TST.b		Sufnxf(a3)			* test function name flag
01:00205412 670E            	  3529: 	BEQ.s		LAB_1D48			* if not FN or FN variable continue
                            	  3530: 
01:00205414 6A14            	  3531: 	BPL.s		LAB_1D49			* if FN variable go find or create it
                            	  3532: 
                            	  3533: 							* else was FN name
01:00205416 202B046A        	  3534: 	MOVE.l	Varname(a3),d0		* get whole function name
01:0020541A 7208            	  3535: 	MOVEQ		#8,d1				* set step to next function size -4
01:0020541C 41EB0432        	  3536: 	LEA		Sfncl(a3),a0		* get pointer to start of functions
01:00205420 601C            	  3537: 	BRA.s		LAB_1D4B			* go find function
                            	  3538: 
                            	  3539: LAB_1D48
01:00205422 903C0028        	  3540: 	SUB.b		#'(',d0			* subtract "("
01:00205426 670000F4        	  3541: 	BEQ		LAB_1E17			* if "(" go find, or make, array
                            	  3542: 
                            	  3543: * either find or create var
                            	  3544: * var name (1st four characters only!) is in Varname
                            	  3545: 
                            	  3546: 							* variable name wasn't var( .. so look for
                            	  3547: 							* plain variable
                            	  3548: LAB_1D49
01:0020542A 202B046A        	  3549: 	MOVE.l	Varname(a3),d0		* get whole variable name
                            	  3550: LAB_1D4A
01:0020542E 7204            	  3551: 	MOVEQ		#4,d1				* set step to next variable size -4
01:00205430 41EB0436        	  3552: 	LEA		Svarl(a3),a0		* get pointer to start of variables
                            	  3553: 
01:00205434 08000017        	  3554: 	BTST.l	#23,d0			* test if string name
01:00205438 6704            	  3555: 	BEQ.s		LAB_1D4B			* branch if not
                            	  3556: 
01:0020543A 5441            	  3557: 	ADDQ.w	#2,d1				* 6 bytes per string entry
01:0020543C 5848            	  3558: 	ADDQ.w	#(Sstrl-Svarl),a0		* move to string area
                            	  3559: 
                            	  3560: LAB_1D4B
01:0020543E 22680004        	  3561: 	MOVEA.l	4(a0),a1			* get end address
01:00205442 2050            	  3562: 	MOVEA.l	(a0),a0			* get start address
01:00205444 6006            	  3563: 	BRA.s		LAB_1D5E			* enter loop at exit check
                            	  3564: 
                            	  3565: LAB_1D5D
01:00205446 B098            	  3566: 	CMP.l		(a0)+,d0			* compare this variable with name
01:00205448 6776            	  3567: 	BEQ.s		LAB_1DD7			* branch if match (found var)
                            	  3568: 
01:0020544A D1C1            	  3569: 	ADDA.l	d1,a0				* add offset to next variable
                            	  3570: LAB_1D5E
01:0020544C B1C9            	  3571: 	CMPA.l	a1,a0				* compare address with variable space end
01:0020544E 66F6            	  3572: 	BNE.s		LAB_1D5D			* if not end go check next
                            	  3573: 
01:00205450 4A2B05DF        	  3574: 	TST.b		Sufnxf(a3)			* is it a function or function variable
01:00205454 660A            	  3575: 	BNE.s		LAB_1D94			* if was go do DEF or function variable
                            	  3576: 
                            	  3577: 							* reached end of variable mem without match
                            	  3578: 							* ... so create new variable, possibly
                            	  3579: 
01:00205456 45FAFF60        	  3580: 	LEA		LAB_FVAR(pc),a2		* get the address of the create if doesn't
                            	  3581: 							* exist call to LAB_GVAR
01:0020545A B5D7            	  3582: 	CMPA.l	(sp),a2			* compare the return address with expected
01:0020545C 6600F0CE        	  3583: 	BNE		LAB_UVER			* if not create go do error or return null
                            	  3584: 
                            	  3585: * this will only branch if the call to LAB_GVAR wasn't from LAB_SVAR
                            	  3586: 
                            	  3587: LAB_1D94
01:00205460 082B000005DF    	  3588: 	BTST.b	#0,Sufnxf(a3)		* test function search flag
01:00205466 6600F0CC        	  3589: 	BNE		LAB_UFER			* if not doing DEF then go do undefined
                            	  3590: 							* function error
                            	  3591: 
                            	  3592: 							* else create new variable/function
                            	  3593: LAB_1D98
01:0020546A 246B0442        	  3594: 	MOVEA.l	Earryl(a3),a2		* get end of block to move
01:0020546E 240A            	  3595: 	MOVE.l	a2,d2				* copy end of block to move
01:00205470 9489            	  3596: 	SUB.l		a1,d2				* calculate block to move size
                            	  3597: 
01:00205472 204A            	  3598: 	MOVEA.l	a2,a0				* copy end of block to move
01:00205474 5881            	  3599: 	ADDQ.l	#4,d1				* space for one variable/function + name
01:00205476 D5C1            	  3600: 	ADDA.l	d1,a2				* add space for one variable/function
01:00205478 274A0442        	  3601: 	MOVE.l	a2,Earryl(a3)		* set new array mem end
01:0020547C E28A            	  3602: 	LSR.l		#1,d2				* /2 for word copy
01:0020547E 6712            	  3603: 	BEQ.s		LAB_1DAF			* skip move if zero length block
                            	  3604: 
01:00205480 5382            	  3605: 	SUBQ.l	#1,d2				* -1 for DFB loop
01:00205482 4842            	  3606: 	SWAP		d2				* swap high word to low word
                            	  3607: LAB_1DAC
01:00205484 4842            	  3608: 	SWAP		d2				* swap high word to low word
                            	  3609: LAB_1DAE
01:00205486 3520            	  3610: 	MOVE.w	-(a0),-(a2)			* copy word
01:00205488 51CAFFFC        	  3611: 	DBF		d2,LAB_1DAE			* loop until done
                            	  3612: 
01:0020548C 4842            	  3613: 	SWAP		d2				* swap high word to low word
01:0020548E 51CAFFF4        	  3614: 	DBF		d2,LAB_1DAC			* decrement high count and loop until done
                            	  3615: 
                            	  3616: * get here after creating either a function, variable or string
                            	  3617: * if function set variables start, string start, array start
                            	  3618: * if variable set string start, array start
                            	  3619: * if string set array start
                            	  3620: 
                            	  3621: LAB_1DAF
01:00205492 4A2B05DF        	  3622: 	TST.b		Sufnxf(a3)			* was it function
01:00205496 6B08            	  3623: 	BMI.s		LAB_1DB0			* branch if was FN
                            	  3624: 
01:00205498 08000017        	  3625: 	BTST.l	#23,d0			* was it string
01:0020549C 660A            	  3626: 	BNE.s		LAB_1DB2			* branch if string
                            	  3627: 
01:0020549E 6004            	  3628: 	BRA.s		LAB_1DB1			* branch if was plain variable
                            	  3629: 
                            	  3630: LAB_1DB0
01:002054A0 D3AB0436        	  3631: 	ADD.l		d1,Svarl(a3)		* set new variable memory start
                            	  3632: LAB_1DB1
01:002054A4 D3AB043A        	  3633: 	ADD.l		d1,Sstrl(a3)		* set new start of strings
                            	  3634: LAB_1DB2
01:002054A8 D3AB043E        	  3635: 	ADD.l		d1,Sarryl(a3)		* set new array memory start
01:002054AC 20C0            	  3636: 	MOVE.l	d0,(a0)+			* save variable/function name
01:002054AE 20BC00000000    	  3637: 	MOVE.l	#$00,(a0)			* initialise variable
01:002054B4 08000017        	  3638: 	BTST.l	#23,d0			* was it string
01:002054B8 6706            	  3639: 	BEQ.s		LAB_1DD7			* branch if not string
                            	  3640: 
01:002054BA 317C00000004    	  3641: 	MOVE.w	#$00,4(a0)			* else initialise string length
                            	  3642: 
                            	  3643: 							* found a match for var ((Vrschl) = ptr)
                            	  3644: LAB_1DD7
01:002054C0 2200            	  3645: 	MOVE.l	d0,d1				* ........ $....... &....... ........
01:002054C2 D281            	  3646: 	ADD.l		d1,d1				* .......$ .......& ........ .......0
01:002054C4 4841            	  3647: 	SWAP		d1				* ........ .......0 .......$ .......&
01:002054C6 E219            	  3648: 	ROR.b		#1,d1				* ........ .......0 .......$ &.......
01:002054C8 E249            	  3649: 	LSR.w		#1,d1				* ........ .......0 0....... $&.....�.
01:002054CA C23C00C0        	  3650: 	AND.b		#$C0,d1			* mask the type bits
01:002054CE 174105B5        	  3651: 	MOVE.b	d1,Dtypef(a3)		* save the data type
                            	  3652: 
01:002054D2 177C000005DF    	  3653: 	MOVE.b	#$00,Sufnxf(a3)		* clear FN flag byte
                            	  3654: 
                            	  3655: * if you want a non existant variable to return a null value then set the novar
                            	  3656: * value at the top of this file to some non zero value
                            	  3657: 
                            	  3658:  ifne	novar
                            	  3659: 
                            	  3660: 	MOVEQ		#-1,d0			* return variable found
                            	  3661: 
                            	  3662:  endc
                            	  3663: 
01:002054D8 4E75            	  3664: 	RTS
                            	  3665: 
                            	  3666: 
                            	  3667: *************************************************************************************
                            	  3668: *
                            	  3669: * set-up array pointer, d0, to first element in array
                            	  3670: * set d0 to (a0)+2*(Dimcnt)+$0A
                            	  3671: 
                            	  3672: LAB_1DE6
01:002054DA 7005            	  3673: 	MOVEQ		#5,d0				* set d0 to 5 (*2 = 10, later)
01:002054DC D02B05DB        	  3674: 	ADD.b		Dimcnt(a3),d0		* add # of dimensions (1, 2 or 3)
01:002054E0 D080            	  3675: 	ADD.l		d0,d0				* *2 (bytes per dimension size)
01:002054E2 D088            	  3676: 	ADD.l		a0,d0				* add array start pointer
01:002054E4 4E75            	  3677: 	RTS
                            	  3678: 
                            	  3679: 
                            	  3680: *************************************************************************************
                            	  3681: *
                            	  3682: * evaluate unsigned integer expression
                            	  3683: 
                            	  3684: LAB_EVIN
01:002054E6 6100FCC4        	  3685: 	BSR		LAB_IGBY			* increment & scan memory
01:002054EA 6100FB48        	  3686: 	BSR		LAB_EVNM			* evaluate expression & check is numeric,
                            	  3687: 							* else do type mismatch
                            	  3688: 
                            	  3689: 
                            	  3690: *************************************************************************************
                            	  3691: *
                            	  3692: * evaluate positive integer expression, result in d0 and Itemp
                            	  3693: 
                            	  3694: LAB_EVPI
01:002054EE 4A2B0595        	  3695: 	TST.b		FAC1_s(a3)			* test FAC1 sign (b7)
01:002054F2 6B00F070        	  3696: 	BMI		LAB_FCER			* do function call error if -ve
                            	  3697: 
                            	  3698: 
                            	  3699: *************************************************************************************
                            	  3700: *
                            	  3701: * evaluate integer expression, no sign check
                            	  3702: * result in d0 and Itemp, exit with flags set correctly
                            	  3703: 
                            	  3704: LAB_EVIR
01:002054F6 0C2B00A00594    	  3705: 	CMPI.b	#$A0,FAC1_e(a3)		* compare exponent with exponent = 2^32 (n>2^31)
01:002054FC 65000B58        	  3706: 	BCS		LAB_2831			* convert FAC1 floating to fixed
                            	  3707: 							* result in d0 and Itemp
01:00205500 6600F062        	  3708: 	BNE		LAB_FCER			* if > do function call error, then warm start
                            	  3709: 
01:00205504 4A2B0595        	  3710: 	TST.b		FAC1_s(a3)			* test sign of FAC1
01:00205508 6A000B4C        	  3711: 	BPL		LAB_2831			* if +ve then ok
                            	  3712: 
01:0020550C 202B0590        	  3713: 	MOVE.l	FAC1_m(a3),d0		* get mantissa
01:00205510 4480            	  3714: 	NEG.l		d0				* do -d0
01:00205512 6800F050        	  3715: 	BVC		LAB_FCER			* if not $80000000 do FC error, then warm start
                            	  3716: 
01:00205516 2740042A        	  3717: 	MOVE.l	d0,Itemp(a3)		* else just set it
01:0020551A 4E75            	  3718: 	RTS
                            	  3719: 
                            	  3720: 
                            	  3721: *************************************************************************************
                            	  3722: *
                            	  3723: * find or make array
                            	  3724: 
                            	  3725: LAB_1E17
01:0020551C 3F2B05B4        	  3726: 	MOVE.w	Defdim(a3),-(sp)		* get DIM flag and data type flag (word in mem)
01:00205520 7200            	  3727: 	MOVEQ		#0,d1				* clear dimensions count
                            	  3728: 
                            	  3729: * now get the array dimension(s) and stack it (them) before the data type and DIM flag
                            	  3730: 
                            	  3731: LAB_1E1F
01:00205522 3F01            	  3732: 	MOVE.w	d1,-(sp)			* save dimensions count
01:00205524 2F2B046A        	  3733: 	MOVE.l	Varname(a3),-(sp)		* save variable name
01:00205528 61BC            	  3734: 	BSR.s		LAB_EVIN			* evaluate integer expression
                            	  3735: 
01:0020552A 4840            	  3736: 	SWAP		d0				* swap high word to low word
01:0020552C 4A40            	  3737: 	TST.w		d0				* test swapped high word
01:0020552E 6600F024        	  3738: 	BNE		LAB_ABER			* if too big do array bounds error
                            	  3739: 
01:00205532 275F046A        	  3740: 	MOVE.l	(sp)+,Varname(a3)		* restore variable name
01:00205536 321F            	  3741: 	MOVE.w	(sp)+,d1			* restore dimensions count
01:00205538 301F            	  3742: 	MOVE.w	(sp)+,d0			* restore DIM and data type flags
01:0020553A 3F2B042C        	  3743: 	MOVE.w	Itemp+2(a3),-(sp)		* stack this dimension size
01:0020553E 3F00            	  3744: 	MOVE.w	d0,-(sp)			* save DIM and data type flags
01:00205540 5241            	  3745: 	ADDQ.w	#1,d1				* increment dimensions count
01:00205542 6100FC6A        	  3746: 	BSR		LAB_GBYT			* scan memory
01:00205546 B03C002C        	  3747: 	CMP.b		#$2C,d0			* compare with ","
01:0020554A 67D6            	  3748: 	BEQ.s		LAB_1E1F			* if found go do next dimension
                            	  3749: 
01:0020554C 174105DB        	  3750: 	MOVE.b	d1,Dimcnt(a3)		* store dimensions count
01:00205550 6100FC48        	  3751: 	BSR		LAB_1BFB			* scan for ")", else do syntax error/warm start
01:00205554 375F05B4        	  3752: 	MOVE.w	(sp)+,Defdim(a3)		* restore DIM and data type flags (word in mem)
01:00205558 206B043E        	  3753: 	MOVEA.l	Sarryl(a3),a0		* get array mem start
                            	  3754: 
                            	  3755: * now check to see if we are at the end of array memory (we would be if there were
                            	  3756: * no arrays).
                            	  3757: 
                            	  3758: LAB_1E5C
01:0020555C 274805AC        	  3759: 	MOVE.l	a0,Astrtl(a3)		* save as array start pointer
01:00205560 B1EB0442        	  3760: 	CMPA.l	Earryl(a3),a0		* compare with array mem end
01:00205564 672E            	  3761: 	BEQ.s		LAB_1EA1			* go build array if not found
                            	  3762: 
                            	  3763: 							* search for array
01:00205566 2010            	  3764: 	MOVE.l	(a0),d0			* get this array name
01:00205568 B0AB046A        	  3765: 	CMP.l		Varname(a3),d0		* compare with array name
01:0020556C 670A            	  3766: 	BEQ.s		LAB_1E8D			* array found so branch
                            	  3767: 
                            	  3768: 							* no match
01:0020556E 20680004        	  3769: 	MOVEA.l	4(a0),a0			* get this array size
01:00205572 D1EB05AC        	  3770: 	ADDA.l	Astrtl(a3),a0		* add to array start pointer
01:00205576 60E4            	  3771: 	BRA.s		LAB_1E5C			* go check next array
                            	  3772: 
                            	  3773: 							* found array, are we trying to dimension it?
                            	  3774: LAB_1E8D
01:00205578 4A2B05B4        	  3775: 	TST.b		Defdim(a3)			* are we trying to dimension it?
01:0020557C 6600EFD2        	  3776: 	BNE		LAB_DDER			* if so do double dimension error/warm start
                            	  3777: 
                            	  3778: * found the array and we're not dimensioning it so we must find an element in it
                            	  3779: 
01:00205580 6100FF58        	  3780: 	BSR		LAB_1DE6			* set data pointer, d0, to the first element
                            	  3781: 							* in the array
01:00205584 5048            	  3782: 	ADDQ.w	#8,a0				* index to dimension count
01:00205586 3018            	  3783: 	MOVE.w	(a0)+,d0			* get no of dimensions
01:00205588 B02B05DB        	  3784: 	CMP.b		Dimcnt(a3),d0		* compare with dimensions count
01:0020558C 67000094        	  3785: 	BEQ		LAB_1F28			* found array so go get element
                            	  3786: 
01:00205590 6000EF92        	  3787: 	BRA		LAB_WDER			* else wrong so do "Wrong dimensions" error
                            	  3788: 
                            	  3789: 							* array not found, so possibly build it
                            	  3790: LAB_1EA1
01:00205594 4A2B05B4        	  3791: 	TST.b		Defdim(a3)			* test the default DIM flag
01:00205598 6700EF8E        	  3792: 	BEQ		LAB_UDER			* if default flag is clear then we are not
                            	  3793: 							* explicitly dimensioning an array so go
                            	  3794: 							* do an "Undimensioned array" error
                            	  3795: 
01:0020559C 6100FF3C        	  3796: 	BSR		LAB_1DE6			* set data pointer, d0, to the first element
                            	  3797: 							* in the array
01:002055A0 202B046A        	  3798: 	MOVE.l	Varname(a3),d0		* get array name
01:002055A4 20C0            	  3799: 	MOVE.l	d0,(a0)+			* save array name
01:002055A6 7204            	  3800: 	MOVEQ		#4,d1				* set 4 bytes per element
01:002055A8 08000017        	  3801: 	BTST.l	#23,d0			* test if string array
01:002055AC 6702            	  3802: 	BEQ.s		LAB_1EDF			* branch if not string
                            	  3803: 
01:002055AE 7206            	  3804: 	MOVEQ		#6,d1				* else 6 bytes per element
                            	  3805: LAB_1EDF
01:002055B0 274105A8        	  3806: 	MOVE.l	d1,Asptl(a3)		* set array data size (bytes per element)
01:002055B4 122B05DB        	  3807: 	MOVE.b	Dimcnt(a3),d1		* get dimensions count
01:002055B8 5848            	  3808: 	ADDQ.w	#4,a0				* skip the array size now (don't know it yet!)
01:002055BA 30C1            	  3809: 	MOVE.w	d1,(a0)+			* set array's dimensions count
                            	  3810: 
                            	  3811: * now calculate the array data space size
                            	  3812: 
                            	  3813: LAB_1EC0
                            	  3814: 
                            	  3815: * If you want arrays to dimension themselves by default then comment out the test
                            	  3816: * above and uncomment the next three code lines and the label LAB_1ED0
                            	  3817: 
                            	  3818: *	MOVE.w	#$0A,d1			* set default dimension value, allow 0 to 9
                            	  3819: *	TST.b		Defdim(a3)			* test default DIM flag
                            	  3820: *	BNE.s		LAB_1ED0			* branch if b6 of Defdim is clear
                            	  3821: 
01:002055BC 321F            	  3822: 	MOVE.w	(sp)+,d1			* get dimension size
                            	  3823: *LAB_1ED0
01:002055BE 30C1            	  3824: 	MOVE.w	d1,(a0)+			* save to array header
01:002055C0 610000AE        	  3825: 	BSR		LAB_1F7C			* do this dimension size+1 * array size
                            	  3826: 							* (d1+1)*(Asptl), result in d0
01:002055C4 274005A8        	  3827: 	MOVE.l	d0,Asptl(a3)		* save array data size
01:002055C8 532B05DB        	  3828: 	SUBQ.b	#1,Dimcnt(a3)		* decrement dimensions count
01:002055CC 66EE            	  3829: 	BNE.s		LAB_1EC0			* loop while not = 0
                            	  3830: 
01:002055CE D1EB05A8        	  3831: 	ADDA.l	Asptl(a3),a0		* add size to first element address
01:002055D2 6500EF88        	  3832: 	BCS		LAB_OMER			* if overflow go do "Out of memory" error
                            	  3833: 
01:002055D6 B1EB0446        	  3834: 	CMPA.l	Sstorl(a3),a0		* compare with bottom of string memory
01:002055DA 650C            	  3835: 	BCS.s		LAB_1ED6			* branch if less (is ok)
                            	  3836: 
01:002055DC 6100028E        	  3837: 	BSR		LAB_GARB			* do garbage collection routine
01:002055E0 B1EB0446        	  3838: 	CMPA.l	Sstorl(a3),a0		* compare with bottom of string memory
01:002055E4 6400EF76        	  3839: 	BCC		LAB_OMER			* if Sstorl <= a0 do "Out of memory"
                            	  3840: 							* error then warm start
                            	  3841: 
                            	  3842: LAB_1ED6						* ok exit, carry set
01:002055E8 27480442        	  3843: 	MOVE.l	a0,Earryl(a3)		* save array mem end
01:002055EC 7000            	  3844: 	MOVEQ		#0,d0				* zero d0
01:002055EE 222B05A8        	  3845: 	MOVE.l	Asptl(a3),d1		* get size in bytes
01:002055F2 E289            	  3846: 	LSR.l		#1,d1				* /2 for word fill (may be odd # words)
01:002055F4 5341            	  3847: 	SUBQ.w	#1,d1				* adjust for DBF loop
                            	  3848: LAB_1ED8
01:002055F6 3100            	  3849: 	MOVE.w	d0,-(a0)			* decrement pointer and clear word
01:002055F8 51C9FFFC        	  3850: 	DBF		d1,LAB_1ED8			* decrement & loop until low word done
                            	  3851: 
01:002055FC 4841            	  3852: 	SWAP		d1				* swap words
01:002055FE 4A41            	  3853: 	TST.w		d1				* test high word
01:00205600 6706            	  3854: 	BEQ.s		LAB_1F07			* exit if done
                            	  3855: 
01:00205602 5341            	  3856: 	SUBQ.w	#1,d1				* decrement low (high) word
01:00205604 4841            	  3857: 	SWAP		d1				* swap back
01:00205606 60EE            	  3858: 	BRA.s		LAB_1ED8			* go do a whole block
                            	  3859: 
                            	  3860: * now we need to calculate the array size by doing Earryl - Astrtl
                            	  3861: 
                            	  3862: LAB_1F07
01:00205608 206B05AC        	  3863: 	MOVEA.l	Astrtl(a3),a0		* get for calculation and as pointer
01:0020560C 202B0442        	  3864: 	MOVE.l	Earryl(a3),d0		* get array memory end
01:00205610 9088            	  3865: 	SUB.l		a0,d0				* calculate array size
01:00205612 21400004        	  3866: 	MOVE.l	d0,4(a0)			* save size to array
01:00205616 4A2B05B4        	  3867: 	TST.b		Defdim(a3)			* test default DIM flag
01:0020561A 6652            	  3868: 	BNE.s		RTS_011			* exit (RET) if this was a DIM command
                            	  3869: 
                            	  3870: 							* else, find element
01:0020561C 5048            	  3871: 	ADDQ.w	#8,a0				* index to dimension count
01:0020561E 375805DB        	  3872: 	MOVE.w	(a0)+,Dimcnt(a3)		* get array's dimension count
                            	  3873: 
                            	  3874: * we have found, or built, the array. now we need to find the element
                            	  3875: 
                            	  3876: LAB_1F28
01:00205622 7000            	  3877: 	MOVEQ		#0,d0				* clear first result
01:00205624 274005A8        	  3878: 	MOVE.l	d0,Asptl(a3)		* clear array data pointer
                            	  3879: 
                            	  3880: * compare nth dimension bound (a0) with nth index (sp)+
                            	  3881: * if greater do array bounds error
                            	  3882: 
                            	  3883: LAB_1F2C
01:00205628 3218            	  3884: 	MOVE.w	(a0)+,d1			* get nth dimension bound
01:0020562A B257            	  3885: 	CMP.w		(sp),d1			* compare nth index with nth dimension bound
01:0020562C 6500EF26        	  3886: 	BCS		LAB_ABER			* if d1 less or = do array bounds error
                            	  3887: 
                            	  3888: * now do pointer = pointer * nth dimension + nth index
                            	  3889: 
01:00205630 4A80            	  3890: 	TST.l		d0				* test pointer
01:00205632 6702            	  3891: 	BEQ.s		LAB_1F5A			* skip multiply if last result = null
                            	  3892: 
01:00205634 613A            	  3893: 	BSR.s		LAB_1F7C			* do this dimension size+1 * array size
                            	  3894: LAB_1F5A
01:00205636 7200            	  3895: 	MOVEQ		#0,d1				* clear longword
01:00205638 321F            	  3896: 	MOVE.w	(sp)+,d1			* get nth dimension index
01:0020563A D081            	  3897: 	ADD.l		d1,d0				* add index to size
01:0020563C 274005A8        	  3898: 	MOVE.l	d0,Asptl(a3)		* save array data pointer
                            	  3899: 
01:00205640 532B05DB        	  3900: 	SUBQ.b	#1,Dimcnt(a3)		* decrement dimensions count
01:00205644 66E2            	  3901: 	BNE.s		LAB_1F2C			* loop if dimensions still to do
                            	  3902: 
01:00205646 177C000005B5    	  3903: 	MOVE.b	#0,Dtypef(a3)		* set data type to float
01:0020564C 7203            	  3904: 	MOVEQ		#3,d1				* set for numeric array
01:0020564E 4A2B046B        	  3905: 	TST.b		Varname+1(a3)		* test if string array
01:00205652 6A0A            	  3906: 	BPL.s		LAB_1F6A			* branch if not string
                            	  3907: 
01:00205654 7205            	  3908: 	MOVEQ		#5,d1				* else set for string array
01:00205656 177C008005B5    	  3909: 	MOVE.b	#$80,Dtypef(a3)		* and set data type to string
01:0020565C 600C            	  3910: 	BRA.s		LAB_1F6B			* skip integer test
                            	  3911: 
                            	  3912: LAB_1F6A
01:0020565E 4A2B046C        	  3913: 	TST.b		Varname+2(a3)		* test if integer array
01:00205662 6A06            	  3914: 	BPL.s		LAB_1F6B			* branch if not integer
                            	  3915: 
01:00205664 177C004005B5    	  3916: 	MOVE.b	#$40,Dtypef(a3)		* else set data type to integer
                            	  3917: LAB_1F6B
01:0020566A 6104            	  3918: 	BSR.s		LAB_1F7C			* do element size (d1) * array size (Asptl)
01:0020566C D1C0            	  3919: 	ADDA.l	d0,a0				* add array data start pointer
                            	  3920: RTS_011
01:0020566E 4E75            	  3921: 	RTS
                            	  3922: 
                            	  3923: 
                            	  3924: *************************************************************************************
                            	  3925: *
                            	  3926: * do this dimension size (d1) * array data size (Asptl)
                            	  3927: 
                            	  3928: * do a 16 x 32 bit multiply
                            	  3929: * d1 holds the 16 bit multiplier
                            	  3930: * Asptl holds the 32 bit multiplicand
                            	  3931: 
                            	  3932: * d0	bbbb  bbbb
                            	  3933: * d1	0000  aaaa
                            	  3934: *	----------
                            	  3935: * d0	rrrr  rrrr
                            	  3936: 
                            	  3937: LAB_1F7C
01:00205670 202B05A8        	  3938: 	MOVE.l	Asptl(a3),d0		* get result
01:00205674 2400            	  3939: 	MOVE.l	d0,d2				* copy it
01:00205676 4842            	  3940: 	SWAP		d2				* shift high word to low word
01:00205678 C0C1            	  3941: 	MULU.w	d1,d0				* d1 * low word = low result
01:0020567A C4C1            	  3942: 	MULU.w	d1,d2				* d1 * high word = high result
01:0020567C 4842            	  3943: 	SWAP		d2				* align words for test
01:0020567E 4A42            	  3944: 	TST.w		d2				* must be zero
01:00205680 6600EEDA        	  3945: 	BNE		LAB_OMER			* if overflow go do "Out of memory" error
                            	  3946: 
01:00205684 D082            	  3947: 	ADD.l		d2,d0				* calculate result
01:00205686 6500EED4        	  3948: 	BCS		LAB_OMER			* if overflow go do "Out of memory" error
                            	  3949: 
01:0020568A D0AB05A8        	  3950: 	ADD.l		Asptl(a3),d0		* add original
01:0020568E 6500EECC        	  3951: 	BCS		LAB_OMER			* if overflow go do "Out of memory" error
                            	  3952: 
01:00205692 4E75            	  3953: 	RTS
                            	  3954: 
                            	  3955: 
                            	  3956: *************************************************************************************
                            	  3957: *
                            	  3958: * perform FRE()
                            	  3959: 
                            	  3960: LAB_FRE
01:00205694 4A2B05B5        	  3961: 	TST.b		Dtypef(a3)			* test data type, $80=string, $40=integer,
                            	  3962: 							* $00=float
01:00205698 6A04            	  3963: 	BPL.s		LAB_1FB4			* branch if numeric
                            	  3964: 
01:0020569A 61000310        	  3965: 	BSR		LAB_22B6			* pop string off descriptor stack, or from
                            	  3966: 							* top of string space, returns d0 = length,
                            	  3967: 							* a0 = pointer
                            	  3968: 
                            	  3969: 							* FRE(n) was numeric so do this
                            	  3970: LAB_1FB4
01:0020569E 610001CC        	  3971: 	BSR		LAB_GARB			* go do garbage collection
01:002056A2 202B0446        	  3972: 	MOVE.l	Sstorl(a3),d0		* get bottom of string space
01:002056A6 90AB0442        	  3973: 	SUB.l		Earryl(a3),d0		* subtract array mem end
                            	  3974: 
                            	  3975: 
                            	  3976: *************************************************************************************
                            	  3977: *
                            	  3978: * convert d0 to signed longword in FAC1
                            	  3979: 
                            	  3980: LAB_AYFC
01:002056AA 177C000005B5    	  3981: 	MOVE.b	#$00,Dtypef(a3)		* clear data type, $80=string, $40=integer,
                            	  3982: 							* $00=float
01:002056B0 377CA0000594    	  3983: 	MOVE.w	#$A000,FAC1_e(a3)		* set FAC1 exponent and clear sign (b7)
01:002056B6 27400590        	  3984: 	MOVE.l	d0,FAC1_m(a3)		* save FAC1 mantissa
01:002056BA 6A000636        	  3985: 	BPL		LAB_24D0			* convert if +ve
                            	  3986: 
01:002056BE 003C0001        	  3987: 	ORI.b		#1,CCR			* else set carry
01:002056C2 6000062E        	  3988: 	BRA		LAB_24D0			* do +/- (carry is sign) & normalise FAC1
                            	  3989: 
                            	  3990: 
                            	  3991: *************************************************************************************
                            	  3992: *
                            	  3993: * remember if the line length is zero (infinite line) then POS(n) will return
                            	  3994: * position MOD tabsize
                            	  3995: 
                            	  3996: * perform POS()
                            	  3997: 
                            	  3998: LAB_POS
01:002056C6 102B05E5        	  3999: 	MOVE.b	TPos(a3),d0			* get terminal position
                            	  4000: 
                            	  4001: * convert d0 to unsigned byte in FAC1
                            	  4002: 
                            	  4003: LAB_1FD0
01:002056CA C0BC000000FF    	  4004: 	AND.l		#$FF,d0			* clear high bits
01:002056D0 60D8            	  4005: 	BRA.s		LAB_AYFC			* convert d0 to signed longword in FAC1 & RET
                            	  4006: 
                            	  4007: * check not direct (used by DEF and INPUT)
                            	  4008: 
                            	  4009: LAB_CKRN
01:002056D2 4A2B0452        	  4010: 	TST.b		Clinel(a3)			* test current line #
01:002056D6 6B00EE70        	  4011: 	BMI		LAB_IDER			* if -ve go do illegal direct error then warm
                            	  4012: 							* start
                            	  4013: 
01:002056DA 4E75            	  4014: 	RTS						* can continue so return
                            	  4015: 
                            	  4016: 
                            	  4017: *************************************************************************************
                            	  4018: *
                            	  4019: * perform DEF
                            	  4020: 
                            	  4021: LAB_DEF
01:002056DC 70AB            	  4022: 	MOVEQ		#TK_FN-$100,d0		* get FN token
01:002056DE 6100FAC4        	  4023: 	BSR		LAB_SCCA			* scan for CHR$(d0), else syntax error and
                            	  4024: 							* warm start
                            	  4025: 							* return character after d0
01:002056E2 177C008005DF    	  4026: 	MOVE.b	#$80,Sufnxf(a3)		* set FN flag bit
01:002056E8 6100FCDA        	  4027: 	BSR		LAB_1D12			* get FN name
01:002056EC 274805B0        	  4028: 	MOVE.l	a0,func_l(a3)		* save function pointer
                            	  4029: 
01:002056F0 61E0            	  4030: 	BSR.s		LAB_CKRN			* check not direct (back here if ok)
01:002056F2 0C1D0028        	  4031: 	CMP.b		#$28,(a5)+			* check next byte is "(" and increment
01:002056F6 6600EE78        	  4032: 	BNE		LAB_SNER			* else do syntax error/warm start
                            	  4033: 
01:002056FA 177C007E05DF    	  4034: 	MOVE.b	#$7E,Sufnxf(a3)		* set FN variable flag bits
01:00205700 6100FCB4        	  4035: 	BSR		LAB_SVAR			* search for or create a variable
                            	  4036: 							* return the variable address in a0
01:00205704 6100FA94        	  4037: 	BSR		LAB_1BFB			* scan for ")", else do syntax error/warm start
01:00205708 70BD            	  4038: 	MOVEQ		#TK_EQUAL-$100,d0		* = token
01:0020570A 6100FA98        	  4039: 	BSR		LAB_SCCA			* scan for CHR$(A), else syntax error/warm start
                            	  4040: 							* return character after d0
01:0020570E 2F2B046A        	  4041: 	MOVE.l	Varname(a3),-(sp)		* push current variable name
01:00205712 2F0D            	  4042: 	MOVE.l	a5,-(sp)			* push BASIC execute pointer
01:00205714 6100F41C        	  4043: 	BSR		LAB_DATA			* go perform DATA, find end of DEF FN statement
01:00205718 206B05B0        	  4044: 	MOVEA.l	func_l(a3),a0		* get the function pointer
01:0020571C 209F            	  4045: 	MOVE.l	(sp)+,(a0)			* save BASIC execute pointer to function
01:0020571E 215F0004        	  4046: 	MOVE.l	(sp)+,4(a0)			* save current variable name to function
01:00205722 4E75            	  4047: 	RTS
                            	  4048: 
                            	  4049: 
                            	  4050: *************************************************************************************
                            	  4051: *
                            	  4052: * evaluate FNx
                            	  4053: 
                            	  4054: LAB_201E
01:00205724 177C008105DF    	  4055: 	MOVE.b	#$81,Sufnxf(a3)		* set FN flag (find not create)
01:0020572A 6100FA80        	  4056: 	BSR		LAB_IGBY			* increment & scan memory
01:0020572E 6100FC94        	  4057: 	BSR		LAB_1D12			* get FN name
01:00205732 1F2B05B5        	  4058: 	MOVE.b	Dtypef(a3),-(sp)		* push data type flag (function type)
01:00205736 2F08            	  4059: 	MOVE.l	a0,-(sp)			* push function pointer
01:00205738 0C150028        	  4060: 	CMP.b		#$28,(a5)			* check next byte is "(", no increment
01:0020573C 6600EE32        	  4061: 	BNE		LAB_SNER			* else do syntax error/warm start
                            	  4062: 
01:00205740 6100FA54        	  4063: 	BSR		LAB_1BF7			* evaluate expression within parentheses
01:00205744 205F            	  4064: 	MOVEA.l	(sp)+,a0			* pop function pointer
01:00205746 274805B0        	  4065: 	MOVE.l	a0,func_l(a3)		* set function pointer
01:0020574A 1F2B05B5        	  4066: 	MOVE.b	Dtypef(a3),-(sp)		* push data type flag (function expression type)
                            	  4067: 
01:0020574E 20280004        	  4068: 	MOVE.l	4(a0),d0			* get function variable name
01:00205752 6100FCDA        	  4069: 	BSR		LAB_1D4A			* go find function variable (already created)
                            	  4070: 
                            	  4071: 							* now check type match for variable
01:00205756 101F            	  4072: 	MOVE.b	(sp)+,d0			* pop data type flag (function expression type)
01:00205758 E318            	  4073: 	ROL.b		#1,d0				* set carry if type = string
01:0020575A 6100F8DC        	  4074: 	BSR		LAB_CKTM			* type match check, set C for string
                            	  4075: 
                            	  4076: 							* now stack the function variable value before
                            	  4077: 							* use
01:0020575E 6712            	  4078: 	BEQ.s		LAB_2043			* branch if not string
                            	  4079: 
01:00205760 43EB0476        	  4080: 	LEA		des_sk_e(a3),a1		* get string stack pointer max+1
01:00205764 B9C9            	  4081: 	CMPA.l	a1,a4				* compare string stack pointer with max+1
01:00205766 6700EDD4        	  4082: 	BEQ		LAB_SCER			* if no space on the stack go do string too
                            	  4083: 							* complex error
                            	  4084: 
01:0020576A 39280004        	  4085: 	MOVE.w	4(a0),-(a4)			* string length on descriptor stack
01:0020576E 2910            	  4086: 	MOVE.l	(a0),-(a4)			* string address on stack
01:00205770 6002            	  4087: 	BRA.s		LAB_204S			* skip var push
                            	  4088: 
                            	  4089: LAB_2043
01:00205772 2F10            	  4090: 	MOVE.l	(a0),-(sp)			* push variable
                            	  4091: LAB_204S
01:00205774 2F08            	  4092: 	MOVE.l	a0,-(sp)			* push variable address
01:00205776 1F2B05B5        	  4093: 	MOVE.b	Dtypef(a3),-(sp)		* push variable data type
                            	  4094: 
01:0020577A 6132            	  4095: 	BSR.s		LAB_2045			* pack function expression value into (a0)
                            	  4096: 							* (function variable)
01:0020577C 2F0D            	  4097: 	MOVE.l	a5,-(sp)			* push BASIC execute pointer
01:0020577E 206B05B0        	  4098: 	MOVEA.l	func_l(a3),a0		* get function pointer
01:00205782 2A50            	  4099: 	MOVEA.l	(a0),a5			* save function execute ptr as BASIC execute ptr
01:00205784 6100F8C6        	  4100: 	BSR		LAB_EVEX			* evaluate expression
01:00205788 6100FA24        	  4101: 	BSR		LAB_GBYT			* scan memory
01:0020578C 6600EDE2        	  4102: 	BNE		LAB_SNER			* if not [EOL] or [EOS] do syntax error and
                            	  4103: 							* warm start
                            	  4104: 
01:00205790 2A5F            	  4105: 	MOVE.l	(sp)+,a5			* restore BASIC execute pointer
                            	  4106: 
                            	  4107: * restore variable from stack and test data type
                            	  4108: 
01:00205792 101F            	  4109: 	MOVE.b	(sp)+,d0			* pull variable data type
01:00205794 205F            	  4110: 	MOVEA.l	(sp)+,a0			* pull variable address
01:00205796 4A00            	  4111: 	TST.b		d0				* test variable data type
01:00205798 6A08            	  4112: 	BPL.s		LAB_204T			* branch if not string
                            	  4113: 
01:0020579A 209C            	  4114: 	MOVE.l	(a4)+,(a0)			* string address from descriptor stack
01:0020579C 315C0004        	  4115: 	MOVE.w	(a4)+,4(a0)			* string length from descriptor stack
01:002057A0 6002            	  4116: 	BRA.s		LAB_2044			* skip variable pull
                            	  4117: 
                            	  4118: LAB_204T
01:002057A2 209F            	  4119: 	MOVE.l	(sp)+,(a0)			* restore variable from stack
                            	  4120: LAB_2044
01:002057A4 101F            	  4121: 	MOVE.b	(sp)+,d0			* pop data type flag (function type)
01:002057A6 E318            	  4122: 	ROL.b		#1,d0				* set carry if type = string
01:002057A8 6100F88E        	  4123: 	BSR		LAB_CKTM			* type match check, set C for string
01:002057AC 4E75            	  4124: 	RTS
                            	  4125: 
                            	  4126: LAB_2045
01:002057AE 4A2B05B5        	  4127: 	TST.b		Dtypef(a3)			* test data type
01:002057B2 6A0007E4        	  4128: 	BPL		LAB_2778			* if numeric pack FAC1 into variable (a0)
                            	  4129: 							* and return
                            	  4130: 
01:002057B6 2448            	  4131: 	MOVEA.l	a0,a2				* copy variable pointer
01:002057B8 6000F516        	  4132: 	BRA		LAB_17D6			* go do string LET & return
                            	  4133: 
                            	  4134: 
                            	  4135: 
                            	  4136: *************************************************************************************
                            	  4137: *
                            	  4138: * perform STR$()
                            	  4139: 
                            	  4140: LAB_STRS
01:002057BC 61000940        	  4141: 	BSR		LAB_2970			* convert FAC1 to string
                            	  4142: 
                            	  4143: * scan, set up string
                            	  4144: * print " terminated string to FAC1 stack
                            	  4145: 
                            	  4146: LAB_20AE
01:002057C0 7422            	  4147: 	MOVEQ		#$22,d2			* set Srchc character (terminator 1)
01:002057C2 3602            	  4148: 	MOVE.w	d2,d3				* set Asrch character (terminator 2)
                            	  4149: 
                            	  4150: * print d2/d3 terminated string to FAC1 stack
                            	  4151: * d2 = Srchc, d3 = Asrch, a0 is source
                            	  4152: * a6 is temp
                            	  4153: 
                            	  4154: LAB_20B4
01:002057C4 7200            	  4155: 	MOVEQ		#0,d1				* clear longword
01:002057C6 5341            	  4156: 	SUBQ.w	#1,d1				* set length to -1
01:002057C8 2448            	  4157: 	MOVEA.l	a0,a2				* copy start to calculate end
                            	  4158: LAB_20BE
01:002057CA 5241            	  4159: 	ADDQ.w	#1,d1				* increment length
01:002057CC 10301000        	  4160: 	MOVE.b	(a0,d1.w),d0		* get byte from string
01:002057D0 6710            	  4161: 	BEQ.s		LAB_20D0			* exit loop if null byte [EOS]
                            	  4162: 
01:002057D2 B002            	  4163: 	CMP.b		d2,d0				* compare with search character (terminator 1)
01:002057D4 6704            	  4164: 	BEQ.s		LAB_20CB			* branch if terminator
                            	  4165: 
01:002057D6 B003            	  4166: 	CMP.b		d3,d0				* compare with terminator 2
01:002057D8 66F0            	  4167: 	BNE.s		LAB_20BE			* loop if not terminator 2 (or null string)
                            	  4168: 
                            	  4169: LAB_20CB
01:002057DA B03C0022        	  4170: 	CMP.b		#$22,d0			* compare with "
01:002057DE 6602            	  4171: 	BNE.s		LAB_20D0			* branch if not "
                            	  4172: 
01:002057E0 524A            	  4173: 	ADDQ.w	#1,a2				* else increment string start (skip " at end)
                            	  4174: LAB_20D0
01:002057E2 D5C1            	  4175: 	ADDA.l	d1,a2				* add longowrd length to make string end+1
                            	  4176: 
01:002057E4 B1CB            	  4177: 	CMPA.l	a3,a0				* is string in ram
01:002057E6 651E            	  4178: 	BCS.s		LAB_RTST			* if not go push descriptor on stack & exit
                            	  4179: 							* (could be message string from ROM)
                            	  4180: 
01:002057E8 B1EB042E        	  4181: 	CMPA.l	Smeml(a3),a0		* is string in utility ram
01:002057EC 6418            	  4182: 	BCC.s		LAB_RTST			* if not go push descriptor on stack & exit
                            	  4183: 							* (is in string or program space)
                            	  4184: 
                            	  4185: 							* (else) copy string to string memory
                            	  4186: LAB_20C9
01:002057EE 2248            	  4187: 	MOVEA.l	a0,a1				* copy descriptor pointer
01:002057F0 2001            	  4188: 	MOVE.l	d1,d0				* copy longword length
01:002057F2 6604            	  4189: 	BNE.s		LAB_20D8			* branch if not null string
                            	  4190: 
01:002057F4 2041            	  4191: 	MOVEA.l	d1,a0				* make null pointer
01:002057F6 600E            	  4192: 	BRA.s		LAB_RTST			* go push descriptor on stack & exit
                            	  4193: 
                            	  4194: LAB_20D8
01:002057F8 6126            	  4195: 	BSR.s		LAB_2115			* make string space d1 bytes long
01:002057FA D1C1            	  4196: 	ADDA.l	d1,a0				* new string end
01:002057FC D3C1            	  4197: 	ADDA.l	d1,a1				* old string end
01:002057FE 5340            	  4198: 	SUBQ.w	#1,d0				* -1 for DBF loop
                            	  4199: LAB_20E0
01:00205800 1121            	  4200: 	MOVE.b	-(a1),-(a0)			* copy byte (source can be odd aligned)
01:00205802 51C8FFFC        	  4201: 	DBF		d0,LAB_20E0			* loop until done
                            	  4202: 
                            	  4203: 
                            	  4204: 
                            	  4205: *************************************************************************************
                            	  4206: *
                            	  4207: * check for space on descriptor stack then ...
                            	  4208: * put string address and length on descriptor stack & update stack pointers
                            	  4209: * start is in a0, length is in d1
                            	  4210: 
                            	  4211: LAB_RTST
01:00205806 43EB0476        	  4212: 	LEA		des_sk_e(a3),a1		* get string stack pointer max+1
01:0020580A B9C9            	  4213: 	CMPA.l	a1,a4				* compare string stack pointer with max+1
01:0020580C 6700ED2E        	  4214: 	BEQ		LAB_SCER			* if no space on string stack ..
                            	  4215: 							* .. go do 'string too complex' error
                            	  4216: 
                            	  4217: 							* push string & update pointers
01:00205810 3901            	  4218: 	MOVE.w	d1,-(a4)			* string length on descriptor stack
01:00205812 2908            	  4219: 	MOVE.l	a0,-(a4)			* string address on stack
01:00205814 274C0590        	  4220: 	MOVE.l	a4,FAC1_m(a3)		* string descriptor pointer in FAC1
01:00205818 177C008005B5    	  4221: 	MOVE.b	#$80,Dtypef(a3)		* save data type flag, $80=string
01:0020581E 4E75            	  4222: 	RTS
                            	  4223: 
                            	  4224: 
                            	  4225: *************************************************************************************
                            	  4226: *
                            	  4227: * build descriptor a0/d1
                            	  4228: * make space in string memory for string d1.w long
                            	  4229: * return pointer in a0/Sutill
                            	  4230: 
                            	  4231: LAB_2115
01:00205820 4A41            	  4232: 	TST.w		d1				* test length
01:00205822 672E            	  4233: 	BEQ.s		LAB_2128			* branch if user wants null string
                            	  4234: 
                            	  4235: 							* make space for string d1 long
01:00205824 2F00            	  4236: 	MOVE.l	d0,-(sp)			* save d0
01:00205826 7000            	  4237: 	MOVEQ		#0,d0				* clear longword
01:00205828 174005DE        	  4238: 	MOVE.b	d0,Gclctd(a3)		* clear garbage collected flag (b7)
01:0020582C 7001            	  4239: 	MOVEQ		#1,d0				* +1 to possibly round up
01:0020582E C041            	  4240: 	AND.w		d1,d0				* mask odd bit
01:00205830 D041            	  4241: 	ADD.w		d1,d0				* ensure d0 is even length
01:00205832 6404            	  4242: 	BCC.s		LAB_2117			* branch if no overflow
                            	  4243: 
01:00205834 7001            	  4244: 	MOVEQ		#1,d0				* set to allocate 65536 bytes
01:00205836 4840            	  4245: 	SWAP		d0				* makes $00010000
                            	  4246: LAB_2117
01:00205838 206B0446        	  4247: 	MOVEA.l	Sstorl(a3),a0		* get bottom of string space
01:0020583C 91C0            	  4248: 	SUBA.l	d0,a0				* subtract string length
01:0020583E B1EB0442        	  4249: 	CMPA.l	Earryl(a3),a0		* compare with top of array space
01:00205842 6512            	  4250: 	BCS.s		LAB_2137			* if less do out of memory error
                            	  4251: 
01:00205844 27480446        	  4252: 	MOVE.l	a0,Sstorl(a3)		* save bottom of string space
01:00205848 2748044E        	  4253: 	MOVE.l	a0,Sutill(a3)		* save string utility pointer
01:0020584C 201F            	  4254: 	MOVE.l	(sp)+,d0			* restore d0
01:0020584E 4A41            	  4255: 	TST.w		d1				* set flags on length
01:00205850 4E75            	  4256: 	RTS
                            	  4257: 
                            	  4258: LAB_2128
01:00205852 3041            	  4259: 	MOVEA.w	d1,a0				* make null pointer
01:00205854 4E75            	  4260: 	RTS
                            	  4261: 
                            	  4262: LAB_2137
01:00205856 4A2B05DE        	  4263: 	TST.b		Gclctd(a3)			* get garbage collected flag
01:0020585A 6B00ED00        	  4264: 	BMI		LAB_OMER			* do "Out of memory" error, then warm start
                            	  4265: 
01:0020585E 2F09            	  4266: 	MOVE.l	a1,-(sp)			* save a1
01:00205860 610A            	  4267: 	BSR.s		LAB_GARB			* else go do garbage collection
01:00205862 225F            	  4268: 	MOVEA.l	(sp)+,a1			* restore a1
01:00205864 177C008005DE    	  4269: 	MOVE.b	#$80,Gclctd(a3)		* set garbage collected flag
01:0020586A 60CC            	  4270: 	BRA.s		LAB_2117			* go try again
                            	  4271: 
                            	  4272: 
                            	  4273: *************************************************************************************
                            	  4274: *
                            	  4275: * garbage collection routine
                            	  4276: 
                            	  4277: LAB_GARB
01:0020586C 48E7E0E0        	  4278: 	MOVEM.l	d0-d2/a0-a2,-(sp)		* save registers
01:00205870 276B044A0446    	  4279: 	MOVE.l	Ememl(a3),Sstorl(a3)	* start with no strings
                            	  4280: 
                            	  4281: 							* re-run routine from last ending
                            	  4282: LAB_214B
01:00205876 222B0442        	  4283: 	MOVE.l	Earryl(a3),d1		* set highest uncollected string so far
01:0020587A 7000            	  4284: 	MOVEQ		#0,d0				* clear longword
01:0020587C 2240            	  4285: 	MOVEA.l	d0,a1				* clear string to move pointer
01:0020587E 206B043A        	  4286: 	MOVEA.l	Sstrl(a3),a0		* set pointer to start of strings
01:00205882 5888            	  4287: 	LEA		4(a0),a0			* index to string pointer
01:00205884 246B043E        	  4288: 	MOVEA.l	Sarryl(a3),a2		* set end pointer to start of arrays (end of
                            	  4289: 							* strings)
01:00205888 6006            	  4290: 	BRA.s		LAB_2176			* branch into loop at end loop test
                            	  4291: 
                            	  4292: LAB_2161
01:0020588A 617E            	  4293: 	BSR		LAB_2206			* test and set if this is the highest string
01:0020588C 41E8000A        	  4294: 	LEA		10(a0),a0			* increment to next string
                            	  4295: LAB_2176
01:00205890 B1CA            	  4296: 	CMPA.l	a2,a0				* compare end of area with pointer
01:00205892 65F6            	  4297: 	BCS.s		LAB_2161			* go do next if not at end
                            	  4298: 
                            	  4299: * done strings, now do arrays.
                            	  4300: 
01:00205894 5988            	  4301: 	LEA		-4(a0),a0			* decrement pointer to start of arrays
01:00205896 246B0442        	  4302: 	MOVEA.l	Earryl(a3),a2		* set end pointer to end of arrays
01:0020589A 6024            	  4303: 	BRA.s		LAB_218F			* branch into loop at end loop test
                            	  4304: 
                            	  4305: LAB_217E
01:0020589C 24280004        	  4306: 	MOVE.l	4(a0),d2			* get array size
01:002058A0 D488            	  4307: 	ADD.l		a0,d2				* makes start of next array
                            	  4308: 
01:002058A2 2010            	  4309: 	MOVE.l	(a0),d0			* get array name
01:002058A4 08000017        	  4310: 	BTST		#23,d0			* test string flag
01:002058A8 6714            	  4311: 	BEQ.s		LAB_218B			* branch if not string
                            	  4312: 
01:002058AA 30280008        	  4313: 	MOVE.w	8(a0),d0			* get # of dimensions
01:002058AE D040            	  4314: 	ADD.w		d0,d0				* *2
01:002058B0 D0C0            	  4315: 	ADDA.w	d0,a0				* add to skip dimension size(s)
01:002058B2 41E8000A        	  4316: 	LEA		10(a0),a0			* increment to first element
                            	  4317: LAB_2183
01:002058B6 6152            	  4318: 	BSR.s		LAB_2206			* test and set if this is the highest string
01:002058B8 5C48            	  4319: 	ADDQ.w	#6,a0				* increment to next element
01:002058BA B1C2            	  4320: 	CMPA.l	d2,a0				* compare with start of next array
01:002058BC 66F8            	  4321: 	BNE.s		LAB_2183			* go do next if not at end of array
                            	  4322: 
                            	  4323: LAB_218B
01:002058BE 2042            	  4324: 	MOVEA.l	d2,a0				* pointer to next array
                            	  4325: LAB_218F
01:002058C0 B5C8            	  4326: 	CMPA.l	a0,a2				* compare pointer with array end
01:002058C2 66D8            	  4327: 	BNE.s		LAB_217E			* go do next if not at end
                            	  4328: 
                            	  4329: * done arrays and variables, now just the descriptor stack to do
                            	  4330: 
01:002058C4 204C            	  4331: 	MOVEA.l	a4,a0				* get descriptor stack pointer
01:002058C6 45EB048E        	  4332: 	LEA		des_sk(a3),a2		* set end pointer to end of stack
01:002058CA 6004            	  4333: 	BRA.s		LAB_21C4			* branch into loop at end loop test
                            	  4334: 
                            	  4335: LAB_21C2
01:002058CC 613C            	  4336: 	BSR.s		LAB_2206			* test and set if this is the highest string
01:002058CE 5C88            	  4337: 	LEA		6(a0),a0			* increment to next string
                            	  4338: LAB_21C4
01:002058D0 B5C8            	  4339: 	CMPA.l	a0,a2				* compare pointer with stack end
01:002058D2 66F8            	  4340: 	BNE.s		LAB_21C2			* go do next if not at end
                            	  4341: 
                            	  4342: * descriptor search complete, now either exit or set-up and move string
                            	  4343: 
01:002058D4 2009            	  4344: 	MOVE.l	a1,d0				* set the flags (a1 is move string)
01:002058D6 672C            	  4345: 	BEQ.s		LAB_21D1			* go tidy up and exit if no move
                            	  4346: 
01:002058D8 2051            	  4347: 	MOVEA.l	(a1),a0			* a0 is now string start
01:002058DA 7200            	  4348: 	MOVEQ		#0,d1				* clear d1
01:002058DC 32290004        	  4349: 	MOVE.w	4(a1),d1			* d1 is string length
01:002058E0 5281            	  4350: 	ADDQ.l	#1,d1				* +1
01:002058E2 C23C00FE        	  4351: 	AND.b		#$FE,d1			* make even length
01:002058E6 D1C1            	  4352: 	ADDA.l	d1,a0				* pointer is now to string end+1
01:002058E8 246B0446        	  4353: 	MOVEA.l	Sstorl(a3),a2		* is destination end+1
01:002058EC B1CA            	  4354: 	CMPA.l	a2,a0				* does the string need moving
01:002058EE 670C            	  4355: 	BEQ.s		LAB_2240			* branch if not
                            	  4356: 
01:002058F0 E289            	  4357: 	LSR.l		#1,d1				* word move so do /2
01:002058F2 5341            	  4358: 	SUBQ.w	#1,d1				* -1 for DBF loop
                            	  4359: LAB_2216
01:002058F4 3520            	  4360: 	MOVE.w	-(a0),-(a2)			* copy word
01:002058F6 51C9FFFC        	  4361: 	DBF		d1,LAB_2216			* loop until done
                            	  4362: 
01:002058FA 228A            	  4363: 	MOVE.l	a2,(a1)			* save new string start
                            	  4364: LAB_2240
01:002058FC 27510446        	  4365: 	MOVE.l	(a1),Sstorl(a3)		* string start is new string mem start
01:00205900 6000FF74        	  4366: 	BRA		LAB_214B			* re-run routine from last ending
                            	  4367: 							* (but don't collect this string)
                            	  4368: 
                            	  4369: LAB_21D1
01:00205904 4CDF0707        	  4370: 	MOVEM.l	(sp)+,d0-d2/a0-a2		* restore registers
01:00205908 4E75            	  4371: 	RTS
                            	  4372: 
                            	  4373: * test and set if this is the highest string
                            	  4374: 
                            	  4375: LAB_2206
01:0020590A 2010            	  4376: 	MOVE.l	(a0),d0			* get this string pointer
01:0020590C 6728            	  4377: 	BEQ.s		RTS_012			* exit if null string
                            	  4378: 
01:0020590E B280            	  4379: 	CMP.l		d0,d1				* compare with highest uncollected string so far
01:00205910 6424            	  4380: 	BCC.s		RTS_012			* exit if <= with highest so far
                            	  4381: 
01:00205912 B0AB0446        	  4382: 	CMP.l		Sstorl(a3),d0		* compare with bottom of string space
01:00205916 641E            	  4383: 	BCC.s		RTS_012			* exit if >= bottom of string space
                            	  4384: 
01:00205918 70FF            	  4385: 	MOVEQ		#-1,d0			* d0 = $FFFFFFFF
01:0020591A 30280004        	  4386: 	MOVE.w	4(a0),d0			* d0 is string length
01:0020591E 4440            	  4387: 	NEG.w		d0				* make -ve
01:00205920 C03C00FE        	  4388: 	AND.b		#$FE,d0			* make -ve even length
01:00205924 D0AB0446        	  4389: 	ADD.l		Sstorl(a3),d0		* add string store to -ve length
01:00205928 B090            	  4390: 	CMP.l		(a0),d0			* compare with string address
01:0020592A 6706            	  4391: 	BEQ.s		LAB_2212			* if = go move string store pointer down
                            	  4392: 
01:0020592C 2210            	  4393: 	MOVE.l	(a0),d1			* highest = current
01:0020592E 2248            	  4394: 	MOVEA.l	a0,a1				* string to move = current
01:00205930 4E75            	  4395: 	RTS
                            	  4396: 
                            	  4397: LAB_2212
01:00205932 27400446        	  4398: 	MOVE.l	d0,Sstorl(a3)		* set new string store start
                            	  4399: RTS_012
01:00205936 4E75            	  4400: 	RTS
                            	  4401: 
                            	  4402: 
                            	  4403: *************************************************************************************
                            	  4404: *
                            	  4405: * concatenate - add strings
                            	  4406: * string descriptor 1 is in FAC1_m, string 2 is in line
                            	  4407: 
                            	  4408: LAB_224D
01:00205938 487AF744        	  4409: 	PEA		LAB_1ADB(pc)		* continue evaluation after concatenate
01:0020593C 2F2B0590        	  4410: 	MOVE.l	FAC1_m(a3),-(sp)		* stack descriptor pointer for string 1
                            	  4411: 
01:00205940 6100F818        	  4412: 	BSR		LAB_GVAL			* get value from line
01:00205944 4A2B05B5        	  4413: 	TST.b		Dtypef(a3)			* test data type flag
01:00205948 6A00EBFA        	  4414: 	BPL		LAB_TMER			* if type is not string do type mismatch error
                            	  4415: 
01:0020594C 205F            	  4416: 	MOVEA.l	(sp)+,a0			* restore descriptor pointer for string 1
                            	  4417: 
                            	  4418: *************************************************************************************
                            	  4419: *
                            	  4420: * concatenate
                            	  4421: * string descriptor 1 is in a0, string descriptor 2 is in FAC1_m
                            	  4422: 
                            	  4423: LAB_224E
01:0020594E 226B0590        	  4424: 	MOVEA.l	FAC1_m(a3),a1		* copy descriptor pointer 2
01:00205952 32280004        	  4425: 	MOVE.w	4(a0),d1			* get length 1
01:00205956 D2690004        	  4426: 	ADD.w		4(a1),d1			* add length 2
01:0020595A 6500EBE4        	  4427: 	BCS		LAB_SLER			* if overflow go do 'string too long' error
                            	  4428: 
01:0020595E 2F08            	  4429: 	MOVE.l	a0,-(sp)			* save descriptor pointer 1
01:00205960 6100FEBE        	  4430: 	BSR		LAB_2115			* make space d1 bytes long
01:00205964 27480598        	  4431: 	MOVE.l	a0,FAC2_m(a3)		* save new string start pointer
01:00205968 2057            	  4432: 	MOVEA.l	(sp),a0			* copy descriptor pointer 1 from stack
01:0020596A 30280004        	  4433: 	MOVE.w	4(a0),d0			* get length
01:0020596E 2050            	  4434: 	MOVEA.l	(a0),a0			* get string pointer
01:00205970 6120            	  4435: 	BSR.s		LAB_229E			* copy string d0 bytes long from a0 to Sutill
                            	  4436: 							* return with a0 = pointer, d1 = length
                            	  4437: 
01:00205972 206B0590        	  4438: 	MOVEA.l	FAC1_m(a3),a0		* get descriptor pointer for string 2
01:00205976 6138            	  4439: 	BSR.s		LAB_22BA			* pop (a0) descriptor, returns with ..
                            	  4440: 							* a0 = pointer, d0 = length
01:00205978 6118            	  4441: 	BSR.s		LAB_229E			* copy string d0 bytes long from a0 to Sutill
                            	  4442: 							* return with a0 = pointer, d1 = length
                            	  4443: 
01:0020597A 205F            	  4444: 	MOVEA.l	(sp)+,a0			* get descriptor pointer for string 1
01:0020597C 6132            	  4445: 	BSR.s		LAB_22BA			* pop (a0) descriptor, returns with ..
                            	  4446: 							* d0 = length, a0 = pointer
                            	  4447: 
01:0020597E 206B0598        	  4448: 	MOVEA.l	FAC2_m(a3),a0		* retreive the result string pointer
01:00205982 2208            	  4449: 	MOVE.l	a0,d1				* copy the result string pointer
01:00205984 6700FE80        	  4450: 	BEQ		LAB_RTST			* if it is a null string just return it
                            	  4451: 							* a0 = pointer, d1 = length
                            	  4452: 
01:00205988 4481            	  4453: 	NEG.l		d1				* else make the start pointer negative
01:0020598A D2AB044E        	  4454: 	ADD.l		Sutill(a3),d1		* add the end pointert to give the length
01:0020598E 6000FE76        	  4455: 	BRA		LAB_RTST			* push string on descriptor stack
                            	  4456: 							* a0 = pointer, d1 = length
                            	  4457: 
                            	  4458: 
                            	  4459: *************************************************************************************
                            	  4460: *
                            	  4461: * copy string d0 bytes long from a0 to Sutill
                            	  4462: * return with a0 = pointer, d1 = length
                            	  4463: 
                            	  4464: LAB_229E
01:00205992 3200            	  4465: 	MOVE.w	d0,d1				* copy and check length
01:00205994 6714            	  4466: 	BEQ.s		RTS_013			* skip copy if null
                            	  4467: 
01:00205996 226B044E        	  4468: 	MOVEA.l	Sutill(a3),a1		* get destination pointer
01:0020599A 2F09            	  4469: 	MOVE.l	a1,-(sp)			* save destination string pointer
01:0020599C 5340            	  4470: 	SUBQ.w	#1,d0				* subtract for DBF loop
                            	  4471: LAB_22A0
01:0020599E 12D8            	  4472: 	MOVE.b	(a0)+,(a1)+			* copy byte
01:002059A0 51C8FFFC        	  4473: 	DBF		d0,LAB_22A0			* loop if not done
                            	  4474: 
01:002059A4 2749044E        	  4475: 	MOVE.l	a1,Sutill(a3)		* update Sutill to end of copied string
01:002059A8 205F            	  4476: 	MOVEA.l	(sp)+,a0			* restore destination string pointer
                            	  4477: RTS_013
01:002059AA 4E75            	  4478: 	RTS
                            	  4479: 
                            	  4480: 
                            	  4481: *************************************************************************************
                            	  4482: *
                            	  4483: * pop string off descriptor stack, or from top of string space
                            	  4484: * returns with d0.l = length, a0 = pointer
                            	  4485: 
                            	  4486: LAB_22B6
01:002059AC 206B0590        	  4487: 	MOVEA.l	FAC1_m(a3),a0		* get descriptor pointer
                            	  4488: 
                            	  4489: 
                            	  4490: *************************************************************************************
                            	  4491: *
                            	  4492: * pop (a0) descriptor off stack or from string space
                            	  4493: * returns with d0.l = length, a0 = pointer
                            	  4494: 
                            	  4495: LAB_22BA
01:002059B0 48E74040        	  4496: 	MOVEM.l	a1/d1,-(sp)			* save other regs
01:002059B4 B9C8            	  4497: 	CMPA.l	a0,a4				* is string on the descriptor stack
01:002059B6 6602            	  4498: 	BNE.s		LAB_22BD			* skip pop if not
                            	  4499: 
01:002059B8 5C4C            	  4500: 	ADDQ.w	#$06,a4			* else update stack pointer
                            	  4501: LAB_22BD
01:002059BA 7000            	  4502: 	MOVEQ		#0,d0				* clear string length longword
01:002059BC 2258            	  4503: 	MOVEA.l	(a0)+,a1			* get string address
01:002059BE 3018            	  4504: 	MOVE.w	(a0)+,d0			* get string length
                            	  4505: 
01:002059C0 B9C8            	  4506: 	CMPA.l	a0,a4				* was it on the descriptor stack
01:002059C2 6610            	  4507: 	BNE.s		LAB_22E6			* branch if it wasn't
                            	  4508: 
01:002059C4 B3EB0446        	  4509: 	CMPA.l	Sstorl(a3),a1		* compare string address with bottom of string
                            	  4510: 							* space
01:002059C8 660A            	  4511: 	BNE.s		LAB_22E6			* branch if <>
                            	  4512: 
01:002059CA 7201            	  4513: 	MOVEQ		#1,d1				* mask for odd bit
01:002059CC C240            	  4514: 	AND.w		d0,d1				* AND length
01:002059CE D280            	  4515: 	ADD.l		d0,d1				* make it fit word aligned length
                            	  4516: 
01:002059D0 D3AB0446        	  4517: 	ADD.l		d1,Sstorl(a3)		* add to bottom of string space
                            	  4518: LAB_22E6
01:002059D4 2049            	  4519: 	MOVEA.l	a1,a0				* copy to a0
01:002059D6 4CDF0202        	  4520: 	MOVEM.l	(sp)+,a1/d1			* restore other regs
01:002059DA 4A80            	  4521: 	TST.l		d0				* set flags on length
01:002059DC 4E75            	  4522: 	RTS
                            	  4523: 
                            	  4524: 
                            	  4525: *************************************************************************************
                            	  4526: *
                            	  4527: * perform CHR$()
                            	  4528: 
                            	  4529: LAB_CHRS
01:002059DE 61000130        	  4530: 	BSR		LAB_EVBY			* evaluate byte expression, result in d0 and
                            	  4531: 							* Itemp
                            	  4532: LAB_MKCHR
01:002059E2 7201            	  4533: 	MOVEQ		#1,d1				* string is single byte
01:002059E4 6100FE3A        	  4534: 	BSR		LAB_2115			* make string space d1 bytes long
                            	  4535: 							* return a0/Sutill = pointer, others unchanged
01:002059E8 1080            	  4536: 	MOVE.b	d0,(a0)			* save byte in string (byte IS string!)
01:002059EA 6000FE1A        	  4537: 	BRA		LAB_RTST			* push string on descriptor stack
                            	  4538: 							* a0 = pointer, d1 = length
                            	  4539: 
                            	  4540: 
                            	  4541: *************************************************************************************
                            	  4542: *
                            	  4543: * perform LEFT$()
                            	  4544: 
                            	  4545: * enter with a0 is descriptor, d0 & Itemp is word 1
                            	  4546: 
                            	  4547: LAB_LEFT
01:002059EE C141            	  4548: 	EXG		d0,d1				* word in d1
01:002059F0 6100F7A8        	  4549: 	BSR		LAB_1BFB			* scan for ")", else do syntax error/warm start
                            	  4550: 
01:002059F4 4A81            	  4551: 	TST.l		d1				* test returned length
01:002059F6 6722            	  4552: 	BEQ.s		LAB_231C			* branch if null return
                            	  4553: 
01:002059F8 7000            	  4554: 	MOVEQ		#0,d0				* clear start offset
01:002059FA B2680004        	  4555: 	CMP.w		4(a0),d1			* compare word parameter with string length
01:002059FE 651A            	  4556: 	BCS.s		LAB_231C			* branch if string length > word parameter
                            	  4557: 
01:00205A00 6014            	  4558: 	BRA.s		LAB_2317			* go copy whole string
                            	  4559: 
                            	  4560: 
                            	  4561: *************************************************************************************
                            	  4562: *
                            	  4563: * perform RIGHT$()
                            	  4564: 
                            	  4565: * enter with a0 is descriptor, d0 & Itemp is word 1
                            	  4566: 
                            	  4567: LAB_RIGHT
01:00205A02 C141            	  4568: 	EXG		d0,d1				* word in d1
01:00205A04 6100F794        	  4569: 	BSR		LAB_1BFB			* scan for ")", else do syntax error/warm start
                            	  4570: 
01:00205A08 4A81            	  4571: 	TST.l		d1				* test returned length
01:00205A0A 670E            	  4572: 	BEQ.s		LAB_231C			* branch if null return
                            	  4573: 
01:00205A0C 30280004        	  4574: 	MOVE.w	4(a0),d0			* get string length
01:00205A10 9081            	  4575: 	SUB.l		d1,d0				* subtract word
01:00205A12 6406            	  4576: 	BCC.s		LAB_231C			* branch if string length > word parameter
                            	  4577: 
                            	  4578: 							* else copy whole string
                            	  4579: LAB_2316
01:00205A14 7000            	  4580: 	MOVEQ		#0,d0				* clear start offset
                            	  4581: LAB_2317
01:00205A16 32280004        	  4582: 	MOVE.w	4(a0),d1			* else make parameter = length
                            	  4583: 
                            	  4584: * get here with ...
                            	  4585: *   a0 - points to descriptor
                            	  4586: *   d0 - is offset from string start
                            	  4587: *   d1 - is required string length
                            	  4588: 
                            	  4589: LAB_231C
01:00205A1A 2248            	  4590: 	MOVEA.l	a0,a1				* save string descriptor pointer
01:00205A1C 6100FE02        	  4591: 	BSR		LAB_2115			* make string space d1 bytes long
                            	  4592: 							* return a0/Sutill = pointer, others unchanged
01:00205A20 2049            	  4593: 	MOVEA.l	a1,a0				* restore string descriptor pointer
01:00205A22 2F00            	  4594: 	MOVE.l	d0,-(sp)			* save start offset (longword)
01:00205A24 618A            	  4595: 	BSR.s		LAB_22BA			* pop (a0) descriptor, returns with ..
                            	  4596: 							* d0 = length, a0 = pointer
01:00205A26 D1DF            	  4597: 	ADDA.l	(sp)+,a0			* adjust pointer to start of wanted string
01:00205A28 3001            	  4598: 	MOVE.w	d1,d0				* length to d0
01:00205A2A 6100FF66        	  4599: 	BSR		LAB_229E			* store string d0 bytes long from (a0) to
                            	  4600: 							* (Sutill) return with a0 = pointer,
                            	  4601: 							* d1 = length
01:00205A2E 6000FDD6        	  4602: 	BRA		LAB_RTST			* push string on descriptor stack
                            	  4603: 							* a0 = pointer, d1 = length
                            	  4604: 
                            	  4605: 
                            	  4606: *************************************************************************************
                            	  4607: *
                            	  4608: * perform MID$()
                            	  4609: 
                            	  4610: * enter with a0 is descriptor, d0 & Itemp is word 1
                            	  4611: 
                            	  4612: LAB_MIDS
01:00205A32 7E00            	  4613: 	MOVEQ		#0,d7				* clear longword
01:00205A34 5347            	  4614: 	SUBQ.w	#1,d7				* set default length = 65535
01:00205A36 2F00            	  4615: 	MOVE.l	d0,-(sp)			* save word 1
01:00205A38 6100F774        	  4616: 	BSR		LAB_GBYT			* scan memory
01:00205A3C B03C002C        	  4617: 	CMP.b		#',',d0			* was it ","
01:00205A40 660C            	  4618: 	BNE.s		LAB_2358			* branch if not "," (skip second byte get)
                            	  4619: 
01:00205A42 101D            	  4620: 	MOVE.b	(a5)+,d0			* increment pointer past ","
01:00205A44 2F08            	  4621: 	MOVE.l	a0,-(sp)			* save descriptor pointer
01:00205A46 610000D8        	  4622: 	BSR		LAB_GTWO			* get word parameter, result in d0 and Itemp
01:00205A4A 205F            	  4623: 	MOVEA.l	(sp)+,a0			* restore descriptor pointer
01:00205A4C 2E00            	  4624: 	MOVE.l	d0,d7				* copy length
                            	  4625: LAB_2358
01:00205A4E 6100F74A        	  4626: 	BSR		LAB_1BFB			* scan for ")", else do syntax error then warm
                            	  4627: 							* start
01:00205A52 201F            	  4628: 	MOVE.l	(sp)+,d0			* restore word 1
01:00205A54 7200            	  4629: 	MOVEQ		#0,d1				* null length
01:00205A56 5380            	  4630: 	SUBQ.l	#1,d0				* decrement start index (word 1)
01:00205A58 6B00EB0A        	  4631: 	BMI		LAB_FCER			* if was null do function call error then warm
                            	  4632: 							* start
                            	  4633: 
01:00205A5C B0680004        	  4634: 	CMP.w		4(a0),d0			* compare string length with start index
01:00205A60 64B8            	  4635: 	BCC.s		LAB_231C			* if start not in string do null string (d1=0)
                            	  4636: 
01:00205A62 2207            	  4637: 	MOVE.l	d7,d1				* get length back
01:00205A64 DE40            	  4638: 	ADD.w		d0,d7				* d7 now = MID$() end
01:00205A66 6506            	  4639: 	BCS.s		LAB_2368			* already too long so do RIGHT$ equivalent
                            	  4640: 
01:00205A68 BE680004        	  4641: 	CMP.w		4(a0),d7			* compare string length with start index+length
01:00205A6C 65AC            	  4642: 	BCS.s		LAB_231C			* if end in string go do string
                            	  4643: 
                            	  4644: LAB_2368
01:00205A6E 32280004        	  4645: 	MOVE.w	4(a0),d1			* get string length
01:00205A72 9240            	  4646: 	SUB.w		d0,d1				* subtract start offset
01:00205A74 60A4            	  4647: 	BRA.s		LAB_231C			* go do string (effectively RIGHT$)
                            	  4648: 
                            	  4649: 
                            	  4650: *************************************************************************************
                            	  4651: *
                            	  4652: * perform LCASE$()
                            	  4653: 
                            	  4654: LAB_LCASE
01:00205A76 6100FF34        	  4655: 	BSR		LAB_22B6			* pop string off descriptor stack or from memory
                            	  4656: 							* returns with d0 = length, a0 = pointer
01:00205A7A 2200            	  4657: 	MOVE.l	d0,d1				* copy the string length
01:00205A7C 6756            	  4658: 	BEQ.s		NoString			* if null go return a null string
                            	  4659: 
                            	  4660: * else copy and change the string
                            	  4661: 
01:00205A7E 2248            	  4662: 	MOVEA.l	a0,a1				* copy the string address
01:00205A80 6100FD9E        	  4663: 	BSR		LAB_2115			* make a string space d1 bytes long
01:00205A84 D1C1            	  4664: 	ADDA.l	d1,a0				* new string end
01:00205A86 D3C1            	  4665: 	ADDA.l	d1,a1				* old string end
01:00205A88 3401            	  4666: 	MOVE.w	d1,d2				* copy length for loop
01:00205A8A 5342            	  4667: 	SUBQ.w	#1,d2				* -1 for DBF loop
                            	  4668: LC_loop
01:00205A8C 1021            	  4669: 	MOVE.b	-(a1),d0			* get byte from string
                            	  4670: 
01:00205A8E B03C005B        	  4671: 	CMP.b		#$5B,d0			* compare with "Z"+1
01:00205A92 640A            	  4672: 	BCC.s		NoUcase			* if > "Z" skip change
                            	  4673: 
01:00205A94 B03C0041        	  4674: 	CMP.b		#$41,d0			* compare with "A"
01:00205A98 6504            	  4675: 	BCS.s		NoUcase			* if < "A" skip change
                            	  4676: 
01:00205A9A 00000020        	  4677: 	ORI.b		#$20,d0			* convert upper case to lower case
                            	  4678: NoUcase
01:00205A9E 1100            	  4679: 	MOVE.b	d0,-(a0)			* copy upper case byte back to string
01:00205AA0 51CAFFEA        	  4680: 	DBF		d2,LC_loop			* decrement and loop if not all done
                            	  4681: 
01:00205AA4 602E            	  4682: 	BRA.s		NoString			* tidy up & exit (branch always)
                            	  4683: 
                            	  4684: 
                            	  4685: *************************************************************************************
                            	  4686: *
                            	  4687: * perform UCASE$()
                            	  4688: 
                            	  4689: LAB_UCASE
01:00205AA6 6100FF04        	  4690: 	BSR		LAB_22B6			* pop string off descriptor stack or from memory
                            	  4691: 							* returns with d0 = length, a0 = pointer
01:00205AAA 2200            	  4692: 	MOVE.l	d0,d1				* copy the string length
01:00205AAC 6726            	  4693: 	BEQ.s		NoString			* if null go return a null string
                            	  4694: 
                            	  4695: * else copy and change the string
                            	  4696: 
01:00205AAE 2248            	  4697: 	MOVEA.l	a0,a1				* copy the string address
01:00205AB0 6100FD6E        	  4698: 	BSR		LAB_2115			* make a string space d1 bytes long
01:00205AB4 D1C1            	  4699: 	ADDA.l	d1,a0				* new string end
01:00205AB6 D3C1            	  4700: 	ADDA.l	d1,a1				* old string end
01:00205AB8 3401            	  4701: 	MOVE.w	d1,d2				* copy length for loop
01:00205ABA 5342            	  4702: 	SUBQ.w	#1,d2				* -1 for DBF loop
                            	  4703: UC_loop
01:00205ABC 1021            	  4704: 	MOVE.b	-(a1),d0			* get a byte from the string
                            	  4705: 
01:00205ABE B03C0061        	  4706: 	CMP.b		#$61,d0			* compare with "a"
01:00205AC2 650A            	  4707: 	BCS.s		NoLcase			* if < "a" skip change
                            	  4708: 
01:00205AC4 B03C007B        	  4709: 	CMP.b		#$7B,d0			* compare with "z"+1
01:00205AC8 6404            	  4710: 	BCC.s		NoLcase			* if > "z" skip change
                            	  4711: 
01:00205ACA 020000DF        	  4712: 	ANDI.b	#$DF,d0			* convert lower case to upper case
                            	  4713: NoLcase
01:00205ACE 1100            	  4714: 	MOVE.b	d0,-(a0)			* copy upper case byte back to string
01:00205AD0 51CAFFEA        	  4715: 	DBF		d2,UC_loop			* decrement and loop if not all done
                            	  4716: 
                            	  4717: NoString
01:00205AD4 6000FD30        	  4718: 	BRA		LAB_RTST			* push string on descriptor stack
                            	  4719: 							* a0 = pointer, d1 = length
                            	  4720: 
                            	  4721: 
                            	  4722: *************************************************************************************
                            	  4723: *
                            	  4724: * perform SADD()
                            	  4725: 
                            	  4726: LAB_SADD
01:00205AD8 101D            	  4727: 	MOVE.b	(a5)+,d0			* increment pointer
01:00205ADA 6100F8DE        	  4728: 	BSR		LAB_GVAR			* get variable address in a0
01:00205ADE 6100F6BA        	  4729: 	BSR		LAB_1BFB			* scan for ")", else do syntax error/warm start
01:00205AE2 4A2B05B5        	  4730: 	TST.b		Dtypef(a3)			* test data type flag
01:00205AE6 6A00EA5C        	  4731: 	BPL		LAB_TMER			* if numeric do Type missmatch Error
                            	  4732: 
                            	  4733: * if you want a non existant variable to return a null value then set the novar
                            	  4734: * value at the top of this file to some non zero value
                            	  4735: 
                            	  4736:  ifne	novar
                            	  4737: 
                            	  4738: 	MOVE.l	a0,d0				* test the variable found flag
                            	  4739: 	BEQ		LAB_AYFC			* if not found go return null
                            	  4740: 
                            	  4741:  endc
                            	  4742: 
01:00205AEA 2010            	  4743: 	MOVE.l	(a0),d0			* get string address
01:00205AEC 6000FBBC        	  4744: 	BRA		LAB_AYFC			* convert d0 to signed longword in FAC1 & return
                            	  4745: 
                            	  4746: 
                            	  4747: *************************************************************************************
                            	  4748: *
                            	  4749: * perform LEN()
                            	  4750: 
                            	  4751: LAB_LENS
01:00205AF0 487AFBB8        	  4752: 	PEA		LAB_AYFC(pc)		* set return address to convert d0 to signed
                            	  4753: 							* longword in FAC1
01:00205AF4 6000FEB6        	  4754: 	BRA		LAB_22B6			* pop string off descriptor stack or from memory
                            	  4755: 							* returns with d0 = length, a0 = pointer
                            	  4756: 
                            	  4757: 
                            	  4758: *************************************************************************************
                            	  4759: *
                            	  4760: * perform ASC()
                            	  4761: 
                            	  4762: LAB_ASC
01:00205AF8 6100FEB2        	  4763: 	BSR		LAB_22B6			* pop string off descriptor stack or from memory
                            	  4764: 							* returns with d0 = length, a0 = pointer
01:00205AFC 4A40            	  4765: 	TST.w		d0				* test length
01:00205AFE 6700EA64        	  4766: 	BEQ		LAB_FCER			* if null do function call error then warm start
                            	  4767: 
01:00205B02 1010            	  4768: 	MOVE.b	(a0),d0			* get first character byte
01:00205B04 6000FBC4        	  4769: 	BRA		LAB_1FD0			* convert d0 to unsigned byte in FAC1 & return
                            	  4770: 
                            	  4771: 
                            	  4772: *************************************************************************************
                            	  4773: *
                            	  4774: * increment and get byte, result in d0 and Itemp
                            	  4775: 
                            	  4776: LAB_SGBY
01:00205B08 6100F6A2        	  4777: 	BSR		LAB_IGBY			* increment & scan memory
                            	  4778: 
                            	  4779: 
                            	  4780: *************************************************************************************
                            	  4781: *
                            	  4782: * get byte parameter, result in d0 and Itemp
                            	  4783: 
                            	  4784: LAB_GTBY
01:00205B0C 6100F526        	  4785: 	BSR		LAB_EVNM			* evaluate expression & check is numeric,
                            	  4786: 							* else do type mismatch
                            	  4787: 
                            	  4788: 
                            	  4789: *************************************************************************************
                            	  4790: *
                            	  4791: * evaluate byte expression, result in d0 and Itemp
                            	  4792: 
                            	  4793: LAB_EVBY
01:00205B10 6100F9DC        	  4794: 	BSR		LAB_EVPI			* evaluate positive integer expression
                            	  4795: 							* result in d0 and Itemp
01:00205B14 7280            	  4796: 	MOVEQ		#-128,d1			* set mask/2
01:00205B16 D281            	  4797: 	ADD.l		d1,d1				* =$FFFFFF00
01:00205B18 C280            	  4798: 	AND.l		d0,d1				* check top 24 bits
01:00205B1A 6600EA48        	  4799: 	BNE		LAB_FCER			* if <> 0 do function call error/warm start
                            	  4800: 
01:00205B1E 4E75            	  4801: 	RTS
                            	  4802: 
                            	  4803: 
                            	  4804: *************************************************************************************
                            	  4805: *
                            	  4806: * get word parameter, result in d0 and Itemp
                            	  4807: 
                            	  4808: LAB_GTWO
01:00205B20 6100F512        	  4809: 	BSR		LAB_EVNM			* evaluate expression & check is numeric,
                            	  4810: 							* else do type mismatch
01:00205B24 6100F9C8        	  4811: 	BSR		LAB_EVPI			* evaluate positive integer expression
                            	  4812: 							* result in d0 and Itemp
01:00205B28 4840            	  4813: 	SWAP		d0				* copy high word to low word
01:00205B2A 4A40            	  4814: 	TST.w		d0				* set flags
01:00205B2C 6600EA36        	  4815: 	BNE		LAB_FCER			* if <> 0 do function call error/warm start
                            	  4816: 
01:00205B30 4840            	  4817: 	SWAP		d0				* copy high word to low word
01:00205B32 4E75            	  4818: 	RTS
                            	  4819: 
                            	  4820: 
                            	  4821: *************************************************************************************
                            	  4822: *
                            	  4823: * perform VAL()
                            	  4824: 
                            	  4825: LAB_VAL
01:00205B34 6100FE76        	  4826: 	BSR		LAB_22B6			* pop string off descriptor stack or from memory
                            	  4827: 							* returns with d0 = length, a0 = pointer
01:00205B38 6722            	  4828: 	BEQ.s		LAB_VALZ			* string was null so set result = $00
                            	  4829: 							* clear FAC1 exponent & sign & return
                            	  4830: 
01:00205B3A 2C4D            	  4831: 	MOVEA.l	a5,a6				* save BASIC execute pointer
01:00205B3C 2A48            	  4832: 	MOVEA.l	a0,a5				* copy string pointer to execute pointer
01:00205B3E D1C0            	  4833: 	ADDA.l	d0,a0				* string end+1
01:00205B40 1010            	  4834: 	MOVE.b	(a0),d0			* get byte from string+1
01:00205B42 3F00            	  4835: 	MOVE.w	d0,-(sp)			* save it
01:00205B44 2F08            	  4836: 	MOVE.l	a0,-(sp)			* save address
01:00205B46 10BC0000        	  4837: 	MOVE.b	#0,(a0)			* null terminate string
01:00205B4A 6100F662        	  4838: 	BSR		LAB_GBYT			* scan memory
01:00205B4E 61001136        	  4839: 	BSR		LAB_2887			* get FAC1 from string
01:00205B52 205F            	  4840: 	MOVEA.l	(sp)+,a0			* restore pointer
01:00205B54 301F            	  4841: 	MOVE.w	(sp)+,d0			* pop byte
01:00205B56 1080            	  4842: 	MOVE.b	d0,(a0)			* restore to memory
01:00205B58 2A4E            	  4843: 	MOVEA.l	a6,a5				* restore BASIC execute pointer
01:00205B5A 4E75            	  4844: 	RTS
                            	  4845: 
                            	  4846: LAB_VALZ
01:00205B5C 37400594        	  4847: 	MOVE.w	d0,FAC1_e(a3)		* clear FAC1 exponent & sign
01:00205B60 4E75            	  4848: 	RTS
                            	  4849: 
                            	  4850: 
                            	  4851: *************************************************************************************
                            	  4852: *
                            	  4853: * get two parameters for POKE or WAIT, first parameter in a0, second in d0
                            	  4854: 
                            	  4855: LAB_GADB
01:00205B62 6100F4D0        	  4856: 	BSR		LAB_EVNM			* evaluate expression & check is numeric,
                            	  4857: 							* else do type mismatch
01:00205B66 6100F98E        	  4858: 	BSR		LAB_EVIR			* evaluate integer expression
                            	  4859: 							* (does FC error not OF error if out of range)
01:00205B6A 2F00            	  4860: 	MOVE.l	d0,-(sp)			* copy to stack
01:00205B6C 6100F634        	  4861: 	BSR		LAB_1C01			* scan for ",", else do syntax error/warm start
01:00205B70 619A            	  4862: 	BSR.s		LAB_GTBY			* get byte parameter, result in d0 and Itemp
01:00205B72 205F            	  4863: 	MOVEA.l	(sp)+,a0			* pull address
01:00205B74 4E75            	  4864: 	RTS
                            	  4865: 
                            	  4866: 
                            	  4867: *************************************************************************************
                            	  4868: *
                            	  4869: * get two parameters for DOKE or WAITW, first parameter in a0, second in d0
                            	  4870: 
                            	  4871: LAB_GADW
01:00205B76 611E            	  4872: 	BSR.s		LAB_GEAD			* get even address for word/long memory actions
                            	  4873: 							* address returned in d0 and on the stack
01:00205B78 6100F628        	  4874: 	BSR		LAB_1C01			* scan for ",", else do syntax error/warm start
01:00205B7C 6100F4B6        	  4875: 	BSR		LAB_EVNM			* evaluate expression & check is numeric,
                            	  4876: 							* else do type mismatch
01:00205B80 6100F974        	  4877: 	BSR		LAB_EVIR			* evaluate integer expression
                            	  4878: 							* result in d0 and Itemp
01:00205B84 4840            	  4879: 	SWAP		d0				* swap words
01:00205B86 4A40            	  4880: 	TST.w		d0				* test high word
01:00205B88 6706            	  4881: 	BEQ.s		LAB_XGADW			* exit if null
                            	  4882: 
01:00205B8A 5240            	  4883: 	ADDQ.w	#1,d0				* increment word
01:00205B8C 6600E9D6        	  4884: 	BNE		LAB_FCER			* if <> 0 do function call error/warm start
                            	  4885: 
                            	  4886: LAB_XGADW
01:00205B90 4840            	  4887: 	SWAP		d0				* swap words back
01:00205B92 205F            	  4888: 	MOVEA.l	(sp)+,a0			* pull address
01:00205B94 4E75            	  4889: 	RTS
                            	  4890: 
                            	  4891: 
                            	  4892: *************************************************************************************
                            	  4893: *
                            	  4894: * get even address (for word or longword memory actions)
                            	  4895: * address returned in d0 and on the stack
                            	  4896: * does address error if the address is odd
                            	  4897: 
                            	  4898: LAB_GEAD
01:00205B96 6100F49C        	  4899: 	BSR		LAB_EVNM			* evaluate expression & check is numeric,
                            	  4900: 							* else do type mismatch
01:00205B9A 6100F95A        	  4901: 	BSR		LAB_EVIR			* evaluate integer expression
                            	  4902: 							* (does FC error not OF error if out of range)
01:00205B9E 08000000        	  4903: 	BTST		#0,d0				* test low bit of longword
01:00205BA2 6600E97C        	  4904: 	BNE		LAB_ADER			* if address is odd do address error/warm start
                            	  4905: 
01:00205BA6 2057            	  4906: 	MOVEA.l	(sp),a0			* copy return address
01:00205BA8 2E80            	  4907: 	MOVE.l	d0,(sp)			* even address on stack
01:00205BAA 4ED0            	  4908: 	JMP		(a0)				* effectively RTS
                            	  4909: 
                            	  4910: 
                            	  4911: *************************************************************************************
                            	  4912: *
                            	  4913: * perform PEEK()
                            	  4914: 
                            	  4915: LAB_PEEK
01:00205BAC 6100F948        	  4916: 	BSR		LAB_EVIR			* evaluate integer expression
                            	  4917: 							* (does FC error not OF error if out of range)
01:00205BB0 2040            	  4918: 	MOVEA.l	d0,a0				* copy to address register
01:00205BB2 1010            	  4919: 	MOVE.b	(a0),d0			* get byte
01:00205BB4 6000FB14        	  4920: 	BRA		LAB_1FD0			* convert d0 to unsigned byte in FAC1 & return
                            	  4921: 
                            	  4922: 
                            	  4923: *************************************************************************************
                            	  4924: *
                            	  4925: * perform POKE
                            	  4926: 
                            	  4927: LAB_POKE
01:00205BB8 61A8            	  4928: 	BSR.s		LAB_GADB			* get two parameters for POKE or WAIT
                            	  4929: 							* first parameter in a0, second in d0
01:00205BBA 1080            	  4930: 	MOVE.b	d0,(a0)			* put byte in memory
01:00205BBC 4E75            	  4931: 	RTS
                            	  4932: 
                            	  4933: 
                            	  4934: *************************************************************************************
                            	  4935: *
                            	  4936: * perform DEEK()
                            	  4937: 
                            	  4938: LAB_DEEK
01:00205BBE 6100F936        	  4939: 	BSR		LAB_EVIR			* evaluate integer expression
                            	  4940: 							* (does FC error not OF error if out of range)
01:00205BC2 E208            	  4941: 	LSR.b		#1,d0				* shift bit 0 to carry
01:00205BC4 6500E95A        	  4942: 	BCS		LAB_ADER			* if address is odd do address error/warm start
                            	  4943: 
01:00205BC8 D000            	  4944: 	ADD.b		d0,d0				* shift byte back
01:00205BCA C188            	  4945: 	EXG		d0,a0				* copy to address register
01:00205BCC 7000            	  4946: 	MOVEQ		#0,d0				* clear top bits
01:00205BCE 3010            	  4947: 	MOVE.w	(a0),d0			* get word
01:00205BD0 6000FAD8        	  4948: 	BRA		LAB_AYFC			* convert d0 to signed longword in FAC1 & return
                            	  4949: 
                            	  4950: 
                            	  4951: *************************************************************************************
                            	  4952: *
                            	  4953: * perform LEEK()
                            	  4954: 
                            	  4955: LAB_LEEK
01:00205BD4 6100F920        	  4956: 	BSR		LAB_EVIR			* evaluate integer expression
                            	  4957: 							* (does FC error not OF error if out of range)
01:00205BD8 E208            	  4958: 	LSR.b		#1,d0				* shift bit 0 to carry
01:00205BDA 6500E944        	  4959: 	BCS		LAB_ADER			* if address is odd do address error/warm start
                            	  4960: 
01:00205BDE D000            	  4961: 	ADD.b		d0,d0				* shift byte back
01:00205BE0 C188            	  4962: 	EXG		d0,a0				* copy to address register
01:00205BE2 2010            	  4963: 	MOVE.l	(a0),d0			* get longword
01:00205BE4 6000FAC4        	  4964: 	BRA		LAB_AYFC			* convert d0 to signed longword in FAC1 & return
                            	  4965: 
                            	  4966: 
                            	  4967: *************************************************************************************
                            	  4968: *
                            	  4969: * perform DOKE
                            	  4970: 
                            	  4971: LAB_DOKE
01:00205BE8 618C            	  4972: 	BSR.s		LAB_GADW			* get two parameters for DOKE or WAIT
                            	  4973: 							* first parameter in a0, second in d0
01:00205BEA 3080            	  4974: 	MOVE.w	d0,(a0)			* put word in memory
01:00205BEC 4E75            	  4975: 	RTS
                            	  4976: 
                            	  4977: 
                            	  4978: *************************************************************************************
                            	  4979: *
                            	  4980: * perform LOKE
                            	  4981: 
                            	  4982: LAB_LOKE
01:00205BEE 61A6            	  4983: 	BSR.s		LAB_GEAD			* get even address for word/long memory actions
                            	  4984: 							* address returned in d0 and on the stack
01:00205BF0 6100F5B0        	  4985: 	BSR		LAB_1C01			* scan for ",", else do syntax error/warm start
01:00205BF4 6100F43E        	  4986: 	BSR		LAB_EVNM			* evaluate expression & check is numeric,
                            	  4987: 							* else do type mismatch
01:00205BF8 6100F8FC        	  4988: 	BSR		LAB_EVIR			* evaluate integer value (no sign check)
01:00205BFC 205F            	  4989: 	MOVEA.l	(sp)+,a0			* pull address
01:00205BFE 2080            	  4990: 	MOVE.l	d0,(a0)			* put longword in memory
                            	  4991: RTS_015
01:00205C00 4E75            	  4992: 	RTS
                            	  4993: 
                            	  4994: 
                            	  4995: *************************************************************************************
                            	  4996: *
                            	  4997: * perform SWAP
                            	  4998: 
                            	  4999: LAB_SWAP
01:00205C02 6100F7B6        	  5000: 	BSR		LAB_GVAR			* get variable 1 address in a0
01:00205C06 2F08            	  5001: 	MOVE.l	a0,-(sp)			* save variable 1 address
01:00205C08 182B05B5        	  5002: 	MOVE.b	Dtypef(a3),d4		* copy variable 1 data type, $80=string,
                            	  5003: 							* $40=inetger, $00=float
                            	  5004: 
01:00205C0C 6100F594        	  5005: 	BSR		LAB_1C01			* scan for ",", else do syntax error/warm start
01:00205C10 6100F7A8        	  5006: 	BSR		LAB_GVAR			* get variable 2 address in a0
01:00205C14 245F            	  5007: 	MOVEA.l	(sp)+,a2			* restore variable 1 address
01:00205C16 B82B05B5        	  5008: 	CMP.b		Dtypef(a3),d4		* compare variable 1 data type with variable 2
                            	  5009: 							* data type
01:00205C1A 6600E928        	  5010: 	BNE		LAB_TMER			* if not both the same type do "Type mismatch"
                            	  5011: 							* error then warm start
                            	  5012: 
                            	  5013: * if you do want a non existant variable to return an error then leave the novar
                            	  5014: * value at the top of this file set to zero
                            	  5015: 
                            	  5016:  ifeq	novar
                            	  5017: 
01:00205C1E 2010            	  5018: 	MOVE.l	(a0),d0			* get variable 2
01:00205C20 20D2            	  5019: 	MOVE.l	(a2),(a0)+			* copy variable 1 to variable 2
01:00205C22 24C0            	  5020: 	MOVE.l	d0,(a2)+			* save variable 2 to variable 1
                            	  5021: 
01:00205C24 4A04            	  5022: 	TST.b		d4				* check data type
01:00205C26 6AD8            	  5023: 	BPL.s		RTS_015			* exit if not string
                            	  5024: 
01:00205C28 3010            	  5025: 	MOVE.w	(a0),d0			* get string 2 length
01:00205C2A 3092            	  5026: 	MOVE.w	(a2),(a0)			* copy string 1 length to string 2 length
01:00205C2C 3480            	  5027: 	MOVE.w	d0,(a2)			* save string 2 length to string 1 length
                            	  5028: 
                            	  5029:  endc
                            	  5030: 
                            	  5031: 
                            	  5032: * if you want a non existant variable to return a null value then set the novar
                            	  5033: * value at the top of this file to some non zero value
                            	  5034: 
                            	  5035:  ifne	novar
                            	  5036: 
                            	  5037: 	MOVE.l	a2,d2				* copy the variable 1 pointer
                            	  5038: 	MOVE.l	d2,d3				* and again for any length
                            	  5039: 	BEQ.s		no_variable1		* if variable 1 doesn't exist skip the
                            	  5040: 							* value get
                            	  5041: 
                            	  5042: 	MOVE.l	(a2),d2			* get variable 1 value
                            	  5043: 	TST.b		d4				* check the data type
                            	  5044: 	BPL.s		no_variable1		* if not string skip the length get
                            	  5045: 
                            	  5046: 	MOVE.w	4(a2),d3			* else get variable 1 string length
                            	  5047: no_variable1
                            	  5048: 	MOVE.l	a0,d0				* copy the variable 2 pointer
                            	  5049: 	MOVE.l	d0,d1				* and again for any length
                            	  5050: 	BEQ.s		no_variable2		* if variable 2 doesn't exist skip the
                            	  5051: 							* value get and the new value save
                            	  5052: 
                            	  5053: 	MOVE.l	(a0),d0			* get variable 2 value
                            	  5054: 	MOVE.l	d2,(a0)+			* save variable 2 new value
                            	  5055: 	TST.b		d4				* check the data type
                            	  5056: 	BPL.s		no_variable2		* if not string skip the length get and
                            	  5057: 							* new length save
                            	  5058: 
                            	  5059: 	MOVE.w	(a0),d1			* else get variable 2 string length
                            	  5060: 	MOVE.w	d3,(a0)			* save variable 2 new string length
                            	  5061: no_variable2
                            	  5062: 	TST.l		d2				* test if variable 1 exists
                            	  5063: 	BEQ.s		EXIT_SWAP			* if variable 1 doesn't exist skip the
                            	  5064: 							* new value save
                            	  5065: 
                            	  5066: 	MOVE.l	d0,(a2)+			* save variable 1 new value
                            	  5067: 	TST.b		d4				* check the data type
                            	  5068: 	BPL.s		EXIT_SWAP			* if not string skip the new length save
                            	  5069: 
                            	  5070: 	MOVE.w	d1,(a2)			* save variable 1 new string length
                            	  5071: EXIT_SWAP
                            	  5072: 
                            	  5073:  endc
                            	  5074: 
01:00205C2E 4E75            	  5075: 	RTS
                            	  5076: 
                            	  5077: 
                            	  5078: *************************************************************************************
                            	  5079: *
                            	  5080: * perform USR
                            	  5081: 
                            	  5082: LAB_USR
01:00205C30 4EAB0406        	  5083: 	JSR		Usrjmp(a3)			* do user vector
01:00205C34 6000F564        	  5084: 	BRA		LAB_1BFB			* scan for ")", else do syntax error/warm start
                            	  5085: 
                            	  5086: 
                            	  5087: *************************************************************************************
                            	  5088: *
                            	  5089: * perform LOAD
                            	  5090: 
                            	  5091: LAB_LOAD
01:00205C38 4EEB0418        	  5092: 	JMP		V_LOAD(a3)			* do load vector
                            	  5093: 
                            	  5094: 
                            	  5095: *************************************************************************************
                            	  5096: *
                            	  5097: * perform SAVE
                            	  5098: 
                            	  5099: LAB_SAVE
01:00205C3C 4EEB041E        	  5100: 	JMP		V_SAVE(a3)			* do save vector
                            	  5101: 
                            	  5102: 
                            	  5103: *************************************************************************************
                            	  5104: *
                            	  5105: * perform CALL
                            	  5106: 
                            	  5107: LAB_CALL
01:00205C40 487AF56C        	  5108: 	PEA		LAB_GBYT(pc)		* put return address on stack
01:00205C44 6100FF50        	  5109: 	BSR		LAB_GEAD			* get even address for word/long memory actions
                            	  5110: 							* address returned in d0 and on the stack
01:00205C48 4E75            	  5111: 	RTS						* effectively calls the routine
                            	  5112: 
                            	  5113: * if the called routine exits correctly then it will return via the get byte routine.
                            	  5114: * this will then get the next byte for the interpreter and return
                            	  5115: 
                            	  5116: 
                            	  5117: *************************************************************************************
                            	  5118: *
                            	  5119: * perform WAIT
                            	  5120: 
                            	  5121: LAB_WAIT
01:00205C4A 6100FF16        	  5122: 	BSR		LAB_GADB			* get two parameters for POKE or WAIT
                            	  5123: 							* first parameter in a0, second in d0
01:00205C4E 2F08            	  5124: 	MOVE.l	a0,-(sp)			* save address
01:00205C50 3F00            	  5125: 	MOVE.w	d0,-(sp)			* save byte
01:00205C52 7400            	  5126: 	MOVEQ		#0,d2				* clear mask
01:00205C54 6100F558        	  5127: 	BSR		LAB_GBYT			* scan memory
01:00205C58 6706            	  5128: 	BEQ.s		LAB_2441			* skip if no third argument
                            	  5129: 
01:00205C5A 6100F542        	  5130: 	BSR		LAB_SCGB			* scan for "," & get byte,
                            	  5131: 							* else do syntax error/warm start
01:00205C5E 2400            	  5132: 	MOVE.l	d0,d2				* copy mask
                            	  5133: LAB_2441
01:00205C60 321F            	  5134: 	MOVE.w	(sp)+,d1			* get byte
01:00205C62 205F            	  5135: 	MOVEA.l	(sp)+,a0			* get address
                            	  5136: LAB_2445
01:00205C64 1010            	  5137: 	MOVE.b	(a0),d0			* read memory byte
01:00205C66 B500            	  5138: 	EOR.b		d2,d0				* EOR with second argument (mask)
01:00205C68 C001            	  5139: 	AND.b		d1,d0				* AND with first argument (byte)
01:00205C6A 67F8            	  5140: 	BEQ.s		LAB_2445			* loop if result is zero
                            	  5141: 
01:00205C6C 4E75            	  5142: 	RTS
                            	  5143: 
                            	  5144: 
                            	  5145: *************************************************************************************
                            	  5146: *
                            	  5147: * perform subtraction, FAC1 from FAC2
                            	  5148: 
                            	  5149: LAB_SUBTRACT
01:00205C6E 0A2B00800595    	  5150: 	EORI.b	#$80,FAC1_s(a3)		* complement FAC1 sign
01:00205C74 176B059D059E    	  5151: 	MOVE.b	FAC2_s(a3),FAC_sc(a3)	* copy FAC2 sign byte
                            	  5152: 
01:00205C7A 102B0595        	  5153: 	MOVE.b	FAC1_s(a3),d0		* get FAC1 sign byte
01:00205C7E B12B059E        	  5154: 	EOR.b		d0,FAC_sc(a3)		* EOR with FAC2 sign
                            	  5155: 
                            	  5156: 
                            	  5157: *************************************************************************************
                            	  5158: *
                            	  5159: * add FAC2 to FAC1
                            	  5160: 
                            	  5161: LAB_ADD
01:00205C82 102B0594        	  5162: 	MOVE.b	FAC1_e(a3),d0		* get exponent
01:00205C86 67000336        	  5163: 	BEQ		LAB_279B			* FAC1 was zero so copy FAC2 to FAC1 & return
                            	  5164: 
                            	  5165: 							* FAC1 is non zero
01:00205C8A 41EB0598        	  5166: 	LEA		FAC2_m(a3),a0		* set pointer1 to FAC2 mantissa
01:00205C8E 102B059C        	  5167: 	MOVE.b	FAC2_e(a3),d0		* get FAC2 exponent
01:00205C92 6746            	  5168: 	BEQ.s		RTS_016			* exit if zero
                            	  5169: 
01:00205C94 902B0594        	  5170: 	SUB.b		FAC1_e(a3),d0		* subtract FAC1 exponent
01:00205C98 6722            	  5171: 	BEQ.s		LAB_24A8			* branch if = (go add mantissa)
                            	  5172: 
01:00205C9A 650A            	  5173: 	BCS.s		LAB_249C			* branch if FAC2 < FAC1
                            	  5174: 
                            	  5175: 							* FAC2 > FAC1
01:00205C9C 376B059C0594    	  5176: 	MOVE.w	FAC2_e(a3),FAC1_e(a3)	* copy sign and exponent of FAC2
01:00205CA2 4400            	  5177: 	NEG.b		d0				* negate exponent difference (make diff -ve)
01:00205CA4 5148            	  5178: 	SUBQ.w	#8,a0				* pointer1 to FAC1
                            	  5179: 
                            	  5180: LAB_249C
01:00205CA6 4400            	  5181: 	NEG.b		d0				* negate exponent difference (make diff +ve)
01:00205CA8 2F01            	  5182: 	MOVE.l	d1,-(sp)			* save d1
01:00205CAA B03C0020        	  5183: 	CMP.b		#32,d0			* compare exponent diff with 32
01:00205CAE 6D04            	  5184: 	BLT.s		LAB_2467			* branch if range >= 32
                            	  5185: 
01:00205CB0 7200            	  5186: 	MOVEQ		#0,d1				* clear d1
01:00205CB2 6004            	  5187: 	BRA.s		LAB_2468			* go clear smaller mantissa
                            	  5188: 
                            	  5189: LAB_2467
01:00205CB4 2210            	  5190: 	MOVE.l	(a0),d1			* get FACx mantissa
01:00205CB6 E0A9            	  5191: 	LSR.l		d0,d1				* shift d0 times right
                            	  5192: LAB_2468
01:00205CB8 2081            	  5193: 	MOVE.l	d1,(a0)			* save it back
01:00205CBA 221F            	  5194: 	MOVE.l	(sp)+,d1			* restore d1
                            	  5195: 
                            	  5196: 							* exponents are equal now do mantissa add or
                            	  5197: 							* subtract
                            	  5198: LAB_24A8
01:00205CBC 4A2B059E        	  5199: 	TST.b		FAC_sc(a3)			* test sign compare (FAC1 EOR FAC2)
01:00205CC0 6B1A            	  5200: 	BMI.s		LAB_24F8			* if <> go do subtract
                            	  5201: 
01:00205CC2 202B0598        	  5202: 	MOVE.l	FAC2_m(a3),d0		* get FAC2 mantissa
01:00205CC6 D0AB0590        	  5203: 	ADD.l		FAC1_m(a3),d0		* add FAC1 mantissa
01:00205CCA 640A            	  5204: 	BCC.s		LAB_24F7			* save and exit if no carry (FAC1 is normal)
                            	  5205: 
01:00205CCC E290            	  5206: 	ROXR.l	#1,d0				* else shift carry back into mantissa
01:00205CCE 522B0594        	  5207: 	ADDQ.b	#1,FAC1_e(a3)		* increment FAC1 exponent
01:00205CD2 6500E88C        	  5208: 	BCS		LAB_OFER			* if carry do overflow error & warm start
                            	  5209: 
                            	  5210: LAB_24F7
01:00205CD6 27400590        	  5211: 	MOVE.l	d0,FAC1_m(a3)		* save mantissa
                            	  5212: RTS_016
01:00205CDA 4E75            	  5213: 	RTS
                            	  5214: 							* signs are different
                            	  5215: LAB_24F8
01:00205CDC 43EB0590        	  5216: 	LEA		FAC1_m(a3),a1		* pointer 2 to FAC1
01:00205CE0 B3C8            	  5217: 	CMPA.l	a0,a1				* compare pointers
01:00205CE2 6602            	  5218: 	BNE.s		LAB_24B4			* branch if <>
                            	  5219: 
01:00205CE4 5049            	  5220: 	ADDQ.w	#8,a1				* else pointer2 to FAC2
                            	  5221: 
                            	  5222: 							* take smaller from bigger (take sign of bigger)
                            	  5223: LAB_24B4
01:00205CE6 2011            	  5224: 	MOVE.l	(a1),d0			* get larger mantissa
01:00205CE8 2210            	  5225: 	MOVE.l	(a0),d1			* get smaller mantissa
01:00205CEA 27400590        	  5226: 	MOVE.l	d0,FAC1_m(a3)		* save larger mantissa
01:00205CEE 93AB0590        	  5227: 	SUB.l		d1,FAC1_m(a3)		* subtract smaller
                            	  5228: 
                            	  5229: 
                            	  5230: *************************************************************************************
                            	  5231: *
                            	  5232: * do +/- (carry is sign) & normalise FAC1
                            	  5233: 
                            	  5234: LAB_24D0
01:00205CF2 6408            	  5235: 	BCC.s		LAB_24D5			* branch if result is +ve
                            	  5236: 
                            	  5237: 							* erk! subtract is the wrong way round so
                            	  5238: 							* negate everything
01:00205CF4 462B0595        	  5239: 	EORI.b	#$FF,FAC1_s(a3)		* complement FAC1 sign
01:00205CF8 44AB0590        	  5240: 	NEG.l		FAC1_m(a3)			* negate FAC1 mantissa
                            	  5241: 
                            	  5242: 
                            	  5243: *************************************************************************************
                            	  5244: *
                            	  5245: * normalise FAC1
                            	  5246: 
                            	  5247: LAB_24D5
01:00205CFC 202B0590        	  5248: 	MOVE.l	FAC1_m(a3),d0		* get mantissa
01:00205D00 6B2E            	  5249: 	BMI.s		LAB_24DA			* mantissa is normal so just exit
                            	  5250: 
01:00205D02 6606            	  5251: 	BNE.s		LAB_24D9			* mantissa is not zero so go normalise FAC1
                            	  5252: 
01:00205D04 37400594        	  5253: 	MOVE.w	d0,FAC1_e(a3)		* else make FAC1 = +zero
01:00205D08 4E75            	  5254: 	RTS
                            	  5255: 
                            	  5256: LAB_24D9
01:00205D0A 2F01            	  5257: 	MOVE.l	d1,-(sp)			* save d1
01:00205D0C 2200            	  5258: 	MOVE.l	d0,d1				* mantissa to d1
01:00205D0E 7000            	  5259: 	MOVEQ		#0,d0				* clear d0
01:00205D10 102B0594        	  5260: 	MOVE.b	FAC1_e(a3),d0		* get exponent byte
01:00205D14 6714            	  5261: 	BEQ.s		LAB_24D8			* if exponent is zero then clean up and exit
                            	  5262: LAB_24D6
01:00205D16 D281            	  5263: 	ADD.l		d1,d1				* shift mantissa, ADD is quicker for a single
                            	  5264: 							* shift
01:00205D18 5BC8FFFC        	  5265: 	DBMI		d0,LAB_24D6			* decrement exponent and loop if mantissa and
                            	  5266: 							* exponent +ve
                            	  5267: 
01:00205D1C 4A40            	  5268: 	TST.w		d0				* test exponent
01:00205D1E 670A            	  5269: 	BEQ.s		LAB_24D8			* if exponent is zero make FAC1 zero
                            	  5270: 
01:00205D20 6A02            	  5271: 	BPL.s		LAB_24D7			* if exponent is >zero go save FAC1
                            	  5272: 
01:00205D22 7001            	  5273: 	MOVEQ		#1,d0				* else set for zero after correction
                            	  5274: LAB_24D7
01:00205D24 5300            	  5275: 	SUBQ.b	#1,d0				* adjust exponent for loop
01:00205D26 27410590        	  5276: 	MOVE.l	d1,FAC1_m(a3)		* save normalised mantissa
                            	  5277: LAB_24D8
01:00205D2A 221F            	  5278: 	MOVE.l	(sp)+,d1			* restore d1
01:00205D2C 17400594        	  5279: 	MOVE.b	d0,FAC1_e(a3)		* save corrected exponent
                            	  5280: LAB_24DA
01:00205D30 4E75            	  5281: 	RTS
                            	  5282: 
                            	  5283: 
                            	  5284: *************************************************************************************
                            	  5285: *
                            	  5286: * perform LOG()
                            	  5287: 
                            	  5288: LAB_LOG
01:00205D32 4A2B0595        	  5289: 	TST.b		FAC1_s(a3)			* test sign
01:00205D36 6B00E82C        	  5290: 	BMI		LAB_FCER			* if -ve do function call error/warm start
                            	  5291: 
01:00205D3A 7E00            	  5292: 	MOVEQ		#0,d7				* clear d7
01:00205D3C 1747059E        	  5293: 	MOVE.b	d7,FAC_sc(a3)		* clear sign compare
01:00205D40 1E2B0594        	  5294: 	MOVE.b	FAC1_e(a3),d7		* get exponent
01:00205D44 6700E81E        	  5295: 	BEQ		LAB_FCER			* if 0 do function call error/warm start
                            	  5296: 
01:00205D48 9EBC00000081    	  5297: 	SUB.l		#$81,d7			* normalise exponent
01:00205D4E 177C00810594    	  5298: 	MOVE.b	#$81,FAC1_e(a3)		* force a value between 1 and 2
01:00205D54 2C2B0590        	  5299: 	MOVE.l	FAC1_m(a3),d6		* copy mantissa
                            	  5300: 
01:00205D58 277C800000000598	  5301: 	MOVE.l	#$80000000,FAC2_m(a3)	* set mantissa for 1
01:00205D60 377C8100059C    	  5302: 	MOVE.w	#$8100,FAC2_e(a3)		* set exponent for 1
01:00205D66 6100FF1A        	  5303: 	BSR		LAB_ADD			* find arg+1
01:00205D6A 7000            	  5304: 	MOVEQ		#0,d0				* setup for calc skip
01:00205D6C 3740059C        	  5305: 	MOVE.w	d0,FAC2_e(a3)		* set FAC1 for zero result
01:00205D70 DC86            	  5306: 	ADD.l		d6,d6				* shift 1 bit out
01:00205D72 27460598        	  5307: 	MOVE.l	d6,FAC2_m(a3)		* put back FAC2
01:00205D76 6758            	  5308: 	BEQ.s		LAB_LONN			* if 0 skip calculation
                            	  5309: 
01:00205D78 377C8000059C    	  5310: 	MOVE.w	#$8000,FAC2_e(a3)		* set exponent for .5
01:00205D7E 61000130        	  5311: 	BSR		LAB_DIVIDE			* do (arg-1)/(arg+1)
01:00205D82 4A2B0594        	  5312: 	TST.b		FAC1_e(a3)			* test exponent
01:00205D86 6748            	  5313: 	BEQ.s		LAB_LONN			* if 0 skip calculation
                            	  5314: 
01:00205D88 122B0594        	  5315: 	MOVE.b	FAC1_e(a3),d1		* get exponent
01:00205D8C 923C0082        	  5316: 	SUB.b		#$82,d1			* normalise and two integer bits
01:00205D90 4401            	  5317: 	NEG.b		d1				* negate for shift
                            	  5318: **	CMP.b		#$1F,d1			* will mantissa vanish?
                            	  5319: **	BGT.s		LAB_dunno			* if so do ???
                            	  5320: 
01:00205D92 202B0590        	  5321: 	MOVE.l	FAC1_m(a3),d0		* get mantissa
01:00205D96 E2A8            	  5322: 	LSR.l		d1,d0				* shift in two integer bits
                            	  5323: 
                            	  5324: * d0 = arg
                            	  5325: * d0 = x, d1 = y
                            	  5326: * d2 = x1, d3 = y1
                            	  5327: * d4 = shift count
                            	  5328: * d5 = loop count
                            	  5329: * d6 = z
                            	  5330: * a0 = table pointer
                            	  5331: 
01:00205D98 7C00            	  5332: 	MOVEQ		#0,d6				* z = 0
01:00205D9A 223C40000000    	  5333: 	MOVE.l	#1<<30,d1			* y = 1
01:00205DA0 41FA13F4        	  5334: 	LEA		TAB_HTHET(pc),a0		* get pointer to hyperbolic tangent table
01:00205DA4 7A1E            	  5335: 	MOVEQ		#30,d5			* loop 31 times
01:00205DA6 7801            	  5336: 	MOVEQ		#1,d4				* set shift count
01:00205DA8 6006            	  5337: 	BRA.s		LAB_LOCC			* entry point for loop
                            	  5338: 
                            	  5339: LAB_LAAD
01:00205DAA E8A2            	  5340: 	ASR.l		d4,d2				* x1 >> i
01:00205DAC 9282            	  5341: 	SUB.l		d2,d1				* y = y - x1
01:00205DAE DC90            	  5342: 	ADD.l		(a0),d6			* z = z + tanh(i)
                            	  5343: LAB_LOCC
01:00205DB0 2400            	  5344: 	MOVE.l	d0,d2				* x1 = x
01:00205DB2 2601            	  5345: 	MOVE.l	d1,d3				* y1 = Y
01:00205DB4 E8A3            	  5346: 	ASR.l		d4,d3				* y1 >> i
01:00205DB6 6402            	  5347: 	BCC.s		LAB_LOLP
                            	  5348: 
01:00205DB8 5283            	  5349: 	ADDQ.l	#1,d3
                            	  5350: LAB_LOLP
01:00205DBA 9083            	  5351: 	SUB.l		d3,d0				* x = x - y1
01:00205DBC 6AEC            	  5352: 	BPL.s		LAB_LAAD			* branch if > 0
                            	  5353: 
01:00205DBE 2002            	  5354: 	MOVE.l	d2,d0				* get x back
01:00205DC0 5848            	  5355: 	ADDQ.w	#4,a0				* next entry
01:00205DC2 5284            	  5356: 	ADDQ.l	#1,d4				* next i
01:00205DC4 E28B            	  5357: 	LSR.l		#1,d3				* /2
01:00205DC6 6704            	  5358: 	BEQ.s		LAB_LOCX			* branch y1 = 0
                            	  5359: 
01:00205DC8 51CDFFF0        	  5360: 	DBF		d5,LAB_LOLP			* decrement and loop if not done
                            	  5361: 
                            	  5362: 							* now sort out the result
                            	  5363: LAB_LOCX
01:00205DCC DC86            	  5364: 	ADD.l		d6,d6				* *2
01:00205DCE 2006            	  5365: 	MOVE.l	d6,d0				* setup for d7 = 0
                            	  5366: LAB_LONN
01:00205DD0 2800            	  5367: 	MOVE.l	d0,d4				* save cordic result
01:00205DD2 7A00            	  5368: 	MOVEQ		#0,d5				* set default exponent sign
01:00205DD4 4A87            	  5369: 	TST.l		d7				* check original exponent sign
01:00205DD6 6716            	  5370: 	BEQ.s		LAB_LOXO			* branch if original was 0
                            	  5371: 
01:00205DD8 6A04            	  5372: 	BPL.s		LAB_LOXP			* branch if was +ve
                            	  5373: 
01:00205DDA 4487            	  5374: 	NEG.l		d7				* make original exponent +ve
01:00205DDC 7A80            	  5375: 	MOVEQ		#$80-$100,d5		* make sign -ve
                            	  5376: LAB_LOXP
01:00205DDE 17450595        	  5377: 	MOVE.b	d5,FAC1_s(a3)		* save original exponent sign
01:00205DE2 4847            	  5378: 	SWAP		d7				* 16 bit shift
01:00205DE4 E18F            	  5379: 	LSL.l		#8,d7				* easy first part
01:00205DE6 7A88            	  5380: 	MOVEQ		#$88-$100,d5		* start with byte
                            	  5381: LAB_LONE
01:00205DE8 5385            	  5382: 	SUBQ.l	#1,d5				* decrement exponent
01:00205DEA DE87            	  5383: 	ADD.l		d7,d7				* shift mantissa
01:00205DEC 6AFA            	  5384: 	BPL.s		LAB_LONE			* loop if not normal
                            	  5385: 
                            	  5386: LAB_LOXO
01:00205DEE 27470590        	  5387: 	MOVE.l	d7,FAC1_m(a3)		* save original exponent as mantissa
01:00205DF2 17450594        	  5388: 	MOVE.b	d5,FAC1_e(a3)		* save exponent for this
01:00205DF6 277CB17217F80598	  5389: 	MOVE.l	#$B17217F8,FAC2_m(a3)	* LOG(2) mantissa
01:00205DFE 377C8000059C    	  5390: 	MOVE.w	#$8000,FAC2_e(a3)		* LOG(2) exponent & sign
01:00205E04 176B0595059E    	  5391: 	MOVE.b	FAC1_s(a3),FAC_sc(a3)	* make sign compare = FAC1 sign
01:00205E0A 6118            	  5392: 	BSR.s		LAB_MULTIPLY		* do multiply
01:00205E0C 27440598        	  5393: 	MOVE.l	d4,FAC2_m(a3)		* save cordic result
01:00205E10 6710            	  5394: 	BEQ.s		LAB_LOWZ			* branch if zero
                            	  5395: 
01:00205E12 377C8200059C    	  5396: 	MOVE.w	#$8200,FAC2_e(a3)		* set exponent & sign
01:00205E18 176B0595059E    	  5397: 	MOVE.b	FAC1_s(a3),FAC_sc(a3)	* clear sign compare
01:00205E1E 6100FE62        	  5398: 	BSR		LAB_ADD			* and add for final result
                            	  5399: 
                            	  5400: LAB_LOWZ
01:00205E22 4E75            	  5401: 	RTS
                            	  5402: 
                            	  5403: 
                            	  5404: *************************************************************************************
                            	  5405: *
                            	  5406: * multiply FAC1 by FAC2
                            	  5407: 
                            	  5408: LAB_MULTIPLY
01:00205E24 48E7F800        	  5409: 	MOVEM.l	d0-d4,-(sp)			* save registers
01:00205E28 4A2B0594        	  5410: 	TST.b		FAC1_e(a3)			* test FAC1 exponent
01:00205E2C 6776            	  5411: 	BEQ.s		LAB_MUUF			* if exponent zero go make result zero
                            	  5412: 
01:00205E2E 102B059C        	  5413: 	MOVE.b	FAC2_e(a3),d0		* get FAC2 exponent
01:00205E32 6770            	  5414: 	BEQ.s		LAB_MUUF			* if exponent zero go make result zero
                            	  5415: 
01:00205E34 176B059E0595    	  5416: 	MOVE.b	FAC_sc(a3),FAC1_s(a3)	* sign compare becomes sign
                            	  5417: 
01:00205E3A D02B0594        	  5418: 	ADD.b		FAC1_e(a3),d0		* multiply exponents by adding
01:00205E3E 640A            	  5419: 	BCC.s		LAB_MNOC			* branch if no carry
                            	  5420: 
01:00205E40 903C0080        	  5421: 	SUB.b		#$80,d0			* normalise result
01:00205E44 6400E71A        	  5422: 	BCC		LAB_OFER			* if no carry do overflow
                            	  5423: 
01:00205E48 6006            	  5424: 	BRA.s		LAB_MADD			* branch
                            	  5425: 
                            	  5426: 							* no carry for exponent add
                            	  5427: LAB_MNOC
01:00205E4A 903C0080        	  5428: 	SUB.b		#$80,d0			* normalise result
01:00205E4E 6554            	  5429: 	BCS.s		LAB_MUUF			* return zero if underflow
                            	  5430: 
                            	  5431: LAB_MADD
01:00205E50 17400594        	  5432: 	MOVE.b	d0,FAC1_e(a3)		* save exponent
                            	  5433: 
                            	  5434: 							* d1 (FAC1) x d2 (FAC2)
01:00205E54 222B0590        	  5435: 	MOVE.l	FAC1_m(a3),d1		* get FAC1 mantissa
01:00205E58 242B0598        	  5436: 	MOVE.l	FAC2_m(a3),d2		* get FAC2 mantissa
                            	  5437: 
01:00205E5C 3801            	  5438: 	MOVE.w	d1,d4				* copy low word FAC1
01:00205E5E 2001            	  5439: 	MOVE.l	d1,d0				* copy long word FAC1
01:00205E60 4840            	  5440: 	SWAP		d0				* high word FAC1 to low word FAC1
01:00205E62 3600            	  5441: 	MOVE.w	d0,d3				* copy high word FAC1
                            	  5442: 
01:00205E64 C2C2            	  5443: 	MULU		d2,d1				* low word FAC2 x low word FAC1
01:00205E66 C0C2            	  5444: 	MULU		d2,d0				* low word FAC2 x high word FAC1
01:00205E68 4842            	  5445: 	SWAP		d2				* high word FAC2 to low word FAC2
01:00205E6A C8C2            	  5446: 	MULU		d2,d4				* high word FAC2 x low word FAC1
01:00205E6C C6C2            	  5447: 	MULU		d2,d3				* high word FAC2 x high word FAC1
                            	  5448: 
                            	  5449: * done multiply, now add partial products
                            	  5450: 
                            	  5451: *			d1 =					aaaa  ----	FAC2_L x FAC1_L
                            	  5452: *			d0 =				bbbb  aaaa		FAC2_L x FAC1_H
                            	  5453: *			d4 =				bbbb  aaaa		FAC2_H x FAC1_L
                            	  5454: *			d3 =			cccc  bbbb			FAC2_H x FAC1_H
                            	  5455: *			product =		mmmm  mmmm
                            	  5456: 
01:00205E6E D2BC00008000    	  5457: 	ADD.L		#$8000,d1			* round up lowest word
01:00205E74 4241            	  5458: 	CLR.w		d1				* clear low word, don't need it
01:00205E76 4841            	  5459: 	SWAP		d1				* align high word
01:00205E78 D280            	  5460: 	ADD.l		d0,d1				* add FAC2_L x FAC1_H (can't be carry)
                            	  5461: LAB_MUF1
01:00205E7A D284            	  5462: 	ADD.l		d4,d1				* now add intermediate (FAC2_H x FAC1_L)
01:00205E7C 6406            	  5463: 	BCC.s		LAB_MUF2			* branch if no carry
                            	  5464: 
01:00205E7E D6BC00010000    	  5465: 	ADD.l		#$10000,d3			* else correct result
                            	  5466: LAB_MUF2
01:00205E84 D2BC00008000    	  5467: 	ADD.l		#$8000,d1			* round up low word
01:00205E8A 4241            	  5468: 	CLR.w		d1				* clear low word
01:00205E8C 4841            	  5469: 	SWAP		d1				* align for final add
01:00205E8E D283            	  5470: 	ADD.l		d3,d1				* add FAC2_H x FAC1_H, result
01:00205E90 6B08            	  5471: 	BMI.s		LAB_MUF3			* branch if normalisation not needed
                            	  5472: 
01:00205E92 D281            	  5473: 	ADD.l		d1,d1				* shift mantissa
01:00205E94 532B0594        	  5474: 	SUBQ.b	#1,FAC1_e(a3)		* adjust exponent
01:00205E98 670A            	  5475: 	BEQ.s		LAB_MUUF			* branch if underflow
                            	  5476: 
                            	  5477: LAB_MUF3
01:00205E9A 27410590        	  5478: 	MOVE.l	d1,FAC1_m(a3)		* save mantissa
                            	  5479: LAB_MUEX
01:00205E9E 4CDF001F        	  5480: 	MOVEM.l	(sp)+,d0-d4			* restore registers
01:00205EA2 4E75            	  5481: 	RTS
                            	  5482: 							* either zero or underflow result
                            	  5483: LAB_MUUF
01:00205EA4 7000            	  5484: 	MOVEQ		#0,d0				* quick clear
01:00205EA6 27400590        	  5485: 	MOVE.l	d0,FAC1_m(a3)		* clear mantissa
01:00205EAA 37400594        	  5486: 	MOVE.w	d0,FAC1_e(a3)		* clear sign and exponent
01:00205EAE 60EE            	  5487: 	BRA.s		LAB_MUEX			* restore regs & exit
                            	  5488: 
                            	  5489: 
                            	  5490: *************************************************************************************
                            	  5491: *
                            	  5492: * do FAC2/FAC1, result in FAC1
                            	  5493: * fast hardware divide version
                            	  5494: 
                            	  5495: LAB_DIVIDE
01:00205EB0 2F07            	  5496: 	MOVE.l	d7,-(sp)			* save d7
01:00205EB2 7000            	  5497: 	MOVEQ		#0,d0				* clear FAC2 exponent
01:00205EB4 2400            	  5498: 	MOVE.l	d0,d2				* clear FAC1 exponent
                            	  5499: 
01:00205EB6 142B0594        	  5500: 	MOVE.b	FAC1_e(a3),d2		* get FAC1 exponent
01:00205EBA 6700E690        	  5501: 	BEQ		LAB_DZER			* if zero go do /0 error
                            	  5502: 
01:00205EBE 102B059C        	  5503: 	MOVE.b	FAC2_e(a3),d0		* get FAC2 exponent
01:00205EC2 6766            	  5504: 	BEQ.s		LAB_DIV0			* if zero return zero
                            	  5505: 
01:00205EC4 9042            	  5506: 	SUB.w		d2,d0				* get result exponent by subtracting
01:00205EC6 D07C0080        	  5507: 	ADD.w		#$80,d0			* correct 16 bit exponent result
                            	  5508: 
01:00205ECA 176B059E0595    	  5509: 	MOVE.b	FAC_sc(a3),FAC1_s(a3)	* sign compare is result sign
                            	  5510: 
                            	  5511: * now to do 32/32 bit mantissa divide
                            	  5512: 
01:00205ED0 422B059F        	  5513: 	CLR.b		flag(a3)			* clear 'flag' byte
01:00205ED4 262B0590        	  5514: 	MOVE.l	FAC1_m(a3),d3		* get FAC1 mantissa
01:00205ED8 282B0598        	  5515: 	MOVE.l	FAC2_m(a3),d4		* get FAC2 mantissa
01:00205EDC B883            	  5516: 	CMP.l		d3,d4				* compare FAC2 with FAC1 mantissa
01:00205EDE 6744            	  5517: 	BEQ.s		LAB_MAN1			* set mantissa result = 1 if equal
                            	  5518: 
01:00205EE0 6506            	  5519: 	BCS.s		AC1gtAC2			* branch if FAC1 > FAC2
                            	  5520: 
01:00205EE2 9883            	  5521: 	SUB.l		d3,d4				* subtract FAC1 from FAC2, result now must be <1
01:00205EE4 562B059F        	  5522: 	ADDQ.b	#3,flag(a3)			* FAC2>FAC1 so set 'flag' byte
                            	  5523: AC1gtAC2
01:00205EE8 6146            	  5524: 	BSR.s		LAB_32_16			* do 32/16 divide
01:00205EEA 4841            	  5525: 	SWAP		d1				* move 16 bit result to high word
01:00205EEC 2802            	  5526: 	MOVE.l	d2,d4				* copy remainder longword
01:00205EEE 6142            	  5527: 	BSR.s		LAB_3216			* do 32/16 divide again (skip copy d4 to d2)
01:00205EF0 84C5            	  5528: 	DIVU.w	d5,d2				* now divide remainder to make guard word
01:00205EF2 1E2B059F        	  5529: 	MOVE.b	flag(a3),d7			* now normalise, get flag byte back
01:00205EF6 6708            	  5530: 	BEQ.s		LAB_DIVX			* skip add if null
                            	  5531: 
                            	  5532: * else result was >1 so we need to add 1 to result mantissa and adjust exponent
                            	  5533: 
01:00205EF8 E20F            	  5534: 	LSR.b		#1,d7				* shift 1 into eXtend
01:00205EFA E291            	  5535: 	ROXR.l	#1,d1				* shift extend result >>
01:00205EFC E252            	  5536: 	ROXR.w	#1,d2				* shift extend guard word >>
01:00205EFE 5200            	  5537: 	ADDQ.b	#1,d0				* adjust exponent
                            	  5538: 
                            	  5539: * now round result to 32 bits
                            	  5540: 
                            	  5541: LAB_DIVX
01:00205F00 D442            	  5542: 	ADD.w		d2,d2				* guard bit into eXtend bit
01:00205F02 6408            	  5543: 	BCC.s		L_DIVRND			* branch if guard=0
                            	  5544: 
01:00205F04 5281            	  5545: 	ADDQ.l	#1,d1				* add guard to mantissa
01:00205F06 6404            	  5546: 	BCC.s		L_DIVRND			* branch if no overflow
                            	  5547: 
                            	  5548: LAB_SET1
01:00205F08 E291            	  5549: 	ROXR.l	#1,d1				* shift extend result >>
01:00205F0A 5240            	  5550: 	ADDQ.w	#1,d0				* adjust exponent
                            	  5551: 
                            	  5552: 							* test for over/under flow
                            	  5553: L_DIVRND
01:00205F0C 3600            	  5554: 	MOVE.w	d0,d3				* copy exponent
01:00205F0E 6B1A            	  5555: 	BMI.s		LAB_DIV0			* if -ve return zero
                            	  5556: 
01:00205F10 0243FF00        	  5557: 	ANDI.w	#$FF00,d3			* mask word high byte
01:00205F14 6600E64A        	  5558: 	BNE		LAB_OFER			* branch if overflow
                            	  5559: 
                            	  5560: 							* move result into FAC1
                            	  5561: LAB_XDIV
01:00205F18 2E1F            	  5562: 	MOVE.l	(sp)+,d7			* restore d7
01:00205F1A 17400594        	  5563: 	MOVE.b	d0,FAC1_e(a3)		* save result exponent
01:00205F1E 27410590        	  5564: 	MOVE.l	d1,FAC1_m(a3)		* save result mantissa
01:00205F22 4E75            	  5565: 	RTS
                            	  5566: 
                            	  5567: * FAC1 mantissa = FAC2 mantissa so set result mantissa
                            	  5568: 
                            	  5569: LAB_MAN1
01:00205F24 7201            	  5570: 	MOVEQ		#1,d1				* set bit
01:00205F26 E2A9            	  5571: 	LSR.l		d1,d1				* bit into eXtend
01:00205F28 60DE            	  5572: 	BRA.s		LAB_SET1			* set mantissa, adjust exponent and exit
                            	  5573: 
                            	  5574: * result is zero
                            	  5575: 
                            	  5576: LAB_DIV0
01:00205F2A 7000            	  5577: 	MOVEQ		#0,d0				* zero exponent & sign
01:00205F2C 2200            	  5578: 	MOVE.l	d0,d1				* zero mantissa
01:00205F2E 60E8            	  5579: 	BRA		LAB_XDIV			* exit divide
                            	  5580: 
                            	  5581: * divide 16 bits into 32, AB/Ex
                            	  5582: *
                            	  5583: * d4			AAAA	BBBB			* 32 bit numerator
                            	  5584: * d3			EEEE	xxxx			* 16 bit denominator
                            	  5585: *
                            	  5586: * returns -
                            	  5587: *
                            	  5588: * d1			xxxx	DDDD			* 16 bit result
                            	  5589: * d2				HHHH	IIII		* 32 bit remainder
                            	  5590: 
                            	  5591: LAB_32_16
01:00205F30 2404            	  5592: 	MOVE.l	d4,d2				* copy FAC2 mantissa		(AB)
                            	  5593: LAB_3216
01:00205F32 2A03            	  5594: 	MOVE.l	d3,d5				* copy FAC1 mantissa		(EF)
01:00205F34 4245            	  5595: 	CLR.w		d5				* clear low word d1		(Ex)
01:00205F36 4845            	  5596: 	SWAP		d5				* swap high word to low word	(xE)
                            	  5597: 
                            	  5598: * d3			EEEE	FFFF			* denominator copy
                            	  5599: * d5		0000	EEEE				* denominator high word
                            	  5600: * d2			AAAA	BBBB			* numerator copy
                            	  5601: * d4			AAAA	BBBB			* numerator
                            	  5602: 
01:00205F38 88C5            	  5603: 	DIVU.w	d5,d4				* do FAC2/FAC1 high word	(AB/E)
01:00205F3A 6802            	  5604: 	BVC.s		LAB_LT_1			* if no overflow DIV was ok
                            	  5605: 
01:00205F3C 78FF            	  5606: 	MOVEQ		#-1,d4			* else set default value
                            	  5607: 
                            	  5608: * done the divide, now check the result, we have ...
                            	  5609: 
                            	  5610: * d3			EEEE	FFFF			* denominator copy
                            	  5611: * d5		0000	EEEE				* denominator high word
                            	  5612: * d2			AAAA	BBBB			* numerator copy
                            	  5613: * d4			MMMM	DDDD			* result MOD and DIV
                            	  5614: 
                            	  5615: LAB_LT_1
01:00205F3E 3C04            	  5616: 	MOVE.w	d4,d6				* copy 16 bit result
01:00205F40 3204            	  5617: 	MOVE.w	d4,d1				* copy 16 bit result again
                            	  5618: 
                            	  5619: * we now have ..
                            	  5620: * d3			EEEE	FFFF			* denominator copy
                            	  5621: * d5		0000	EEEE				* denominator high word
                            	  5622: * d6			xxxx  DDDD			* result DIV copy
                            	  5623: * d1			xxxx  DDDD			* result DIV copy
                            	  5624: * d2			AAAA	BBBB			* numerator copy
                            	  5625: * d4			MMMM	DDDD			* result MOD and DIV
                            	  5626: 
                            	  5627: * now multiply out 32 bit denominator by 16 bit result
                            	  5628: * QRS = AB*D
                            	  5629: 
01:00205F42 CCC3            	  5630: 	MULU.w	d3,d6				* FFFF * DDDD =       rrrr  SSSS
01:00205F44 C8C5            	  5631: 	MULU.w	d5,d4				* EEEE * DDDD = QQQQ  rrrr
                            	  5632: 
                            	  5633: * we now have ..
                            	  5634: * d3			EEEE	FFFF			* denominator copy
                            	  5635: * d5		0000	EEEE				* denominator high word
                            	  5636: * d6				rrrr  SSSS		* 48 bit result partial low
                            	  5637: * d1			xxxx  DDDD			* result DIV copy
                            	  5638: * d2			AAAA	BBBB			* numerator copy
                            	  5639: * d4			QQQQ	rrrr			* 48 bit result partial
                            	  5640: 
01:00205F46 3E06            	  5641: 	MOVE.w	d6,d7				* copy low word of low multiply
                            	  5642: 
                            	  5643: * d7				xxxx	SSSS		* 48 bit result partial low
                            	  5644: 
01:00205F48 4246            	  5645: 	CLR.w		d6				* clear low word of low multiply
01:00205F4A 4846            	  5646: 	SWAP		d6				* high word of low multiply to low word
                            	  5647: 
                            	  5648: * d6			0000	rrrr			* high word of 48 bit result partial low
                            	  5649: 
01:00205F4C D886            	  5650: 	ADD.l		d6,d4
                            	  5651: 
                            	  5652: * d4			QQQQ	RRRR			* 48 bit result partial high longword
                            	  5653: 
01:00205F4E 7C00            	  5654: 	MOVEQ		#0,d6				* clear to extend numerator to 48 bits
                            	  5655: 
                            	  5656: * now do GHI = AB0 - QRS (which is the remainder)
                            	  5657: 
01:00205F50 9C47            	  5658: 	SUB.w		d7,d6				* low word subtract
                            	  5659: 
                            	  5660: * d6				xxxx	IIII		* remainder low word
                            	  5661: 
01:00205F52 9584            	  5662: 	SUBX.l	d4,d2				* high longword subtract
                            	  5663: 
                            	  5664: * d2			GGGG	HHHH			* remainder high longword
                            	  5665: 
                            	  5666: * now if we got the divide correct then the remainder high longword will be +ve
                            	  5667: 
01:00205F54 6A08            	  5668: 	BPL.s		L_DDIV			* branch if result is ok (<needed)
                            	  5669: 
                            	  5670: * remainder was -ve so DDDD is too big
                            	  5671: 
                            	  5672: LAB_REMM
01:00205F56 5341            	  5673: 	SUBQ.w	#1,d1				* adjust DDDD
                            	  5674: 
                            	  5675: * d3				xxxx	FFFF		* denominator copy
                            	  5676: * d6				xxxx	IIII		* remainder low word
                            	  5677: 
01:00205F58 DC43            	  5678: 	ADD.w		d3,d6				* add EF*1 low remainder low word
                            	  5679: 
                            	  5680: * d5			0000	EEEE			* denominator high word
                            	  5681: * d2			GGGG	HHHH			* remainder high longword
                            	  5682: 
01:00205F5A D585            	  5683: 	ADDX.l	d5,d2				* add extend EF*1 to remainder high longword
01:00205F5C 6BF8            	  5684: 	BMI.s		LAB_REMM			* loop if result still too big
                            	  5685: 
                            	  5686: * all done and result correct or <
                            	  5687: 
                            	  5688: L_DDIV
01:00205F5E 4842            	  5689: 	SWAP		d2				* remainder mid word to high word
                            	  5690: 
                            	  5691: * d2			HHHH	GGGG			* (high word /should/ be $0000)
                            	  5692: 
01:00205F60 3406            	  5693: 	MOVE.w	d6,d2				* remainder in high word
                            	  5694: 
                            	  5695: * d2				HHHH	IIII		* now is 32 bit remainder
                            	  5696: * d1			xxxx	DDDD			* 16 bit result
                            	  5697: 
01:00205F62 4E75            	  5698: 	RTS
                            	  5699: 
                            	  5700: 
                            	  5701: *************************************************************************************
                            	  5702: *
                            	  5703: * unpack memory (a0) into FAC1
                            	  5704: 
                            	  5705: LAB_UFAC
01:00205F64 2010            	  5706: 	MOVE.l	(a0),d0			* get packed value
01:00205F66 4840            	  5707: 	SWAP		d0				* exponent and sign into least significant word
01:00205F68 37400594        	  5708: 	MOVE.w	d0,FAC1_e(a3)		* save exponent and sign
01:00205F6C 6708            	  5709: 	BEQ.s		LAB_NB1T			* branch if exponent (and the rest) zero
                            	  5710: 
01:00205F6E 807C0080        	  5711: 	OR.w		#$80,d0			* set MSb
01:00205F72 4840            	  5712: 	SWAP		d0				* word order back to normal
01:00205F74 E180            	  5713: 	ASL.l		#8,d0				* shift exponent & clear guard byte
                            	  5714: LAB_NB1T
01:00205F76 27400590        	  5715: 	MOVE.l	d0,FAC1_m(a3)		* move into FAC1
                            	  5716: 
01:00205F7A 102B0594        	  5717: 	MOVE.b	FAC1_e(a3),d0		* get FAC1 exponent
01:00205F7E 4E75            	  5718: 	RTS
                            	  5719: 
                            	  5720: 
                            	  5721: *************************************************************************************
                            	  5722: *
                            	  5723: * set numeric variable, pack FAC1 into Lvarpl
                            	  5724: 
                            	  5725: LAB_PFAC
01:00205F80 2F08            	  5726: 	MOVE.l	a0,-(sp)			* save pointer
01:00205F82 206B0472        	  5727: 	MOVEA.l	Lvarpl(a3),a0		* get destination pointer
01:00205F86 082B000605B5    	  5728: 	BTST		#6,Dtypef(a3)		* test data type
01:00205F8C 670C            	  5729: 	BEQ.s		LAB_277C			* branch if floating
                            	  5730: 
01:00205F8E 610000C6        	  5731: 	BSR		LAB_2831			* convert FAC1 floating to fixed
                            	  5732: 							* result in d0 and Itemp
01:00205F92 2080            	  5733: 	MOVE.l	d0,(a0)			* save in var
01:00205F94 205F            	  5734: 	MOVE.l	(sp)+,a0			* restore pointer
01:00205F96 4E75            	  5735: 	RTS
                            	  5736: 
                            	  5737: 
                            	  5738: *************************************************************************************
                            	  5739: *
                            	  5740: * normalise round and pack FAC1 into (a0)
                            	  5741: 
                            	  5742: LAB_2778
01:00205F98 2F08            	  5743: 	MOVE.l	a0,-(sp)			* save pointer
                            	  5744: LAB_277C
01:00205F9A 6100FD60        	  5745: 	BSR		LAB_24D5			* normalise FAC1
01:00205F9E 612C            	  5746: 	BSR.s		LAB_27BA			* round FAC1
01:00205FA0 202B0590        	  5747: 	MOVE.l	FAC1_m(a3),d0		* get FAC1 mantissa
01:00205FA4 E098            	  5748: 	ROR.l		#8,d0				* align 24/32 bit mantissa
01:00205FA6 4840            	  5749: 	SWAP		d0				* exponent/sign into 0-15
01:00205FA8 C07C007F        	  5750: 	AND.w		#$7F,d0			* clear exponent and sign bit
01:00205FAC 022B00800595    	  5751: 	ANDI.b	#$80,FAC1_s(a3)		* clear non sign bits in sign
01:00205FB2 806B0594        	  5752: 	OR.w		FAC1_e(a3),d0		* OR in exponent and sign
01:00205FB6 4840            	  5753: 	SWAP		d0				* move exponent and sign back to 16-31
01:00205FB8 2080            	  5754: 	MOVE.l	d0,(a0)			* store in destination
01:00205FBA 205F            	  5755: 	MOVE.l	(sp)+,a0			* restore pointer
01:00205FBC 4E75            	  5756: 	RTS
                            	  5757: 
                            	  5758: 
                            	  5759: *************************************************************************************
                            	  5760: *
                            	  5761: * copy FAC2 to FAC1
                            	  5762: 
                            	  5763: LAB_279B
01:00205FBE 376B059C0594    	  5764: 	MOVE.w	FAC2_e(a3),FAC1_e(a3)	* copy exponent & sign
01:00205FC4 276B05980590    	  5765: 	MOVE.l	FAC2_m(a3),FAC1_m(a3)	* copy mantissa
01:00205FCA 4E75            	  5766: 	RTS
                            	  5767: 
                            	  5768: 
                            	  5769: *************************************************************************************
                            	  5770: *
                            	  5771: * round FAC1
                            	  5772: 
                            	  5773: LAB_27BA
01:00205FCC 102B0594        	  5774: 	MOVE.b	FAC1_e(a3),d0		* get FAC1 exponent
01:00205FD0 6720            	  5775: 	BEQ.s		LAB_27C4			* branch if zero
                            	  5776: 
01:00205FD2 202B0590        	  5777: 	MOVE.l	FAC1_m(a3),d0		* get FAC1
01:00205FD6 D0BC00000080    	  5778: 	ADD.l		#$80,d0			* round to 24 bit
01:00205FDC 640A            	  5779: 	BCC.s		LAB_27C3			* branch if no overflow
                            	  5780: 
01:00205FDE E290            	  5781: 	ROXR.l	#1,d0				* shift FAC1 mantissa
01:00205FE0 522B0594        	  5782: 	ADDQ.b	#1,FAC1_e(a3)		* correct exponent
01:00205FE4 6500E57A        	  5783: 	BCS		LAB_OFER			* if carry do overflow error & warm start
                            	  5784: 
                            	  5785: LAB_27C3
01:00205FE8 C03C0000        	  5786: 	AND.b		#$00,d0			* clear guard byte
01:00205FEC 27400590        	  5787: 	MOVE.l	d0,FAC1_m(a3)		* save back to FAC1
01:00205FF0 4E75            	  5788: 	RTS
                            	  5789: 
                            	  5790: LAB_27C4
01:00205FF2 17400595        	  5791: 	MOVE.b	d0,FAC1_s(a3)		* make zero always +ve
                            	  5792: RTS_017
01:00205FF6 4E75            	  5793: 	RTS
                            	  5794: 
                            	  5795: 
                            	  5796: *************************************************************************************
                            	  5797: *
                            	  5798: * get FAC1 sign
                            	  5799: * return d0=-1,C=1/-ve d0=+1,C=0/+ve
                            	  5800: 
                            	  5801: LAB_27CA
01:00205FF8 7000            	  5802: 	MOVEQ		#0,d0				* clear d0
01:00205FFA 102B0594        	  5803: 	MOVE.b	FAC1_e(a3),d0		* get FAC1 exponent
01:00205FFE 67F6            	  5804: 	BEQ.s		RTS_017			* exit if zero (already correct SGN(0)=0)
                            	  5805: 
                            	  5806: 
                            	  5807: *************************************************************************************
                            	  5808: *
                            	  5809: * return d0=-1,C=1/-ve d0=+1,C=0/+ve
                            	  5810: * no = 0 check
                            	  5811: 
                            	  5812: LAB_27CE
01:00206000 102B0595        	  5813: 	MOVE.b	FAC1_s(a3),d0		* else get FAC1 sign (b7)
                            	  5814: 
                            	  5815: 
                            	  5816: *************************************************************************************
                            	  5817: *
                            	  5818: * return d0=-1,C=1/-ve d0=+1,C=0/+ve
                            	  5819: * no = 0 check, sign in d0
                            	  5820: 
                            	  5821: LAB_27D0
01:00206004 4880            	  5822: 	EXT.w		d0				* make word
01:00206006 48C0            	  5823: 	EXT.l		d0				* make longword
01:00206008 E080            	  5824: 	ASR.l		#8,d0				* move sign bit through byte to carry
01:0020600A 65EA            	  5825: 	BCS.s		RTS_017			* exit if carry set
                            	  5826: 
01:0020600C 7001            	  5827: 	MOVEQ		#1,d0				* set result for +ve sign
01:0020600E 4E75            	  5828: 	RTS
                            	  5829: 
                            	  5830: 
                            	  5831: *************************************************************************************
                            	  5832: *
                            	  5833: * perform SGN()
                            	  5834: 
                            	  5835: LAB_SGN
01:00206010 61E6            	  5836: 	BSR.s		LAB_27CA			* get FAC1 sign
                            	  5837: 							* return d0=-1/-ve d0=+1/+ve
                            	  5838: 
                            	  5839: 
                            	  5840: *************************************************************************************
                            	  5841: *
                            	  5842: * save d0 as integer longword
                            	  5843: 
                            	  5844: LAB_27DB
01:00206012 27400590        	  5845: 	MOVE.l	d0,FAC1_m(a3)		* save FAC1 mantissa
01:00206016 377CA0000594    	  5846: 	MOVE.w	#$A000,FAC1_e(a3)		* set FAC1 exponent & sign
01:0020601C D080            	  5847: 	ADD.l		d0,d0				* top bit into carry
01:0020601E 6000FCD2        	  5848: 	BRA		LAB_24D0			* do +/- (carry is sign) & normalise FAC1
                            	  5849: 
                            	  5850: 
                            	  5851: *************************************************************************************
                            	  5852: *
                            	  5853: * perform ABS()
                            	  5854: 
                            	  5855: LAB_ABS
01:00206022 177C00000595    	  5856: 	MOVE.b	#0,FAC1_s(a3)		* clear FAC1 sign
01:00206028 4E75            	  5857: 	RTS
                            	  5858: 
                            	  5859: 
                            	  5860: *************************************************************************************
                            	  5861: *
                            	  5862: * compare FAC1 with FAC2
                            	  5863: * returns d0=+1 Cb=0 if FAC1 > FAC2
                            	  5864: * returns d0= 0 Cb=0 if FAC1 = FAC2
                            	  5865: * returns d0=-1 Cb=1 if FAC1 < FAC2
                            	  5866: 
                            	  5867: LAB_27FA
01:0020602A 122B059C        	  5868: 	MOVE.b	FAC2_e(a3),d1		* get FAC2 exponent
01:0020602E 67C8            	  5869: 	BEQ.s		LAB_27CA			* branch if FAC2 exponent=0 & get FAC1 sign
                            	  5870: 							* d0=-1,C=1/-ve d0=+1,C=0/+ve
                            	  5871: 
01:00206030 102B059E        	  5872: 	MOVE.b	FAC_sc(a3),d0		* get FAC sign compare
01:00206034 6BCA            	  5873: 	BMI.s		LAB_27CE			* if signs <> do return d0=-1,C=1/-ve
                            	  5874: 							* d0=+1,C=0/+ve & return
                            	  5875: 
01:00206036 102B0595        	  5876: 	MOVE.b	FAC1_s(a3),d0		* get FAC1 sign
01:0020603A B22B0594        	  5877: 	CMP.b		FAC1_e(a3),d1		* compare FAC1 exponent with FAC2 exponent
01:0020603E 660A            	  5878: 	BNE.s		LAB_2828			* branch if different
                            	  5879: 
01:00206040 222B0598        	  5880: 	MOVE.l	FAC2_m(a3),d1		* get FAC2 mantissa
01:00206044 B2AB0590        	  5881: 	CMP.l		FAC1_m(a3),d1		* compare mantissas
01:00206048 6708            	  5882: 	BEQ.s		LAB_282F			* exit if mantissas equal
                            	  5883: 
                            	  5884: * gets here if number <> FAC1
                            	  5885: 
                            	  5886: LAB_2828
01:0020604A 65B8            	  5887: 	BCS.s		LAB_27D0			* if FAC1 > FAC2 return d0=-1,C=1/-ve d0=+1,
                            	  5888: 							* C=0/+ve
                            	  5889: 
01:0020604C 0A000080        	  5890: 	EORI.b	#$80,d0			* else toggle FAC1 sign
                            	  5891: LAB_282E
01:00206050 60B2            	  5892: 	BRA.s		LAB_27D0			* return d0=-1,C=1/-ve d0=+1,C=0/+ve
                            	  5893: 
                            	  5894: LAB_282F
01:00206052 7000            	  5895: 	MOVEQ		#0,d0				* clear result
01:00206054 4E75            	  5896: 	RTS
                            	  5897: 
                            	  5898: 
                            	  5899: *************************************************************************************
                            	  5900: *
                            	  5901: * convert FAC1 floating to fixed
                            	  5902: * result in d0 and Itemp, sets flags correctly
                            	  5903: 
                            	  5904: LAB_2831
01:00206056 202B0590        	  5905: 	MOVE.l	FAC1_m(a3),d0		* copy mantissa
01:0020605A 6730            	  5906: 	BEQ.s		LAB_284J			* branch if mantissa = 0
                            	  5907: 
01:0020605C 2F01            	  5908: 	MOVE.l	d1,-(sp)			* save d1
01:0020605E 72A0            	  5909: 	MOVEQ		#-96,d1			* set for no floating bits
01:00206060 922B0594        	  5910: 	SUB.b		FAC1_e(a3),d1		* subtract FAC1 exponent
01:00206064 6500E4FA        	  5911: 	BCS		LAB_OFER			* do overflow if too big
                            	  5912: 
01:00206068 660E            	  5913: 	BNE.s		LAB_284G			* branch if exponent was not $A0
                            	  5914: 
01:0020606A 4A2B0595        	  5915: 	TST.b		FAC1_s(a3)			* test FAC1 sign
01:0020606E 6A1A            	  5916: 	BPL.s		LAB_284H			* branch if FAC1 +ve
                            	  5917: 
01:00206070 4480            	  5918: 	NEG.l		d0
01:00206072 6916            	  5919: 	BVS.s		LAB_284H			* branch if was $80000000
                            	  5920: 
01:00206074 6000E4EA        	  5921: 	BRA		LAB_OFER			* do overflow if too big
                            	  5922: 
                            	  5923: LAB_284G
01:00206078 B23C0020        	  5924: 	CMP.b		#$20,d1			* compare with minimum result for integer
01:0020607C 6502            	  5925: 	BCS.s		LAB_284L			* if < minimum just do shift
                            	  5926: 
01:0020607E 7000            	  5927: 	MOVEQ		#0,d0				* else return zero
                            	  5928: LAB_284L
01:00206080 E2A8            	  5929: 	LSR.l		d1,d0				* shift integer
                            	  5930: 
01:00206082 4A2B0595        	  5931: 	TST.b		FAC1_s(a3)			* test FAC1 sign (b7)
01:00206086 6A02            	  5932: 	BPL.s		LAB_284H			* branch if FAC1 +ve
                            	  5933: 
01:00206088 4480            	  5934: 	NEG.l		d0				* negate integer value
                            	  5935: LAB_284H
01:0020608A 221F            	  5936: 	MOVE.l	(sp)+,d1			* restore d1
                            	  5937: LAB_284J
01:0020608C 2740042A        	  5938: 	MOVE.l	d0,Itemp(a3)		* save result to Itemp
01:00206090 4E75            	  5939: 	RTS
                            	  5940: 
                            	  5941: 
                            	  5942: *************************************************************************************
                            	  5943: *
                            	  5944: * perform INT()
                            	  5945: 
                            	  5946: LAB_INT
01:00206092 70A0            	  5947: 	MOVEQ		#-96,d0			* set for no floating bits
01:00206094 902B0594        	  5948: 	SUB.b		FAC1_e(a3),d0		* subtract FAC1 exponent
01:00206098 6310            	  5949: 	BLS.s		LAB_IRTS			* exit if exponent >= $A0
                            	  5950: 							* (too big for fraction part!)
                            	  5951: 
01:0020609A B03C0020        	  5952: 	CMP.b		#$20,d0			* compare with minimum result for integer
01:0020609E 6400025E        	  5953: 	BCC		LAB_POZE			* if >= minimum go return 0
                            	  5954: 							* (too small for integer part!)
                            	  5955: 
01:002060A2 72FF            	  5956: 	MOVEQ		#-1,d1			* set integer mask
01:002060A4 E1A1            	  5957: 	ASL.l		d0,d1				* shift mask [8+2*d0]
01:002060A6 C3AB0590        	  5958: 	AND.l		d1,FAC1_m(a3)		* mask mantissa
                            	  5959: LAB_IRTS
01:002060AA 4E75            	  5960: 	RTS
                            	  5961: 
                            	  5962: 
                            	  5963: *************************************************************************************
                            	  5964: *
                            	  5965: * print " in line [LINE #]"
                            	  5966: 
                            	  5967: LAB_2953
01:002060AC 41FA17F0        	  5968: 	LEA		LAB_LMSG(pc),a0		* point to " in line " message
01:002060B0 6100ED30        	  5969: 	BSR		LAB_18C3			* print null terminated string
                            	  5970: 
                            	  5971: 							* Print Basic line #
01:002060B4 202B0452        	  5972: 	MOVE.l	Clinel(a3),d0		* get current line
                            	  5973: 
                            	  5974: 
                            	  5975: *************************************************************************************
                            	  5976: *
                            	  5977: * print d0 as unsigned integer
                            	  5978: 
                            	  5979: LAB_295E
01:002060B8 43FA0DDE        	  5980: 	LEA		Bin2dec(pc),a1		* get table address
01:002060BC 7200            	  5981: 	MOVEQ		#0,d1				* table index
01:002060BE 41EB05CC        	  5982: 	LEA		Usdss(a3),a0		* output string start
01:002060C2 2401            	  5983: 	MOVE.l	d1,d2				* output string index
                            	  5984: LAB_2967
01:002060C4 26311000        	  5985: 	MOVE.l	(a1,d1.w),d3		* get table value
01:002060C8 6714            	  5986: 	BEQ.s		LAB_2969			* exit if end marker
                            	  5987: 
01:002060CA 782F            	  5988: 	MOVEQ		#'0'-1,d4			* set character to "0"-1
                            	  5989: LAB_2968
01:002060CC 5244            	  5990: 	ADDQ.w	#1,d4				* next numeric character
01:002060CE 9083            	  5991: 	SUB.l		d3,d0				* subtract table value
01:002060D0 6AFA            	  5992: 	BPL.s		LAB_2968			* not overdone so loop
                            	  5993: 
01:002060D2 D083            	  5994: 	ADD.l		d3,d0				* correct value
01:002060D4 11842000        	  5995: 	MOVE.b	d4,(a0,d2.w)		* character out to string
01:002060D8 5841            	  5996: 	ADDQ.w	#4,d1				* increment table pointer
01:002060DA 5242            	  5997: 	ADDQ.w	#1,d2				* increment output string pointer
01:002060DC 60E6            	  5998: 	BRA.s		LAB_2967			* loop
                            	  5999: 
                            	  6000: LAB_2969
01:002060DE D03C0030        	  6001: 	ADD.b		#'0',d0			* make last character
01:002060E2 11802000        	  6002: 	MOVE.b	d0,(a0,d2.w)		* character out to string
01:002060E6 5348            	  6003: 	SUBQ.w	#1,a0				* decrement a0 (allow simple loop)
                            	  6004: 
                            	  6005: 							* now find non zero start of string
                            	  6006: LAB_296A
01:002060E8 5248            	  6007: 	ADDQ.w	#1,a0				* increment a0 (this will never carry to b16)
01:002060EA 43EB05D5        	  6008: 	LEA		BHsend-1(a3),a1		* get string end
01:002060EE B1C9            	  6009: 	CMPA.l	a1,a0				* are we at end
01:002060F0 6700ECF0        	  6010: 	BEQ		LAB_18C3			* if so print null terminated string and RETURN
                            	  6011: 
01:002060F4 0C100030        	  6012: 	CMPI.b	#'0',(a0)			* is character "0" ?
01:002060F8 67EE            	  6013: 	BEQ.s		LAB_296A			* loop if so
                            	  6014: 
01:002060FA 6000ECE6        	  6015: 	BRA		LAB_18C3			* print null terminated string from memory & RET
                            	  6016: 
                            	  6017: 
                            	  6018: *************************************************************************************
                            	  6019: *
                            	  6020: * convert FAC1 to ASCII string result in (a0)
                            	  6021: * STR$() function enters here
                            	  6022: 
                            	  6023: * now outputs 7 significant digits
                            	  6024: 
                            	  6025: * d0 is character out
                            	  6026: * d1 is save index
                            	  6027: * d2 is gash
                            	  6028: 
                            	  6029: * a0 is output string pointer
                            	  6030: 
                            	  6031: LAB_2970
01:002060FE 43EB05C6        	  6032: 	LEA		Decss(a3),a1		* set output string start
                            	  6033: 
01:00206102 7420            	  6034: 	MOVEQ		#' ',d2			* character = " ", assume +ve
01:00206104 08AB00070595    	  6035: 	BCLR.b	#7,FAC1_s(a3)		* test and clear FAC1 sign (b7)
01:0020610A 6702            	  6036: 	BEQ.s		LAB_2978			* branch if +ve
                            	  6037: 
01:0020610C 742D            	  6038: 	MOVEQ		#'-',d2			* else character = "-"
                            	  6039: LAB_2978
01:0020610E 1282            	  6040: 	MOVE.b	d2,(a1)			* save the sign character
01:00206110 142B0594        	  6041: 	MOVE.b	FAC1_e(a3),d2		* get FAC1 exponent
01:00206114 6608            	  6042: 	BNE.s		LAB_2989			* branch if FAC1<>0
                            	  6043: 
                            	  6044: 							* exponent was $00 so FAC1 is 0
01:00206116 7030            	  6045: 	MOVEQ		#'0',d0			* set character = "0"
01:00206118 7201            	  6046: 	MOVEQ		#1,d1				* set output string index
01:0020611A 600001A4        	  6047: 	BRA		LAB_2A89			* save last character, [EOT] & exit
                            	  6048: 
                            	  6049: 							* FAC1 is some non zero value
                            	  6050: LAB_2989
01:0020611E 177C000005AC    	  6051: 	MOVE.b	#0,numexp(a3)		* clear number exponent count
01:00206124 B43C0081        	  6052: 	CMP.b		#$81,d2			* compare FAC1 exponent with $81 (>1.00000)
                            	  6053: 
01:00206128 6448            	  6054: 	BCC.s		LAB_299C			* branch if FAC1=>1
                            	  6055: 
                            	  6056: 							* else FAC1 < 1
01:0020612A 277C989680000598	  6057: 	MOVE.l	#$98968000,FAC2_m(a3)	* 10000000 mantissa
01:00206132 377C9800059C    	  6058: 	MOVE.w	#$9800,FAC2_e(a3)		* 10000000 exponent & sign
01:00206138 176B0595059E    	  6059: 	MOVE.b	FAC1_s(a3),FAC_sc(a3)	* make FAC1 sign sign compare
01:0020613E 6100FCE4        	  6060: 	BSR		LAB_MULTIPLY		* do FAC2*FAC1
                            	  6061: 
01:00206142 177C00F905AC    	  6062: 	MOVE.b	#$F9,numexp(a3)		* set number exponent count (-7)
01:00206148 6028            	  6063: 	BRA.s		LAB_299C			* go test for fit
                            	  6064: 
                            	  6065: LAB_29B9
01:0020614A 376B0594059C    	  6066: 	MOVE.w	FAC1_e(a3),FAC2_e(a3)	* copy exponent & sign from FAC1 to FAC2
01:00206150 276B05900598    	  6067: 	MOVE.l	FAC1_m(a3),FAC2_m(a3)	* copy FAC1 mantissa to FAC2 mantissa
01:00206156 176B0595059E    	  6068: 	MOVE.b	FAC1_s(a3),FAC_sc(a3)	* save FAC1_s as sign compare
                            	  6069: 
01:0020615C 277CCCCCCCCD0590	  6070: 	MOVE.l	#$CCCCCCCD,FAC1_m(a3)	* 1/10 mantissa
01:00206164 377C7D000594    	  6071: 	MOVE.w	#$7D00,FAC1_e(a3)		* 1/10 exponent & sign
01:0020616A 6100FCB8        	  6072: 	BSR		LAB_MULTIPLY		* do FAC2*FAC1, effectively divide by 10 but
                            	  6073: 							* faster
                            	  6074: 
01:0020616E 522B05AC        	  6075: 	ADDQ.b	#1,numexp(a3)		* increment number exponent count
                            	  6076: LAB_299C
01:00206172 277C98967F700598	  6077: 	MOVE.l	#$98967F70,FAC2_m(a3)	* 9999999.4375 mantissa
01:0020617A 377C9800059C    	  6078: 	MOVE.w	#$9800,FAC2_e(a3)		* 9999999.4375 exponent & sign
                            	  6079: 							* (max before scientific notation)
01:00206180 6100014C        	  6080: 	BSR		LAB_27F0			* fast compare FAC1 with FAC2
                            	  6081: 							* returns d0=+1 C=0 if FAC1 > FAC2
                            	  6082: 							* returns d0= 0 C=0 if FAC1 = FAC2
                            	  6083: 							* returns d0=-1 C=1 if FAC1 < FAC2
01:00206184 62C4            	  6084: 	BHI.s		LAB_29B9			* go do /10 if FAC1 > 9999999.4375
                            	  6085: 
01:00206186 6750            	  6086: 	BEQ.s		LAB_29C3			* branch if FAC1 = 9999999.4375
                            	  6087: 
                            	  6088: 							* FAC1 < 9999999.4375
01:00206188 277CF423F8000598	  6089: 	MOVE.l	#$F423F800,FAC2_m(a3)	* set mantissa for 999999.5
01:00206190 377C9400059C    	  6090: 	MOVE.w	#$9400,FAC2_e(a3)		* set exponent for 999999.5
                            	  6091: 
01:00206196 41EB0590        	  6092: 	LEA		FAC1_m(a3),a0		* set pointer for x10
                            	  6093: LAB_29A7
01:0020619A 61000132        	  6094: 	BSR		LAB_27F0			* fast compare FAC1 with FAC2
                            	  6095: 							* returns d0=+1 C=0 if FAC1 > FAC2
                            	  6096: 							* returns d0= 0 C=0 if FAC1 = FAC2
                            	  6097: 							* returns d0=-1 C=1 if FAC1 < FAC2
01:0020619E 6220            	  6098: 	BHI.s		LAB_29C0			* branch if FAC1 > 99999.9375,no decimal places
                            	  6099: 
                            	  6100: 							* FAC1 <= 999999.5 so do x 10
01:002061A0 2010            	  6101: 	MOVE.l	(a0),d0			* get FAC1 mantissa
01:002061A2 12280004        	  6102: 	MOVE.b	4(a0),d1			* get FAC1 exponent
01:002061A6 2400            	  6103: 	MOVE.l	d0,d2				* copy it
01:002061A8 E488            	  6104: 	LSR.l		#2,d0				* /4
01:002061AA D082            	  6105: 	ADD.l		d2,d0				* add FAC1 (x1.125)
01:002061AC 6404            	  6106: 	BCC.s		LAB_29B7			* branch if no carry
                            	  6107: 
01:002061AE E290            	  6108: 	ROXR.l	#1,d0				* shift carry back in
01:002061B0 5201            	  6109: 	ADDQ.b	#1,d1				* increment exponent (never overflows)
                            	  6110: LAB_29B7
01:002061B2 5601            	  6111: 	ADDQ.b	#3,d1				* correct exponent ( 8 x 1.125 = 10 )
                            	  6112: 							* (never overflows)
01:002061B4 2080            	  6113: 	MOVE.l	d0,(a0)			* save new mantissa
01:002061B6 11410004        	  6114: 	MOVE.b	d1,4(a0)			* save new exponent
01:002061BA 532B05AC        	  6115: 	SUBQ.b	#1,numexp(a3)		* decrement number exponent count
01:002061BE 60DA            	  6116: 	BRA.s		LAB_29A7			* go test again
                            	  6117: 
                            	  6118: 							* now we have just the digits to do
                            	  6119: LAB_29C0
01:002061C0 277C800000000598	  6120: 	MOVE.l	#$80000000,FAC2_m(a3)	* set mantissa for 0.5
01:002061C8 377C8000059C    	  6121: 	MOVE.w	#$8000,FAC2_e(a3)		* set exponent for 0.5
01:002061CE 176B0595059E    	  6122: 	MOVE.b	FAC1_s(a3),FAC_sc(a3)	* sign compare = sign
01:002061D4 6100FAAC        	  6123: 	BSR		LAB_ADD			* add the 0.5 to FAC1 (round FAC1)
                            	  6124: 
                            	  6125: LAB_29C3
01:002061D8 6100FE7C        	  6126: 	BSR		LAB_2831			* convert FAC1 floating to fixed
                            	  6127: 							* result in d0 and Itemp
01:002061DC 7401            	  6128: 	MOVEQ		#$01,d2			* set default digits before dp = 1
01:002061DE 102B05AC        	  6129: 	MOVE.b	numexp(a3),d0		* get number exponent count
01:002061E2 5000            	  6130: 	ADD.b		#8,d0				* allow 7 digits before point
01:002061E4 6B0C            	  6131: 	BMI.s		LAB_29D9			* if -ve then 1 digit before dp
                            	  6132: 
01:002061E6 B03C0009        	  6133: 	CMP.b		#$09,d0			* d0>=9 if n>=1E7
01:002061EA 6406            	  6134: 	BCC.s		LAB_29D9			* branch if >= $09
                            	  6135: 
                            	  6136: 							* < $08
01:002061EC 5300            	  6137: 	SUBQ.b	#1,d0				* take 1 from digit count
01:002061EE 1400            	  6138: 	MOVE.b	d0,d2				* copy byte
01:002061F0 7002            	  6139: 	MOVEQ		#$02,d0			* set exponent adjust
                            	  6140: LAB_29D9
01:002061F2 7200            	  6141: 	MOVEQ		#0,d1				* set output string index
01:002061F4 5500            	  6142: 	SUBQ.b	#2,d0				* -2
01:002061F6 174005AD        	  6143: 	MOVE.b	d0,expcnt(a3)		* save exponent adjust
01:002061FA 174205AC        	  6144: 	MOVE.b	d2,numexp(a3)		* save digits before dp count
01:002061FE 1002            	  6145: 	MOVE.b	d2,d0				* copy digits before dp count
01:00206200 6702            	  6146: 	BEQ.s		LAB_29E4			* branch if no digits before dp
                            	  6147: 
01:00206202 6A14            	  6148: 	BPL.s		LAB_29F7			* branch if digits before dp
                            	  6149: 
                            	  6150: LAB_29E4
01:00206204 5281            	  6151: 	ADDQ.l	#1,d1				* increment index
01:00206206 13BC002E1000    	  6152: 	MOVE.b	#'.',(a1,d1.w)		* save to output string
                            	  6153: 
01:0020620C 4A02            	  6154: 	TST.b		d2				* test digits before dp count
01:0020620E 6708            	  6155: 	BEQ.s		LAB_29F7			* branch if no digits before dp
                            	  6156: 
01:00206210 5281            	  6157: 	ADDQ.l	#1,d1				* increment index
01:00206212 13BC00301000    	  6158: 	MOVE.b	#'0',(a1,d1.w)		* save to output string
                            	  6159: LAB_29F7
01:00206218 7400            	  6160: 	MOVEQ		#0,d2				* clear index (point to 1,000,000)
01:0020621A 7080            	  6161: 	MOVEQ		#$80-$100,d0		* set output character
                            	  6162: LAB_29FB
01:0020621C 41FA1114        	  6163: 	LEA		LAB_2A9A(pc),a0		* get base of table
01:00206220 26302000        	  6164: 	MOVE.l	(a0,d2.w),d3		* get table value
                            	  6165: LAB_29FD
01:00206224 5200            	  6166: 	ADDQ.b	#1,d0				* increment output character
01:00206226 D7AB042A        	  6167: 	ADD.l		d3,Itemp(a3)		* add to (now fixed) mantissa
01:0020622A 08000007        	  6168: 	BTST		#7,d0				* set test sense (z flag only)
01:0020622E 6504            	  6169: 	BCS.s		LAB_2A18			* did carry so has wrapped past zero
                            	  6170: 
01:00206230 67F2            	  6171: 	BEQ.s		LAB_29FD			* no wrap and +ve test so try again
                            	  6172: 
01:00206232 6002            	  6173: 	BRA.s		LAB_2A1A			* found this digit
                            	  6174: 
                            	  6175: LAB_2A18
01:00206234 66EE            	  6176: 	BNE.s		LAB_29FD			* wrap and -ve test so try again
                            	  6177: 
                            	  6178: LAB_2A1A
01:00206236 6406            	  6179: 	BCC.s		LAB_2A21			* branch if +ve test result
                            	  6180: 
01:00206238 4400            	  6181: 	NEG.b		d0				* negate the digit number
01:0020623A D03C000B        	  6182: 	ADD.b		#$0B,d0			* and subtract from 11 decimal
                            	  6183: LAB_2A21
01:0020623E D03C002F        	  6184: 	ADD.b		#$2F,d0			* add "0"-1 to result
01:00206242 5842            	  6185: 	ADDQ.w	#4,d2				* increment index to next less power of ten
01:00206244 5241            	  6186: 	ADDQ.w	#1,d1				* increment output string index
01:00206246 1600            	  6187: 	MOVE.b	d0,d3				* copy character to d3
01:00206248 C63C007F        	  6188: 	AND.b		#$7F,d3			* mask out top bit
01:0020624C 13831000        	  6189: 	MOVE.b	d3,(a1,d1.w)		* save to output string
01:00206250 532B05AC        	  6190: 	SUB.b		#1,numexp(a3)		* decrement # of characters before the dp
01:00206254 6608            	  6191: 	BNE.s		LAB_2A3B			* branch if still characters to do
                            	  6192: 
                            	  6193: 							* else output the point
01:00206256 5281            	  6194: 	ADDQ.l	#1,d1				* increment index
01:00206258 13BC002E1000    	  6195: 	MOVE.b	#'.',(a1,d1.w)		* save to output string
                            	  6196: LAB_2A3B
01:0020625E C03C0080        	  6197: 	AND.b		#$80,d0			* mask test sense bit
01:00206262 0A000080        	  6198: 	EORI.b	#$80,d0			* invert it
01:00206266 B43C001C        	  6199: 	CMP.b		#LAB_2A9B-LAB_2A9A,d2	* compare table index with max+4
01:0020626A 66B0            	  6200: 	BNE.s		LAB_29FB			* loop if not max
                            	  6201: 
                            	  6202: 							* now remove trailing zeroes
                            	  6203: LAB_2A4B
01:0020626C 10311000        	  6204: 	MOVE.b	(a1,d1.w),d0		* get character from output string
01:00206270 5381            	  6205: 	SUBQ.l	#1,d1				* decrement output string index
01:00206272 B03C0030        	  6206: 	CMP.b		#'0',d0			* compare with "0"
01:00206276 67F4            	  6207: 	BEQ.s		LAB_2A4B			* loop until non "0" character found
                            	  6208: 
01:00206278 B03C002E        	  6209: 	CMP.b		#'.',d0			* compare with "."
01:0020627C 6702            	  6210: 	BEQ.s		LAB_2A58			* branch if was dp
                            	  6211: 
                            	  6212: 							* else restore last character
01:0020627E 5281            	  6213: 	ADDQ.l	#1,d1				* increment output string index
                            	  6214: LAB_2A58
01:00206280 13BC002B1002    	  6215: 	MOVE.b	#'+',2(a1,d1.w)		* save character "+" to output string
01:00206286 4A2B05AD        	  6216: 	TST.b		expcnt(a3)			* test exponent count
01:0020628A 6738            	  6217: 	BEQ.s		LAB_2A8C			* if zero go set null terminator & exit
                            	  6218: 
                            	  6219: 							* exponent isn't zero so write exponent
01:0020628C 6A0A            	  6220: 	BPL.s		LAB_2A68			* branch if exponent count +ve
                            	  6221: 
01:0020628E 13BC002D1002    	  6222: 	MOVE.b	#'-',2(a1,d1.w)		* save character "-" to output string
01:00206294 442B05AD        	  6223: 	NEG.b		expcnt(a3)			* convert -ve to +ve
                            	  6224: LAB_2A68
01:00206298 13BC00451001    	  6225: 	MOVE.b	#'E',1(a1,d1.w)		* save character "E" to output string
01:0020629E 142B05AD        	  6226: 	MOVE.b	expcnt(a3),d2		* get exponent count
01:002062A2 702F            	  6227: 	MOVEQ		#$2F,d0			* one less than "0" character
                            	  6228: LAB_2A74
01:002062A4 5200            	  6229: 	ADDQ.b	#1,d0				* increment 10's character
01:002062A6 943C000A        	  6230: 	SUB.b		#$0A,d2			* subtract 10 from exponent count
01:002062AA 64F8            	  6231: 	BCC.s		LAB_2A74			* loop while still >= 0
                            	  6232: 
01:002062AC D43C003A        	  6233: 	ADD.b		#$3A,d2			* add character ":", $30+$0A, result is 10-value
01:002062B0 13801003        	  6234: 	MOVE.b	d0,3(a1,d1.w)		* save 10's character to output string
01:002062B4 13821004        	  6235: 	MOVE.b	d2,4(a1,d1.w)		* save 1's character to output string
01:002062B8 13BC00001005    	  6236: 	MOVE.b	#0,5(a1,d1.w)		* save null terminator after last character
01:002062BE 600A            	  6237: 	BRA.s		LAB_2A91			* go set string pointer (a0) and exit
                            	  6238: 
                            	  6239: LAB_2A89
01:002062C0 13801000        	  6240: 	MOVE.b	d0,(a1,d1.w)		* save last character to output string
                            	  6241: LAB_2A8C
01:002062C4 13BC00001001    	  6242: 	MOVE.b	#0,1(a1,d1.w)		* save null terminator after last character
                            	  6243: LAB_2A91
01:002062CA 2049            	  6244: 	MOVEA.l	a1,a0				* set result string pointer (a0)
01:002062CC 4E75            	  6245: 	RTS
                            	  6246: 
                            	  6247: 
                            	  6248: *************************************************************************************
                            	  6249: *
                            	  6250: * fast compare FAC1 with FAC2
                            	  6251: * assumes both are +ve and FAC2>0
                            	  6252: * returns d0=+1 C=0 if FAC1 > FAC2
                            	  6253: * returns d0= 0 C=0 if FAC1 = FAC2
                            	  6254: * returns d0=-1 C=1 if FAC1 < FAC2
                            	  6255: 
                            	  6256: LAB_27F0
01:002062CE 7000            	  6257: 	MOVEQ		#0,d0				* set for FAC1 = FAC2
01:002062D0 122B059C        	  6258: 	MOVE.b	FAC2_e(a3),d1		* get FAC2 exponent
01:002062D4 B22B0594        	  6259: 	CMP.b		FAC1_e(a3),d1		* compare FAC1 exponent with FAC2 exponent
01:002062D8 660A            	  6260: 	BNE.s		LAB_27F1			* branch if different
                            	  6261: 
01:002062DA 222B0598        	  6262: 	MOVE.l	FAC2_m(a3),d1		* get FAC2 mantissa
01:002062DE B2AB0590        	  6263: 	CMP.l		FAC1_m(a3),d1		* compare mantissas
01:002062E2 6708            	  6264: 	BEQ.s		LAB_27F3			* exit if mantissas equal
                            	  6265: 
                            	  6266: LAB_27F1
01:002062E4 6504            	  6267: 	BCS.s		LAB_27F2			* if FAC1 > FAC2 return d0=+1,C=0
                            	  6268: 
01:002062E6 5380            	  6269: 	SUBQ.l	#1,d0				* else FAC1 < FAC2 return d0=-1,C=1
01:002062E8 4E75            	  6270: 	RTS
                            	  6271: 
                            	  6272: LAB_27F2
01:002062EA 5280            	  6273: 	ADDQ.l	#1,d0
                            	  6274: LAB_27F3
01:002062EC 4E75            	  6275: 	RTS
                            	  6276: 
                            	  6277: 
                            	  6278: *************************************************************************************
                            	  6279: *
                            	  6280: * make FAC1 = 1
                            	  6281: 
                            	  6282: LAB_POON
01:002062EE 277C800000000590	  6283: 	MOVE.l	#$80000000,FAC1_m(a3)	* 1 mantissa
01:002062F6 377C81000594    	  6284: 	MOVE.w	#$8100,FAC1_e(a3)		* 1 exonent & sign
01:002062FC 4E75            	  6285: 	RTS
                            	  6286: 
                            	  6287: 
                            	  6288: *************************************************************************************
                            	  6289: *
                            	  6290: * make FAC1 = 0
                            	  6291: 
                            	  6292: LAB_POZE
01:002062FE 7000            	  6293: 	MOVEQ		#0,d0				* clear longword
01:00206300 27400590        	  6294: 	MOVE.l	d0,FAC1_m(a3)		* 0 mantissa
01:00206304 37400594        	  6295: 	MOVE.w	d0,FAC1_e(a3)		* 0 exonent & sign
01:00206308 4E75            	  6296: 	RTS
                            	  6297: 
                            	  6298: 
                            	  6299: *************************************************************************************
                            	  6300: *
                            	  6301: * perform power function
                            	  6302: * the number is in FAC2, the power is in FAC1
                            	  6303: * no longer trashes Itemp
                            	  6304: 
                            	  6305: LAB_POWER
01:0020630A 4A2B0594        	  6306: 	TST.b		FAC1_e(a3)			* test power
01:0020630E 67DE            	  6307: 	BEQ.s		LAB_POON			* if zero go return 1
                            	  6308: 
01:00206310 4A2B059C        	  6309: 	TST.b		FAC2_e(a3)			* test number
01:00206314 67E8            	  6310: 	BEQ.s		LAB_POZE			* if zero go return 0
                            	  6311: 
01:00206316 1F2B059D        	  6312: 	MOVE.b	FAC2_s(a3),-(sp)		* save number sign
01:0020631A 6A20            	  6313: 	BPL.s		LAB_POWP			* power of positive number
                            	  6314: 
01:0020631C 7200            	  6315: 	MOVEQ		#0,d1				* clear d1
01:0020631E 1741059D        	  6316: 	MOVE.b	d1,FAC2_s(a3)		* make sign +ve
                            	  6317: 
                            	  6318: 							* number sign was -ve and can only be raised to
                            	  6319: 							* an integer power which gives an x +j0 result,
                            	  6320: 							* else do 'function call' error
01:00206322 122B0594        	  6321: 	MOVE.b	FAC1_e(a3),d1		* get power exponent
01:00206326 927C0080        	  6322: 	SUB.w		#$80,d1			* normalise to .5
01:0020632A 6300E238        	  6323: 	BLS		LAB_FCER			* if 0<power<1 then do 'function call' error
                            	  6324: 
                            	  6325: 							* now shift all the integer bits out
01:0020632E 202B0590        	  6326: 	MOVE.l	FAC1_m(a3),d0		* get power mantissa
01:00206332 E3A0            	  6327: 	ASL.l		d1,d0				* shift mantissa
01:00206334 6600E22E        	  6328: 	BNE		LAB_FCER			* if power<>INT(power) then do 'function call'
                            	  6329: 							* error
                            	  6330: 
01:00206338 6502            	  6331: 	BCS.s		LAB_POWP			* if integer value odd then leave result -ve
                            	  6332: 
01:0020633A 1E80            	  6333: 	MOVE.b	d0,(sp)			* save result sign +ve
                            	  6334: LAB_POWP
01:0020633C 2F2B0590        	  6335: 	MOVE.l	FAC1_m(a3),-(sp)		* save power mantissa
01:00206340 3F2B0594        	  6336: 	MOVE.w	FAC1_e(a3),-(sp)		* save power sign & exponent
                            	  6337: 
01:00206344 6100FC78        	  6338: 	BSR		LAB_279B			* copy number to FAC1
01:00206348 6100F9E8        	  6339: 	BSR		LAB_LOG			* find log of number
                            	  6340: 
01:0020634C 301F            	  6341: 	MOVE.w	(sp)+,d0			* get power sign & exponent
01:0020634E 275F0598        	  6342: 	MOVE.l	(sp)+,FAC2_m(a3)		* get power mantissa
01:00206352 3740059C        	  6343: 	MOVE.w	d0,FAC2_e(a3)		* save sign & exponent to FAC2
01:00206356 1740059E        	  6344: 	MOVE.b	d0,FAC_sc(a3)		* save sign as sign compare
01:0020635A 102B0595        	  6345: 	MOVE.b	FAC1_s(a3),d0		* get FAC1 sign
01:0020635E B12B059E        	  6346: 	EOR.b		d0,FAC_sc(a3)		* make sign compare (FAC1_s EOR FAC2_s)
                            	  6347: 
01:00206362 6100FAC0        	  6348: 	BSR		LAB_MULTIPLY		* multiply by power
01:00206366 6158            	  6349: 	BSR.s		LAB_EXP			* find exponential
01:00206368 175F0595        	  6350: 	MOVE.b	(sp)+,FAC1_s(a3)		* restore number sign
01:0020636C 4E75            	  6351: 	RTS
                            	  6352: 
                            	  6353: 
                            	  6354: *************************************************************************************
                            	  6355: *
                            	  6356: * do - FAC1
                            	  6357: 
                            	  6358: LAB_GTHAN
01:0020636E 4A2B0594        	  6359: 	TST.b		FAC1_e(a3)			* test for non zero FAC1
01:00206372 6706            	  6360: 	BEQ.s		RTS_020			* branch if null
                            	  6361: 
01:00206374 0A2B00800595    	  6362: 	EORI.b	#$80,FAC1_s(a3)		* (else) toggle FAC1 sign bit
                            	  6363: RTS_020
01:0020637A 4E75            	  6364: 	RTS
                            	  6365: 
                            	  6366: 
                            	  6367: *************************************************************************************
                            	  6368: *
                            	  6369: 							* return +1
                            	  6370: LAB_EX1
01:0020637C 277C800000000590	  6371: 	MOVE.l	#$80000000,FAC1_m(a3)	* +1 mantissa
01:00206384 377C81000594    	  6372: 	MOVE.w	#$8100,FAC1_e(a3)		* +1 sign & exponent
01:0020638A 4E75            	  6373: 	RTS
                            	  6374: 							* do over/under flow
                            	  6375: LAB_EXOU
01:0020638C 4A2B0595        	  6376: 	TST.b		FAC1_s(a3)			* test sign
01:00206390 6A00E1CE        	  6377: 	BPL		LAB_OFER			* was +ve so do overflow error
                            	  6378: 
                            	  6379: 							* else underflow so return zero
01:00206394 7000            	  6380: 	MOVEQ		#0,d0				* clear longword
01:00206396 27400590        	  6381: 	MOVE.l	d0,FAC1_m(a3)		* 0 mantissa
01:0020639A 37400594        	  6382: 	MOVE.w	d0,FAC1_e(a3)		* 0 sign & exponent
01:0020639E 4E75            	  6383: 	RTS
                            	  6384: 							* fraction was zero so do 2^n
                            	  6385: LAB_EXOF
01:002063A0 277C800000000590	  6386: 	MOVE.l	#$80000000,FAC1_m(a3)	* +n mantissa
01:002063A8 177C00000595    	  6387: 	MOVE.b	#0,FAC1_s(a3)		* clear sign
01:002063AE 4A2B05B4        	  6388: 	TST.b		cosout(a3)			* test sign flag
01:002063B2 6A02            	  6389: 	BPL.s		LAB_EXOL			* branch if +ve
                            	  6390: 
01:002063B4 4481            	  6391: 	NEG.l		d1				* else do 1/2^n
                            	  6392: LAB_EXOL
01:002063B6 D23C0081        	  6393: 	ADD.b		#$81,d1			* adjust exponent
01:002063BA 17410594        	  6394: 	MOVE.b	d1,FAC1_e(a3)		* save exponent
01:002063BE 4E75            	  6395: 	RTS
                            	  6396: 
                            	  6397: * perform EXP()	(x^e)
                            	  6398: * valid input range is -88 to +88
                            	  6399: 
                            	  6400: LAB_EXP
01:002063C0 102B0594        	  6401: 	MOVE.b	FAC1_e(a3),d0		* get exponent
01:002063C4 67B6            	  6402: 	BEQ.s		LAB_EX1			* return 1 for zero in
                            	  6403: 
01:002063C6 B03C0064        	  6404: 	CMP.b		#$64,d0			* compare exponent with min
01:002063CA 65B0            	  6405: 	BCS.s		LAB_EX1			* if smaller just return 1
                            	  6406: 
                            	  6407: **	MOVEM.l	d1-d6/a0,-(sp)		* save the registers
01:002063CC 177C000005B4    	  6408: 	MOVE.b	#0,cosout(a3)		* flag +ve number
01:002063D2 222B0590        	  6409: 	MOVE.l	FAC1_m(a3),d1		* get mantissa
01:002063D6 B03C0087        	  6410: 	CMP.b		#$87,d0			* compare exponent with max
01:002063DA 62B0            	  6411: 	BHI.s		LAB_EXOU			* go do over/under flow if greater
                            	  6412: 
01:002063DC 6608            	  6413: 	BNE.s		LAB_EXCM			* branch if less
                            	  6414: 
                            	  6415: 							* else is 2^7
01:002063DE B2BCB00F33C7    	  6416: 	CMP.l		#$B00F33C7,d1		* compare mantissa with n*2^7 max
01:002063E4 64A6            	  6417: 	BCC.s		LAB_EXOU			* if => go over/underflow
                            	  6418: 
                            	  6419: LAB_EXCM
01:002063E6 4A2B0595        	  6420: 	TST.b		FAC1_s(a3)			* test sign
01:002063EA 6A0C            	  6421: 	BPL.s		LAB_EXPS			* branch if arg +ve
                            	  6422: 
01:002063EC 177C00FF05B4    	  6423: 	MOVE.b	#$FF,cosout(a3)		* flag -ve number
01:002063F2 177C00000595    	  6424: 	MOVE.b	#0,FAC1_s(a3)		* take absolute value
                            	  6425: LAB_EXPS
                            	  6426: 							* now do n/LOG(2)
01:002063F8 277CB8AA3B290598	  6427: 	MOVE.l	#$B8AA3B29,FAC2_m(a3)	* 1/LOG(2) mantissa
01:00206400 377C8100059C    	  6428: 	MOVE.w	#$8100,FAC2_e(a3)		* 1/LOG(2) exponent & sign
01:00206406 177C0000059E    	  6429: 	MOVE.b	#0,FAC_sc(a3)		* we know they're both +ve
01:0020640C 6100FA16        	  6430: 	BSR		LAB_MULTIPLY		* effectively divide by log(2)
                            	  6431: 
                            	  6432: 							* max here is +/- 127
                            	  6433: 							* now separate integer and fraction
01:00206410 177C000005D9    	  6434: 	MOVE.b	#0,tpower(a3)		* clear exponent add byte
01:00206416 1A2B0594        	  6435: 	MOVE.b	FAC1_e(a3),d5		* get exponent
01:0020641A 9A3C0080        	  6436: 	SUB.b		#$80,d5			* normalise
01:0020641E 6324            	  6437: 	BLS.s		LAB_ESML			* branch if < 1 (d5 is 0 or -ve)
                            	  6438: 
                            	  6439: 							* result is > 1
01:00206420 202B0590        	  6440: 	MOVE.l	FAC1_m(a3),d0		* get mantissa
01:00206424 2200            	  6441: 	MOVE.l	d0,d1				* copy it
01:00206426 2C05            	  6442: 	MOVE.l	d5,d6				* copy normalised exponent
                            	  6443: 
01:00206428 4446            	  6444: 	NEG.w		d6				* make -ve
01:0020642A DC7C0020        	  6445: 	ADD.w		#32,d6			* is now 32-d6
01:0020642E ECA9            	  6446: 	LSR.l		d6,d1				* just integer bits
01:00206430 174105D9        	  6447: 	MOVE.b	d1,tpower(a3)		* set exponent add byte
                            	  6448: 
01:00206434 EBA8            	  6449: 	LSL.l		d5,d0				* shift out integer bits
01:00206436 6700FF68        	  6450: 	BEQ		LAB_EXOF			* fraction is zero so do 2^n
                            	  6451: 
01:0020643A 27400590        	  6452: 	MOVE.l	d0,FAC1_m(a3)		* fraction to FAC1
01:0020643E 377C80000594    	  6453: 	MOVE.w	#$8000,FAC1_e(a3)		* set exponent & sign
                            	  6454: 
                            	  6455: 							* multiple was < 1
                            	  6456: LAB_ESML
01:00206444 277CB17217F80598	  6457: 	MOVE.l	#$B17217F8,FAC2_m(a3)	* LOG(2) mantissa
01:0020644C 377C8000059C    	  6458: 	MOVE.w	#$8000,FAC2_e(a3)		* LOG(2) exponent & sign
01:00206452 177C0000059E    	  6459: 	MOVE.b	#0,FAC_sc(a3)		* clear sign compare
01:00206458 6100F9CA        	  6460: 	BSR		LAB_MULTIPLY		* multiply by log(2)
                            	  6461: 
01:0020645C 202B0590        	  6462: 	MOVE.l	FAC1_m(a3),d0		* get mantissa
01:00206460 1A2B0594        	  6463: 	MOVE.b	FAC1_e(a3),d5		* get exponent
01:00206464 9A7C0082        	  6464: 	SUB.w		#$82,d5			* normalise and -2 (result is -1 to -30)
01:00206468 4445            	  6465: 	NEG.w		d5				* make +ve
01:0020646A EAA8            	  6466: 	LSR.l		d5,d0				* shift for 2 integer bits
                            	  6467: 
                            	  6468: * d0 = arg
                            	  6469: * d6 = x, d1 = y
                            	  6470: * d2 = x1, d3 = y1
                            	  6471: * d4 = shift count
                            	  6472: * d5 = loop count
                            	  6473: 							* now do cordic set-up
01:0020646C 7200            	  6474: 	MOVEQ		#0,d1				* y = 0
01:0020646E 2C3C26A3D110    	  6475: 	MOVE.l	#KFCTSEED,d6		* x = 1 with jkh inverse factored out
01:00206474 41FA0D20        	  6476: 	LEA		TAB_HTHET(pc),a0		* get pointer to hyperbolic arctan table
01:00206478 7800            	  6477: 	MOVEQ		#0,d4				* clear shift count
                            	  6478:  
                            	  6479: 							* cordic loop, shifts 4 and 13 (and 39
                            	  6480: 							* if it went that far) need to be repeated
01:0020647A 7A03            	  6481: 	MOVEQ		#3,d5				* 4 loops
01:0020647C 6136            	  6482: 	BSR.s		LAB_EXCC			* do loops 1 through 4
01:0020647E 5948            	  6483: 	SUBQ.w	#4,a0				* do table entry again
01:00206480 5384            	  6484: 	SUBQ.l	#1,d4				* do shift count again
01:00206482 7A09            	  6485: 	MOVEQ		#9,d5				* 10 loops
01:00206484 612E            	  6486: 	BSR.s		LAB_EXCC			* do loops 4 (again) through 13
01:00206486 5948            	  6487: 	SUBQ.w	#4,a0				* do table entry again
01:00206488 5384            	  6488: 	SUBQ.l	#1,d4				* do shift count again
01:0020648A 7A12            	  6489: 	MOVEQ		#18,d5			* 19 loops
01:0020648C 6126            	  6490: 	BSR.s		LAB_EXCC			* do loops 13 (again) through 31
                            	  6491:  
                            	  6492: 							* now get the result
01:0020648E 4A2B05B4        	  6493: 	TST.b		cosout(a3)			* test sign flag
01:00206492 6A06            	  6494: 	BPL.s		LAB_EXPL			* branch if +ve
                            	  6495: 
01:00206494 4481            	  6496: 	NEG.l		d1				* do -y
01:00206496 442B05D9        	  6497: 	NEG.b		tpower(a3)			* do -exp
                            	  6498: LAB_EXPL
01:0020649A 7083            	  6499: 	MOVEQ		#$83-$100,d0		* set exponent
01:0020649C DC81            	  6500: 	ADD.l		d1,d6				* y = y +/- x
01:0020649E 6B06            	  6501: 	BMI.s		LAB_EXRN			* branch if result normal
                            	  6502: 
                            	  6503: LAB_EXNN
01:002064A0 5380            	  6504: 	SUBQ.l	#1,d0				* decrement exponent
01:002064A2 DC86            	  6505: 	ADD.l		d6,d6				* shift mantissa
01:002064A4 6AFA            	  6506: 	BPL.s		LAB_EXNN			* loop if not normal
                            	  6507: 
                            	  6508: LAB_EXRN
01:002064A6 27460590        	  6509: 	MOVE.l	d6,FAC1_m(a3)		* save exponent result
01:002064AA D02B05D9        	  6510: 	ADD.b		tpower(a3),d0		* add integer part
01:002064AE 17400594        	  6511: 	MOVE.b	d0,FAC1_e(a3)		* save exponent
                            	  6512: **	MOVEM.l	(sp)+,d1-d6/a0		* restore registers
01:002064B2 4E75            	  6513: 	RTS
                            	  6514:  
                            	  6515: 							* cordic loop
                            	  6516: LAB_EXCC
01:002064B4 5284            	  6517: 	ADDQ.l	#1,d4				* increment shift count
01:002064B6 2406            	  6518: 	MOVE.l	d6,d2				* x1 = x
01:002064B8 E8A2            	  6519: 	ASR.l		d4,d2				* x1 >> n
01:002064BA 2601            	  6520: 	MOVE.l	d1,d3				* y1 = y
01:002064BC E8A3            	  6521: 	ASR.l		d4,d3				* y1 >> n
01:002064BE 4A80            	  6522: 	TST.l		d0				* test arg
01:002064C0 6B0C            	  6523: 	BMI.s		LAB_EXAD			* branch if -ve
                            	  6524: 
01:002064C2 D282            	  6525: 	ADD.l		d2,d1				* y = y + x1
01:002064C4 DC83            	  6526: 	ADD.l		d3,d6				* x = x + y1
01:002064C6 9098            	  6527: 	SUB.l		(a0)+,d0			* arg = arg - atnh(a0)
01:002064C8 51CDFFEA        	  6528: 	DBF		d5,LAB_EXCC			* decrement and loop if not done
                            	  6529: 
01:002064CC 4E75            	  6530: 	RTS
                            	  6531: 
                            	  6532: LAB_EXAD
01:002064CE 9282            	  6533: 	SUB.l		d2,d1				* y = y - x1
01:002064D0 9C83            	  6534: 	SUB.l		d3,d6				* x = x + y1
01:002064D2 D098            	  6535: 	ADD.l		(a0)+,d0			* arg = arg + atnh(a0)
01:002064D4 51CDFFDE        	  6536: 	DBF		d5,LAB_EXCC			* decrement and loop if not done
                            	  6537: 
01:002064D8 4E75            	  6538: 	RTS
                            	  6539: 
                            	  6540: 
                            	  6541: *************************************************************************************
                            	  6542: *
                            	  6543: * RND(n), 32 bit Galois version. make n=0 for 19th next number in sequence or n<>0
                            	  6544: * to get 19th next number in sequence after seed n. This version of the PRNG uses
                            	  6545: * the Galois method and a sample of 65536 bytes produced gives the following values.
                            	  6546: 
                            	  6547: * Entropy = 7.997442 bits per byte
                            	  6548: * Optimum compression would reduce these 65536 bytes by 0 percent
                            	  6549: 
                            	  6550: * Chi square distribution for 65536 samples is 232.01, and
                            	  6551: * randomly would exceed this value 75.00 percent of the time
                            	  6552: 
                            	  6553: * Arithmetic mean value of data bytes is 127.6724, 127.5 would be random
                            	  6554: * Monte Carlo value for Pi is 3.122871269, error 0.60 percent
                            	  6555: * Serial correlation coefficient is -0.000370, totally uncorrelated would be 0.0
                            	  6556: 
                            	  6557: LAB_RND
01:002064DA 4A2B0594        	  6558: 	TST.b		FAC1_e(a3)			* get FAC1 exponent
01:002064DE 6708            	  6559: 	BEQ.s		NextPRN			* do next random number if zero
                            	  6560: 
                            	  6561: 							* else get seed into random number store
01:002064E0 41EB05A0        	  6562: 	LEA		PRNlword(a3),a0		* set PRNG pointer
01:002064E4 6100FAB2        	  6563: 	BSR		LAB_2778			* pack FAC1 into (a0)
                            	  6564: NextPRN
01:002064E8 72AF            	  6565: 	MOVEQ		#$AF-$100,d1		* set EOR value
01:002064EA 7412            	  6566: 	MOVEQ		#18,d2			* do this 19 times
01:002064EC 202B05A0        	  6567: 	MOVE.l	PRNlword(a3),d0		* get current
                            	  6568: Ninc0
01:002064F0 D080            	  6569: 	ADD.l		d0,d0				* shift left 1 bit
01:002064F2 6402            	  6570: 	BCC.s		Ninc1				* branch if bit 32 not set
                            	  6571: 
01:002064F4 B300            	  6572: 	EOR.b		d1,d0				* do Galois LFSR feedback
                            	  6573: Ninc1
01:002064F6 51CAFFF8        	  6574: 	DBF		d2,Ninc0			* loop
                            	  6575: 
01:002064FA 274005A0        	  6576: 	MOVE.l	d0,PRNlword(a3)		* save back to seed word
01:002064FE 27400590        	  6577: 	MOVE.l	d0,FAC1_m(a3)		* copy to FAC1 mantissa
01:00206502 377C80000594    	  6578: 	MOVE.w	#$8000,FAC1_e(a3)		* set the exponent and clear the sign
01:00206508 6000F7F2        	  6579: 	BRA		LAB_24D5			* normalise FAC1 & return
                            	  6580: 
                            	  6581: 
                            	  6582: *************************************************************************************
                            	  6583: *
                            	  6584: * cordic TAN(x) routine, TAN(x) = SIN(x)/COS(x)
                            	  6585: * x = angle in radians
                            	  6586: 
                            	  6587: LAB_TAN
01:0020650C 6138            	  6588: 	BSR.s		LAB_SIN			* go do SIN/COS cordic compute
01:0020650E 376B0594059C    	  6589: 	MOVE.w	FAC1_e(a3),FAC2_e(a3)	* copy exponent & sign from FAC1 to FAC2
01:00206514 276B05900598    	  6590: 	MOVE.l	FAC1_m(a3),FAC2_m(a3)	* copy FAC1 mantissa to FAC2 mantissa
01:0020651A 27410590        	  6591: 	MOVE.l	d1,FAC1_m(a3)		* get COS(x) mantissa
01:0020651E 17430594        	  6592: 	MOVE.b	d3,FAC1_e(a3)		* get COS(x) exponent
01:00206522 6700E03C        	  6593: 	BEQ		LAB_OFER			* do overflow if COS = 0
                            	  6594: 
01:00206526 6100F7D4        	  6595: 	BSR		LAB_24D5			* normalise FAC1
01:0020652A 6000F984        	  6596: 	BRA		LAB_DIVIDE			* do FAC2/FAC1 and return, FAC_sc set by SIN
                            	  6597: 							* COS calculation
                            	  6598: 
                            	  6599: 
                            	  6600: *************************************************************************************
                            	  6601: *
                            	  6602: * cordic SIN(x), COS(x) routine
                            	  6603: * x = angle in radians
                            	  6604: 
                            	  6605: LAB_COS
01:0020652E 277CC90FDAA30598	  6606: 	MOVE.l	#$C90FDAA3,FAC2_m(a3)	* pi/2 mantissa (LSB is rounded up so
                            	  6607: 							* COS(PI/2)=0)
01:00206536 377C8100059C    	  6608: 	MOVE.w	#$8100,FAC2_e(a3)		* pi/2 exponent and sign
01:0020653C 176B0595059E    	  6609: 	MOVE.b	FAC1_s(a3),FAC_sc(a3)	* sign = FAC1 sign (b7)
01:00206542 6100F73E        	  6610: 	BSR		LAB_ADD			* add FAC2 to FAC1, adjust for COS(x)
                            	  6611: 
                            	  6612: 
                            	  6613: *************************************************************************************
                            	  6614: *
                            	  6615: * SIN/COS cordic calculator
                            	  6616: 
                            	  6617: LAB_SIN
01:00206546 177C000005B4    	  6618: 	MOVE.b	#0,cosout(a3)		* set needed result
                            	  6619: 
01:0020654C 277CA2F9836F0598	  6620: 	MOVE.l	#$A2F9836F,FAC2_m(a3)	* 1/pi mantissa (LSB is rounded up so SIN(PI)=0)
01:00206554 377C7F00059C    	  6621: 	MOVE.w	#$7F00,FAC2_e(a3)		* 1/pi exponent & sign
01:0020655A 176B0595059E    	  6622: 	MOVE.b	FAC1_s(a3),FAC_sc(a3)	* sign = FAC1 sign (b7)
01:00206560 6100F8C2        	  6623: 	BSR		LAB_MULTIPLY		* multiply by 1/pi
                            	  6624: 
01:00206564 102B0594        	  6625: 	MOVE.b	FAC1_e(a3),d0		* get FAC1 exponent
01:00206568 671C            	  6626: 	BEQ.s		LAB_SCZE			* branch if zero
                            	  6627: 
01:0020656A 41FA0B2A        	  6628: 	LEA		TAB_SNCO(pc),a0		* get pointer to constants table
01:0020656E 2C2B0590        	  6629: 	MOVE.l	FAC1_m(a3),d6		* get FAC1 mantissa
01:00206572 5300            	  6630: 	SUBQ.b	#1,d0				* 2 radians in 360 degrees so /2
01:00206574 6710            	  6631: 	BEQ.s		LAB_SCZE			* branch if zero
                            	  6632: 
01:00206576 903C0080        	  6633: 	SUB.b		#$80,d0			* normalise exponent
01:0020657A 6B18            	  6634: 	BMI.s		LAB_SCL0			* branch if < 1
                            	  6635: 
                            	  6636: 							* X is > 1
01:0020657C B03C0020        	  6637: 	CMP.b		#$20,d0			* is it >= 2^32
01:00206580 6404            	  6638: 	BCC.s		LAB_SCZE			* may as well do zero
                            	  6639: 
01:00206582 E1AE            	  6640: 	LSL.l		d0,d6				* shift out integer part bits
01:00206584 6618            	  6641: 	BNE.s		LAB_CORD			* if fraction go test quadrant and adjust
                            	  6642: 
                            	  6643: 							* else no fraction so do zero
                            	  6644: LAB_SCZE
01:00206586 7481            	  6645: 	MOVEQ		#$81-$100,d2		* set exponent for 1.0
01:00206588 7600            	  6646: 	MOVEQ		#0,d3				* set exponent for 0.0
01:0020658A 203C80000000    	  6647: 	MOVE.l	#$80000000,d0		* mantissa for 1.0
01:00206590 2203            	  6648: 	MOVE.l	d3,d1				* mantissa for 0.0
01:00206592 605C            	  6649: 	BRA.s		outloop			* go output it
                            	  6650: 
                            	  6651: 							* x is < 1
                            	  6652: LAB_SCL0
01:00206594 4400            	  6653: 	NEG.b		d0				* make +ve
01:00206596 B03C001E        	  6654: 	CMP.b		#$1E,d0			* is it <= 2^-30
01:0020659A 64EA            	  6655: 	BCC.s		LAB_SCZE			* may as well do zero
                            	  6656: 
01:0020659C E0AE            	  6657: 	LSR.l		d0,d6				* shift out <= 2^-32 bits
                            	  6658: 
                            	  6659: * cordic calculator, argument in d6
                            	  6660: * table pointer in a0, returns in d0-d3
                            	  6661: 
                            	  6662: LAB_CORD
01:0020659E 176B0595059E    	  6663: 	MOVE.b	FAC1_s(a3),FAC_sc(a3)	* copy as sign compare for TAN
01:002065A4 DC86            	  6664: 	ADD.l		d6,d6				* shift 0.5 bit into carry
01:002065A6 6404            	  6665: 	BCC.s		LAB_LTPF			* branch if less than 0.5
                            	  6666: 
01:002065A8 462B0595        	  6667: 	EORI.b	#$FF,FAC1_s(a3)		* toggle result sign
                            	  6668: LAB_LTPF
01:002065AC DC86            	  6669: 	ADD.l		d6,d6				* shift 0.25 bit into carry
01:002065AE 6408            	  6670: 	BCC.s		LAB_LTPT			* branch if less than 0.25
                            	  6671: 
01:002065B0 462B05B4        	  6672: 	EORI.b	#$FF,cosout(a3)		* toggle needed result
01:002065B4 462B059E        	  6673: 	EORI.b	#$FF,FAC_sc(a3)		* toggle sign compare for TAN
                            	  6674: 
                            	  6675: LAB_LTPT
01:002065B8 E48E            	  6676: 	LSR.l		#2,d6				* shift the bits back (clear integer bits)
01:002065BA 67CA            	  6677: 	BEQ.s		LAB_SCZE			* no fraction so go do zero
                            	  6678: 
                            	  6679: 							* set start values
01:002065BC 7A01            	  6680: 	MOVEQ		#1,d5				* set bit count
01:002065BE 2028FFFC        	  6681: 	MOVE.l	-4(a0),d0			* get multiply constant (1st itteration d0)
01:002065C2 2200            	  6682: 	MOVE.l	d0,d1				* 1st itteration d1
01:002065C4 9C98            	  6683: 	SUB.l		(a0)+,d6			* 1st always +ve so do 1st step
01:002065C6 6008            	  6684: 	BRA.s		mainloop			* jump into routine
                            	  6685: 
                            	  6686: subloop
01:002065C8 9C98            	  6687: 	SUB.l		(a0)+,d6			* z = z - arctan(i)/2pi
01:002065CA 9083            	  6688: 	SUB.l		d3,d0				* x = x - y1
01:002065CC D282            	  6689: 	ADD.l		d2,d1				* y = y + x1
01:002065CE 6012            	  6690: 	BRA.s		nexta				* back to main loop
                            	  6691: 
                            	  6692: mainloop
01:002065D0 2400            	  6693: 	MOVE.l	d0,d2				* x1 = x
01:002065D2 EAA2            	  6694: 	ASR.l		d5,d2				* / (2 ^ i)
01:002065D4 2601            	  6695: 	MOVE.l	d1,d3				* y1 = y
01:002065D6 EAA3            	  6696: 	ASR.l		d5,d3				* / (2 ^ i)
01:002065D8 4A86            	  6697: 	TST.l		d6				* test sign (is 2^0 bit)
01:002065DA 6AEC            	  6698: 	BPL.s		subloop			* go do subtract if > 1
                            	  6699: 
01:002065DC DC98            	  6700: 	ADD.l		(a0)+,d6			* z = z + arctan(i)/2pi
01:002065DE D083            	  6701: 	ADD.l		d3,d0				* x = x + y1
01:002065E0 9282            	  6702: 	SUB.l		d2,d1				* y = y + x1
                            	  6703: nexta
01:002065E2 5285            	  6704: 	ADDQ.l	#1,d5				* i = i + 1
01:002065E4 BABC0000001E    	  6705: 	CMP.l		#$1E,d5			* check end condition
01:002065EA 66E4            	  6706: 	BNE.s		mainloop			* loop if not all done
                            	  6707: 
                            	  6708: 							* now untangle output value
01:002065EC 7481            	  6709: 	MOVEQ		#$81-$100,d2		* set exponent for 0 to .99 rec.
01:002065EE 2602            	  6710: 	MOVE.l	d2,d3				* copy it for cos output
                            	  6711: outloop
01:002065F0 4A2B05B4        	  6712: 	TST.b		cosout(a3)			* did we want cos output?
01:002065F4 6B04            	  6713: 	BMI.s		subexit			* if so skip
                            	  6714: 
01:002065F6 C141            	  6715: 	EXG		d0,d1				* swap SIN and COS mantissas
01:002065F8 C543            	  6716: 	EXG		d2,d3				* swap SIN and COS exponents
                            	  6717: subexit
01:002065FA 27400590        	  6718: 	MOVE.l	d0,FAC1_m(a3)		* set result mantissa
01:002065FE 17420594        	  6719: 	MOVE.b	d2,FAC1_e(a3)		* set result exponent
01:00206602 6000F6F8        	  6720: 	BRA		LAB_24D5			* normalise FAC1 & return
                            	  6721: 
                            	  6722: 
                            	  6723: 
                            	  6724: *************************************************************************************
                            	  6725: *
                            	  6726: * perform ATN()
                            	  6727: 
                            	  6728: LAB_ATN
01:00206606 102B0594        	  6729: 	MOVE.b	FAC1_e(a3),d0		* get FAC1 exponent
01:0020660A 670000AA        	  6730: 	BEQ		RTS_021			* ATN(0) = 0 so skip calculation
                            	  6731: 
01:0020660E 177C000005B4    	  6732: 	MOVE.b	#0,cosout(a3)		* set result needed
01:00206614 B03C0081        	  6733: 	CMP.b		#$81,d0			* compare exponent with 1
01:00206618 6528            	  6734: 	BCS.s		LAB_ATLE			* branch if n<1
                            	  6735: 
01:0020661A 6608            	  6736: 	BNE.s		LAB_ATGO			* branch if n>1
                            	  6737: 
01:0020661C 202B0590        	  6738: 	MOVE.l	FAC1_m(a3),d0		* get mantissa
01:00206620 D080            	  6739: 	ADD.l		d0,d0				* shift left
01:00206622 671E            	  6740: 	BEQ.s		LAB_ATLE			* branch if n=1
                            	  6741: 
                            	  6742: LAB_ATGO
01:00206624 277C800000000598	  6743: 	MOVE.l	#$80000000,FAC2_m(a3)	* set mantissa for 1
01:0020662C 377C8100059C    	  6744: 	MOVE.w	#$8100,FAC2_e(a3)		* set exponent for 1
01:00206632 176B0595059E    	  6745: 	MOVE.b	FAC1_s(a3),FAC_sc(a3)	* sign compare = sign
01:00206638 6100F876        	  6746: 	BSR		LAB_DIVIDE			* do 1/n
01:0020663C 177C00FF05B4    	  6747: 	MOVE.b	#$FF,cosout(a3)		* set inverse result needed
                            	  6748: LAB_ATLE
01:00206642 202B0590        	  6749: 	MOVE.l	FAC1_m(a3),d0		* get FAC1 mantissa
01:00206646 7282            	  6750: 	MOVEQ		#-126,d1			* set to correct exponent
01:00206648 922B0594        	  6751: 	SUB.b		FAC1_e(a3),d1		* subtract FAC1 exponent (always <= 1)
01:0020664C E2A8            	  6752: 	LSR.l		d1,d0				* shift in two integer part bits
01:0020664E 41FA0AC6        	  6753: 	LEA		TAB_ATNC(pc),a0		* get pointer to arctan table
01:00206652 7C00            	  6754: 	MOVEQ		#0,d6				* Z = 0
01:00206654 223C40000000    	  6755: 	MOVE.l	#1<<30,d1			* y = 1
01:0020665A 7A1D            	  6756: 	MOVEQ		#29,d5			* loop 30 times
01:0020665C 7801            	  6757: 	MOVEQ		#1,d4				* shift counter
01:0020665E 6006            	  6758: 	BRA.s		LAB_ATCD			* enter loop
                            	  6759: 
                            	  6760: LAB_ATNP
01:00206660 E8A2            	  6761: 	ASR.l		d4,d2				* x1 / 2^i
01:00206662 D282            	  6762: 	ADD.l		d2,d1				* y = y + x1
01:00206664 DC90            	  6763: 	ADD.l		(a0),d6			* z = z + atn(i)
                            	  6764: LAB_ATCD
01:00206666 2400            	  6765: 	MOVE.l	d0,d2				* x1 = x
01:00206668 2601            	  6766: 	MOVE.l	d1,d3				* y1 = y
01:0020666A E8A3            	  6767: 	ASR.l		d4,d3				* y1 / 2^i
                            	  6768: LAB_CATN
01:0020666C 9083            	  6769: 	SUB.l		d3,d0				* x = x - y1
01:0020666E 6AF0            	  6770: 	BPL.s		LAB_ATNP			* branch if x >= 0
                            	  6771: 
01:00206670 2002            	  6772: 	MOVE.l	d2,d0				* else get x back
01:00206672 5848            	  6773: 	ADDQ.w	#4,a0				* increment pointer
01:00206674 5284            	  6774: 	ADDQ.l	#1,d4				* increment i
01:00206676 E283            	  6775: 	ASR.l		#1,d3				* y1 / 2^i
01:00206678 51CDFFF2        	  6776: 	DBF		d5,LAB_CATN			* decrement and loop if not done
                            	  6777: 
01:0020667C 177C00820594    	  6778: 	MOVE.b	#$82,FAC1_e(a3)		* set new exponent
01:00206682 27460590        	  6779: 	MOVE.l	d6,FAC1_m(a3)		* save mantissa
01:00206686 6100F674        	  6780: 	BSR		LAB_24D5			* normalise FAC1
                            	  6781: 
01:0020668A 4A2B05B4        	  6782: 	TST.b		cosout(a3)			* was it > 1 ?
01:0020668E 6A26            	  6783: 	BPL.s		RTS_021			* branch if not
                            	  6784: 
01:00206690 1E2B0595        	  6785: 	MOVE.b	FAC1_s(a3),d7		* get sign
01:00206694 177C00000595    	  6786: 	MOVE.b	#0,FAC1_s(a3)		* clear sign
01:0020669A 277CC90FDAA20598	  6787: 	MOVE.l	#$C90FDAA2,FAC2_m(a3)	* set -(pi/2)
01:002066A2 377C8180059C    	  6788: 	MOVE.w	#$8180,FAC2_e(a3)		* set exponent and sign
01:002066A8 177C00FF059E    	  6789: 	MOVE.b	#$FF,FAC_sc(a3)		* set sign compare
01:002066AE 6100F5D2        	  6790: 	BSR		LAB_ADD			* perform addition, FAC2 to FAC1
01:002066B2 17470595        	  6791: 	MOVE.b	d7,FAC1_s(a3)		* restore sign
                            	  6792: RTS_021
01:002066B6 4E75            	  6793: 	RTS
                            	  6794: 
                            	  6795: 
                            	  6796: *************************************************************************************
                            	  6797: *
                            	  6798: * perform BITSET
                            	  6799: 
                            	  6800: LAB_BITSET
01:002066B8 6100F4A8        	  6801: 	BSR		LAB_GADB			* get two parameters for POKE or WAIT
                            	  6802: 							* first parameter in a0, second in d0
01:002066BC B03C0008        	  6803: 	CMP.b		#$08,d0			* only 0 to 7 are allowed
01:002066C0 6400DEA2        	  6804: 	BCC		LAB_FCER			* branch if > 7
                            	  6805: 
01:002066C4 01D0            	  6806: 	BSET		d0,(a0)			* set bit
01:002066C6 4E75            	  6807: 	RTS
                            	  6808: 
                            	  6809: 
                            	  6810: *************************************************************************************
                            	  6811: *
                            	  6812: * perform BITCLR
                            	  6813: 
                            	  6814: LAB_BITCLR
01:002066C8 6100F498        	  6815: 	BSR		LAB_GADB			* get two parameters for POKE or WAIT
                            	  6816: 							* first parameter in a0, second in d0
01:002066CC B03C0008        	  6817: 	CMP.b		#$08,d0			* only 0 to 7 are allowed
01:002066D0 6400DE92        	  6818: 	BCC		LAB_FCER			* branch if > 7
                            	  6819: 
01:002066D4 0190            	  6820: 	BCLR		d0,(a0)			* clear bit
01:002066D6 4E75            	  6821: 	RTS
                            	  6822: 
                            	  6823: 
                            	  6824: *************************************************************************************
                            	  6825: *
                            	  6826: * perform BITTST()
                            	  6827: 
                            	  6828: LAB_BTST
01:002066D8 101D            	  6829: 	MOVE.b	(a5)+,d0			* increment BASIC pointer
01:002066DA 6100F486        	  6830: 	BSR		LAB_GADB			* get two parameters for POKE or WAIT
                            	  6831: 							* first parameter in a0, second in d0
01:002066DE B03C0008        	  6832: 	CMP.b		#$08,d0			* only 0 to 7 are allowed
01:002066E2 6400DE80        	  6833: 	BCC		LAB_FCER			* branch if > 7
                            	  6834: 
01:002066E6 2200            	  6835: 	MOVE.l	d0,d1				* copy bit # to test
01:002066E8 6100EAC4        	  6836: 	BSR		LAB_GBYT			* get next BASIC byte
01:002066EC B03C0029        	  6837: 	CMP.b		#')',d0			* is next character ")"
01:002066F0 6600DE7E        	  6838: 	BNE		LAB_SNER			* if not ")" go do syntax error, then warm start
                            	  6839: 
01:002066F4 6100EAB6        	  6840: 	BSR		LAB_IGBY			* update execute pointer (to character past ")")
01:002066F8 7000            	  6841: 	MOVEQ		#0,d0				* set the result as zero
01:002066FA 0310            	  6842: 	BTST		d1,(a0)			* test bit
01:002066FC 6700F914        	  6843: 	BEQ		LAB_27DB			* branch if zero (already correct)
                            	  6844: 
01:00206700 70FF            	  6845: 	MOVEQ		#-1,d0			* set for -1 result
01:00206702 6000F90E        	  6846: 	BRA		LAB_27DB			* go do SGN tail
                            	  6847: 
                            	  6848: 
                            	  6849: *************************************************************************************
                            	  6850: *
                            	  6851: * perform USING$()
                            	  6852: 
                            	  6853: fsd	EQU	 0					*   (sp) format string descriptor pointer
                            	  6854: fsti	EQU	 4					*  4(sp) format string this index
                            	  6855: fsli	EQU	 6					*  6(sp) format string last index
                            	  6856: fsdpi	EQU	 8					*  8(sp) format string decimal point index
                            	  6857: fsdc	EQU	10					* 10(sp) format string decimal characters
                            	  6858: fend	EQU	12-4					*  x(sp) end-4, fsd is popped by itself
                            	  6859: 
                            	  6860: ofchr	EQU	'#'					* the overflow character
                            	  6861: 
                            	  6862: LAB_USINGS
01:00206706 4A2B05B5        	  6863: 	TST.b		Dtypef(a3)			* test data type, $80=string
01:0020670A 6A00DE10        	  6864: 	BPL		LAB_FOER			* if not string type go do format error
                            	  6865: 
01:0020670E 246B0590        	  6866: 	MOVEA.l	FAC1_m(a3),a2		* get the format string descriptor pointer
01:00206712 3E2A0004        	  6867: 	MOVE.w	4(a2),d7			* get the format string length
01:00206716 6700DE04        	  6868: 	BEQ		LAB_FOER			* if null string go do format error
                            	  6869: 
                            	  6870: * clear the format string values
                            	  6871: 
01:0020671A 7000            	  6872: 	MOVEQ		#0,d0				* clear d0
01:0020671C 3F00            	  6873: 	MOVE.w	d0,-(sp)			* clear the format string decimal characters
01:0020671E 3F00            	  6874: 	MOVE.w	d0,-(sp)			* clear the format string decimal point index
01:00206720 3F00            	  6875: 	MOVE.w	d0,-(sp)			* clear the format string last index
01:00206722 3F00            	  6876: 	MOVE.w	d0,-(sp)			* clear the format string this index
01:00206724 2F0A            	  6877: 	MOVE.l	a2,-(sp)			* save the format string descriptor pointer
                            	  6878: 
                            	  6879: * make a null return string for the first string add
                            	  6880: 
01:00206726 7200            	  6881: 	MOVEQ		#0,d1				* make a null string
01:00206728 2041            	  6882: 	MOVEA.l	d1,a0				* with a null pointer
01:0020672A 6100F0DA        	  6883: 	BSR		LAB_RTST			* push a string on the descriptor stack
                            	  6884: 							* a0 = pointer, d1 = length
                            	  6885: 
                            	  6886: * do the USING$() function next value
                            	  6887: 
01:0020672E 101D            	  6888: 	MOVE.b	(a5)+,d0			* get the next BASIC byte
                            	  6889: LAB_U002
01:00206730 B03C002C        	  6890: 	CMP.b		#',',d0			* compare with comma
01:00206734 6600DE3A        	  6891: 	BNE		LAB_SNER			* if not "," go do syntax error
                            	  6892: 
01:00206738 6100028C        	  6893: 	BSR		LAB_ProcFo			* process the format string
01:0020673C 4A02            	  6894: 	TST.b		d2				* test the special characters flag
01:0020673E 6700DDDC        	  6895: 	BEQ		LAB_FOER			* if no special characters go do format error
                            	  6896: 
01:00206742 6100E908        	  6897: 	BSR		LAB_EVEX			* evaluate the expression
01:00206746 4A2B05B5        	  6898: 	TST.b		Dtypef(a3)			* test the data type
01:0020674A 6B00DDF8        	  6899: 	BMI		LAB_TMER			* if string type go do type missmatch error
                            	  6900: 
01:0020674E 4A2B0594        	  6901: 	TST.b		FAC1_e(a3)			* test FAC1 exponent
01:00206752 6732            	  6902: 	BEQ.s		LAB_U004			* if FAC1 = 0 skip the rounding
                            	  6903: 
01:00206754 322F000A        	  6904: 	MOVE.w	fsdc(sp),d1			* get the format string decimal character count
01:00206758 B27C0008        	  6905: 	CMP.w		#8,d1				* compare the fraction digit count with 8
01:0020675C 6428            	  6906: 	BCC.s		LAB_U004			* if >= 8 skip the rounding
                            	  6907: 
01:0020675E 3001            	  6908: 	MOVE.w	d1,d0				* else copy the fraction digit count
01:00206760 D241            	  6909: 	ADD.w		d1,d1				* * 2
01:00206762 D240            	  6910: 	ADD.w		d0,d1				* * 3
01:00206764 D241            	  6911: 	ADD.w		d1,d1				* * 6
01:00206766 41FA0840        	  6912: 	LEA		LAB_P_10(pc),a0		* get the rounding table base
01:0020676A 277010020598    	  6913: 	MOVE.l	2(a0,d1.w),FAC2_m(a3)	* get the rounding mantissa
01:00206770 30301000        	  6914: 	MOVE.w	(a0,d1.w),d0		* get the rounding exponent
01:00206774 907C0100        	  6915: 	SUB.w		#$100,d0			* effectively divide the mantissa by 2
01:00206778 3740059C        	  6916: 	MOVE.w	d0,FAC2_e(a3)		* save the rounding exponent
01:0020677C 177C0000059E    	  6917: 	MOVE.b	#$00,FAC_sc(a3)		* clear the sign compare
01:00206782 6100F4FE        	  6918: 	BSR		LAB_ADD			* round the value to n places
                            	  6919: LAB_U004
01:00206786 6100F976        	  6920: 	BSR		LAB_2970			* convert FAC1 to string - not on stack
                            	  6921: 
01:0020678A 610001FC        	  6922: 	BSR		LAB_DupFmt			* duplicate the processed format string section
                            	  6923: 							* returns length in d1, pointer in a0
                            	  6924: 
                            	  6925: * process the number string, length in d6, decimal point index in d2
                            	  6926: 
01:0020678E 45EB05C6        	  6927: 	LEA		Decss(a3),a2		* set the number string start
01:00206792 7C00            	  6928: 	MOVEQ		#0,d6				* clear the number string index
01:00206794 782E            	  6929: 	MOVEQ		#'.',d4			* set the decimal point character
                            	  6930: LAB_U005
01:00206796 3406            	  6931: 	MOVE.w	d6,d2				* save the index to flag the decimal point
                            	  6932: LAB_U006
01:00206798 5246            	  6933: 	ADDQ.w	#1,d6				* increment the number string index
01:0020679A 10326000        	  6934: 	MOVE.b	(a2,d6.w),d0		* get a number string character
01:0020679E 677A            	  6935: 	BEQ.s		LAB_U010			* if null then number complete
                            	  6936: 
01:002067A0 B03C0045        	  6937: 	CMP.b		#'E',d0			* compare the character with an "E"
01:002067A4 6706            	  6938: 	BEQ.s		LAB_U008			* was sx[.x]Esxx so go handle sci notation
                            	  6939: 
01:002067A6 B004            	  6940: 	CMP.b		d4,d0				* compare the character with "."
01:002067A8 66EE            	  6941: 	BNE.s		LAB_U006			* if not decimal point go get the next digit
                            	  6942: 
01:002067AA 60EA            	  6943: 	BRA.s		LAB_U005			* go save the index and get the next digit
                            	  6944: 
                            	  6945: * have found an sx[.x]Esxx number, the [.x] will not be present for a single digit
                            	  6946: 
                            	  6947: LAB_U008
01:002067AC 3606            	  6948: 	MOVE.w	d6,d3				* copy the index to the "E"
01:002067AE 5343            	  6949: 	SUBQ.w	#1,d3				* -1 gives the last digit index
                            	  6950: 
01:002067B0 5246            	  6951: 	ADDQ.w	#1,d6				* increment the index to the exponent sign
01:002067B2 10326000        	  6952: 	MOVE.b	(a2,d6.w),d0		* get the exponent sign character
01:002067B6 B03C002D        	  6953: 	CMP.b		#'-',d0			* compare the exponent sign with "-"
01:002067BA 6600DDA8        	  6954: 	BNE		LAB_FCER			* if it wasn't sx[.x]E-xx go do function
                            	  6955: 							* call error
                            	  6956: 
                            	  6957: * found an sx[.x]E-xx number so check the exponent magnitude
                            	  6958: 
01:002067BE 5246            	  6959: 	ADDQ.w	#1,d6				* increment the index to the exponent 10s
01:002067C0 10326000        	  6960: 	MOVE.b	(a2,d6.w),d0		* get the exponent 10s character
01:002067C4 B03C0030        	  6961: 	CMP.b		#'0',d0			* compare the exponent 10s with "0"
01:002067C8 6704            	  6962: 	BEQ.s		LAB_U009			* if it was sx[.x]E-0x go get the exponent
                            	  6963: 							* 1s character
                            	  6964: 
01:002067CA 700A            	  6965: 	MOVEQ		#10,d0			* else start writing at index 10
01:002067CC 6008            	  6966: 	BRA.s		LAB_U00A			* go copy the digits
                            	  6967: 
                            	  6968: * found an sx[.x]E-0x number so get the exponent magnitude
                            	  6969: 
                            	  6970: LAB_U009
01:002067CE 5246            	  6971: 	ADDQ.w	#1,d6				* increment the index to the exponent 1s
01:002067D0 700F            	  6972: 	MOVEQ		#$0F,d0			* set the mask for the exponent 1s digit
01:002067D2 C0326000        	  6973: 	AND.b		(a2,d6.w),d0		* get and convert the exponent 1s digit
                            	  6974: LAB_U00A
01:002067D6 3403            	  6975: 	MOVE.w	d3,d2				* copy the number last digit index
01:002067D8 0C420001        	  6976: 	CMPI.w	#1,d2				* is the number of the form sxE-0x
01:002067DC 6602            	  6977: 	BNE.s		LAB_U00B			* if it is sx.xE-0x skip the increment
                            	  6978: 
                            	  6979: 							* else make room for the decimal point
01:002067DE 5242            	  6980: 	ADDQ.w	#1,d2				* add 1 to the write index
                            	  6981: LAB_U00B
01:002067E0 D440            	  6982: 	ADD.w		d0,d2				* add the exponent 1s to the write index
01:002067E2 700A            	  6983: 	MOVEQ		#10,d0			* set the maximum write index
01:002067E4 9042            	  6984: 	SUB.w		d2,d0				* compare the index with the maximum
01:002067E6 6E0C            	  6985: 	BGT.s		LAB_U00C			* if the index < the maximum continue
                            	  6986: 
01:002067E8 D440            	  6987: 	ADD.w		d0,d2				* else set the index to the maximum
01:002067EA D640            	  6988: 	ADD.w		d0,d3				* adjust the read index
01:002067EC 0C430001        	  6989: 	CMPI.w	#1,d3				* compare the adjusted index with 1
01:002067F0 6E02            	  6990: 	BGT.s		LAB_U00C			* if > 1 continue
                            	  6991: 
01:002067F2 7600            	  6992: 	MOVEQ		#0,d3				* else allow for the decimal point
                            	  6993: LAB_U00C
01:002067F4 3C02            	  6994: 	MOVE.w		d2,d6				* copy the write index as the number
                            	  6995: 							* string length
01:002067F6 7000            	  6996: 	MOVEQ		#0,d0				* clear d0 to null terminate the number
                            	  6997: 							* string
                            	  6998: LAB_U00D
01:002067F8 15802000        	  6999: 	MOVE.b	d0,(a2,d2.w)		* save the character to the number string
01:002067FC 5342            	  7000: 	SUBQ.w	#1,d2				* decrement the number write index
01:002067FE 0C420001        	  7001: 	CMPI.w	#1,d2				* compare the number write index with 1
01:00206802 6712            	  7002: 	BEQ.s		LAB_U00F			* if at the decimal point go save it
                            	  7003: 
                            	  7004: 							* else write a digit to the number string
01:00206804 7030            	  7005: 	MOVEQ		#'0',d0			* default to "0"
01:00206806 4A43            	  7006: 	TST.w		d3				* test the number read index
01:00206808 67EE            	  7007: 	BEQ.s		LAB_U00D			* if zero just go save the "0"
                            	  7008: 
                            	  7009: LAB_U00E
01:0020680A 10323000        	  7010: 	MOVE.b	(a2,d3.w),d0		* read the next number digit
01:0020680E 5343            	  7011: 	SUBQ.w	#1,d3				* decrement the read index
01:00206810 B004            	  7012: 	CMP.b		d4,d0				* compare the digit with "."
01:00206812 66E4            	  7013: 	BNE.s		LAB_U00D			* if not "." go save the digit
                            	  7014: 
01:00206814 60F4            	  7015: 	BRA.s		LAB_U00E			* else go get the next digit
                            	  7016: 
                            	  7017: LAB_U00F
01:00206816 15842000        	  7018: 	MOVE.b	d4,(a2,d2.w)		* save the decimal point
                            	  7019: LAB_U010
01:0020681A 4A42            	  7020: 	TST.w		d2				* test the number string decimal point index
01:0020681C 6602            	  7021: 	BNE.s		LAB_U014			* if dp present skip the reset
                            	  7022: 
01:0020681E 3406            	  7023: 	MOVE.w	d6,d2				* make the decimal point index = the length
                            	  7024: 
                            	  7025: * copy the fractional digit characters from the number string
                            	  7026: 
                            	  7027: LAB_U014
01:00206820 3602            	  7028: 	MOVE.w	d2,d3				* copy the number string decimal point index
01:00206822 5243            	  7029: 	ADDQ.w	#1,d3				* increment the number string index
01:00206824 382F0008        	  7030: 	MOVE.w	fsdpi(sp),d4		* get the new format string decimal point index
                            	  7031: LAB_U018
01:00206828 5244            	  7032: 	ADDQ.w	#1,d4				* increment the new format string index
01:0020682A B244            	  7033: 	CMP.w		d4,d1				* compare it with the new format string length
01:0020682C 6322            	  7034: 	BLS.s		LAB_U022			* if done the fraction digits go do integer
                            	  7035: 
01:0020682E 10304000        	  7036: 	MOVE.b	(a0,d4.w),d0		* get a new format string character
01:00206832 B03C0025        	  7037: 	CMP.b		#'%',d0			* compare it with "%"
01:00206836 6706            	  7038: 	BEQ.s		LAB_U01C			* if "%" go copy a number character
                            	  7039: 
01:00206838 B03C0023        	  7040: 	CMP.b		#'#',d0			* compare it with "#"
01:0020683C 66EA            	  7041: 	BNE.s		LAB_U018			* if not "#" go do the next new format character
                            	  7042: 
                            	  7043: LAB_U01C
01:0020683E 7030            	  7044: 	MOVEQ		#'0',d0			* default to "0" character
01:00206840 BC43            	  7045: 	CMP.w		d3,d6				* compare the number string index with length
01:00206842 6306            	  7046: 	BLS.s		LAB_U020			* if there skip the character get
                            	  7047: 
01:00206844 10323000        	  7048: 	MOVE.b	(a2,d3.w),d0		* get a character from the number string
01:00206848 5243            	  7049: 	ADDQ.w	#1,d3				* increment the number string index
                            	  7050: LAB_U020
01:0020684A 11804000        	  7051: 	MOVE.b	d0,(a0,d4.w)		* save the number character to the new format
                            	  7052: 							* string
01:0020684E 60D8            	  7053: 	BRA.s		LAB_U018			* go do the next new format character
                            	  7054: 
                            	  7055: * now copy the integer digit characters from the number string
                            	  7056: 
                            	  7057: LAB_U022
01:00206850 7C00            	  7058: 	MOVEQ		#0,d6				* clear the sign done flag
01:00206852 7A00            	  7059: 	MOVEQ		#0,d5				* clear the sign present flag
01:00206854 5342            	  7060: 	SUBQ.w	#1,d2				* decrement the number string index
01:00206856 6608            	  7061: 	BNE.s		LAB_U026			* if not now at sign continue
                            	  7062: 
01:00206858 7401            	  7063: 	MOVEQ		#1,d2				* increment the number string index
01:0020685A 15BC00302000    	  7064: 	MOVE.b	#'0',(a2,d2.w)		* replace the point with a zero
                            	  7065: LAB_U026
01:00206860 382F0008        	  7066: 	MOVE.w	fsdpi(sp),d4		* get the new format string decimal point index
01:00206864 B244            	  7067: 	CMP.w		d4,d1				* compare it with the new format string length
01:00206866 6402            	  7068: 	BCC.s		LAB_U02A			* if within the string go use the index
                            	  7069: 
01:00206868 3801            	  7070: 	MOVE.w	d1,d4				* else set the index to the end of the string
                            	  7071: LAB_U02A
01:0020686A 5344            	  7072: 	SUBQ.w	#1,d4				* decrement the new format string index
01:0020686C 6B62            	  7073: 	BMI.s		LAB_U03E			* if all done go test for any overflow
                            	  7074: 
01:0020686E 10304000        	  7075: 	MOVE.b	(a0,d4.w),d0		* else get a new format string character
                            	  7076: 
01:00206872 7E30            	  7077: 	MOVEQ		#'0',d7			* default to "0" character
01:00206874 B03C0025        	  7078: 	CMP.b		#'%',d0			* compare it with "%"
01:00206878 6708            	  7079: 	BEQ.s		LAB_U02B			* if "%" go copy a number character
                            	  7080: 
01:0020687A 7E20            	  7081: 	MOVEQ		#' ',d7			* default to " " character
01:0020687C B03C0023        	  7082: 	CMP.b		#'#',d0			* compare it with "#"
01:00206880 6606            	  7083: 	BNE.s		LAB_U02C			* if not "#" go try ","
                            	  7084: 
                            	  7085: LAB_U02B
01:00206882 4A42            	  7086: 	TST.w		d2				* test the number string index
01:00206884 6634            	  7087: 	BNE.s		LAB_U036			* if not at the sign go get a number character
                            	  7088: 
01:00206886 6042            	  7089: 	BRA.s		LAB_U03C			* else go save the default character
                            	  7090: 
                            	  7091: LAB_U02C
01:00206888 B03C002C        	  7092: 	CMP.b		#',',d0			* compare it with ","
01:0020688C 6610            	  7093: 	BNE.s		LAB_U030			* if not "," go try the sign characters
                            	  7094: 
01:0020688E 4A42            	  7095: 	TST.w		d2				* test the number string index
01:00206890 6608            	  7096: 	BNE.s		LAB_U02E			* if not at the sign keep the ","
                            	  7097: 
01:00206892 0C30002540FF    	  7098: 	CMP.b		#'%',-1(a0,d4.w)		* else compare the next format string character
                            	  7099: 							* with "%"
01:00206898 6630            	  7100: 	BNE.s		LAB_U03C			* if not "%" keep the default character
                            	  7101: 
                            	  7102: LAB_U02E
01:0020689A 1E00            	  7103: 	MOVE.b	d0,d7				* else use the "," character
01:0020689C 602C            	  7104: 	BRA.s		LAB_U03C			* go save the character to the string
                            	  7105: 
                            	  7106: LAB_U030
01:0020689E B03C002D        	  7107: 	CMP.b		#'-',d0			* compare it with "-"
01:002068A2 6710            	  7108: 	BEQ.s		LAB_U034			* if "-" go do the sign character
                            	  7109: 
01:002068A4 B03C002B        	  7110: 	CMP.b		#'+',d0			* compare it with "+"
01:002068A8 66C0            	  7111: 	BNE.s		LAB_U02A			* if not "+" go do the next new format character
                            	  7112: 
01:002068AA 0C12002D        	  7113: 	CMP.b		#'-',(a2)			* compare the sign character with "-"
01:002068AE 6704            	  7114: 	BEQ.s		LAB_U034			* if "-" don't change the sign character
                            	  7115: 
01:002068B0 14BC002B        	  7116: 	MOVE.b	#'+',(a2)			* else make the sign character "+"
                            	  7117: LAB_U034
01:002068B4 1A00            	  7118: 	MOVE.b	d0,d5				* set the sign present flag
01:002068B6 4A42            	  7119: 	TST.w		d2				* test the number string index
01:002068B8 6708            	  7120: 	BEQ.s		LAB_U038			* if at the sign keep the default character
                            	  7121: 
                            	  7122: LAB_U036
01:002068BA 1E322000        	  7123: 	MOVE.b	(a2,d2.w),d7		* else get a character from the number string
01:002068BE 5342            	  7124: 	SUBQ.w	#1,d2				* decrement the number string index
01:002068C0 6008            	  7125: 	BRA.s		LAB_U03C			* go save the character
                            	  7126: 
                            	  7127: LAB_U038
01:002068C2 4A06            	  7128: 	TST.b		d6				* test the sign done flag
01:002068C4 6604            	  7129: 	BNE.s		LAB_U03C			* if the sign has been done go use the space
                            	  7130: 							* character
                            	  7131: 
01:002068C6 1E12            	  7132: 	MOVE.b	(a2),d7			* else get the sign character
01:002068C8 1C07            	  7133: 	MOVE.b	d7,d6				* flag that the sign has been done
                            	  7134: LAB_U03C
01:002068CA 11874000        	  7135: 	MOVE.b	d7,(a0,d4.w)		* save the number character to the new format
                            	  7136: 							* string
01:002068CE 609A            	  7137: 	BRA.s		LAB_U02A			* go do the next new format character
                            	  7138: 
                            	  7139: * test for overflow conditions
                            	  7140: 
                            	  7141: LAB_U03E
01:002068D0 4A42            	  7142: 	TST.w		d2				* test the number string index
01:002068D2 6614            	  7143: 	BNE.s		LAB_U040			* if all the digits aren't done go output
                            	  7144: 							* an overflow indication
                            	  7145: 
                            	  7146: * test for sign overflows
                            	  7147: 
01:002068D4 4A05            	  7148: 	TST.b		d5				* test the sign present flag
01:002068D6 6754            	  7149: 	BEQ.s		LAB_U04A			* if no sign present go add the string
                            	  7150: 
                            	  7151: * there was a sign in the format string
                            	  7152: 
01:002068D8 4A06            	  7153: 	TST.b		d6				* test the sign done flag
01:002068DA 6650            	  7154: 	BNE.s		LAB_U04A			* if the sign is done go add the string
                            	  7155: 
                            	  7156: * the sign isn't done so see if it was mandatory
                            	  7157: 
01:002068DC 0C05002B        	  7158: 	CMPI.b	#'+',d5			* compare the sign with "+"
01:002068E0 6706            	  7159: 	BEQ.s		LAB_U040			* if it was "+" go output an overflow
                            	  7160: 							* indication
                            	  7161: 
                            	  7162: * the sign wasn't mandatory but the number may have been negative
                            	  7163: 
01:002068E2 0C12002D        	  7164: 	CMP.b		#'-',(a2)			* compare the sign character with "-"
01:002068E6 6644            	  7165: 	BNE.s		LAB_U04A			* if it wasn't "-" go add the string
                            	  7166: 
                            	  7167: * else the sign was "-" and a sign hasn't been output so ..
                            	  7168: 
                            	  7169: * the number overflowed the format string so replace all the special format characters
                            	  7170: * with the overflow character
                            	  7171: 
                            	  7172: LAB_U040
01:002068E8 7A23            	  7173: 	MOVEQ		#ofchr,d5			* set the overflow character
01:002068EA 3E01            	  7174: 	MOVE.w	d1,d7				* copy the new format string length
01:002068EC 5347            	  7175: 	SUBQ.w	#1,d7				* adjust for the loop type
01:002068EE 3C2F0004        	  7176: 	MOVE.w	fsti(sp),d6			* copy the new format string last index
01:002068F2 5346            	  7177: 	SUBQ.w	#1,d6				* -1 gives the last character of this string
01:002068F4 6E02            	  7178: 	BGT.s		LAB_U044			* if not zero continue
                            	  7179: 
01:002068F6 3C07            	  7180: 	MOVE.w	d7,d6				* else set the format string index to the end
                            	  7181: LAB_U044
01:002068F8 10316000        	  7182: 	MOVE.b	(a1,d6.w),d0		* get a character from the format string
01:002068FC 0C000023        	  7183: 	CMPI.b	#'#',d0			* compare it with "#" special format character
01:00206900 671E            	  7184: 	BEQ.s		LAB_U046			* if "#" go use the overflow character
                            	  7185: 
01:00206902 0C000025        	  7186: 	CMPI.b	#'%',d0			* compare it with "%" special format character
01:00206906 6718            	  7187: 	BEQ.s		LAB_U046			* if "%" go use the overflow character
                            	  7188: 
01:00206908 0C00002C        	  7189: 	CMPI.b	#',',d0			* compare it with "," special format character
01:0020690C 6712            	  7190: 	BEQ.s		LAB_U046			* if "," go use the overflow character
                            	  7191: 
01:0020690E 0C00002B        	  7192: 	CMPI.b	#'+',d0			* compare it with "+" special format character
01:00206912 670C            	  7193: 	BEQ.s		LAB_U046			* if "+" go use the overflow character
                            	  7194: 
01:00206914 0C00002D        	  7195: 	CMPI.b	#'-',d0			* compare it with "-" special format character
01:00206918 6706            	  7196: 	BEQ.s		LAB_U046			* if "-" go use the overflow character
                            	  7197: 
01:0020691A 0C00002E        	  7198: 	CMPI.b	#'.',d0			* compare it with "." special format character
01:0020691E 6602            	  7199: 	BNE.s		LAB_U048			* if not "." skip the using overflow character
                            	  7200: 
                            	  7201: LAB_U046
01:00206920 1005            	  7202: 	MOVE.b	d5,d0				* use the overflow character
                            	  7203: LAB_U048
01:00206922 11807000        	  7204: 	MOVE.b	d0,(a0,d7.w)		* save the character to the new format string
01:00206926 5346            	  7205: 	SUBQ.w	#1,d6				* decrement the format string index
01:00206928 51CFFFCE        	  7206: 	DBF		d7,LAB_U044			* decrement the count and loop if not all done
                            	  7207: 
                            	  7208: * add the new string to the previous string
                            	  7209: 
                            	  7210: LAB_U04A
01:0020692C 41EC0006        	  7211: 	LEA		6(a4),a0			* get the descriptor pointer for string 1
01:00206930 274C0590        	  7212: 	MOVE.l	a4,FAC1_m(a3)		* save the descriptor pointer for string 2
01:00206934 6100F018        	  7213: 	BSR		LAB_224E			* concatenate the strings
                            	  7214: 
                            	  7215: * now check for any tail on the format string
                            	  7216: 
01:00206938 302F0004        	  7217: 	MOVE.w	fsti(sp),d0			* get this index
01:0020693C 6720            	  7218: 	BEQ.s		LAB_U04C			* if at start of string skip the output
                            	  7219: 
01:0020693E 3F400006        	  7220: 	MOVE.w	d0,fsli(sp)			* save this index to the last index
01:00206942 61000082        	  7221: 	BSR		LAB_ProcFo			* now process the format string
01:00206946 4A02            	  7222: 	TST.b		d2				* test the special characters flag
01:00206948 6614            	  7223: 	BNE.s		LAB_U04C			* if special characters present skip the output
                            	  7224: 
                            	  7225: * else output the new string part
                            	  7226: 
01:0020694A 613C            	  7227: 	BSR.s		LAB_DupFmt			* duplicate the processed format string section
01:0020694C 3F6F00040006    	  7228: 	MOVE.w	fsti(sp),fsli(sp)		* copy this index to the last index
                            	  7229: 
                            	  7230: * add the new string to the previous string
                            	  7231: 
01:00206952 41EC0006        	  7232: 	LEA		6(a4),a0			* get the descriptor pointer for string 1
01:00206956 274C0590        	  7233: 	MOVE.l	a4,FAC1_m(a3)		* save the descriptor pointer for string 2
01:0020695A 6100EFF2        	  7234: 	BSR		LAB_224E			* concatenate the strings
                            	  7235: 
                            	  7236: * check for another value or end of function
                            	  7237: 
                            	  7238: LAB_U04C
01:0020695E 101D            	  7239: 	MOVE.b	(a5)+,d0			* get the next BASIC byte
01:00206960 B03C0029        	  7240: 	CMP.b		#')',d0			* compare with close bracket
01:00206964 6600FDCA        	  7241: 	BNE		LAB_U002			* if not ")" go do next value
                            	  7242: 
                            	  7243: * pop the result string off the descriptor stack
                            	  7244: 
01:00206968 204C            	  7245: 	MOVEA.l	a4,a0				* copy the result string descriptor pointer
01:0020696A 222B0446        	  7246: 	MOVE.l	Sstorl(a3),d1		* save the bottom of string space
01:0020696E 6100F040        	  7247: 	BSR		LAB_22BA			* pop (a0) descriptor, returns with ..
                            	  7248: 							* d0 = length, a0 = pointer
01:00206972 27410446        	  7249: 	MOVE.l	d1,Sstorl(a3)		* restore the bottom of string space
01:00206976 2248            	  7250: 	MOVEA.l	a0,a1				* copy the string result pointer
01:00206978 3200            	  7251: 	MOVE.w	d0,d1				* copy the string result length
                            	  7252: 
                            	  7253: * pop the format string off the descriptor stack
                            	  7254: 
01:0020697A 205F            	  7255: 	MOVEA.l	(sp)+,a0			* pull the format string descriptor pointer
01:0020697C 6100F032        	  7256: 	BSR		LAB_22BA			* pop (a0) descriptor, returns with ..
                            	  7257: 							* d0 = length, a0 = pointer
                            	  7258: 
01:00206980 508F            	  7259: 	LEA		fend(sp),sp			* dump the saved values
                            	  7260: 
                            	  7261: * push the result string back on the descriptor stack and return
                            	  7262: 
01:00206982 2049            	  7263: 	MOVEA.l	a1,a0				* copy the result string pointer back
01:00206984 6000EE80        	  7264: 	BRA		LAB_RTST			* push a string on the descriptor stack and
                            	  7265: 							* return. a0 = pointer, d1 = length
                            	  7266: 
                            	  7267: 
                            	  7268: *************************************************************************************
                            	  7269: *
                            	  7270: * duplicate the processed format string section
                            	  7271: 
                            	  7272: 							* make a string as long as the format string
                            	  7273: LAB_DupFmt
01:00206988 226F0004        	  7274: 	MOVEA.l	4+fsd(sp),a1		* get the format string descriptor pointer
01:0020698C 3E290004        	  7275: 	MOVE.w	4(a1),d7			* get the format string length
01:00206990 342F000A        	  7276: 	MOVE.w	4+fsli(sp),d2		* get the format string last index
01:00206994 3C2F0008        	  7277: 	MOVE.w	4+fsti(sp),d6		* get the format string this index
01:00206998 3206            	  7278: 	MOVE.w	d6,d1				* copy the format string this index
01:0020699A 9242            	  7279: 	SUB.w		d2,d1				* subtract the format string last index
01:0020699C 6202            	  7280: 	BHI.s		LAB_D002			* if > 0 skip the correction
                            	  7281: 
01:0020699E D247            	  7282: 	ADD.w		d7,d1				* else add the format string length as the
                            	  7283: 							* correction
                            	  7284: LAB_D002
01:002069A0 6100EE7E        	  7285: 	BSR		LAB_2115			* make string space d1 bytes long
                            	  7286: 							* return a0/Sutill = pointer, others unchanged
                            	  7287: 
                            	  7288: * push the new string on the descriptor stack
                            	  7289: 
01:002069A4 6100EE60        	  7290: 	BSR		LAB_RTST			* push a string on the descriptor stack and
                            	  7291: 							* return. a0 = pointer, d1 = length
                            	  7292: 
                            	  7293: * copy the characters from the format string
                            	  7294: 
01:002069A8 226F0004        	  7295: 	MOVEA.l	4+fsd(sp),a1		* get the format string descriptor pointer
01:002069AC 2251            	  7296: 	MOVEA.l	(a1),a1			* get the format string pointer
01:002069AE 7800            	  7297: 	MOVEQ		#0,d4				* clear the new string index
                            	  7298: LAB_D00A
01:002069B0 11B120004000    	  7299: 	MOVE.b	(a1,d2.w),(a0,d4.w)	* get a character from the format string and
                            	  7300: 							* save it to the new string
01:002069B6 5244            	  7301: 	ADDQ.w	#1,d4				* increment the new string index
01:002069B8 5242            	  7302: 	ADDQ.w	#1,d2				* increment the format string index
01:002069BA BE42            	  7303: 	CMP.w		d2,d7				* compare the format index with the length
01:002069BC 6602            	  7304: 	BNE.s		LAB_D00E			* if not there skip the reset
                            	  7305: 
01:002069BE 7400            	  7306: 	MOVEQ		#0,d2				* else reset the format string index
                            	  7307: LAB_D00E
01:002069C0 BC42            	  7308: 	CMP.w		d2,d6				* compare the index with this index
01:002069C2 66EC            	  7309: 	BNE.s		LAB_D00A			* if not equal go do the next character
                            	  7310: 
01:002069C4 4E75            	  7311: 	RTS
                            	  7312: 
                            	  7313: 
                            	  7314: **************************************************************************************
                            	  7315: *
                            	  7316: * process the format string
                            	  7317: 
                            	  7318: LAB_ProcFo
01:002069C6 226F0004        	  7319: 	MOVEA.l	4+fsd(sp),a1		* get the format string descriptor pointer
01:002069CA 3E290004        	  7320: 	MOVE.w	4(a1),d7			* get the format string length
01:002069CE 2251            	  7321: 	MOVEA.l	(a1),a1			* get the format string pointer
01:002069D0 3C2F000A        	  7322: 	MOVE.w	4+fsli(sp),d6		* get the format string last index
                            	  7323: 
01:002069D4 3F47000C        	  7324: 	MOVE.w	d7,4+fsdpi(sp)		* set the format string decimal point index
                            	  7325: *##	MOVE.w	#-1,4+fsdpi(sp)		* set the format string decimal point index
01:002069D8 7A00            	  7326: 	MOVEQ		#0,d5				* no decimal point
01:002069DA 7600            	  7327: 	MOVEQ		#0,d3				* no decimal characters
01:002069DC 7400            	  7328: 	MOVEQ		#0,d2				* no special characters
                            	  7329: LAB_P004
01:002069DE 10316000        	  7330: 	MOVE.b	(a1,d6.w),d0		* get a format string byte
                            	  7331: 
01:002069E2 B03C002C        	  7332: 	CMP.b		#',',d0			* compare it with ","
01:002069E6 6742            	  7333: 	BEQ.s		LAB_P01A			* if "," go do the next format string byte
                            	  7334: 
01:002069E8 B03C0023        	  7335: 	CMP.b		#'#',d0			* compare it with "#"
01:002069EC 6706            	  7336: 	BEQ.s		LAB_P008			* if "#" go flag special characters
                            	  7337: 
01:002069EE B03C0025        	  7338: 	CMP.b		#'%',d0			* compare it with "%"
01:002069F2 6608            	  7339: 	BNE.s		LAB_P00C			* if not "%" go try "+"
                            	  7340: 
                            	  7341: LAB_P008
01:002069F4 4A85            	  7342: 	TST.l		d5				* test the decimal point flag
01:002069F6 6A10            	  7343: 	BPL.s		LAB_P00E			* if no point skip counting decimal characters
                            	  7344: 
01:002069F8 5243            	  7345: 	ADDQ.w	#1,d3				* else increment the decimal character count
01:002069FA 602E            	  7346: 	BRA.s		LAB_P01A			* go do the next character
                            	  7347: 
                            	  7348: LAB_P00C
01:002069FC B03C002B        	  7349: 	CMP.b		#'+',d0			* compare it with "+"
01:00206A00 6706            	  7350: 	BEQ.s		LAB_P00E			* if "+" go flag special characters
                            	  7351: 
01:00206A02 B03C002D        	  7352: 	CMP.b		#'-',d0			* compare it with "-"
01:00206A06 6604            	  7353: 	BNE.s		LAB_P010			* if not "-" go check decimal point
                            	  7354: 
                            	  7355: LAB_P00E
01:00206A08 8400            	  7356: 	OR.b		d0,d2				* flag special characters
01:00206A0A 601E            	  7357: 	BRA.s		LAB_P01A			* go do the next character
                            	  7358: 
                            	  7359: LAB_P010
01:00206A0C B03C002E        	  7360: 	CMP.b		#'.',d0			* compare it with "."
01:00206A10 6614            	  7361: 	BNE.s		LAB_P018			* if not "." go check next
                            	  7362: 
                            	  7363: * "." a decimal point
                            	  7364: 
01:00206A12 4A85            	  7365: 	TST.l		d5				* if there is already a decimal point
01:00206A14 6B14            	  7366: 	BMI.s		LAB_P01A			* go do the next character
                            	  7367: 
01:00206A16 3006            	  7368: 	MOVE.w	d6,d0				* copy the decimal point index
01:00206A18 906F000A        	  7369: 	SUB.w		4+fsli(sp),d0		* calculate it from the scan start
01:00206A1C 3F40000C        	  7370: 	MOVE.w	d0,4+fsdpi(sp)		* save the decimal point index
01:00206A20 7AFF            	  7371: 	MOVEQ		#-1,d5			* flag decimal point
01:00206A22 8400            	  7372: 	OR.b		d0,d2				* flag special characters
01:00206A24 6004            	  7373: 	BRA.s		LAB_P01A			* go do the next character
                            	  7374: 
                            	  7375: * was not a special character
                            	  7376: 
                            	  7377: LAB_P018
01:00206A26 4A02            	  7378: 	TST.b		d2				* test if there have been special characters
01:00206A28 6608            	  7379: 	BNE.s		LAB_P01E			* if so exit the format string process
                            	  7380: 
                            	  7381: LAB_P01A
01:00206A2A 5246            	  7382: 	ADDQ.w	#1,d6				* increment the format string index
01:00206A2C BE46            	  7383: 	CMP.w		d6,d7				* compare it with the format string length
01:00206A2E 62AE            	  7384: 	BHI.s		LAB_P004			* if length > index go get the next character
                            	  7385: 
01:00206A30 7C00            	  7386: 	MOVEQ		#0,d6				* length = index so reset the format string
                            	  7387: 							* index
                            	  7388: LAB_P01E
01:00206A32 3F460008        	  7389: 	MOVE.w	d6,4+fsti(sp)		* save the format string this index
01:00206A36 3F43000E        	  7390: 	MOVE.w	d3,4+fsdc(sp)		* save the format string decimal characters
                            	  7391: 
01:00206A3A 4E75            	  7392: 	RTS
                            	  7393: 
                            	  7394: 
                            	  7395: *************************************************************************************
                            	  7396: *
                            	  7397: * perform BIN$()
                            	  7398: * # of leading 0s is in d1, the number is in d0
                            	  7399: 
                            	  7400: LAB_BINS
01:00206A3C B23C0021        	  7401: 	CMP.b		#$21,d1			* max + 1
01:00206A40 6400DB22        	  7402: 	BCC		LAB_FCER			* exit if too big ( > or = )
                            	  7403: 
01:00206A44 741F            	  7404: 	MOVEQ		#$1F,d2			* bit count-1
01:00206A46 41EB05B6        	  7405: 	LEA		Binss(a3),a0		* point to string
01:00206A4A 7830            	  7406: 	MOVEQ		#$30,d4			* "0" character for ADDX
                            	  7407: NextB1
01:00206A4C 7600            	  7408: 	MOVEQ		#0,d3				* clear byte
01:00206A4E E288            	  7409: 	LSR.l		#1,d0				* shift bit into Xb
01:00206A50 D704            	  7410: 	ADDX.b	d4,d3				* add carry and character to zero
01:00206A52 11832000        	  7411: 	MOVE.b	d3,(a0,d2.w)		* save character to string
01:00206A56 51CAFFF4        	  7412: 	DBF		d2,NextB1			* decrement and loop if not done
                            	  7413: 
                            	  7414: * this is the exit code and is also used by HEX$()
                            	  7415: 
                            	  7416: EndBHS
01:00206A5A 177C000005D6    	  7417: 	MOVE.b	#0,BHsend(a3)		* null terminate the string
01:00206A60 4A01            	  7418: 	TST.b		d1				* test # of characters
01:00206A62 670E            	  7419: 	BEQ.s		NextB2			* go truncate string
                            	  7420: 
01:00206A64 4481            	  7421: 	NEG.l		d1				* make -ve
01:00206A66 D2BC000005D6    	  7422: 	ADD.l		#BHsend,d1			* effectively (end-length)
01:00206A6C 41F31000        	  7423: 	LEA		0(a3,d1.w),a0		* effectively add (end-length) to pointer
01:00206A70 600E            	  7424: 	BRA.s		BinPr				* go print string
                            	  7425: 
                            	  7426: * truncate string to remove leading "0"s
                            	  7427: 
                            	  7428: NextB2
01:00206A72 1010            	  7429: 	MOVE.b	(a0),d0			* get byte
01:00206A74 670A            	  7430: 	BEQ.s		BinPr				* if null then end of string so add 1 and go
                            	  7431: 							* print it
                            	  7432: 
01:00206A76 B03C0030        	  7433: 	CMP.b		#'0',d0			* compare with "0"
01:00206A7A 660E            	  7434: 	BNE.s		GoPr				* if not "0" then go print string from here
                            	  7435: 
01:00206A7C 5248            	  7436: 	ADDQ.w	#1,a0				* else increment pointer
01:00206A7E 60F2            	  7437: 	BRA.s		NextB2			* loop always
                            	  7438: 
                            	  7439: * make fixed length output string - ignore overflows!
                            	  7440: 
                            	  7441: BinPr
01:00206A80 43EB05D6        	  7442: 	LEA		BHsend(a3),a1		* get string end
01:00206A84 B1C9            	  7443: 	CMPA.l	a1,a0				* are we at the string end
01:00206A86 6602            	  7444: 	BNE.s		GoPr				* branch if not
                            	  7445: 
01:00206A88 5348            	  7446: 	SUBQ.w	#1,a0				* else need at least one zero
                            	  7447: GoPr
01:00206A8A 6000ED34        	  7448: 	BRA		LAB_20AE			* print " terminated string to FAC1, stack & RET
                            	  7449: 
                            	  7450: 
                            	  7451: *************************************************************************************
                            	  7452: *
                            	  7453: * perform HEX$()
                            	  7454: * # of leading 0s is in d1, the number is in d0
                            	  7455: 
                            	  7456: LAB_HEXS
01:00206A8E B23C0009        	  7457: 	CMP.b		#$09,d1			* max + 1
01:00206A92 6400DAD0        	  7458: 	BCC		LAB_FCER			* exit if too big ( > or = )
                            	  7459: 
01:00206A96 7407            	  7460: 	MOVEQ		#$07,d2			* nibble count-1
01:00206A98 41EB05CE        	  7461: 	LEA		Hexss(a3),a0		* point to string
01:00206A9C 7830            	  7462: 	MOVEQ		#$30,d4			* "0" character for ABCD
                            	  7463: NextH1
01:00206A9E 1600            	  7464: 	MOVE.b	d0,d3				* copy lowest byte
01:00206AA0 E898            	  7465: 	ROR.l		#4,d0				* shift nibble into 0-3
01:00206AA2 C63C000F        	  7466: 	AND.b		#$0F,d3			* just this nibble
01:00206AA6 1A03            	  7467: 	MOVE.b	d3,d5				* copy it
01:00206AA8 DA3C00F6        	  7468: 	ADD.b		#$F6,d5			* set extend bit
01:00206AAC C704            	  7469: 	ABCD		d4,d3				* decimal add extend and character to zero
01:00206AAE 11832000        	  7470: 	MOVE.b	d3,(a0,d2.w)		* save character to string
01:00206AB2 51CAFFEA        	  7471: 	DBF		d2,NextH1			* decrement and loop if not done
                            	  7472: 
01:00206AB6 60A2            	  7473: 	BRA.s		EndBHS			* go process string
                            	  7474: 
                            	  7475: 
                            	  7476: *************************************************************************************
                            	  7477: *
                            	  7478: * ctrl-c check routine. includes limited "life" byte save for INGET routine
                            	  7479: 
                            	  7480: VEC_CC
01:00206AB8 4A2B05E8        	  7481: 	TST.b		ccflag(a3)			* check [CTRL-C] check flag
01:00206ABC 661E            	  7482: 	BNE.s		RTS_022			* exit if [CTRL-C] check inhibited
                            	  7483: 
01:00206ABE 4EAB040C        	  7484: 	JSR		V_INPT(a3)			* scan input device
01:00206AC2 640E            	  7485: 	BCC.s		LAB_FBA0			* exit if buffer empty
                            	  7486: 
01:00206AC4 174005E9        	  7487: 	MOVE.b	d0,ccbyte(a3)		* save received byte
01:00206AC8 177C002005EA    	  7488: 	MOVE.b	#$20,ccnull(a3)		* set "life" timer for bytes countdown
01:00206ACE 6000DF06        	  7489: 	BRA		LAB_1636			* return to BASIC
                            	  7490: 
                            	  7491: LAB_FBA0
01:00206AD2 4A2B05EA        	  7492: 	TST.b		ccnull(a3)			* get countdown byte
01:00206AD6 6704            	  7493: 	BEQ.s		RTS_022			* exit if finished
                            	  7494: 
01:00206AD8 532B05EA        	  7495: 	SUBQ.b	#1,ccnull(a3)		* else decrement countdown
                            	  7496: RTS_022
01:00206ADC 4E75            	  7497: 	RTS
                            	  7498: 
                            	  7499: 
                            	  7500: *************************************************************************************
                            	  7501: *
                            	  7502: * get byte from input device, no waiting
                            	  7503: * returns with carry set if byte in A
                            	  7504: 
                            	  7505: INGET
01:00206ADE 4EAB040C        	  7506: 	JSR		V_INPT(a3)			* call scan input device
01:00206AE2 650A            	  7507: 	BCS.s		LAB_FB95			* if byte go reset timer
                            	  7508: 
01:00206AE4 102B05EA        	  7509: 	MOVE.b	ccnull(a3),d0		* get countdown
01:00206AE8 67F2            	  7510: 	BEQ.s		RTS_022			* exit if empty
                            	  7511: 
01:00206AEA 102B05E9        	  7512: 	MOVE.b	ccbyte(a3),d0		* get last received byte
                            	  7513: LAB_FB95
01:00206AEE 177C000005EA    	  7514: 	MOVE.b	#$00,ccnull(a3)		* clear timer because we got a byte
01:00206AF4 003C0001        	  7515: 	ORI.b		#1,CCR			* set carry, flag we got a byte
01:00206AF8 4E75            	  7516: 	RTS
                            	  7517: 
                            	  7518: 
                            	  7519: *************************************************************************************
                            	  7520: *
                            	  7521: * perform MAX()
                            	  7522: 
                            	  7523: LAB_MAX
01:00206AFA 6100E552        	  7524: 	BSR		LAB_EVEZ			* evaluate expression (no decrement)
01:00206AFE 4A2B05B5        	  7525: 	TST.b		Dtypef(a3)			* test data type
01:00206B02 6B00DA40        	  7526: 	BMI		LAB_TMER			* if string do Type missmatch Error/warm start
                            	  7527: 
                            	  7528: LAB_MAXN
01:00206B06 612C            	  7529: 	BSR.s		LAB_PHFA			* push FAC1, evaluate expression,
                            	  7530: 							* pull FAC2 & compare with FAC1
01:00206B08 64FC            	  7531: 	BCC.s		LAB_MAXN			* branch if no swap to do
                            	  7532: 
01:00206B0A 6100F4B2        	  7533: 	BSR		LAB_279B			* copy FAC2 to FAC1
01:00206B0E 60F6            	  7534: 	BRA.s		LAB_MAXN			* go do next
                            	  7535: 
                            	  7536: 
                            	  7537: *************************************************************************************
                            	  7538: *
                            	  7539: * perform MIN()
                            	  7540: 
                            	  7541: LAB_MIN
01:00206B10 6100E53C        	  7542: 	BSR		LAB_EVEZ			* evaluate expression (no decrement)
01:00206B14 4A2B05B5        	  7543: 	TST.b		Dtypef(a3)			* test data type
01:00206B18 6B00DA2A        	  7544: 	BMI		LAB_TMER			* if string do Type missmatch Error/warm start
                            	  7545: 
                            	  7546: LAB_MINN
01:00206B1C 6116            	  7547: 	BSR.s		LAB_PHFA			* push FAC1, evaluate expression,
                            	  7548: 							* pull FAC2 & compare with FAC1
01:00206B1E 63FC            	  7549: 	BLS.s		LAB_MINN			* branch if no swap to do
                            	  7550: 
01:00206B20 6100F49C        	  7551: 	BSR		LAB_279B			* copy FAC2 to FAC1
01:00206B24 60F6            	  7552: 	BRA.s		LAB_MINN			* go do next (branch always)
                            	  7553: 
                            	  7554: * exit routine. don't bother returning to the loop code
                            	  7555: * check for correct exit, else so syntax error
                            	  7556: 
                            	  7557: LAB_MMEC
01:00206B26 B03C0029        	  7558: 	CMP.b		#')',d0			* is it end of function?
01:00206B2A 6600DA44        	  7559: 	BNE		LAB_SNER			* if not do MAX MIN syntax error
                            	  7560: 
01:00206B2E 588F            	  7561: 	LEA		4(sp),sp			* dump return address (faster)
01:00206B30 6000E67A        	  7562: 	BRA		LAB_IGBY			* update BASIC execute pointer (to chr past ")")
                            	  7563: 							* and return
                            	  7564: 
                            	  7565: * check for next, evaluate & return or exit
                            	  7566: * this is the routine that does most of the work
                            	  7567: 
                            	  7568: LAB_PHFA
01:00206B34 6100E678        	  7569: 	BSR		LAB_GBYT			* get next BASIC byte
01:00206B38 B03C002C        	  7570: 	CMP.b		#',',d0			* is there more ?
01:00206B3C 66E8            	  7571: 	BNE.s		LAB_MMEC			* if not go do end check
                            	  7572: 
01:00206B3E 3F2B0594        	  7573: 	MOVE.w	FAC1_e(a3),-(sp)		* push exponent and sign
01:00206B42 2F2B0590        	  7574: 	MOVE.l	FAC1_m(a3),-(sp)		* push mantissa
                            	  7575: 
01:00206B46 6100E506        	  7576: 	BSR		LAB_EVEZ			* evaluate expression (no decrement)
01:00206B4A 4A2B05B5        	  7577: 	TST.b		Dtypef(a3)			* test data type
01:00206B4E 6B00D9F4        	  7578: 	BMI		LAB_TMER			* if string do Type missmatch Error/warm start
                            	  7579: 
                            	  7580: 
                            	  7581: 							* pop FAC2 (MAX/MIN expression so far)
01:00206B52 275F0598        	  7582: 	MOVE.l	(sp)+,FAC2_m(a3)		* pop mantissa
                            	  7583: 
01:00206B56 301F            	  7584: 	MOVE.w	(sp)+,d0			* pop exponent and sign
01:00206B58 3740059C        	  7585: 	MOVE.w	d0,FAC2_e(a3)		* save exponent and sign
01:00206B5C 176B0595059E    	  7586: 	MOVE.b	FAC1_s(a3),FAC_sc(a3)	* get FAC1 sign
01:00206B62 B12B059E        	  7587: 	EOR.b		d0,FAC_sc(a3)		* EOR to create sign compare
01:00206B66 6000F4C2        	  7588: 	BRA		LAB_27FA			* compare FAC1 with FAC2 & return
                            	  7589: 							* returns d0=+1 Cb=0 if FAC1 > FAC2
                            	  7590: 							* returns d0= 0 Cb=0 if FAC1 = FAC2
                            	  7591: 							* returns d0=-1 Cb=1 if FAC1 < FAC2
                            	  7592: 
                            	  7593: 
                            	  7594: *************************************************************************************
                            	  7595: *
                            	  7596: * perform WIDTH
                            	  7597: 
                            	  7598: LAB_WDTH
01:00206B6A B03C002C        	  7599: 	CMP.b		#',',d0			* is next byte ","
01:00206B6E 672C            	  7600: 	BEQ.s		LAB_TBSZ			* if so do tab size
                            	  7601: 
01:00206B70 6100EF9A        	  7602: 	BSR		LAB_GTBY			* get byte parameter, result in d0 and Itemp
01:00206B74 4A00            	  7603: 	TST.b		d0				* test result
01:00206B76 6712            	  7604: 	BEQ.s		LAB_NSTT			* branch if set for infinite line
                            	  7605: 
01:00206B78 B03C0010        	  7606: 	CMP.b		#$10,d0			* else make min width = 16d
01:00206B7C 6500D9E6        	  7607: 	BCS		LAB_FCER			* if less do function call error & exit
                            	  7608: 
                            	  7609: * this next compare ensures that we can't exit WIDTH via an error leaving the
                            	  7610: * tab size greater than the line length.
                            	  7611: 
01:00206B80 B02B05E2        	  7612: 	CMP.b		TabSiz(a3),d0		* compare with tab size
01:00206B84 6404            	  7613: 	BCC.s		LAB_NSTT			* branch if >= tab size
                            	  7614: 
01:00206B86 174005E2        	  7615: 	MOVE.b	d0,TabSiz(a3)		* else make tab size = terminal width
                            	  7616: LAB_NSTT
01:00206B8A 174005E6        	  7617: 	MOVE.b	d0,TWidth(a3)		* set the terminal width
01:00206B8E 6100E61E        	  7618: 	BSR		LAB_GBYT			* get BASIC byte back
01:00206B92 672C            	  7619: 	BEQ.s		WExit				* exit if no following
                            	  7620: 
01:00206B94 B03C002C        	  7621: 	CMP.b		#',',d0			* else is it ","
01:00206B98 6600D9D6        	  7622: 	BNE		LAB_SNER			* if not do syntax error
                            	  7623: 
                            	  7624: LAB_TBSZ
01:00206B9C 6100EF6A        	  7625: 	BSR		LAB_SGBY			* increment and get byte, result in d0 and Itemp
01:00206BA0 4A00            	  7626: 	TST.b		d0				* test TAB size
01:00206BA2 6B00D9C0        	  7627: 	BMI		LAB_FCER			* if >127 do function call error & exit
                            	  7628: 
01:00206BA6 B03C0001        	  7629: 	CMP.b		#1,d0				* compare with min-1
01:00206BAA 6500D9B8        	  7630: 	BCS		LAB_FCER			* if <=1 do function call error & exit
                            	  7631: 
01:00206BAE 122B05E6        	  7632: 	MOVE.b	TWidth(a3),d1		* set flags for width
01:00206BB2 6708            	  7633: 	BEQ.s		LAB_SVTB			* skip check if infinite line
                            	  7634: 
01:00206BB4 B02B05E6        	  7635: 	CMP.b		TWidth(a3),d0		* compare TAB with width
01:00206BB8 6E00D9AA        	  7636: 	BGT		LAB_FCER			* branch if too big
                            	  7637: 
                            	  7638: LAB_SVTB
01:00206BBC 174005E2        	  7639: 	MOVE.b	d0,TabSiz(a3)		* save TAB size
                            	  7640: 
                            	  7641: * calculate tab column limit from TAB size. The Iclim is set to the last tab
                            	  7642: * position on a line that still has at least one whole tab width between it
                            	  7643: * and the end of the line.
                            	  7644: 
                            	  7645: WExit
01:00206BC0 102B05E6        	  7646: 	MOVE.b	TWidth(a3),d0		* get width
01:00206BC4 670A            	  7647: 	BEQ.s		LAB_WDLP			* branch if infinite line
                            	  7648: 
01:00206BC6 B02B05E2        	  7649: 	CMP.b		TabSiz(a3),d0		* compare with tab size
01:00206BCA 6404            	  7650: 	BCC.s		LAB_WDLP			* branch if >= tab size
                            	  7651: 
01:00206BCC 174005E2        	  7652: 	MOVE.b	d0,TabSiz(a3)		* else make tab size = terminal width
                            	  7653: LAB_WDLP
01:00206BD0 902B05E2        	  7654: 	SUB.b		TabSiz(a3),d0		* subtract tab size
01:00206BD4 64FA            	  7655: 	BCC.s		LAB_WDLP			* loop while no borrow
                            	  7656: 
01:00206BD6 D02B05E2        	  7657: 	ADD.b		TabSiz(a3),d0		* add tab size back
01:00206BDA D02B05E2        	  7658: 	ADD.b		TabSiz(a3),d0		* add tab size back again
                            	  7659: 
01:00206BDE 4400            	  7660: 	NEG.b		d0				* make -ve
01:00206BE0 D02B05E6        	  7661: 	ADD.b		TWidth(a3),d0		* subtract remainder from width
01:00206BE4 174005E7        	  7662: 	MOVE.b	d0,Iclim(a3)		* save tab column limit
                            	  7663: RTS_023
01:00206BE8 4E75            	  7664: 	RTS
                            	  7665: 
                            	  7666: 
                            	  7667: *************************************************************************************
                            	  7668: *
                            	  7669: * perform SQR()
                            	  7670: 
                            	  7671: * d0 is number to find the root of
                            	  7672: * d1 is the root result
                            	  7673: * d2 is the remainder
                            	  7674: * d3 is a counter
                            	  7675: * d4 is temp
                            	  7676: 
                            	  7677: LAB_SQR
01:00206BEA 4A2B0595        	  7678: 	TST.b		FAC1_s(a3)			* test FAC1 sign
01:00206BEE 6B00D974        	  7679: 	BMI		LAB_FCER			* if -ve do function call error
                            	  7680: 
01:00206BF2 4A2B0594        	  7681: 	TST.b		FAC1_e(a3)			* test exponent
01:00206BF6 67F0            	  7682: 	BEQ.s		RTS_023			* exit if zero
                            	  7683: 
01:00206BF8 48E77800        	  7684: 	MOVEM.l	d1-d4,-(sp)			* save registers
01:00206BFC 202B0590        	  7685: 	MOVE.l	FAC1_m(a3),d0		* copy FAC1
01:00206C00 7400            	  7686: 	MOVEQ		#0,d2				* clear remainder
01:00206C02 2202            	  7687: 	MOVE.l	d2,d1				* clear root
                            	  7688: 
01:00206C04 761F            	  7689: 	MOVEQ		#$1F,d3			* $1F for DBF, 64 pairs of bits to
                            	  7690: 							* do for a 32 bit result
01:00206C06 082B00000594    	  7691: 	BTST		#0,FAC1_e(a3)		* test exponent odd/even
01:00206C0C 6606            	  7692: 	BNE.s		LAB_SQE2			* if odd only 1 shift first time
                            	  7693: 
                            	  7694: LAB_SQE1
01:00206C0E D080            	  7695: 	ADD.l		d0,d0				* shift highest bit of number ..
01:00206C10 D582            	  7696: 	ADDX.l	d2,d2				* .. into remainder .. never overflows
01:00206C12 D281            	  7697: 	ADD.l		d1,d1				* root = root * 2 .. never overflows
                            	  7698: LAB_SQE2
01:00206C14 D080            	  7699: 	ADD.l		d0,d0				* shift highest bit of number ..
01:00206C16 D582            	  7700: 	ADDX.l	d2,d2				* .. into remainder .. never overflows
                            	  7701: 
01:00206C18 2801            	  7702: 	MOVE.l	d1,d4				* copy root
01:00206C1A D884            	  7703: 	ADD.l		d4,d4				* 2n
01:00206C1C 5284            	  7704: 	ADDQ.l	#1,d4				* 2n+1
                            	  7705: 
01:00206C1E B484            	  7706: 	CMP.l		d4,d2				* compare 2n+1 to remainder
01:00206C20 6504            	  7707: 	BCS.s		LAB_SQNS			* skip sub if remainder smaller
                            	  7708: 
01:00206C22 9484            	  7709: 	SUB.l		d4,d2				* subtract temp from remainder
01:00206C24 5281            	  7710: 	ADDQ.l	#1,d1				* increment root
                            	  7711: LAB_SQNS
01:00206C26 51CBFFE6        	  7712: 	DBF		d3,LAB_SQE1			* loop if not all done
                            	  7713: 
01:00206C2A 27410590        	  7714: 	MOVE.l	d1,FAC1_m(a3)		* save result mantissa
01:00206C2E 102B0594        	  7715: 	MOVE.b	FAC1_e(a3),d0		* get exponent (d0 is clear here)
01:00206C32 907C0080        	  7716: 	SUB.w		#$80,d0			* normalise
01:00206C36 E248            	  7717: 	LSR.w		#1,d0				* /2
01:00206C38 6402            	  7718: 	BCC.s		LAB_SQNA			* skip increment if carry clear
                            	  7719: 
01:00206C3A 5240            	  7720: 	ADDQ.w	#1,d0				* add bit zero back in (allow for half shift)
                            	  7721: LAB_SQNA
01:00206C3C D07C0080        	  7722: 	ADD.w		#$80,d0			* re-bias to $80
01:00206C40 17400594        	  7723: 	MOVE.b	d0,FAC1_e(a3)		* save it
01:00206C44 4CDF001E        	  7724: 	MOVEM.l	(sp)+,d1-d4			* restore registers
01:00206C48 6000F0B2        	  7725: 	BRA		LAB_24D5			* normalise FAC1 & return
                            	  7726: 
                            	  7727: 
                            	  7728: *************************************************************************************
                            	  7729: *
                            	  7730: * perform VARPTR()
                            	  7731: 
                            	  7732: LAB_VARPTR
01:00206C4C 101D            	  7733: 	MOVE.b	(a5)+,d0			* increment pointer
                            	  7734: LAB_VARCALL
01:00206C4E 6100E76A        	  7735: 	BSR		LAB_GVAR			* get variable address in a0
01:00206C52 6100E546        	  7736: 	BSR		LAB_1BFB			* scan for ")", else do syntax error/warm start
01:00206C56 2008            	  7737: 	MOVE.l	a0,d0				* copy the variable address
01:00206C58 6000EA50        	  7738: 	BRA		LAB_AYFC			* convert d0 to signed longword in FAC1 & return
                            	  7739: 
                            	  7740: 
                            	  7741: *************************************************************************************
                            	  7742: *
                            	  7743: * perform RAMBASE
                            	  7744: 
                            	  7745: LAB_RAM
01:00206C5C 41EB0400        	  7746: 	LEA		ram_base(a3),a0		* get start of EhBASIC RAM
01:00206C60 2008            	  7747: 	MOVE.l	a0,d0				* copy it
01:00206C62 6000EA46        	  7748: 	BRA		LAB_AYFC			* convert d0 to signed longword in FAC1 & return
                            	  7749: 
                            	  7750: 
                            	  7751: *************************************************************************************
                            	  7752: *
                            	  7753: * perform PI
                            	  7754: 
                            	  7755: LAB_PI
01:00206C66 277CC90FDAA20590	  7756: 	MOVE.l	#$C90FDAA2,FAC1_m(a3)	* pi mantissa (32 bit)
01:00206C6E 377C82000594    	  7757: 	MOVE.w	#$8200,FAC1_e(a3)		* pi exponent and sign
01:00206C74 4E75            	  7758: 	RTS
                            	  7759: 
                            	  7760: 
                            	  7761: *************************************************************************************
                            	  7762: *
                            	  7763: * perform TWOPI
                            	  7764: 
                            	  7765: LAB_TWOPI
01:00206C76 277CC90FDAA20590	  7766: 	MOVE.l	#$C90FDAA2,FAC1_m(a3)	* 2pi mantissa (32 bit)
01:00206C7E 377C83000594    	  7767: 	MOVE.w	#$8300,FAC1_e(a3)		* 2pi exponent and sign
01:00206C84 4E75            	  7768: 	RTS
                            	  7769: 
                            	  7770: 
                            	  7771: *************************************************************************************
                            	  7772: *
                            	  7773: * get ASCII string equivalent into FAC1 as integer32 or float
                            	  7774: 
                            	  7775: * entry is with a5 pointing to the first character of the string
                            	  7776: * exit with a5 pointing to the first character after the string
                            	  7777: 
                            	  7778: * d0 is character
                            	  7779: * d1 is mantissa
                            	  7780: * d2 is partial and table mantissa
                            	  7781: * d3 is mantissa exponent (decimal & binary)
                            	  7782: * d4 is decimal exponent
                            	  7783: 
                            	  7784: * get FAC1 from string
                            	  7785: * this routine now handles hex and binary values from strings
                            	  7786: * starting with "$" and "%" respectively
                            	  7787: 
                            	  7788: LAB_2887
01:00206C86 48E77C00        	  7789: 	MOVEM.l	d1-d5,-(sp)			* save registers
01:00206C8A 7200            	  7790: 	MOVEQ		#$00,d1			* clear temp accumulator
01:00206C8C 2601            	  7791: 	MOVE.l	d1,d3				* set mantissa decimal exponent count
01:00206C8E 2801            	  7792: 	MOVE.l	d1,d4				* clear decimal exponent
01:00206C90 17410595        	  7793: 	MOVE.b	d1,FAC1_s(a3)		* clear sign byte
01:00206C94 174105B5        	  7794: 	MOVE.b	d1,Dtypef(a3)		* set float data type
01:00206C98 174105AF        	  7795: 	MOVE.b	d1,expneg(a3)		* clear exponent sign
01:00206C9C 6100E510        	  7796: 	BSR		LAB_GBYT			* get first byte back
01:00206CA0 653C            	  7797: 	BCS.s		LAB_28FE			* go get floating if 1st character numeric
                            	  7798: 
01:00206CA2 B03C002D        	  7799: 	CMP.b		#'-',d0			* or is it -ve number
01:00206CA6 6608            	  7800: 	BNE.s		LAB_289A			* branch if not
                            	  7801: 
01:00206CA8 177C00FF0595    	  7802: 	MOVE.b	#$FF,FAC1_s(a3)		* set sign byte
01:00206CAE 6006            	  7803: 	BRA.s		LAB_289C			* now go scan & check for hex/bin/int
                            	  7804: 
                            	  7805: LAB_289A
                            	  7806: 							* first character wasn't numeric or -
01:00206CB0 B03C002B        	  7807: 	CMP.b		#'+',d0			* compare with '+'
01:00206CB4 6606            	  7808: 	BNE.s		LAB_289D			* branch if not '+' (go check for '.'/hex/binary
                            	  7809: 							* /integer)
                            	  7810: 	
                            	  7811: LAB_289C
                            	  7812: 							* was "+" or "-" to start, so get next character
01:00206CB6 6100E4F4        	  7813: 	BSR		LAB_IGBY			* increment & scan memory
01:00206CBA 6522            	  7814: 	BCS.s		LAB_28FE			* branch if numeric character
                            	  7815: 
                            	  7816: LAB_289D
01:00206CBC B03C002E        	  7817: 	CMP.b		#'.',d0			* else compare with '.'
01:00206CC0 67000092        	  7818: 	BEQ		LAB_2904			* branch if '.'
                            	  7819: 
                            	  7820: 							* code here for hex/binary/integer numbers
01:00206CC4 B03C0024        	  7821: 	CMP.b		#'$',d0			* compare with '$'
01:00206CC8 6700010A        	  7822: 	BEQ		LAB_CHEX			* branch if '$'
                            	  7823: 
01:00206CCC B03C0025        	  7824: 	CMP.b		#'%',d0			* else compare with '%'
01:00206CD0 67000164        	  7825: 	BEQ		LAB_CBIN			* branch if '%'
                            	  7826: 
01:00206CD4 6000008C        	  7827: 	BRA		LAB_2Y01			* not #.$%& so return 0
                            	  7828: 
                            	  7829: LAB_28FD
01:00206CD8 6100E4D2        	  7830: 	BSR		LAB_IGBY			* get next character
01:00206CDC 646C            	  7831: 	BCC.s		LAB_2902			* exit loop if not a digit
                            	  7832: 
                            	  7833: LAB_28FE
01:00206CDE 610001A8        	  7834: 	BSR		d1x10				* multiply d1 by 10 and add character
01:00206CE2 64F4            	  7835: 	BCC.s		LAB_28FD			* loop for more if no overflow
                            	  7836: 
                            	  7837: LAB_28FF
                            	  7838: 							* overflowed mantissa, count 10s exponent
01:00206CE4 5283            	  7839: 	ADDQ.l	#1,d3				* increment mantissa decimal exponent count
01:00206CE6 6100E4C4        	  7840: 	BSR		LAB_IGBY			* get next character
01:00206CEA 65F8            	  7841: 	BCS.s		LAB_28FF			* loop while numeric character
                            	  7842: 
                            	  7843: 							* done overflow, now flush fraction or do E
01:00206CEC B03C002E        	  7844: 	CMP.b		#'.',d0			* else compare with '.'
01:00206CF0 6606            	  7845: 	BNE.s		LAB_2901			* branch if not '.'
                            	  7846: 
                            	  7847: LAB_2900
                            	  7848: 							* flush remaining fraction digits
01:00206CF2 6100E4B8        	  7849: 	BSR		LAB_IGBY			* get next character
01:00206CF6 65FA            	  7850: 	BCS		LAB_2900			* loop while numeric character
                            	  7851: 
                            	  7852: LAB_2901
                            	  7853: 							* done number, only (possible) exponent remains
01:00206CF8 B03C0045        	  7854: 	CMP.b		#'E',d0			* else compare with 'E'
01:00206CFC 6664            	  7855: 	BNE.s		LAB_2Y01			* if not 'E' all done, go evaluate
                            	  7856: 
                            	  7857: 							* process exponent
01:00206CFE 6100E4AC        	  7858: 	BSR		LAB_IGBY			* get next character
01:00206D02 6528            	  7859: 	BCS.s		LAB_2X04			* branch if digit
                            	  7860: 
01:00206D04 B03C002D        	  7861: 	CMP.b		#'-',d0			* or is it -ve number
01:00206D08 6706            	  7862: 	BEQ.s		LAB_2X01			* branch if so
                            	  7863: 
01:00206D0A B03C00B3        	  7864: 	CMP.b		#TK_MINUS,d0		* or is it -ve number
01:00206D0E 6608            	  7865: 	BNE.s		LAB_2X02			* branch if not
                            	  7866: 
                            	  7867: LAB_2X01
01:00206D10 177C00FF05AF    	  7868: 	MOVE.b	#$FF,expneg(a3)		* set exponent sign
01:00206D16 600E            	  7869: 	BRA.s		LAB_2X03			* now go scan & check exponent
                            	  7870: 
                            	  7871: LAB_2X02
01:00206D18 B03C002B        	  7872: 	CMP.b		#'+',d0			* or is it +ve number
01:00206D1C 6708            	  7873: 	BEQ.s		LAB_2X03			* branch if so
                            	  7874: 
01:00206D1E B03C00B2        	  7875: 	CMP.b		#TK_PLUS,d0			* or is it +ve number
01:00206D22 6600D84C        	  7876: 	BNE		LAB_SNER			* wasn't - + TK_MINUS TK_PLUS or # so do error
                            	  7877: 
                            	  7878: LAB_2X03
01:00206D26 6100E484        	  7879: 	BSR		LAB_IGBY			* get next character
01:00206D2A 6436            	  7880: 	BCC.s		LAB_2Y01			* if not digit all done, go evaluate
                            	  7881: LAB_2X04
01:00206D2C C8FC000A        	  7882: 	MULU		#10,d4			* multiply decimal exponent by 10
01:00206D30 C0BC000000FF    	  7883: 	AND.l		#$FF,d0			* mask character
01:00206D36 903C0030        	  7884: 	SUB.b		#'0',d0			* convert to value
01:00206D3A D880            	  7885: 	ADD.l		d0,d4				* add to decimal exponent
01:00206D3C B83C0030        	  7886: 	CMP.b		#48,d4			* compare with decimal exponent limit+10
01:00206D40 6FE4            	  7887: 	BLE.s		LAB_2X03			* loop if no overflow/underflow
                            	  7888: 
                            	  7889: LAB_2X05
                            	  7890: 							* exponent value has overflowed
01:00206D42 6100E468        	  7891: 	BSR		LAB_IGBY			* get next character
01:00206D46 65FA            	  7892: 	BCS.s		LAB_2X05			* loop while numeric digit
                            	  7893: 
01:00206D48 6018            	  7894: 	BRA.s		LAB_2Y01			* all done, go evaluate
                            	  7895: 
                            	  7896: LAB_2902
01:00206D4A B03C002E        	  7897: 	CMP.b		#'.',d0			* else compare with '.'
01:00206D4E 6704            	  7898: 	BEQ.s		LAB_2904			* branch if was '.'
                            	  7899: 
01:00206D50 60A6            	  7900: 	BRA.s		LAB_2901			* branch if not '.' (go check/do 'E')
                            	  7901: 
                            	  7902: LAB_2903
01:00206D52 5383            	  7903: 	SUBQ.l	#1,d3				* decrement mantissa decimal exponent
                            	  7904: LAB_2904
                            	  7905: 							* was dp so get fraction part
01:00206D54 6100E456        	  7906: 	BSR		LAB_IGBY			* get next character
01:00206D58 649E            	  7907: 	BCC.s		LAB_2901			* exit loop if not a digit (go check/do 'E')
                            	  7908: 
01:00206D5A 6100012C        	  7909: 	BSR		d1x10				* multiply d1 by 10 and add character
01:00206D5E 64F2            	  7910: 	BCC.s		LAB_2903			* loop for more if no overflow
                            	  7911: 
01:00206D60 6090            	  7912: 	BRA.s		LAB_2900			* else go flush remaining fraction part
                            	  7913: 
                            	  7914: LAB_2Y01
                            	  7915: 							* now evaluate result
01:00206D62 4A2B05AF        	  7916: 	TST.b		expneg(a3)			* test exponent sign
01:00206D66 6A02            	  7917: 	BPL.s		LAB_2Y02			* branch if sign positive
                            	  7918: 
01:00206D68 4484            	  7919: 	NEG.l		d4				* negate decimal exponent
                            	  7920: LAB_2Y02
01:00206D6A D883            	  7921: 	ADD.l		d3,d4				* add mantissa decimal exponent
01:00206D6C 7620            	  7922: 	MOVEQ		#32,d3			* set up max binary exponent
01:00206D6E 4A81            	  7923: 	TST.l		d1				* test mantissa
01:00206D70 6752            	  7924: 	BEQ.s		LAB_rtn0			* if mantissa=0 return 0
                            	  7925: 
01:00206D72 6B08            	  7926: 	BMI.s		LAB_2Y04			* branch if already mormalised
                            	  7927: 
01:00206D74 5383            	  7928: 	SUBQ.l	#1,d3				* decrement bianry exponent for DBMI loop
                            	  7929: LAB_2Y03
01:00206D76 D281            	  7930: 	ADD.l		d1,d1				* shift mantissa
01:00206D78 5BCBFFFC        	  7931: 	DBMI		d3,LAB_2Y03			* decrement & loop if not normalised
                            	  7932: 
                            	  7933: 							* ensure not too big or small
                            	  7934: LAB_2Y04
01:00206D7C B8BC00000026    	  7935: 	CMP.l		#38,d4			* compare decimal exponent with max exponent
01:00206D82 6E00D7DC        	  7936: 	BGT		LAB_OFER			* if greater do overflow error and warm start
                            	  7937: 
01:00206D86 B8BCFFFFFFDA    	  7938: 	CMP.l		#-38,d4			* compare decimal exponent with min exponent
01:00206D8C 6D34            	  7939: 	BLT.s		LAB_ret0			* if less just return zero
                            	  7940: 
01:00206D8E 4484            	  7941: 	NEG.l		d4				* negate decimal exponent to go right way
01:00206D90 C9FC0006        	  7942: 	MULS		#6,d4				* 6 bytes per entry
01:00206D94 2F08            	  7943: 	MOVE.l	a0,-(sp)			* save register
01:00206D96 41FA0210        	  7944: 	LEA		LAB_P_10(pc),a0		* point to table
01:00206D9A 17704000059C    	  7945: 	MOVE.b	(a0,d4.w),FAC2_e(a3)	* copy exponent for multiply
01:00206DA0 277040020598    	  7946: 	MOVE.l	2(a0,d4.w),FAC2_m(a3)	* copy table mantissa
01:00206DA6 205F            	  7947: 	MOVE.l	(sp)+,a0			* restore register
                            	  7948: 
01:00206DA8 0A030080        	  7949: 	EORI.b	#$80,d3			* normalise input exponent
01:00206DAC 27410590        	  7950: 	MOVE.l	d1,FAC1_m(a3)		* save input mantissa
01:00206DB0 17430594        	  7951: 	MOVE.b	d3,FAC1_e(a3)		* save input exponent
01:00206DB4 176B0595059E    	  7952: 	MOVE.b	FAC1_s(a3),FAC_sc(a3)	* set sign as sign compare
                            	  7953: 
01:00206DBA 4CDF003E        	  7954: 	MOVEM.l	(sp)+,d1-d5			* restore registers
01:00206DBE 6000F064        	  7955: 	BRA		LAB_MULTIPLY		* go multiply input by table
                            	  7956: 
                            	  7957: LAB_ret0
01:00206DC2 7200            	  7958: 	MOVEQ		#0,d1				* clear mantissa
                            	  7959: LAB_rtn0
01:00206DC4 2601            	  7960: 	MOVE.l	d1,d3				* clear exponent
01:00206DC6 17430594        	  7961: 	MOVE.b	d3,FAC1_e(a3)		* save exponent
01:00206DCA 27410590        	  7962: 	MOVE.l	d1,FAC1_m(a3)		* save mantissa
01:00206DCE 4CDF003E        	  7963: 	MOVEM.l	(sp)+,d1-d5			* restore registers
01:00206DD2 4E75            	  7964: 	RTS
                            	  7965: 
                            	  7966: 
                            	  7967: *************************************************************************************
                            	  7968: *
                            	  7969: * $ for hex add-on
                            	  7970: 
                            	  7971: * gets here if the first character was "$" for hex
                            	  7972: * get hex number
                            	  7973: 
                            	  7974: LAB_CHEX
01:00206DD4 177C004005B5    	  7975: 	MOVE.b	#$40,Dtypef(a3)		* set integer numeric data type
01:00206DDA 7620            	  7976: 	MOVEQ		#32,d3			* set up max binary exponent
                            	  7977: LAB_CHXX
01:00206DDC 6100E3CE        	  7978: 	BSR		LAB_IGBY			* increment & scan memory
01:00206DE0 6514            	  7979: 	BCS.s		LAB_ISHN			* branch if numeric character
                            	  7980: 
01:00206DE2 803C0020        	  7981: 	OR.b		#$20,d0			* case convert, allow "A" to "F" and "a" to "f"
01:00206DE6 903C0061        	  7982: 	SUB.b		#'a',d0			* subtract "a"
01:00206DEA 652A            	  7983: 	BCS.s		LAB_CHX3			* exit if <"a"
                            	  7984: 
01:00206DEC B03C0006        	  7985: 	CMP.b		#$06,d0			* compare normalised with $06 (max+1)
01:00206DF0 6424            	  7986: 	BCC.s		LAB_CHX3			* exit if >"f"
                            	  7987: 
01:00206DF2 D03C003A        	  7988: 	ADD.b		#$3A,d0			* convert to nibble+"0"
                            	  7989: LAB_ISHN
01:00206DF6 616C            	  7990: 	BSR.s		d1x16				* multiply d1 by 16 and add the character
01:00206DF8 64E2            	  7991: 	BCC.s		LAB_CHXX			* loop for more if no overflow
                            	  7992: 
                            	  7993: 							* overflowed mantissa, count 16s exponent
                            	  7994: LAB_CHX1
01:00206DFA 5883            	  7995: 	ADDQ.l	#4,d3				* increment mantissa exponent count
01:00206DFC 6900D762        	  7996: 	BVS		LAB_OFER			* do overflow error if overflowed
                            	  7997: 
01:00206E00 6100E3AA        	  7998: 	BSR		LAB_IGBY			* get next character
01:00206E04 65F4            	  7999: 	BCS.s		LAB_CHX1			* loop while numeric character
                            	  8000: 
01:00206E06 803C0020        	  8001: 	OR.b		#$20,d0			* case convert, allow "A" to "F" and "a" to "f"
01:00206E0A 903C0061        	  8002: 	SUB.b		#'a',d0			* subtract "a"
01:00206E0E 6506            	  8003: 	BCS.s		LAB_CHX3			* exit if <"a"
                            	  8004: 
01:00206E10 B03C0006        	  8005: 	CMP.b		#$06,d0			* compare normalised with $06 (max+1)
01:00206E14 65E4            	  8006: 	BCS.s		LAB_CHX1			* loop if <="f"
                            	  8007: 
                            	  8008: 							* now return value
                            	  8009: LAB_CHX3
01:00206E16 4A81            	  8010: 	TST.l		d1				* test mantissa
01:00206E18 67AA            	  8011: 	BEQ.s		LAB_rtn0			* if mantissa=0 return 0
                            	  8012: 
01:00206E1A 6B08            	  8013: 	BMI.s		LAB_exxf			* branch if already mormalised
                            	  8014: 
01:00206E1C 5383            	  8015: 	SUBQ.l	#1,d3				* decrement bianry exponent for DBMI loop
                            	  8016: LAB_CHX2
01:00206E1E D281            	  8017: 	ADD.l		d1,d1				* shift mantissa
01:00206E20 5BCBFFFC        	  8018: 	DBMI		d3,LAB_CHX2			* decrement & loop if not normalised
                            	  8019: 
                            	  8020: LAB_exxf
01:00206E24 0A030080        	  8021: 	EORI.b	#$80,d3			* normalise exponent
01:00206E28 17430594        	  8022: 	MOVE.b	d3,FAC1_e(a3)		* save exponent
01:00206E2C 27410590        	  8023: 	MOVE.l	d1,FAC1_m(a3)		* save mantissa
01:00206E30 4CDF003E        	  8024: 	MOVEM.l	(sp)+,d1-d5			* restore registers
                            	  8025: RTS_024
01:00206E34 4E75            	  8026: 	RTS
                            	  8027: 
                            	  8028: 
                            	  8029: *************************************************************************************
                            	  8030: *
                            	  8031: * % for binary add-on
                            	  8032: 
                            	  8033: * gets here if the first character was "%" for binary
                            	  8034: * get binary number
                            	  8035: 
                            	  8036: LAB_CBIN
01:00206E36 177C004005B5    	  8037: 	MOVE.b	#$40,Dtypef(a3)		* set integer numeric data type
01:00206E3C 7620            	  8038: 	MOVEQ		#32,d3			* set up max binary exponent
                            	  8039: LAB_CBXN
01:00206E3E 6100E36C        	  8040: 	BSR		LAB_IGBY			* increment & scan memory
01:00206E42 64D2            	  8041: 	BCC.s		LAB_CHX3			* if not numeric character go return value
                            	  8042: 
01:00206E44 B03C0032        	  8043: 	CMP.b		#'2',d0			* compare with "2" (max+1)
01:00206E48 64CC            	  8044: 	BCC.s		LAB_CHX3			* if >="2" go return value
                            	  8045: 
01:00206E4A 2401            	  8046: 	MOVE.l	d1,d2				* copy value
01:00206E4C 6124            	  8047: 	BSR.s		d1x02				* multiply d1 by 2 and add character
01:00206E4E 64EE            	  8048: 	BCC.s		LAB_CBXN			* loop for more if no overflow
                            	  8049: 
                            	  8050: 							* overflowed mantissa, count 2s exponent
                            	  8051: LAB_CBX1
01:00206E50 5283            	  8052: 	ADDQ.l	#1,d3				* increment mantissa exponent count
01:00206E52 6900D70C        	  8053: 	BVS		LAB_OFER			* do overflow error if overflowed
                            	  8054: 
01:00206E56 6100E354        	  8055: 	BSR		LAB_IGBY			* get next character
01:00206E5A 64BA            	  8056: 	BCC.s		LAB_CHX3			* if not numeric character go return value
                            	  8057: 
01:00206E5C B03C0032        	  8058: 	CMP.b		#'2',d0			* compare with "2" (max+1)
01:00206E60 65EE            	  8059: 	BCS.s		LAB_CBX1			* loop if <"2"
                            	  8060: 
01:00206E62 60B2            	  8061: 	BRA.s		LAB_CHX3			* if not numeric character go return value
                            	  8062: 
                            	  8063: * half way decent times 16 and times 2 with overflow checks
                            	  8064: 
                            	  8065: d1x16
01:00206E64 2401            	  8066: 	MOVE.l	d1,d2				* copy value
01:00206E66 D482            	  8067: 	ADD.l		d2,d2				* times two
01:00206E68 65CA            	  8068: 	BCS.s		RTS_024			* return if overflow
                            	  8069: 
01:00206E6A D482            	  8070: 	ADD.l		d2,d2				* times four
01:00206E6C 65C6            	  8071: 	BCS.s		RTS_024			* return if overflow
                            	  8072: 
01:00206E6E D482            	  8073: 	ADD.l		d2,d2				* times eight
01:00206E70 65C2            	  8074: 	BCS.s		RTS_024			* return if overflow
                            	  8075: 
                            	  8076: d1x02
01:00206E72 D482            	  8077: 	ADD.l		d2,d2				* times sixteen (ten/two)
01:00206E74 65BE            	  8078: 	BCS.s		RTS_024			* return if overflow
                            	  8079: 
                            	  8080: * now add in new digit
                            	  8081: 
01:00206E76 C0BC000000FF    	  8082: 	AND.l		#$FF,d0			* mask character
01:00206E7C 903C0030        	  8083: 	SUB.b		#'0',d0			* convert to value
01:00206E80 D480            	  8084: 	ADD.l		d0,d2				* add to result
01:00206E82 65B0            	  8085: 	BCS.s		RTS_024			* return if overflow, it should never ever do
                            	  8086: 							* this
                            	  8087: 
01:00206E84 2202            	  8088: 	MOVE.l	d2,d1				* copy result
01:00206E86 4E75            	  8089: 	RTS
                            	  8090: 
                            	  8091: * half way decent times 10 with overflow checks
                            	  8092: 
                            	  8093: d1x10
01:00206E88 2401            	  8094: 	MOVE.l	d1,d2				* copy value
01:00206E8A D482            	  8095: 	ADD.l		d2,d2				* times two
01:00206E8C 6508            	  8096: 	BCS.s		RTS_025			* return if overflow
                            	  8097: 
01:00206E8E D482            	  8098: 	ADD.l		d2,d2				* times four
01:00206E90 6504            	  8099: 	BCS.s		RTS_025			* return if overflow
                            	  8100: 
01:00206E92 D481            	  8101: 	ADD.l		d1,d2				* times five
01:00206E94 64DC            	  8102: 	BCC.s		d1x02				* do times two and add in new digit if ok
                            	  8103: 
                            	  8104: RTS_025
01:00206E96 4E75            	  8105: 	RTS
                            	  8106: 
                            	  8107: 
                            	  8108: *************************************************************************************
                            	  8109: *
                            	  8110: * token values needed for BASIC
                            	  8111: 
                            	  8112: TK_END		EQU $80			* $80
                            	  8113: TK_FOR		EQU TK_END+1		* $81
                            	  8114: TK_NEXT		EQU TK_FOR+1		* $82
                            	  8115: TK_DATA		EQU TK_NEXT+1		* $83
                            	  8116: TK_INPUT		EQU TK_DATA+1		* $84
                            	  8117: TK_DIM		EQU TK_INPUT+1		* $85
                            	  8118: TK_READ		EQU TK_DIM+1		* $86
                            	  8119: TK_LET		EQU TK_READ+1		* $87
                            	  8120: TK_DEC		EQU TK_LET+1		* $88
                            	  8121: TK_GOTO		EQU TK_DEC+1		* $89
                            	  8122: TK_RUN		EQU TK_GOTO+1		* $8A
                            	  8123: TK_IF			EQU TK_RUN+1		* $8B
                            	  8124: TK_RESTORE		EQU TK_IF+1			* $8C
                            	  8125: TK_GOSUB		EQU TK_RESTORE+1		* $8D
                            	  8126: TK_RETURN		EQU TK_GOSUB+1		* $8E
                            	  8127: TK_REM		EQU TK_RETURN+1		* $8F
                            	  8128: TK_STOP		EQU TK_REM+1		* $90
                            	  8129: TK_ON			EQU TK_STOP+1		* $91
                            	  8130: TK_NULL		EQU TK_ON+1			* $92
                            	  8131: TK_INC		EQU TK_NULL+1		* $93
                            	  8132: TK_WAIT		EQU TK_INC+1		* $94
                            	  8133: TK_LOAD		EQU TK_WAIT+1		* $95
                            	  8134: TK_SAVE		EQU TK_LOAD+1		* $96
                            	  8135: TK_DEF		EQU TK_SAVE+1		* $97
                            	  8136: TK_POKE		EQU TK_DEF+1		* $98
                            	  8137: TK_DOKE		EQU TK_POKE+1		* $99
                            	  8138: TK_LOKE		EQU TK_DOKE+1		* $9A
                            	  8139: TK_CALL		EQU TK_LOKE+1		* $9B
                            	  8140: TK_DO			EQU TK_CALL+1		* $9C
                            	  8141: TK_LOOP		EQU TK_DO+1			* $9D
                            	  8142: TK_PRINT		EQU TK_LOOP+1		* $9E
                            	  8143: TK_CONT		EQU TK_PRINT+1		* $9F
                            	  8144: TK_LIST		EQU TK_CONT+1		* $A0
                            	  8145: TK_CLEAR		EQU TK_LIST+1		* $A1
                            	  8146: TK_NEW		EQU TK_CLEAR+1		* $A2
                            	  8147: TK_WIDTH		EQU TK_NEW+1		* $A3
                            	  8148: TK_GET		EQU TK_WIDTH+1		* $A4
                            	  8149: TK_SWAP		EQU TK_GET+1		* $A5
                            	  8150: TK_BITSET		EQU TK_SWAP+1		* $A6
                            	  8151: TK_BITCLR		EQU TK_BITSET+1		* $A7
                            	  8152: TK_TAB		EQU TK_BITCLR+1		* $A8
                            	  8153: TK_ELSE		EQU TK_TAB+1		* $A9
                            	  8154: TK_TO			EQU TK_ELSE+1		* $AA
                            	  8155: TK_FN			EQU TK_TO+1			* $AB
                            	  8156: TK_SPC		EQU TK_FN+1			* $AC
                            	  8157: TK_THEN		EQU TK_SPC+1		* $AD
                            	  8158: TK_NOT		EQU TK_THEN+1		* $AE
                            	  8159: TK_STEP		EQU TK_NOT+1		* $AF
                            	  8160: TK_UNTIL		EQU TK_STEP+1		* $B0
                            	  8161: TK_WHILE		EQU TK_UNTIL+1		* $B1
                            	  8162: TK_PLUS		EQU TK_WHILE+1		* $B2
                            	  8163: TK_MINUS		EQU TK_PLUS+1		* $B3
                            	  8164: TK_MULT		EQU TK_MINUS+1		* $B4
                            	  8165: TK_DIV		EQU TK_MULT+1		* $B5
                            	  8166: TK_POWER		EQU TK_DIV+1		* $B6
                            	  8167: TK_AND		EQU TK_POWER+1		* $B7
                            	  8168: TK_EOR		EQU TK_AND+1		* $B8
                            	  8169: TK_OR			EQU TK_EOR+1		* $B9
                            	  8170: TK_RSHIFT		EQU TK_OR+1			* $BA
                            	  8171: TK_LSHIFT		EQU TK_RSHIFT+1		* $BB
                            	  8172: TK_GT			EQU TK_LSHIFT+1		* $BC
                            	  8173: TK_EQUAL		EQU TK_GT+1			* $BD
                            	  8174: TK_LT			EQU TK_EQUAL+1		* $BE
                            	  8175: TK_SGN		EQU TK_LT+1			* $BF
                            	  8176: TK_INT		EQU TK_SGN+1		* $C0
                            	  8177: TK_ABS		EQU TK_INT+1		* $C1
                            	  8178: TK_USR		EQU TK_ABS+1		* $C2
                            	  8179: TK_FRE		EQU TK_USR+1		* $C3
                            	  8180: TK_POS		EQU TK_FRE+1		* $C4
                            	  8181: TK_SQR		EQU TK_POS+1		* $C5
                            	  8182: TK_RND		EQU TK_SQR+1		* $C6
                            	  8183: TK_LOG		EQU TK_RND+1		* $C7
                            	  8184: TK_EXP		EQU TK_LOG+1		* $C8
                            	  8185: TK_COS		EQU TK_EXP+1		* $C9
                            	  8186: TK_SIN		EQU TK_COS+1		* $CA
                            	  8187: TK_TAN		EQU TK_SIN+1		* $CB
                            	  8188: TK_ATN		EQU TK_TAN+1		* $CC
                            	  8189: TK_PEEK		EQU TK_ATN+1		* $CD
                            	  8190: TK_DEEK		EQU TK_PEEK+1		* $CE
                            	  8191: TK_LEEK		EQU TK_DEEK+1		* $CF
                            	  8192: TK_LEN		EQU TK_LEEK+1		* $D0
                            	  8193: TK_STRS		EQU TK_LEN+1		* $D1
                            	  8194: TK_VAL		EQU TK_STRS+1		* $D2
                            	  8195: TK_ASC		EQU TK_VAL+1		* $D3
                            	  8196: TK_UCASES		EQU TK_ASC+1		* $D4
                            	  8197: TK_LCASES		EQU TK_UCASES+1		* $D5
                            	  8198: TK_CHRS		EQU TK_LCASES+1		* $D6
                            	  8199: TK_HEXS		EQU TK_CHRS+1		* $D7
                            	  8200: TK_BINS		EQU TK_HEXS+1		* $D8
                            	  8201: TK_BITTST		EQU TK_BINS+1		* $D9
                            	  8202: TK_MAX		EQU TK_BITTST+1		* $DA
                            	  8203: TK_MIN		EQU TK_MAX+1		* $DB
                            	  8204: TK_RAM		EQU TK_MIN+1		* $DC
                            	  8205: TK_PI			EQU TK_RAM+1		* $DD
                            	  8206: TK_TWOPI		EQU TK_PI+1			* $DE
                            	  8207: TK_VPTR		EQU TK_TWOPI+1		* $DF
                            	  8208: TK_SADD		EQU TK_VPTR+1		* $E0
                            	  8209: TK_LEFTS		EQU TK_SADD+1		* $E1
                            	  8210: TK_RIGHTS		EQU TK_LEFTS+1		* $E2
                            	  8211: TK_MIDS		EQU TK_RIGHTS+1		* $E3
                            	  8212: TK_USINGS		EQU TK_MIDS+1		* $E4
                            	  8213: 
                            	  8214: 
                            	  8215: *************************************************************************************
                            	  8216: *
                            	  8217: * binary to unsigned decimal table
                            	  8218: 
                            	  8219: Bin2dec
01:00206E98 3B9ACA00        	  8220: 	dc.l	$3B9ACA00				* 1000000000
01:00206E9C 05F5E100        	  8221: 	dc.l	$05F5E100				* 100000000
01:00206EA0 00989680        	  8222: 	dc.l	$00989680				* 10000000
01:00206EA4 000F4240        	  8223: 	dc.l	$000F4240				* 1000000
01:00206EA8 000186A0        	  8224: 	dc.l	$000186A0				* 100000
01:00206EAC 00002710        	  8225: 	dc.l	$00002710				* 10000
01:00206EB0 000003E8        	  8226: 	dc.l	$000003E8				* 1000
01:00206EB4 00000064        	  8227: 	dc.l	$00000064				* 100
01:00206EB8 0000000A        	  8228: 	dc.l	$0000000A				* 10
01:00206EBC 00000000        	  8229: 	dc.l	$00000000				* 0 end marker
                            	  8230: 
                            	  8231: LAB_RSED
01:00206EC0 332E3232        	  8232: 	dc.l	$332E3232				* 858665522
                            	  8233: 
                            	  8234: * string to value exponent table
                            	  8235: 
01:00206EC4 FF00            	  8236: 	dc.w	255<<8				* 10**38
01:00206EC6 96769951        	  8237: 	dc.l	$96769951
01:00206ECA FB00            	  8238: 	dc.w	251<<8				* 10**37
01:00206ECC F0BDC21B        	  8239: 	dc.l	$F0BDC21B
01:00206ED0 F800            	  8240: 	dc.w	248<<8				* 10**36
01:00206ED2 C097CE7C        	  8241: 	dc.l	$C097CE7C
01:00206ED6 F500            	  8242: 	dc.w	245<<8				* 10**35
01:00206ED8 9A130B96        	  8243: 	dc.l	$9A130B96
01:00206EDC F100            	  8244: 	dc.w	241<<8				* 10**34
01:00206EDE F684DF57        	  8245: 	dc.l	$F684DF57
01:00206EE2 EE00            	  8246: 	dc.w	238<<8				* 10**33
01:00206EE4 C5371912        	  8247: 	dc.l	$C5371912
01:00206EE8 EB00            	  8248: 	dc.w	235<<8				* 10**32
01:00206EEA 9DC5ADA8        	  8249: 	dc.l	$9DC5ADA8
01:00206EEE E700            	  8250: 	dc.w	231<<8				* 10**31
01:00206EF0 FC6F7C40        	  8251: 	dc.l	$FC6F7C40
01:00206EF4 E400            	  8252: 	dc.w	228<<8				* 10**30
01:00206EF6 C9F2C9CD        	  8253: 	dc.l	$C9F2C9CD
01:00206EFA E100            	  8254: 	dc.w	225<<8				* 10**29
01:00206EFC A18F07D7        	  8255: 	dc.l	$A18F07D7
01:00206F00 DE00            	  8256: 	dc.w	222<<8				* 10**28
01:00206F02 813F3979        	  8257: 	dc.l	$813F3979
01:00206F06 DA00            	  8258: 	dc.w	218<<8				* 10**27
01:00206F08 CECB8F28        	  8259: 	dc.l	$CECB8F28
01:00206F0C D700            	  8260: 	dc.w	215<<8				* 10**26
01:00206F0E A56FA5BA        	  8261: 	dc.l	$A56FA5BA
01:00206F12 D400            	  8262: 	dc.w	212<<8				* 10**25
01:00206F14 84595161        	  8263: 	dc.l	$84595161
01:00206F18 D000            	  8264: 	dc.w	208<<8				* 10**24
01:00206F1A D3C21BCF        	  8265: 	dc.l	$D3C21BCF
01:00206F1E CD00            	  8266: 	dc.w	205<<8				* 10**23
01:00206F20 A968163F        	  8267: 	dc.l	$A968163F
01:00206F24 CA00            	  8268: 	dc.w	202<<8				* 10**22
01:00206F26 87867832        	  8269: 	dc.l	$87867832
01:00206F2A C600            	  8270: 	dc.w	198<<8				* 10**21
01:00206F2C D8D726B7        	  8271: 	dc.l	$D8D726B7
01:00206F30 C300            	  8272: 	dc.w	195<<8				* 10**20
01:00206F32 AD78EBC6        	  8273: 	dc.l	$AD78EBC6
01:00206F36 C000            	  8274: 	dc.w	192<<8				* 10**19
01:00206F38 8AC72305        	  8275: 	dc.l	$8AC72305
01:00206F3C BC00            	  8276: 	dc.w	188<<8				* 10**18
01:00206F3E DE0B6B3A        	  8277: 	dc.l	$DE0B6B3A
01:00206F42 B900            	  8278: 	dc.w	185<<8				* 10**17
01:00206F44 B1A2BC2F        	  8279: 	dc.l	$B1A2BC2F
01:00206F48 B600            	  8280: 	dc.w	182<<8				* 10**16
01:00206F4A 8E1BC9BF        	  8281: 	dc.l	$8E1BC9BF
01:00206F4E B200            	  8282: 	dc.w	178<<8				* 10**15
01:00206F50 E35FA932        	  8283: 	dc.l	$E35FA932
01:00206F54 AF00            	  8284: 	dc.w	175<<8				* 10**14
01:00206F56 B5E620F5        	  8285: 	dc.l	$B5E620F5
01:00206F5A AC00            	  8286: 	dc.w	172<<8				* 10**13
01:00206F5C 9184E72A        	  8287: 	dc.l	$9184E72A
01:00206F60 A800            	  8288: 	dc.w	168<<8				* 10**12
01:00206F62 E8D4A510        	  8289: 	dc.l	$E8D4A510
01:00206F66 A500            	  8290: 	dc.w	165<<8				* 10**11
01:00206F68 BA43B740        	  8291: 	dc.l	$BA43B740
01:00206F6C A200            	  8292: 	dc.w	162<<8				* 10**10
01:00206F6E 9502F900        	  8293: 	dc.l	$9502F900
01:00206F72 9E00            	  8294: 	dc.w	158<<8				* 10**9
01:00206F74 EE6B2800        	  8295: 	dc.l	$EE6B2800
01:00206F78 9B00            	  8296: 	dc.w	155<<8				* 10**8
01:00206F7A BEBC2000        	  8297: 	dc.l	$BEBC2000
01:00206F7E 9800            	  8298: 	dc.w	152<<8				* 10**7
01:00206F80 98968000        	  8299: 	dc.l	$98968000
01:00206F84 9400            	  8300: 	dc.w	148<<8				* 10**6
01:00206F86 F4240000        	  8301: 	dc.l	$F4240000
01:00206F8A 9100            	  8302: 	dc.w	145<<8				* 10**5
01:00206F8C C3500000        	  8303: 	dc.l	$C3500000
01:00206F90 8E00            	  8304: 	dc.w	142<<8				* 10**4
01:00206F92 9C400000        	  8305: 	dc.l	$9C400000
01:00206F96 8A00            	  8306: 	dc.w	138<<8				* 10**3
01:00206F98 FA000000        	  8307: 	dc.l	$FA000000
01:00206F9C 8700            	  8308: 	dc.w	135<<8				* 10**2
01:00206F9E C8000000        	  8309: 	dc.l	$C8000000
01:00206FA2 8400            	  8310: 	dc.w	132<<8				* 10**1
01:00206FA4 A0000000        	  8311: 	dc.l	$A0000000
                            	  8312: LAB_P_10
01:00206FA8 8100            	  8313: 	dc.w	129<<8				* 10**0
01:00206FAA 80000000        	  8314: 	dc.l	$80000000
01:00206FAE 7D00            	  8315: 	dc.w	125<<8				* 10**-1
01:00206FB0 CCCCCCCD        	  8316: 	dc.l	$CCCCCCCD
01:00206FB4 7A00            	  8317: 	dc.w	122<<8				* 10**-2
01:00206FB6 A3D70A3D        	  8318: 	dc.l	$A3D70A3D
01:00206FBA 7700            	  8319: 	dc.w	119<<8				* 10**-3
01:00206FBC 83126E98        	  8320: 	dc.l	$83126E98
01:00206FC0 7300            	  8321: 	dc.w	115<<8				* 10**-4
01:00206FC2 D1B71759        	  8322: 	dc.l	$D1B71759
01:00206FC6 7000            	  8323: 	dc.w	112<<8				* 10**-5
01:00206FC8 A7C5AC47        	  8324: 	dc.l	$A7C5AC47
01:00206FCC 6D00            	  8325: 	dc.w	109<<8				* 10**-6
01:00206FCE 8637BD06        	  8326: 	dc.l	$8637BD06
01:00206FD2 6900            	  8327: 	dc.w	105<<8				* 10**-7
01:00206FD4 D6BF94D6        	  8328: 	dc.l	$D6BF94D6
01:00206FD8 6600            	  8329: 	dc.w	102<<8				* 10**-8
01:00206FDA ABCC7712        	  8330: 	dc.l	$ABCC7712
01:00206FDE 6300            	  8331: 	dc.w	99<<8					* 10**-9
01:00206FE0 89705F41        	  8332: 	dc.l	$89705F41
01:00206FE4 5F00            	  8333: 	dc.w	95<<8					* 10**-10
01:00206FE6 DBE6FECF        	  8334: 	dc.l	$DBE6FECF
01:00206FEA 5C00            	  8335: 	dc.w	92<<8					* 10**-11
01:00206FEC AFEBFF0C        	  8336: 	dc.l	$AFEBFF0C
01:00206FF0 5900            	  8337: 	dc.w	89<<8					* 10**-12
01:00206FF2 8CBCCC09        	  8338: 	dc.l	$8CBCCC09
01:00206FF6 5500            	  8339: 	dc.w	85<<8					* 10**-13
01:00206FF8 E12E1342        	  8340: 	dc.l	$E12E1342
01:00206FFC 5200            	  8341: 	dc.w	82<<8					* 10**-14
01:00206FFE B424DC35        	  8342: 	dc.l	$B424DC35
01:00207002 4F00            	  8343: 	dc.w	79<<8					* 10**-15
01:00207004 901D7CF7        	  8344: 	dc.l	$901D7CF7
01:00207008 4B00            	  8345: 	dc.w	75<<8					* 10**-16
01:0020700A E69594BF        	  8346: 	dc.l	$E69594BF
01:0020700E 4800            	  8347: 	dc.w	72<<8					* 10**-17
01:00207010 B877AA32        	  8348: 	dc.l	$B877AA32
01:00207014 4500            	  8349: 	dc.w	69<<8					* 10**-18
01:00207016 9392EE8F        	  8350: 	dc.l	$9392EE8F
01:0020701A 4100            	  8351: 	dc.w	65<<8					* 10**-19
01:0020701C EC1E4A7E        	  8352: 	dc.l	$EC1E4A7E
01:00207020 3E00            	  8353: 	dc.w	62<<8					* 10**-20
01:00207022 BCE50865        	  8354: 	dc.l	$BCE50865
01:00207026 3B00            	  8355: 	dc.w	59<<8					* 10**-21
01:00207028 971DA050        	  8356: 	dc.l	$971DA050
01:0020702C 3700            	  8357: 	dc.w	55<<8					* 10**-22
01:0020702E F1C90081        	  8358: 	dc.l	$F1C90081
01:00207032 3400            	  8359: 	dc.w	52<<8					* 10**-23
01:00207034 C16D9A01        	  8360: 	dc.l	$C16D9A01
01:00207038 3100            	  8361: 	dc.w	49<<8					* 10**-24
01:0020703A 9ABE14CD        	  8362: 	dc.l	$9ABE14CD
01:0020703E 2D00            	  8363: 	dc.w	45<<8					* 10**-25
01:00207040 F79687AE        	  8364: 	dc.l	$F79687AE
01:00207044 2A00            	  8365: 	dc.w	42<<8					* 10**-26
01:00207046 C6120625        	  8366: 	dc.l	$C6120625
01:0020704A 2700            	  8367: 	dc.w	39<<8					* 10**-27
01:0020704C 9E74D1B8        	  8368: 	dc.l	$9E74D1B8
01:00207050 2300            	  8369: 	dc.w	35<<8					* 10**-28
01:00207052 FD87B5F3        	  8370: 	dc.l	$FD87B5F3
01:00207056 2000            	  8371: 	dc.w	32<<8					* 10**-29
01:00207058 CAD2F7F5        	  8372: 	dc.l	$CAD2F7F5
01:0020705C 1D00            	  8373: 	dc.w	29<<8					* 10**-30
01:0020705E A2425FF7        	  8374: 	dc.l	$A2425FF7
01:00207062 1A00            	  8375: 	dc.w	26<<8					* 10**-31
01:00207064 81CEB32C        	  8376: 	dc.l	$81CEB32C
01:00207068 1600            	  8377: 	dc.w	22<<8					* 10**-32
01:0020706A CFB11EAD        	  8378: 	dc.l	$CFB11EAD
01:0020706E 1300            	  8379: 	dc.w	19<<8					* 10**-33
01:00207070 A6274BBE        	  8380: 	dc.l	$A6274BBE
01:00207074 1000            	  8381: 	dc.w	16<<8					* 10**-34
01:00207076 84EC3C98        	  8382: 	dc.l	$84EC3C98
01:0020707A 0C00            	  8383: 	dc.w	12<<8					* 10**-35
01:0020707C D4AD2DC0        	  8384: 	dc.l	$D4AD2DC0
01:00207080 0900            	  8385: 	dc.w	9<<8					* 10**-36
01:00207082 AA242499        	  8386: 	dc.l	$AA242499
01:00207086 0600            	  8387: 	dc.w	6<<8					* 10**-37
01:00207088 881CEA14        	  8388: 	dc.l	$881CEA14
01:0020708C 0200            	  8389: 	dc.w	2<<8					* 10**-38
01:0020708E D9C7DCED        	  8390: 	dc.l	$D9C7DCED
                            	  8391: 
                            	  8392: 
                            	  8393: *************************************************************************************
                            	  8394: *
                            	  8395: * table of constants for cordic SIN/COS/TAN calculations
                            	  8396: * constants are un normalised fractions and are atn(2^-i)/2pi
                            	  8397: 
01:00207092 4DBA76D4        	  8398: 	dc.l	$4DBA76D4				* SIN/COS multiply constant
                            	  8399: TAB_SNCO
01:00207096 20000000        	  8400: 	dc.l	$20000000				* atn(2^0)/2pi
01:0020709A 12E4051E        	  8401: 	dc.l	$12E4051E				* atn(2^1)/2pi
01:0020709E 09FB385C        	  8402: 	dc.l	$09FB385C				* atn(2^2)/2pi
01:002070A2 051111D5        	  8403: 	dc.l	$051111D5				* atn(2^3)/2pi
01:002070A6 028B0D44        	  8404: 	dc.l	$028B0D44				* atn(2^4)/2pi
01:002070AA 0145D7E2        	  8405: 	dc.l	$0145D7E2				* atn(2^5)/2pi
01:002070AE 00A2F61F        	  8406: 	dc.l	$00A2F61F				* atn(2^6)/2pi
01:002070B2 00517C56        	  8407: 	dc.l	$00517C56				* atn(2^7)/2pi
01:002070B6 0028BE54        	  8408: 	dc.l	$0028BE54				* atn(2^8)/2pi
01:002070BA 00145F2F        	  8409: 	dc.l	$00145F2F				* atn(2^9)/2pi
01:002070BE 000A2F99        	  8410: 	dc.l	$000A2F99				* atn(2^10)/2pi
01:002070C2 000517CD        	  8411: 	dc.l	$000517CD				* atn(2^11)/2pi
01:002070C6 00028BE7        	  8412: 	dc.l	$00028BE7				* atn(2^12)/2pi
01:002070CA 000145F4        	  8413: 	dc.l	$000145F4				* atn(2^13)/2pi
01:002070CE 0000A2FA        	  8414: 	dc.l	$0000A2FA				* atn(2^14)/2pi
01:002070D2 0000517D        	  8415: 	dc.l	$0000517D				* atn(2^15)/2pi
01:002070D6 000028BF        	  8416: 	dc.l	$000028BF				* atn(2^16)/2pi
01:002070DA 00001460        	  8417: 	dc.l	$00001460				* atn(2^17)/2pi
01:002070DE 00000A30        	  8418: 	dc.l	$00000A30				* atn(2^18)/2pi
01:002070E2 00000518        	  8419: 	dc.l	$00000518				* atn(2^19)/2pi
01:002070E6 0000028C        	  8420: 	dc.l	$0000028C				* atn(2^20)/2pi
01:002070EA 00000146        	  8421: 	dc.l	$00000146				* atn(2^21)/2pi
01:002070EE 000000A3        	  8422: 	dc.l	$000000A3				* atn(2^22)/2pi
01:002070F2 00000052        	  8423: 	dc.l	$00000052				* atn(2^23)/2pi
01:002070F6 00000029        	  8424: 	dc.l	$00000029				* atn(2^24)/2pi
01:002070FA 00000015        	  8425: 	dc.l	$00000015				* atn(2^25)/2pi
01:002070FE 0000000B        	  8426: 	dc.l	$0000000B				* atn(2^26)/2pi
01:00207102 00000006        	  8427: 	dc.l	$00000006				* atn(2^27)/2pi
01:00207106 00000003        	  8428: 	dc.l	$00000003				* atn(2^28)/2pi
01:0020710A 00000002        	  8429: 	dc.l	$00000002				* atn(2^29)/2pi
01:0020710E 00000001        	  8430: 	dc.l	$00000001				* atn(2^30)/2pi
01:00207112 00000001        	  8431: 	dc.l	$00000001				* atn(2^31)/2pi
                            	  8432: 
                            	  8433: 
                            	  8434: *************************************************************************************
                            	  8435: *
                            	  8436: * table of constants for cordic ATN calculation
                            	  8437: * constants are normalised to two integer bits and are atn(2^-i)
                            	  8438: 
                            	  8439: TAB_ATNC
01:00207116 1DAC6705        	  8440: 	dc.l	$1DAC6705				* atn(2^-1)
01:0020711A 0FADBAFD        	  8441: 	dc.l	$0FADBAFD				* atn(2^-2)
01:0020711E 07F56EA7        	  8442: 	dc.l	$07F56EA7				* atn(2^-3)
01:00207122 03FEAB77        	  8443: 	dc.l	$03FEAB77				* atn(2^-4)
01:00207126 01FFD55C        	  8444: 	dc.l	$01FFD55C				* atn(2^-5)
01:0020712A 00FFFAAB        	  8445: 	dc.l	$00FFFAAB				* atn(2^-6)
01:0020712E 007FFF55        	  8446: 	dc.l	$007FFF55				* atn(2^-7)
01:00207132 003FFFEB        	  8447: 	dc.l	$003FFFEB				* atn(2^-8)
01:00207136 001FFFFD        	  8448: 	dc.l	$001FFFFD				* atn(2^-9)
01:0020713A 00100000        	  8449: 	dc.l	$00100000				* atn(2^-10)
01:0020713E 00080000        	  8450: 	dc.l	$00080000				* atn(2^-11)
01:00207142 00040000        	  8451: 	dc.l	$00040000				* atn(2^-12)
01:00207146 00020000        	  8452: 	dc.l	$00020000				* atn(2^-13)
01:0020714A 00010000        	  8453: 	dc.l	$00010000				* atn(2^-14)
01:0020714E 00008000        	  8454: 	dc.l	$00008000				* atn(2^-15)
01:00207152 00004000        	  8455: 	dc.l	$00004000				* atn(2^-16)
01:00207156 00002000        	  8456: 	dc.l	$00002000				* atn(2^-17)
01:0020715A 00001000        	  8457: 	dc.l	$00001000				* atn(2^-18)
01:0020715E 00000800        	  8458: 	dc.l	$00000800				* atn(2^-19)
01:00207162 00000400        	  8459: 	dc.l	$00000400				* atn(2^-20)
01:00207166 00000200        	  8460: 	dc.l	$00000200				* atn(2^-21)
01:0020716A 00000100        	  8461: 	dc.l	$00000100				* atn(2^-22)
01:0020716E 00000080        	  8462: 	dc.l	$00000080				* atn(2^-23)
01:00207172 00000040        	  8463: 	dc.l	$00000040				* atn(2^-24)
01:00207176 00000020        	  8464: 	dc.l	$00000020				* atn(2^-25)
01:0020717A 00000010        	  8465: 	dc.l	$00000010				* atn(2^-26)
01:0020717E 00000008        	  8466: 	dc.l	$00000008				* atn(2^-27)
01:00207182 00000004        	  8467: 	dc.l	$00000004				* atn(2^-28)
01:00207186 00000002        	  8468: 	dc.l	$00000002				* atn(2^-29)
01:0020718A 00000001        	  8469: 	dc.l	$00000001				* atn(2^-30)
                            	  8470: LAB_1D96
01:0020718E 00000000        	  8471: 	dc.l	$00000000				* atn(2^-31)
01:00207192 00000000        	  8472: 	dc.l	$00000000				* atn(2^-32)
                            	  8473: 
                            	  8474: * constants are normalised to n integer bits and are tanh(2^-i)
                            	  8475: n	equ	2
                            	  8476: TAB_HTHET
01:00207196 2327D4F4        	  8477: 	dc.l	$2327d4f4			* atnh(2^-1) .549306144
01:0020719A 1058AEFA        	  8478: 	dc.l	$1058aefa			* atnh(2^-2) .255412812
01:0020719E 080AC48E        	  8479: 	dc.l	$080ac48e			* atnh(2^-3)
01:002071A2 04015622        	  8480: 	dc.l	$04015622			* atnh(2^-4)
01:002071A6 02002AB0        	  8481: 	dc.l	$02002ab0			* atnh(2^-5)
01:002071AA 01000554        	  8482: 	dc.l	$01000554			* atnh(2^-6)
01:002071AE 008000AA        	  8483: 	dc.l	$008000aa			* atnh(2^-7)
01:002071B2 00400014        	  8484: 	dc.l	$00400014			* atnh(2^-8)
01:002071B6 00200002        	  8485: 	dc.l	$00200002			* atnh(2^-9)
01:002071BA 00100000        	  8486: 	dc.l	$00100000			* atnh(2^-10)
01:002071BE 00080000        	  8487: 	dc.l	$00080000			* atnh(2^-11)
01:002071C2 00040000        	  8488: 	dc.l	$00040000			* atnh(2^-12)
01:002071C6 00020000        	  8489: 	dc.l	$00020000			* atnh(2^-13)
01:002071CA 00010000        	  8490: 	dc.l	$00010000			* atnh(2^-14)
01:002071CE 00008000        	  8491: 	dc.l	$00008000			* atnh(2^-15)
01:002071D2 00004000        	  8492: 	dc.l	$00004000			* atnh(2^-16)
01:002071D6 00002000        	  8493: 	dc.l	$00002000			* atnh(2^-17)
01:002071DA 00001000        	  8494: 	dc.l	$00001000			* atnh(2^-18)
01:002071DE 00000800        	  8495: 	dc.l	$00000800			* atnh(2^-19)
01:002071E2 00000400        	  8496: 	dc.l	$00000400			* atnh(2^-20)
01:002071E6 00000200        	  8497: 	dc.l	$00000200			* atnh(2^-21)
01:002071EA 00000100        	  8498: 	dc.l	$00000100			* atnh(2^-22)
01:002071EE 00000080        	  8499: 	dc.l	$00000080			* atnh(2^-23)
01:002071F2 00000040        	  8500: 	dc.l	$00000040			* atnh(2^-24)
01:002071F6 00000020        	  8501: 	dc.l	$00000020			* atnh(2^-25)
01:002071FA 00000010        	  8502: 	dc.l	$00000010			* atnh(2^-26)
01:002071FE 00000008        	  8503: 	dc.l	$00000008			* atnh(2^-27)
01:00207202 00000004        	  8504: 	dc.l	$00000004			* atnh(2^-28)
01:00207206 00000002        	  8505: 	dc.l	$00000002			* atnh(2^-29)
01:0020720A 00000001        	  8506: 	dc.l	$00000001			* atnh(2^-30)
01:0020720E 00000000        	  8507: 	dc.l	$00000000			* atnh(2^-31)
01:00207212 00000000        	  8508: 	dc.l	$00000000			* atnh(2^-32)
                            	  8509: KFCTSEED	equ	$26A3D110		* $26A3D110
                            	  8510: 
                            	  8511: 
                            	  8512: *************************************************************************************
                            	  8513: *
                            	  8514: * command vector table
                            	  8515: 
                            	  8516: LAB_CTBL
01:00207216 D7C8            	  8517: 	dc.w	LAB_END-LAB_CTBL			* END
01:00207218 D6FC            	  8518: 	dc.w	LAB_FOR-LAB_CTBL			* FOR
01:0020721A DD68            	  8519: 	dc.w	LAB_NEXT-LAB_CTBL			* NEXT
01:0020721C D91C            	  8520: 	dc.w	LAB_DATA-LAB_CTBL			* DATA
01:0020721E DC5C            	  8521: 	dc.w	LAB_INPUT-LAB_CTBL		* INPUT
01:00207220 E136            	  8522: 	dc.w	LAB_DIM-LAB_CTBL			* DIM
01:00207222 DC82            	  8523: 	dc.w	LAB_READ-LAB_CTBL			* READ
01:00207224 DA8E            	  8524: 	dc.w	LAB_LET-LAB_CTBL			* LET
01:00207226 DA2C            	  8525: 	dc.w	LAB_DEC-LAB_CTBL			* DEC	
01:00207228 D884            	  8526: 	dc.w	LAB_GOTO-LAB_CTBL			* GOTO
01:0020722A D84C            	  8527: 	dc.w	LAB_RUN-LAB_CTBL			* RUN
01:0020722C D944            	  8528: 	dc.w	LAB_IF-LAB_CTBL			* IF
01:0020722E D7F6            	  8529: 	dc.w	LAB_RESTORE-LAB_CTBL		* RESTORE
01:00207230 D872            	  8530: 	dc.w	LAB_GOSUB-LAB_CTBL		* GOSUB
01:00207232 D908            	  8531: 	dc.w	LAB_RETURN-LAB_CTBL		* RETURN
01:00207234 D9B2            	  8532: 	dc.w	LAB_REM-LAB_CTBL			* REM
01:00207236 D7D0            	  8533: 	dc.w	LAB_STOP-LAB_CTBL			* STOP
01:00207238 D9BA            	  8534: 	dc.w	LAB_ON-LAB_CTBL			* ON
01:0020723A D824            	  8535: 	dc.w	LAB_NULL-LAB_CTBL			* NULL
01:0020723C DA32            	  8536: 	dc.w	LAB_INC-LAB_CTBL			* INC	
01:0020723E EA34            	  8537: 	dc.w	LAB_WAIT-LAB_CTBL			* WAIT
01:00207240 EA22            	  8538: 	dc.w	LAB_LOAD-LAB_CTBL			* LOAD
01:00207242 EA26            	  8539: 	dc.w	LAB_SAVE-LAB_CTBL			* SAVE
01:00207244 E4C6            	  8540: 	dc.w	LAB_DEF-LAB_CTBL			* DEF
01:00207246 E9A2            	  8541: 	dc.w	LAB_POKE-LAB_CTBL			* POKE
01:00207248 E9D2            	  8542: 	dc.w	LAB_DOKE-LAB_CTBL			* DOKE
01:0020724A E9D8            	  8543: 	dc.w	LAB_LOKE-LAB_CTBL			* LOKE
01:0020724C EA2A            	  8544: 	dc.w	LAB_CALL-LAB_CTBL			* CALL
01:0020724E D860            	  8545: 	dc.w	LAB_DO-LAB_CTBL			* DO	
01:00207250 D8B2            	  8546: 	dc.w	LAB_LOOP-LAB_CTBL			* LOOP
01:00207252 DB22            	  8547: 	dc.w	LAB_PRINT-LAB_CTBL		* PRINT
01:00207254 D82E            	  8548: 	dc.w	LAB_CONT-LAB_CTBL			* CONT
01:00207256 D648            	  8549: 	dc.w	LAB_LIST-LAB_CTBL			* LIST
01:00207258 D644            	  8550: 	dc.w	LAB_CLEAR-LAB_CTBL		* CLEAR
01:0020725A D5F4            	  8551: 	dc.w	LAB_NEW-LAB_CTBL			* NEW
01:0020725C F954            	  8552: 	dc.w	LAB_WDTH-LAB_CTBL			* WIDTH
01:0020725E DAE8            	  8553: 	dc.w	LAB_GET-LAB_CTBL			* GET
01:00207260 E9EC            	  8554: 	dc.w	LAB_SWAP-LAB_CTBL			* SWAP
01:00207262 F4A2            	  8555: 	dc.w	LAB_BITSET-LAB_CTBL		* BITSET
01:00207264 F4B2            	  8556: 	dc.w	LAB_BITCLR-LAB_CTBL		* BITCLR
                            	  8557: 
                            	  8558: 
                            	  8559: *************************************************************************************
                            	  8560: *
                            	  8561: * function pre process routine table
                            	  8562: 
                            	  8563: LAB_FTPP
01:00207266 DFE4            	  8564: 	dc.w	LAB_PPFN-LAB_FTPP			* SGN(n)	process numeric expression in ()
01:00207268 DFE4            	  8565: 	dc.w	LAB_PPFN-LAB_FTPP			* INT(n)		"
01:0020726A DFE4            	  8566: 	dc.w	LAB_PPFN-LAB_FTPP			* ABS(n)		"
01:0020726C DDE8            	  8567: 	dc.w	LAB_EVEZ-LAB_FTPP			* USR(x)	process any expression
01:0020726E DF30            	  8568: 	dc.w	LAB_1BF7-LAB_FTPP			* FRE(x)	process any expression in ()
01:00207270 DF30            	  8569: 	dc.w	LAB_1BF7-LAB_FTPP			* POS(x)		"
01:00207272 DFE4            	  8570: 	dc.w	LAB_PPFN-LAB_FTPP			* SQR(n)	process numeric expression in ()
01:00207274 DFE4            	  8571: 	dc.w	LAB_PPFN-LAB_FTPP			* RND(n)		"
01:00207276 DFE4            	  8572: 	dc.w	LAB_PPFN-LAB_FTPP			* LOG(n)		"
01:00207278 DFE4            	  8573: 	dc.w	LAB_PPFN-LAB_FTPP			* EXP(n)		"
01:0020727A DFE4            	  8574: 	dc.w	LAB_PPFN-LAB_FTPP			* COS(n)		"
01:0020727C DFE4            	  8575: 	dc.w	LAB_PPFN-LAB_FTPP			* SIN(n)		"
01:0020727E DFE4            	  8576: 	dc.w	LAB_PPFN-LAB_FTPP			* TAN(n)		"
01:00207280 DFE4            	  8577: 	dc.w	LAB_PPFN-LAB_FTPP			* ATN(n)		"
01:00207282 DFE4            	  8578: 	dc.w	LAB_PPFN-LAB_FTPP			* PEEK(n)		"
01:00207284 DFE4            	  8579: 	dc.w	LAB_PPFN-LAB_FTPP			* DEEK(n)		"
01:00207286 DFE4            	  8580: 	dc.w	LAB_PPFN-LAB_FTPP			* LEEK(n)		"
01:00207288 DFD6            	  8581: 	dc.w	LAB_PPFS-LAB_FTPP			* LEN($)	process string expression in ()
01:0020728A DFE4            	  8582: 	dc.w	LAB_PPFN-LAB_FTPP			* STR$(n)	process numeric expression in ()
01:0020728C DFD6            	  8583: 	dc.w	LAB_PPFS-LAB_FTPP			* VAL($)	process string expression in ()
01:0020728E DFD6            	  8584: 	dc.w	LAB_PPFS-LAB_FTPP			* ASC($)		"
01:00207290 DFD6            	  8585: 	dc.w	LAB_PPFS-LAB_FTPP			* UCASE$($)		"
01:00207292 DFD6            	  8586: 	dc.w	LAB_PPFS-LAB_FTPP			* LCASE$($)		"
01:00207294 DFE4            	  8587: 	dc.w	LAB_PPFN-LAB_FTPP			* CHR$(n)	process numeric expression in ()
01:00207296 E01E            	  8588: 	dc.w	LAB_BHSS-LAB_FTPP			* HEX$()	bin/hex pre process
01:00207298 E01E            	  8589: 	dc.w	LAB_BHSS-LAB_FTPP			* BIN$()		"
01:0020729A 0000            	  8590: 	dc.w	$0000					* BITTST()	none
01:0020729C 0000            	  8591: 	dc.w	$0000					* MAX()		"
01:0020729E 0000            	  8592: 	dc.w	$0000					* MIN()		"
01:002072A0 DFF2            	  8593: 	dc.w	LAB_PPBI-LAB_FTPP			* RAMBASE	advance pointer
01:002072A2 DFF2            	  8594: 	dc.w	LAB_PPBI-LAB_FTPP			* PI			"
01:002072A4 DFF2            	  8595: 	dc.w	LAB_PPBI-LAB_FTPP			* TWOPI		"
01:002072A6 0000            	  8596: 	dc.w	$0000					* VARPTR()	none
01:002072A8 0000            	  8597: 	dc.w	$0000					* SADD()		"
01:002072AA DFFC            	  8598: 	dc.w	LAB_LRMS-LAB_FTPP			* LEFT$()	process string expression
01:002072AC DFFC            	  8599: 	dc.w	LAB_LRMS-LAB_FTPP			* RIGHT$()		"
01:002072AE DFFC            	  8600: 	dc.w	LAB_LRMS-LAB_FTPP			* MID$()		"
01:002072B0 DDE8            	  8601: 	dc.w	LAB_EVEZ-LAB_FTPP			* USING$(x)	process any expression
                            	  8602: 
                            	  8603: 
                            	  8604: *************************************************************************************
                            	  8605: *
                            	  8606: * action addresses for functions
                            	  8607: 
                            	  8608: LAB_FTBL
01:002072B2 ED5E            	  8609: 	dc.w	LAB_SGN-LAB_FTBL			* SGN()
01:002072B4 EDE0            	  8610: 	dc.w	LAB_INT-LAB_FTBL			* INT()
01:002072B6 ED70            	  8611: 	dc.w	LAB_ABS-LAB_FTBL			* ABS()
01:002072B8 E97E            	  8612: 	dc.w	LAB_USR-LAB_FTBL			* USR()
01:002072BA E3E2            	  8613: 	dc.w	LAB_FRE-LAB_FTBL			* FRE()
01:002072BC E414            	  8614: 	dc.w	LAB_POS-LAB_FTBL			* POS()
01:002072BE F938            	  8615: 	dc.w	LAB_SQR-LAB_FTBL			* SQR()
01:002072C0 F228            	  8616: 	dc.w	LAB_RND-LAB_FTBL			* RND()
01:002072C2 EA80            	  8617: 	dc.w	LAB_LOG-LAB_FTBL			* LOG()
01:002072C4 F10E            	  8618: 	dc.w	LAB_EXP-LAB_FTBL			* EXP()
01:002072C6 F27C            	  8619: 	dc.w	LAB_COS-LAB_FTBL			* COS()
01:002072C8 F294            	  8620: 	dc.w	LAB_SIN-LAB_FTBL			* SIN()
01:002072CA F25A            	  8621: 	dc.w	LAB_TAN-LAB_FTBL			* TAN()
01:002072CC F354            	  8622: 	dc.w	LAB_ATN-LAB_FTBL			* ATN()
01:002072CE E8FA            	  8623: 	dc.w	LAB_PEEK-LAB_FTBL			* PEEK()
01:002072D0 E90C            	  8624: 	dc.w	LAB_DEEK-LAB_FTBL			* DEEK()
01:002072D2 E922            	  8625: 	dc.w	LAB_LEEK-LAB_FTBL			* LEEK()
01:002072D4 E83E            	  8626: 	dc.w	LAB_LENS-LAB_FTBL			* LEN()
01:002072D6 E50A            	  8627: 	dc.w	LAB_STRS-LAB_FTBL			* STR$()
01:002072D8 E882            	  8628: 	dc.w	LAB_VAL-LAB_FTBL			* VAL()
01:002072DA E846            	  8629: 	dc.w	LAB_ASC-LAB_FTBL			* ASC()
01:002072DC E7F4            	  8630: 	dc.w	LAB_UCASE-LAB_FTBL		* UCASE$()
01:002072DE E7C4            	  8631: 	dc.w	LAB_LCASE-LAB_FTBL		* LCASE$()
01:002072E0 E72C            	  8632: 	dc.w	LAB_CHRS-LAB_FTBL			* CHR$()
01:002072E2 F7DC            	  8633: 	dc.w	LAB_HEXS-LAB_FTBL			* HEX$()
01:002072E4 F78A            	  8634: 	dc.w	LAB_BINS-LAB_FTBL			* BIN$()
01:002072E6 F426            	  8635: 	dc.w	LAB_BTST-LAB_FTBL			* BITTST()
01:002072E8 F848            	  8636: 	dc.w	LAB_MAX-LAB_FTBL			* MAX()
01:002072EA F85E            	  8637: 	dc.w	LAB_MIN-LAB_FTBL			* MIN()
01:002072EC F9AA            	  8638: 	dc.w	LAB_RAM-LAB_FTBL			* RAMBASE
01:002072EE F9B4            	  8639: 	dc.w	LAB_PI-LAB_FTBL			* PI
01:002072F0 F9C4            	  8640: 	dc.w	LAB_TWOPI-LAB_FTBL		* TWOPI
01:002072F2 F99A            	  8641: 	dc.w	LAB_VARPTR-LAB_FTBL		* VARPTR()
01:002072F4 E826            	  8642: 	dc.w	LAB_SADD-LAB_FTBL			* SADD()
01:002072F6 E73C            	  8643: 	dc.w	LAB_LEFT-LAB_FTBL			* LEFT$()
01:002072F8 E750            	  8644: 	dc.w	LAB_RIGHT-LAB_FTBL		* RIGHT$()
01:002072FA E780            	  8645: 	dc.w	LAB_MIDS-LAB_FTBL			* MID$()
01:002072FC F454            	  8646: 	dc.w	LAB_USINGS-LAB_FTBL		* USING$()
                            	  8647: 
                            	  8648: 
                            	  8649: *************************************************************************************
                            	  8650: *
                            	  8651: * hierarchy and action addresses for operator
                            	  8652: 
                            	  8653: LAB_OPPT
01:002072FE 0079            	  8654: 	dc.w	$0079					* +
01:00207300 E984            	  8655: 	dc.w	LAB_ADD-LAB_OPPT
01:00207302 0079            	  8656: 	dc.w	$0079					* -
01:00207304 E970            	  8657: 	dc.w	LAB_SUBTRACT-LAB_OPPT
01:00207306 007B            	  8658: 	dc.w	$007B					* *
01:00207308 EB26            	  8659: 	dc.w	LAB_MULTIPLY-LAB_OPPT
01:0020730A 007B            	  8660: 	dc.w	$007B					* /
01:0020730C EBB2            	  8661: 	dc.w	LAB_DIVIDE-LAB_OPPT
01:0020730E 007F            	  8662: 	dc.w	$007F					* ^
01:00207310 F00C            	  8663: 	dc.w	LAB_POWER-LAB_OPPT
01:00207312 0050            	  8664: 	dc.w	$0050					* AND
01:00207314 DFC6            	  8665: 	dc.w	LAB_AND-LAB_OPPT
01:00207316 0046            	  8666: 	dc.w	$0046					* EOR
01:00207318 DFB6            	  8667: 	dc.w	LAB_EOR-LAB_OPPT
01:0020731A 0046            	  8668: 	dc.w	$0046					* OR
01:0020731C DFBE            	  8669: 	dc.w	LAB_OR-LAB_OPPT
01:0020731E 0056            	  8670: 	dc.w	$0056					* >>
01:00207320 E06A            	  8671: 	dc.w	LAB_RSHIFT-LAB_OPPT
01:00207322 0056            	  8672: 	dc.w	$0056					* <<
01:00207324 E05A            	  8673: 	dc.w	LAB_LSHIFT-LAB_OPPT
01:00207326 007D            	  8674: 	dc.w	$007D					* >
01:00207328 F070            	  8675: 	dc.w	LAB_GTHAN-LAB_OPPT		* used to evaluate -n
01:0020732A 005A            	  8676: 	dc.w	$005A					* =
01:0020732C DFDC            	  8677: 	dc.w	LAB_EQUAL-LAB_OPPT		* used to evaluate NOT
01:0020732E 0064            	  8678: 	dc.w	$0064					* <
01:00207330 DFE6            	  8679: 	dc.w	LAB_LTHAN-LAB_OPPT
                            	  8680: 
                            	  8681: 
                            	  8682: *************************************************************************************
                            	  8683: *
                            	  8684: * misc constants
                            	  8685: 
                            	  8686: * This table is used in converting numbers to ASCII.
                            	  8687: * first four entries for expansion to 9.25 digits
                            	  8688: 
                            	  8689: LAB_2A9A
01:00207332 FFF0BDC0        	  8690: 	dc.l	$FFF0BDC0				* -1000000
01:00207336 000186A0        	  8691: 	dc.l	$000186A0				* 100000
01:0020733A FFFFD8F0        	  8692: 	dc.l	$FFFFD8F0				* -10000
01:0020733E 000003E8        	  8693: 	dc.l	$000003E8				* 1000
01:00207342 FFFFFF9C        	  8694: 	dc.l	$FFFFFF9C				* -100
01:00207346 0000000A        	  8695: 	dc.l	$0000000A				* 10
01:0020734A FFFFFFFF        	  8696: 	dc.l	$FFFFFFFF				* -1
                            	  8697: LAB_2A9B
                            	  8698: 
                            	  8699: 
                            	  8700: *************************************************************************************
                            	  8701: *
                            	  8702: * new keyword tables
                            	  8703: 
                            	  8704: * offsets to keyword tables
                            	  8705: 
                            	  8706: TAB_CHRT
01:0020734E 0000            	  8707: 	dc.w	TAB_STAR-TAB_STAR			* "*"	$2A
01:00207350 0002            	  8708: 	dc.w	TAB_PLUS-TAB_STAR			* "+"	$2B
01:00207352 FFFF            	  8709: 	dc.w	-1					* "," $2C no keywords
01:00207354 0004            	  8710: 	dc.w	TAB_MNUS-TAB_STAR			* "-"	$2D
01:00207356 FFFF            	  8711: 	dc.w	-1					* "." $2E no keywords
01:00207358 0006            	  8712: 	dc.w	TAB_SLAS-TAB_STAR			* "/"	$2F
01:0020735A FFFF            	  8713: 	dc.w	-1					* "0" $30 no keywords
01:0020735C FFFF            	  8714: 	dc.w	-1					* "1" $31 no keywords
01:0020735E FFFF            	  8715: 	dc.w	-1					* "2" $32 no keywords
01:00207360 FFFF            	  8716: 	dc.w	-1					* "3" $33 no keywords
01:00207362 FFFF            	  8717: 	dc.w	-1					* "4" $34 no keywords
01:00207364 FFFF            	  8718: 	dc.w	-1					* "5" $35 no keywords
01:00207366 FFFF            	  8719: 	dc.w	-1					* "6" $36 no keywords
01:00207368 FFFF            	  8720: 	dc.w	-1					* "7" $37 no keywords
01:0020736A FFFF            	  8721: 	dc.w	-1					* "8" $38 no keywords
01:0020736C FFFF            	  8722: 	dc.w	-1					* "9" $39 no keywords
01:0020736E FFFF            	  8723: 	dc.w	-1					* ";" $3A no keywords
01:00207370 FFFF            	  8724: 	dc.w	-1					* ":" $3B no keywords
01:00207372 0008            	  8725: 	dc.w	TAB_LESS-TAB_STAR			* "<"	$3C
01:00207374 000C            	  8726: 	dc.w	TAB_EQUL-TAB_STAR			* "="	$3D
01:00207376 000E            	  8727: 	dc.w	TAB_MORE-TAB_STAR			* ">"	$3E
01:00207378 0012            	  8728: 	dc.w	TAB_QEST-TAB_STAR			* "?"	$3F
01:0020737A FFFF            	  8729: 	dc.w	-1					* "@" $40 no keywords
01:0020737C 0014            	  8730: 	dc.w	TAB_ASCA-TAB_STAR			* "A"	$41
01:0020737E 0024            	  8731: 	dc.w	TAB_ASCB-TAB_STAR			* "B"	$42
01:00207380 003D            	  8732: 	dc.w	TAB_ASCC-TAB_STAR			* "C"	$43
01:00207382 0054            	  8733: 	dc.w	TAB_ASCD-TAB_STAR			* "D"	$44
01:00207384 006D            	  8734: 	dc.w	TAB_ASCE-TAB_STAR			* "E"	$45
01:00207386 007C            	  8735: 	dc.w	TAB_ASCF-TAB_STAR			* "F"	$46
01:00207388 0086            	  8736: 	dc.w	TAB_ASCG-TAB_STAR			* "G"	$47
01:0020738A 0093            	  8737: 	dc.w	TAB_ASCH-TAB_STAR			* "H"	$48
01:0020738C 0099            	  8738: 	dc.w	TAB_ASCI-TAB_STAR			* "I"	$49
01:0020738E FFFF            	  8739: 	dc.w	-1					* "J" $4A no keywords
01:00207390 FFFF            	  8740: 	dc.w	-1					* "K" $4B no keywords
01:00207392 00A8            	  8741: 	dc.w	TAB_ASCL-TAB_STAR			* "L"	$4C
01:00207394 00D6            	  8742: 	dc.w	TAB_ASCM-TAB_STAR			* "M"	$4D
01:00207396 00E4            	  8743: 	dc.w	TAB_ASCN-TAB_STAR			* "N"	$4E
01:00207398 00F3            	  8744: 	dc.w	TAB_ASCO-TAB_STAR			* "O"	$4F
01:0020739A 00F8            	  8745: 	dc.w	TAB_ASCP-TAB_STAR			* "P"	$50
01:0020739C FFFF            	  8746: 	dc.w	-1					* "Q" $51 no keywords
01:0020739E 010D            	  8747: 	dc.w	TAB_ASCR-TAB_STAR			* "R"	$52
01:002073A0 0137            	  8748: 	dc.w	TAB_ASCS-TAB_STAR			* "S"	$53
01:002073A2 0162            	  8749: 	dc.w	TAB_ASCT-TAB_STAR			* "T"	$54
01:002073A4 0176            	  8750: 	dc.w	TAB_ASCU-TAB_STAR			* "U"	$55
01:002073A6 018E            	  8751: 	dc.w	TAB_ASCV-TAB_STAR			* "V"	$56
01:002073A8 019A            	  8752: 	dc.w	TAB_ASCW-TAB_STAR			* "W"	$57
01:002073AA FFFF            	  8753: 	dc.w	-1					* "X" $58 no keywords
01:002073AC FFFF            	  8754: 	dc.w	-1					* "Y" $59 no keywords
01:002073AE FFFF            	  8755: 	dc.w	-1					* "Z" $5A no keywords
01:002073B0 FFFF            	  8756: 	dc.w	-1					* "[" $5B no keywords
01:002073B2 FFFF            	  8757: 	dc.w	-1					* "\" $5C no keywords
01:002073B4 FFFF            	  8758: 	dc.w	-1					* "]" $5D no keywords
01:002073B6 01A9            	  8759: 	dc.w	TAB_POWR-TAB_STAR			* "^"	$5E
                            	  8760: 
                            	  8761: 
                            	  8762: *************************************************************************************
                            	  8763: *
                            	  8764: * Table of Basic keywords for LIST command
                            	  8765: * [byte]first character,[byte]remaining length -1
                            	  8766: * [word]offset from table start
                            	  8767: 
                            	  8768: LAB_KEYT
01:002073B8 45              	  8769: 	dc.b	'E',1
01:002073B9 01
01:002073BA 0071            	  8770: 	dc.w	KEY_END-TAB_STAR			* END
01:002073BC 46              	  8771: 	dc.b	'F',1
01:002073BD 01
01:002073BE 007C            	  8772: 	dc.w	KEY_FOR-TAB_STAR			* FOR
01:002073C0 4E              	  8773: 	dc.b	'N',2
01:002073C1 02
01:002073C2 00E7            	  8774: 	dc.w	KEY_NEXT-TAB_STAR			* NEXT
01:002073C4 44              	  8775: 	dc.b	'D',2
01:002073C5 02
01:002073C6 0054            	  8776: 	dc.w	KEY_DATA-TAB_STAR			* DATA
01:002073C8 49              	  8777: 	dc.b	'I',3
01:002073C9 03
01:002073CA 009E            	  8778: 	dc.w	KEY_INPUT-TAB_STAR		* INPUT
01:002073CC 44              	  8779: 	dc.b	'D',1
01:002073CD 01
01:002073CE 0063            	  8780: 	dc.w	KEY_DIM-TAB_STAR			* DIM
01:002073D0 52              	  8781: 	dc.b	'R',2
01:002073D1 02
01:002073D2 0114            	  8782: 	dc.w	KEY_READ-TAB_STAR			* READ
01:002073D4 4C              	  8783: 	dc.b	'L',1
01:002073D5 01
01:002073D6 00BE            	  8784: 	dc.w	KEY_LET-TAB_STAR			* LET
01:002073D8 44              	  8785: 	dc.b	'D',1
01:002073D9 01
01:002073DA 0058            	  8786: 	dc.w	KEY_DEC-TAB_STAR			* DEC
01:002073DC 47              	  8787: 	dc.b	'G',2
01:002073DD 02
01:002073DE 0089            	  8788: 	dc.w	KEY_GOTO-TAB_STAR			* GOTO
01:002073E0 52              	  8789: 	dc.b	'R',1
01:002073E1 01
01:002073E2 0133            	  8790: 	dc.w	KEY_RUN-TAB_STAR			* RUN
01:002073E4 49              	  8791: 	dc.b	'I',0
01:002073E5 00
01:002073E6 0099            	  8792: 	dc.w	KEY_IF-TAB_STAR			* IF
01:002073E8 52              	  8793: 	dc.b	'R',5
01:002073E9 05
01:002073EA 011B            	  8794: 	dc.w	KEY_RESTORE-TAB_STAR		* RESTORE
01:002073EC 47              	  8795: 	dc.b	'G',3
01:002073ED 03
01:002073EE 008D            	  8796: 	dc.w	KEY_GOSUB-TAB_STAR		* GOSUB
01:002073F0 52              	  8797: 	dc.b	'R',4
01:002073F1 04
01:002073F2 0122            	  8798: 	dc.w	KEY_RETURN-TAB_STAR		* RETURN
01:002073F4 52              	  8799: 	dc.b	'R',1
01:002073F5 01
01:002073F6 0118            	  8800: 	dc.w	KEY_REM-TAB_STAR			* REM
01:002073F8 53              	  8801: 	dc.b	'S',2
01:002073F9 02
01:002073FA 0154            	  8802: 	dc.w	KEY_STOP-TAB_STAR			* STOP
01:002073FC 4F              	  8803: 	dc.b	'O',0
01:002073FD 00
01:002073FE 00F3            	  8804: 	dc.w	KEY_ON-TAB_STAR			* ON
01:00207400 4E              	  8805: 	dc.b	'N',2
01:00207401 02
01:00207402 00EE            	  8806: 	dc.w	KEY_NULL-TAB_STAR			* NULL
01:00207404 49              	  8807: 	dc.b	'I',1
01:00207405 01
01:00207406 009B            	  8808: 	dc.w	KEY_INC-TAB_STAR			* INC
01:00207408 57              	  8809: 	dc.b	'W',2
01:00207409 02
01:0020740A 019A            	  8810: 	dc.w	KEY_WAIT-TAB_STAR			* WAIT
01:0020740C 4C              	  8811: 	dc.b	'L',2
01:0020740D 02
01:0020740E 00C5            	  8812: 	dc.w	KEY_LOAD-TAB_STAR			* LOAD
01:00207410 53              	  8813: 	dc.b	'S',2
01:00207411 02
01:00207412 013C            	  8814: 	dc.w	KEY_SAVE-TAB_STAR			* SAVE
01:00207414 44              	  8815: 	dc.b	'D',1
01:00207415 01
01:00207416 0060            	  8816: 	dc.w	KEY_DEF-TAB_STAR			* DEF
01:00207418 50              	  8817: 	dc.b	'P',2
01:00207419 02
01:0020741A 00FF            	  8818: 	dc.w	KEY_POKE-TAB_STAR			* POKE
01:0020741C 44              	  8819: 	dc.b	'D',2
01:0020741D 02
01:0020741E 0066            	  8820: 	dc.w	KEY_DOKE-TAB_STAR			* DOKE
01:00207420 4C              	  8821: 	dc.b	'L',2
01:00207421 02
01:00207422 00CD            	  8822: 	dc.w	KEY_LOKE-TAB_STAR			* LOKE
01:00207424 43              	  8823: 	dc.b	'C',2
01:00207425 02
01:00207426 003D            	  8824: 	dc.w	KEY_CALL-TAB_STAR			* CALL
01:00207428 44              	  8825: 	dc.b	'D',0
01:00207429 00
01:0020742A 006A            	  8826: 	dc.w	KEY_DO-TAB_STAR			* DO
01:0020742C 4C              	  8827: 	dc.b	'L',2
01:0020742D 02
01:0020742E 00D1            	  8828: 	dc.w	KEY_LOOP-TAB_STAR			* LOOP
01:00207430 50              	  8829: 	dc.b	'P',3
01:00207431 03
01:00207432 0107            	  8830: 	dc.w	KEY_PRINT-TAB_STAR		* PRINT
01:00207434 43              	  8831: 	dc.b	'C',2
01:00207435 02
01:00207436 004B            	  8832: 	dc.w	KEY_CONT-TAB_STAR			* CONT
01:00207438 4C              	  8833: 	dc.b	'L',2
01:00207439 02
01:0020743A 00C1            	  8834: 	dc.w	KEY_LIST-TAB_STAR			* LIST
01:0020743C 43              	  8835: 	dc.b	'C',3
01:0020743D 03
01:0020743E 0046            	  8836: 	dc.w	KEY_CLEAR-TAB_STAR		* CLEAR
01:00207440 4E              	  8837: 	dc.b	'N',1
01:00207441 01
01:00207442 00E4            	  8838: 	dc.w	KEY_NEW-TAB_STAR			* NEW
01:00207444 57              	  8839: 	dc.b	'W',3
01:00207445 03
01:00207446 01A3            	  8840: 	dc.w	KEY_WIDTH-TAB_STAR		* WIDTH
01:00207448 47              	  8841: 	dc.b	'G',1
01:00207449 01
01:0020744A 0086            	  8842: 	dc.w	KEY_GET-TAB_STAR			* GET
01:0020744C 53              	  8843: 	dc.b	'S',2
01:0020744D 02
01:0020744E 015D            	  8844: 	dc.w	KEY_SWAP-TAB_STAR			* SWAP
01:00207450 42              	  8845: 	dc.b	'B',4
01:00207451 04
01:00207452 002F            	  8846: 	dc.w	KEY_BITSET-TAB_STAR		* BITSET
01:00207454 42              	  8847: 	dc.b	'B',4
01:00207455 04
01:00207456 0029            	  8848: 	dc.w	KEY_BITCLR-TAB_STAR		* BITCLR
01:00207458 54              	  8849: 	dc.b	'T',2
01:00207459 02
01:0020745A 0162            	  8850: 	dc.w	KEY_TAB-TAB_STAR			* TAB(
01:0020745C 45              	  8851: 	dc.b	'E',2
01:0020745D 02
01:0020745E 006D            	  8852: 	dc.w	KEY_ELSE-TAB_STAR			* ELSE
01:00207460 54              	  8853: 	dc.b	'T',0
01:00207461 00
01:00207462 016E            	  8854: 	dc.w	KEY_TO-TAB_STAR			* TO
01:00207464 46              	  8855: 	dc.b	'F',0
01:00207465 00
01:00207466 007F            	  8856: 	dc.w	KEY_FN-TAB_STAR			* FN
01:00207468 53              	  8857: 	dc.b	'S',2
01:00207469 02
01:0020746A 0148            	  8858: 	dc.w	KEY_SPC-TAB_STAR			* SPC(
01:0020746C 54              	  8859: 	dc.b	'T',2
01:0020746D 02
01:0020746E 016A            	  8860: 	dc.w	KEY_THEN-TAB_STAR			* THEN
01:00207470 4E              	  8861: 	dc.b	'N',1
01:00207471 01
01:00207472 00EB            	  8862: 	dc.w	KEY_NOT-TAB_STAR			* NOT
01:00207474 53              	  8863: 	dc.b	'S',2
01:00207475 02
01:00207476 0150            	  8864: 	dc.w	KEY_STEP-TAB_STAR			* STEP
01:00207478 55              	  8865: 	dc.b	'U',3
01:00207479 03
01:0020747A 017D            	  8866: 	dc.w	KEY_UNTIL-TAB_STAR		* UNTIL
01:0020747C 57              	  8867: 	dc.b	'W',3
01:0020747D 03
01:0020747E 019E            	  8868: 	dc.w	KEY_WHILE-TAB_STAR		* WHILE
                            	  8869: 
01:00207480 2B              	  8870: 	dc.b	'+',-1
01:00207481 FF
01:00207482 0002            	  8871: 	dc.w	KEY_PLUS-TAB_STAR			* +
01:00207484 2D              	  8872: 	dc.b	'-',-1
01:00207485 FF
01:00207486 0004            	  8873: 	dc.w	KEY_MINUS-TAB_STAR		* -
01:00207488 2A              	  8874: 	dc.b	'*',-1
01:00207489 FF
01:0020748A 0000            	  8875: 	dc.w	KEY_MULT-TAB_STAR			* *
01:0020748C 2F              	  8876: 	dc.b	'/',-1
01:0020748D FF
01:0020748E 0006            	  8877: 	dc.w	KEY_DIV-TAB_STAR			* /
01:00207490 5E              	  8878: 	dc.b	'^',-1
01:00207491 FF
01:00207492 01A9            	  8879: 	dc.w	KEY_POWER-TAB_STAR		* ^
01:00207494 41              	  8880: 	dc.b	'A',1
01:00207495 01
01:00207496 0018            	  8881: 	dc.w	KEY_AND-TAB_STAR			* AND
01:00207498 45              	  8882: 	dc.b	'E',1
01:00207499 01
01:0020749A 0074            	  8883: 	dc.w	KEY_EOR-TAB_STAR			* EOR
01:0020749C 4F              	  8884: 	dc.b	'O',0
01:0020749D 00
01:0020749E 00F5            	  8885: 	dc.w	KEY_OR-TAB_STAR			* OR
01:002074A0 3E              	  8886: 	dc.b	'>',0
01:002074A1 00
01:002074A2 000E            	  8887: 	dc.w	KEY_RSHIFT-TAB_STAR		* >>
01:002074A4 3C              	  8888: 	dc.b	'<',0
01:002074A5 00
01:002074A6 0008            	  8889: 	dc.w	KEY_LSHIFT-TAB_STAR		* <<
01:002074A8 3E              	  8890: 	dc.b	'>',-1
01:002074A9 FF
01:002074AA 0010            	  8891: 	dc.w	KEY_GT-TAB_STAR			* >
01:002074AC 3D              	  8892: 	dc.b	'=',-1
01:002074AD FF
01:002074AE 000C            	  8893: 	dc.w	KEY_EQUAL-TAB_STAR		* =
01:002074B0 3C              	  8894: 	dc.b	'<',-1
01:002074B1 FF
01:002074B2 000A            	  8895: 	dc.w	KEY_LT-TAB_STAR			* <
                            	  8896: 
01:002074B4 53              	  8897: 	dc.b	'S',2
01:002074B5 02
01:002074B6 0140            	  8898: 	dc.w	KEY_SGN-TAB_STAR			* SGN(
01:002074B8 49              	  8899: 	dc.b	'I',2
01:002074B9 02
01:002074BA 00A3            	  8900: 	dc.w	KEY_INT-TAB_STAR			* INT(
01:002074BC 41              	  8901: 	dc.b	'A',2
01:002074BD 02
01:002074BE 0014            	  8902: 	dc.w	KEY_ABS-TAB_STAR			* ABS(
01:002074C0 55              	  8903: 	dc.b	'U',2
01:002074C1 02
01:002074C2 0189            	  8904: 	dc.w	KEY_USR-TAB_STAR			* USR(
01:002074C4 46              	  8905: 	dc.b	'F',2
01:002074C5 02
01:002074C6 0081            	  8906: 	dc.w	KEY_FRE-TAB_STAR			* FRE(
01:002074C8 50              	  8907: 	dc.b	'P',2
01:002074C9 02
01:002074CA 0103            	  8908: 	dc.w	KEY_POS-TAB_STAR			* POS(
01:002074CC 53              	  8909: 	dc.b	'S',2
01:002074CD 02
01:002074CE 014C            	  8910: 	dc.w	KEY_SQR-TAB_STAR			* SQR(
01:002074D0 52              	  8911: 	dc.b	'R',2
01:002074D1 02
01:002074D2 012F            	  8912: 	dc.w	KEY_RND-TAB_STAR			* RND(
01:002074D4 4C              	  8913: 	dc.b	'L',2
01:002074D5 02
01:002074D6 00C9            	  8914: 	dc.w	KEY_LOG-TAB_STAR			* LOG(
01:002074D8 45              	  8915: 	dc.b	'E',2
01:002074D9 02
01:002074DA 0077            	  8916: 	dc.w	KEY_EXP-TAB_STAR			* EXP(
01:002074DC 43              	  8917: 	dc.b	'C',2
01:002074DD 02
01:002074DE 004F            	  8918: 	dc.w	KEY_COS-TAB_STAR			* COS(
01:002074E0 53              	  8919: 	dc.b	'S',2
01:002074E1 02
01:002074E2 0144            	  8920: 	dc.w	KEY_SIN-TAB_STAR			* SIN(
01:002074E4 54              	  8921: 	dc.b	'T',2
01:002074E5 02
01:002074E6 0166            	  8922: 	dc.w	KEY_TAN-TAB_STAR			* TAN(
01:002074E8 41              	  8923: 	dc.b	'A',2
01:002074E9 02
01:002074EA 001F            	  8924: 	dc.w	KEY_ATN-TAB_STAR			* ATN(
01:002074EC 50              	  8925: 	dc.b	'P',3
01:002074ED 03
01:002074EE 00F8            	  8926: 	dc.w	KEY_PEEK-TAB_STAR			* PEEK(
01:002074F0 44              	  8927: 	dc.b	'D',3
01:002074F1 03
01:002074F2 005B            	  8928: 	dc.w	KEY_DEEK-TAB_STAR			* DEEK(
01:002074F4 4C              	  8929: 	dc.b	'L',3
01:002074F5 03
01:002074F6 00AF            	  8930: 	dc.w	KEY_LEEK-TAB_STAR			* LEEK(
01:002074F8 4C              	  8931: 	dc.b	'L',2
01:002074F9 02
01:002074FA 00BA            	  8932: 	dc.w	KEY_LEN-TAB_STAR			* LEN(
01:002074FC 53              	  8933: 	dc.b	'S',3
01:002074FD 03
01:002074FE 0158            	  8934: 	dc.w	KEY_STRS-TAB_STAR			* STR$(
01:00207500 56              	  8935: 	dc.b	'V',2
01:00207501 02
01:00207502 018E            	  8936: 	dc.w	KEY_VAL-TAB_STAR			* VAL(
01:00207504 41              	  8937: 	dc.b	'A',2
01:00207505 02
01:00207506 001B            	  8938: 	dc.w	KEY_ASC-TAB_STAR			* ASC(
01:00207508 55              	  8939: 	dc.b	'U',5
01:00207509 05
01:0020750A 0176            	  8940: 	dc.w	KEY_UCASES-TAB_STAR		* UCASE$(
01:0020750C 4C              	  8941: 	dc.b	'L',5
01:0020750D 05
01:0020750E 00A8            	  8942: 	dc.w	KEY_LCASES-TAB_STAR		* LCASE$(
01:00207510 43              	  8943: 	dc.b	'C',3
01:00207511 03
01:00207512 0041            	  8944: 	dc.w	KEY_CHRS-TAB_STAR			* CHR$(
01:00207514 48              	  8945: 	dc.b	'H',3
01:00207515 03
01:00207516 0093            	  8946: 	dc.w	KEY_HEXS-TAB_STAR			* HEX$(
01:00207518 42              	  8947: 	dc.b	'B',3
01:00207519 03
01:0020751A 0024            	  8948: 	dc.w	KEY_BINS-TAB_STAR			* BIN$(
01:0020751C 42              	  8949: 	dc.b	'B',5
01:0020751D 05
01:0020751E 0035            	  8950: 	dc.w	KEY_BITTST-TAB_STAR		* BITTST(
01:00207520 4D              	  8951: 	dc.b	'M',2
01:00207521 02
01:00207522 00D6            	  8952: 	dc.w	KEY_MAX-TAB_STAR			* MAX(
01:00207524 4D              	  8953: 	dc.b	'M',2
01:00207525 02
01:00207526 00DF            	  8954: 	dc.w	KEY_MIN-TAB_STAR			* MIN(
01:00207528 52              	  8955: 	dc.b	'R',5
01:00207529 05
01:0020752A 010D            	  8956: 	dc.w	KEY_RAM-TAB_STAR			* RAMBASE
01:0020752C 50              	  8957: 	dc.b	'P',0
01:0020752D 00
01:0020752E 00FD            	  8958: 	dc.w	KEY_PI-TAB_STAR			* PI
01:00207530 54              	  8959: 	dc.b	'T',3
01:00207531 03
01:00207532 0170            	  8960: 	dc.w	KEY_TWOPI-TAB_STAR		* TWOPI
01:00207534 56              	  8961: 	dc.b	'V',5
01:00207535 05
01:00207536 0192            	  8962: 	dc.w	KEY_VPTR-TAB_STAR			* VARPTR(
01:00207538 53              	  8963: 	dc.b	'S',3
01:00207539 03
01:0020753A 0137            	  8964: 	dc.w	KEY_SADD-TAB_STAR			* SADD(
01:0020753C 4C              	  8965: 	dc.b	'L',4
01:0020753D 04
01:0020753E 00B4            	  8966: 	dc.w	KEY_LEFTS-TAB_STAR		* LEFT$(
01:00207540 52              	  8967: 	dc.b	'R',5
01:00207541 05
01:00207542 0128            	  8968: 	dc.w	KEY_RIGHTS-TAB_STAR		* RIGHT$(
01:00207544 4D              	  8969: 	dc.b	'M',3
01:00207545 03
01:00207546 00DA            	  8970: 	dc.w	KEY_MIDS-TAB_STAR			* MID$(
01:00207548 55              	  8971: 	dc.b	'U',5
01:00207549 05
01:0020754A 0182            	  8972: 	dc.w	KEY_USINGS-TAB_STAR		* USING$(
                            	  8973: 
                            	  8974: 
                            	  8975: *************************************************************************************
                            	  8976: *
                            	  8977: * BASIC error messages
                            	  8978: 
                            	  8979: LAB_BAER
01:0020754C 0030            	  8980: 	dc.w	LAB_NF-LAB_BAER			* $00 NEXT without FOR
01:0020754E 0041            	  8981: 	dc.w	LAB_SN-LAB_BAER			* $02 syntax
01:00207550 0048            	  8982: 	dc.w	LAB_RG-LAB_BAER			* $04 RETURN without GOSUB
01:00207552 005D            	  8983: 	dc.w	LAB_OD-LAB_BAER			* $06 out of data
01:00207554 0069            	  8984: 	dc.w	LAB_FC-LAB_BAER			* $08 function call
01:00207556 0077            	  8985: 	dc.w	LAB_OV-LAB_BAER			* $0A overflow
01:00207558 0080            	  8986: 	dc.w	LAB_OM-LAB_BAER			* $0C out of memory
01:0020755A 008E            	  8987: 	dc.w	LAB_US-LAB_BAER			* $0E undefined statement
01:0020755C 00A2            	  8988: 	dc.w	LAB_BS-LAB_BAER			* $10 array bounds
01:0020755E 00AF            	  8989: 	dc.w	LAB_DD-LAB_BAER			* $12 double dimension array
01:00207560 00C0            	  8990: 	dc.w	LAB_D0-LAB_BAER			* $14 divide by 0
01:00207562 00CF            	  8991: 	dc.w	LAB_ID-LAB_BAER			* $16 illegal direct
01:00207564 00DE            	  8992: 	dc.w	LAB_TM-LAB_BAER			* $18 type mismatch
01:00207566 00EC            	  8993: 	dc.w	LAB_LS-LAB_BAER			* $1A long string
01:00207568 00FC            	  8994: 	dc.w	LAB_ST-LAB_BAER			* $1C string too complex
01:0020756A 010F            	  8995: 	dc.w	LAB_CN-LAB_BAER			* $1E continue error
01:0020756C 011E            	  8996: 	dc.w	LAB_UF-LAB_BAER			* $20 undefined function
01:0020756E 0131            	  8997: 	dc.w	LAB_LD-LAB_BAER			* $22 LOOP without DO
01:00207570 0141            	  8998: 	dc.w	LAB_UV-LAB_BAER			* $24 undefined variable
01:00207572 0154            	  8999: 	dc.w	LAB_UA-LAB_BAER			* $26 undimensioned array
01:00207574 0168            	  9000: 	dc.w	LAB_WD-LAB_BAER			* $28 wrong dimensions
01:00207576 0179            	  9001: 	dc.w	LAB_AD-LAB_BAER			* $2A address
01:00207578 0181            	  9002: 	dc.w	LAB_FO-LAB_BAER			* $2C format
01:0020757A 0188            	  9003: 	dc.w	LAB_NI-LAB_BAER			* $2E not implemented
                            	  9004: 
01:0020757C 4E45585420776974	  9005: LAB_NF	dc.b	'NEXT without FOR',$00
01:00207584 686F757420464F52
01:0020758C 00
01:0020758D 53796E746178    	  9006: LAB_SN	dc.b	'Syntax',$00
01:00207593 00
01:00207594 52455455524E2077	  9007: LAB_RG	dc.b	'RETURN without GOSUB',$00
01:0020759C 6974686F75742047
01:002075A4 4F535542
01:002075A8 00
01:002075A9 4F7574206F662044	  9008: LAB_OD	dc.b	'Out of DATA',$00
01:002075B1 415441
01:002075B4 00
01:002075B5 46756E6374696F6E	  9009: LAB_FC	dc.b	'Function call',$00
01:002075BD 2063616C6C
01:002075C2 00
01:002075C3 4F766572666C6F77	  9010: LAB_OV	dc.b	'Overflow',$00
01:002075CB 00
01:002075CC 4F7574206F66206D	  9011: LAB_OM	dc.b	'Out of memory',$00
01:002075D4 656D6F7279
01:002075D9 00
01:002075DA 556E646566696E65	  9012: LAB_US	dc.b	'Undefined statement',$00
01:002075E2 642073746174656D
01:002075EA 656E74
01:002075ED 00
01:002075EE 417272617920626F	  9013: LAB_BS	dc.b	'Array bounds',$00
01:002075F6 756E6473
01:002075FA 00
01:002075FB 446F75626C652064	  9014: LAB_DD	dc.b	'Double dimension',$00
01:00207603 696D656E73696F6E
01:0020760B 00
01:0020760C 4469766964652062	  9015: LAB_D0	dc.b	'Divide by zero',$00
01:00207614 79207A65726F
01:0020761A 00
01:0020761B 496C6C6567616C20	  9016: LAB_ID	dc.b	'Illegal direct',$00
01:00207623 646972656374
01:00207629 00
01:0020762A 54797065206D6973	  9017: LAB_TM	dc.b	'Type mismatch',$00
01:00207632 6D61746368
01:00207637 00
01:00207638 537472696E672074	  9018: LAB_LS	dc.b	'String too long',$00
01:00207640 6F6F206C6F6E67
01:00207647 00
01:00207648 537472696E672074	  9019: LAB_ST	dc.b	'String too complex',$00
01:00207650 6F6F20636F6D706C
01:00207658 6578
01:0020765A 00
01:0020765B 43616E277420636F	  9020: LAB_CN	dc.b	'Can''t continue',$00
01:00207663 6E74696E7565
01:00207669 00
01:0020766A 556E646566696E65	  9021: LAB_UF	dc.b	'Undefined function',$00
01:00207672 642066756E637469
01:0020767A 6F6E
01:0020767C 00
01:0020767D 4C4F4F5020776974	  9022: LAB_LD	dc.b	'LOOP without DO',$00
01:00207685 686F757420444F
01:0020768C 00
01:0020768D 556E646566696E65	  9023: LAB_UV	dc.b	'Undefined variable',$00
01:00207695 6420766172696162
01:0020769D 6C65
01:0020769F 00
01:002076A0 556E64696D656E73	  9024: LAB_UA	dc.b	'Undimensioned array',$00
01:002076A8 696F6E6564206172
01:002076B0 726179
01:002076B3 00
01:002076B4 57726F6E67206469	  9025: LAB_WD	dc.b	'Wrong dimensions',$00
01:002076BC 6D656E73696F6E73
01:002076C4 00
01:002076C5 41646472657373  	  9026: LAB_AD	dc.b	'Address',$00
01:002076CC 00
01:002076CD 466F726D6174    	  9027: LAB_FO	dc.b	'Format',$00
01:002076D3 00
01:002076D4 4E6F7420696D706C	  9028: LAB_NI  dc.b    'Not implemented',$00
01:002076DC 656D656E746564
01:002076E3 00
                            	  9029: 
                            	  9030: 
                            	  9031: *************************************************************************************
                            	  9032: *
                            	  9033: * keyword table for line (un)crunching
                            	  9034: 
                            	  9035: * [keyword,token
                            	  9036: * [keyword,token]]
                            	  9037: * end marker (#$00)
                            	  9038: 
                            	  9039: TAB_STAR
                            	  9040: KEY_MULT
01:002076E4 B4              	  9041: 	dc.b TK_MULT,$00				* *
01:002076E5 00
                            	  9042: TAB_PLUS
                            	  9043: KEY_PLUS
01:002076E6 B2              	  9044: 	dc.b TK_PLUS,$00				* +
01:002076E7 00
                            	  9045: TAB_MNUS
                            	  9046: KEY_MINUS
01:002076E8 B3              	  9047: 	dc.b TK_MINUS,$00				* -
01:002076E9 00
                            	  9048: TAB_SLAS
                            	  9049: KEY_DIV
01:002076EA B5              	  9050: 	dc.b TK_DIV,$00				* /
01:002076EB 00
                            	  9051: TAB_LESS
                            	  9052: KEY_LSHIFT
01:002076EC 3C              	  9053: 	dc.b	'<',TK_LSHIFT			* <<
01:002076ED BB
                            	  9054: KEY_LT
01:002076EE BE              	  9055: 	dc.b TK_LT					* <
01:002076EF 00              	  9056: 	dc.b	$00
                            	  9057: TAB_EQUL
                            	  9058: KEY_EQUAL
01:002076F0 BD              	  9059: 	dc.b TK_EQUAL,$00				* =
01:002076F1 00
                            	  9060: TAB_MORE
                            	  9061: KEY_RSHIFT
01:002076F2 3E              	  9062: 	dc.b	'>',TK_RSHIFT			* >>
01:002076F3 BA
                            	  9063: KEY_GT
01:002076F4 BC              	  9064: 	dc.b TK_GT					* >
01:002076F5 00              	  9065: 	dc.b	$00
                            	  9066: TAB_QEST
01:002076F6 9E              	  9067: 	dc.b TK_PRINT,$00				* ?
01:002076F7 00
                            	  9068: TAB_ASCA
                            	  9069: KEY_ABS
01:002076F8 425328          	  9070: 	dc.b	'BS(',TK_ABS			* ABS(
01:002076FB C1
                            	  9071: KEY_AND
01:002076FC 4E44            	  9072: 	dc.b	'ND',TK_AND				* AND
01:002076FE B7
                            	  9073: KEY_ASC
01:002076FF 534328          	  9074: 	dc.b	'SC(',TK_ASC			* ASC(
01:00207702 D3
                            	  9075: KEY_ATN
01:00207703 544E28          	  9076: 	dc.b	'TN(',TK_ATN			* ATN(
01:00207706 CC
01:00207707 00              	  9077: 	dc.b	$00
                            	  9078: TAB_ASCB
                            	  9079: KEY_BINS
01:00207708 494E2428        	  9080: 	dc.b	'IN$(',TK_BINS			* BIN$(
01:0020770C D8
                            	  9081: KEY_BITCLR
01:0020770D 4954434C52      	  9082: 	dc.b	'ITCLR',TK_BITCLR			* BITCLR
01:00207712 A7
                            	  9083: KEY_BITSET
01:00207713 4954534554      	  9084: 	dc.b	'ITSET',TK_BITSET			* BITSET
01:00207718 A6
                            	  9085: KEY_BITTST
01:00207719 495454535428    	  9086: 	dc.b	'ITTST(',TK_BITTST		* BITTST(
01:0020771F D9
01:00207720 00              	  9087: 	dc.b	$00
                            	  9088: TAB_ASCC
                            	  9089: KEY_CALL
01:00207721 414C4C          	  9090: 	dc.b	'ALL',TK_CALL			* CALL
01:00207724 9B
                            	  9091: KEY_CHRS
01:00207725 48522428        	  9092: 	dc.b	'HR$(',TK_CHRS			* CHR$(
01:00207729 D6
                            	  9093: KEY_CLEAR
01:0020772A 4C454152        	  9094: 	dc.b	'LEAR',TK_CLEAR			* CLEAR
01:0020772E A1
                            	  9095: KEY_CONT
01:0020772F 4F4E54          	  9096: 	dc.b	'ONT',TK_CONT			* CONT
01:00207732 9F
                            	  9097: KEY_COS
01:00207733 4F5328          	  9098: 	dc.b	'OS(',TK_COS			* COS(
01:00207736 C9
01:00207737 00              	  9099: 	dc.b	$00
                            	  9100: TAB_ASCD
                            	  9101: KEY_DATA
01:00207738 415441          	  9102: 	dc.b	'ATA',TK_DATA			* DATA
01:0020773B 83
                            	  9103: KEY_DEC
01:0020773C 4543            	  9104: 	dc.b	'EC',TK_DEC				* DEC
01:0020773E 88
                            	  9105: KEY_DEEK
01:0020773F 45454B28        	  9106: 	dc.b	'EEK(',TK_DEEK			* DEEK(
01:00207743 CE
                            	  9107: KEY_DEF
01:00207744 4546            	  9108: 	dc.b	'EF',TK_DEF				* DEF
01:00207746 97
                            	  9109: KEY_DIM
01:00207747 494D            	  9110: 	dc.b	'IM',TK_DIM				* DIM
01:00207749 85
                            	  9111: KEY_DOKE
01:0020774A 4F4B45          	  9112: 	dc.b	'OKE',TK_DOKE			* DOKE
01:0020774D 99
                            	  9113: KEY_DO
01:0020774E 4F              	  9114: 	dc.b	'O',TK_DO				* DO
01:0020774F 9C
01:00207750 00              	  9115: 	dc.b	$00
                            	  9116: TAB_ASCE
                            	  9117: KEY_ELSE
01:00207751 4C5345          	  9118: 	dc.b	'LSE',TK_ELSE			* ELSE
01:00207754 A9
                            	  9119: KEY_END
01:00207755 4E44            	  9120: 	dc.b	'ND',TK_END				* END
01:00207757 80
                            	  9121: KEY_EOR
01:00207758 4F52            	  9122: 	dc.b	'OR',TK_EOR				* EOR
01:0020775A B8
                            	  9123: KEY_EXP
01:0020775B 585028          	  9124: 	dc.b	'XP(',TK_EXP			* EXP(
01:0020775E C8
01:0020775F 00              	  9125: 	dc.b	$00
                            	  9126: TAB_ASCF
                            	  9127: KEY_FOR
01:00207760 4F52            	  9128: 	dc.b	'OR',TK_FOR				* FOR
01:00207762 81
                            	  9129: KEY_FN
01:00207763 4E              	  9130: 	dc.b	'N',TK_FN				* FN
01:00207764 AB
                            	  9131: KEY_FRE
01:00207765 524528          	  9132: 	dc.b	'RE(',TK_FRE			* FRE(
01:00207768 C3
01:00207769 00              	  9133: 	dc.b	$00
                            	  9134: TAB_ASCG
                            	  9135: KEY_GET
01:0020776A 4554            	  9136: 	dc.b	'ET',TK_GET				* GET
01:0020776C A4
                            	  9137: KEY_GOTO
01:0020776D 4F544F          	  9138: 	dc.b	'OTO',TK_GOTO			* GOTO
01:00207770 89
                            	  9139: KEY_GOSUB
01:00207771 4F535542        	  9140: 	dc.b	'OSUB',TK_GOSUB			* GOSUB
01:00207775 8D
01:00207776 00              	  9141: 	dc.b	$00
                            	  9142: TAB_ASCH
                            	  9143: KEY_HEXS
01:00207777 45582428        	  9144: 	dc.b	'EX$(',TK_HEXS,$00		* HEX$(
01:0020777B D7
01:0020777C 00
                            	  9145: TAB_ASCI
                            	  9146: KEY_IF
01:0020777D 46              	  9147: 	dc.b	'F',TK_IF				* IF
01:0020777E 8B
                            	  9148: KEY_INC
01:0020777F 4E43            	  9149: 	dc.b	'NC',TK_INC				* INC
01:00207781 93
                            	  9150: KEY_INPUT
01:00207782 4E505554        	  9151: 	dc.b	'NPUT',TK_INPUT			* INPUT
01:00207786 84
                            	  9152: KEY_INT
01:00207787 4E5428          	  9153: 	dc.b	'NT(',TK_INT			* INT(
01:0020778A C0
01:0020778B 00              	  9154: 	dc.b	$00
                            	  9155: TAB_ASCL
                            	  9156: KEY_LCASES
01:0020778C 434153452428    	  9157: 	dc.b	'CASE$(',TK_LCASES		* LCASE$(
01:00207792 D5
                            	  9158: KEY_LEEK
01:00207793 45454B28        	  9159: 	dc.b	'EEK(',TK_LEEK			* LEEK(
01:00207797 CF
                            	  9160: KEY_LEFTS
01:00207798 4546542428      	  9161: 	dc.b	'EFT$(',TK_LEFTS			* LEFT$(
01:0020779D E1
                            	  9162: KEY_LEN
01:0020779E 454E28          	  9163: 	dc.b	'EN(',TK_LEN			* LEN(
01:002077A1 D0
                            	  9164: KEY_LET
01:002077A2 4554            	  9165: 	dc.b	'ET',TK_LET				* LET
01:002077A4 87
                            	  9166: KEY_LIST
01:002077A5 495354          	  9167: 	dc.b	'IST',TK_LIST			* LIST
01:002077A8 A0
                            	  9168: KEY_LOAD
01:002077A9 4F4144          	  9169: 	dc.b	'OAD',TK_LOAD			* LOAD
01:002077AC 95
                            	  9170: KEY_LOG
01:002077AD 4F4728          	  9171: 	dc.b	'OG(',TK_LOG			* LOG(
01:002077B0 C7
                            	  9172: KEY_LOKE
01:002077B1 4F4B45          	  9173: 	dc.b	'OKE',TK_LOKE			* LOKE
01:002077B4 9A
                            	  9174: KEY_LOOP
01:002077B5 4F4F50          	  9175: 	dc.b	'OOP',TK_LOOP			* LOOP
01:002077B8 9D
01:002077B9 00              	  9176: 	dc.b	$00
                            	  9177: TAB_ASCM
                            	  9178: KEY_MAX
01:002077BA 415828          	  9179: 	dc.b	'AX(',TK_MAX			* MAX(
01:002077BD DA
                            	  9180: KEY_MIDS
01:002077BE 49442428        	  9181: 	dc.b	'ID$(',TK_MIDS			* MID$(
01:002077C2 E3
                            	  9182: KEY_MIN
01:002077C3 494E28          	  9183: 	dc.b	'IN(',TK_MIN			* MIN(
01:002077C6 DB
01:002077C7 00              	  9184: 	dc.b	$00
                            	  9185: TAB_ASCN
                            	  9186: KEY_NEW
01:002077C8 4557            	  9187: 	dc.b	'EW',TK_NEW				* NEW
01:002077CA A2
                            	  9188: KEY_NEXT
01:002077CB 455854          	  9189: 	dc.b	'EXT',TK_NEXT			* NEXT
01:002077CE 82
                            	  9190: KEY_NOT
01:002077CF 4F54            	  9191: 	dc.b	'OT',TK_NOT				* NOT
01:002077D1 AE
                            	  9192: KEY_NULL
01:002077D2 554C4C          	  9193: 	dc.b	'ULL',TK_NULL			* NULL
01:002077D5 92
01:002077D6 00              	  9194: 	dc.b	$00
                            	  9195: TAB_ASCO
                            	  9196: KEY_ON
01:002077D7 4E              	  9197: 	dc.b	'N',TK_ON				* ON
01:002077D8 91
                            	  9198: KEY_OR
01:002077D9 52              	  9199: 	dc.b	'R',TK_OR				* OR
01:002077DA B9
01:002077DB 00              	  9200: 	dc.b	$00
                            	  9201: TAB_ASCP
                            	  9202: KEY_PEEK
01:002077DC 45454B28        	  9203: 	dc.b	'EEK(',TK_PEEK			* PEEK(
01:002077E0 CD
                            	  9204: KEY_PI
01:002077E1 49              	  9205: 	dc.b	'I',TK_PI				* PI
01:002077E2 DD
                            	  9206: KEY_POKE
01:002077E3 4F4B45          	  9207: 	dc.b	'OKE',TK_POKE			* POKE
01:002077E6 98
                            	  9208: KEY_POS
01:002077E7 4F5328          	  9209: 	dc.b	'OS(',TK_POS			* POS(
01:002077EA C4
                            	  9210: KEY_PRINT
01:002077EB 52494E54        	  9211: 	dc.b	'RINT',TK_PRINT			* PRINT
01:002077EF 9E
01:002077F0 00              	  9212: 	dc.b	$00
                            	  9213: TAB_ASCR
                            	  9214: KEY_RAM
01:002077F1 414D42415345    	  9215: 	dc.b	'AMBASE',TK_RAM			* RAMBASE
01:002077F7 DC
                            	  9216: KEY_READ
01:002077F8 454144          	  9217: 	dc.b	'EAD',TK_READ			* READ
01:002077FB 86
                            	  9218: KEY_REM
01:002077FC 454D            	  9219: 	dc.b	'EM',TK_REM				* REM
01:002077FE 8F
                            	  9220: KEY_RESTORE
01:002077FF 4553544F5245    	  9221: 	dc.b	'ESTORE',TK_RESTORE		* RESTORE
01:00207805 8C
                            	  9222: KEY_RETURN
01:00207806 455455524E      	  9223: 	dc.b	'ETURN',TK_RETURN			* RETURN
01:0020780B 8E
                            	  9224: KEY_RIGHTS
01:0020780C 494748542428    	  9225: 	dc.b	'IGHT$(',TK_RIGHTS		* RIGHT$(
01:00207812 E2
                            	  9226: KEY_RND
01:00207813 4E4428          	  9227: 	dc.b	'ND(',TK_RND			* RND(
01:00207816 C6
                            	  9228: KEY_RUN
01:00207817 554E            	  9229: 	dc.b	'UN',TK_RUN				* RUN
01:00207819 8A
01:0020781A 00              	  9230: 	dc.b	$00
                            	  9231: TAB_ASCS
                            	  9232: KEY_SADD
01:0020781B 41444428        	  9233: 	dc.b	'ADD(',TK_SADD			* SADD(
01:0020781F E0
                            	  9234: KEY_SAVE
01:00207820 415645          	  9235: 	dc.b	'AVE',TK_SAVE			* SAVE
01:00207823 96
                            	  9236: KEY_SGN
01:00207824 474E28          	  9237: 	dc.b	'GN(',TK_SGN			* SGN(
01:00207827 BF
                            	  9238: KEY_SIN
01:00207828 494E28          	  9239: 	dc.b	'IN(',TK_SIN			* SIN(
01:0020782B CA
                            	  9240: KEY_SPC
01:0020782C 504328          	  9241: 	dc.b	'PC(',TK_SPC			* SPC(
01:0020782F AC
                            	  9242: KEY_SQR
01:00207830 515228          	  9243: 	dc.b	'QR(',TK_SQR			* SQR(
01:00207833 C5
                            	  9244: KEY_STEP
01:00207834 544550          	  9245: 	dc.b	'TEP',TK_STEP			* STEP
01:00207837 AF
                            	  9246: KEY_STOP
01:00207838 544F50          	  9247: 	dc.b	'TOP',TK_STOP			* STOP
01:0020783B 90
                            	  9248: KEY_STRS
01:0020783C 54522428        	  9249: 	dc.b	'TR$(',TK_STRS			* STR$(
01:00207840 D1
                            	  9250: KEY_SWAP
01:00207841 574150          	  9251: 	dc.b	'WAP',TK_SWAP			* SWAP
01:00207844 A5
01:00207845 00              	  9252: 	dc.b	$00
                            	  9253: TAB_ASCT
                            	  9254: KEY_TAB
01:00207846 414228          	  9255: 	dc.b	'AB(',TK_TAB			* TAB(
01:00207849 A8
                            	  9256: KEY_TAN
01:0020784A 414E28          	  9257: 	dc.b	'AN(',TK_TAN			* TAN
01:0020784D CB
                            	  9258: KEY_THEN
01:0020784E 48454E          	  9259: 	dc.b	'HEN',TK_THEN			* THEN
01:00207851 AD
                            	  9260: KEY_TO
01:00207852 4F              	  9261: 	dc.b	'O',TK_TO				* TO
01:00207853 AA
                            	  9262: KEY_TWOPI
01:00207854 574F5049        	  9263: 	dc.b	'WOPI',TK_TWOPI			* TWOPI
01:00207858 DE
01:00207859 00              	  9264: 	dc.b	$00
                            	  9265: TAB_ASCU
                            	  9266: KEY_UCASES
01:0020785A 434153452428    	  9267: 	dc.b	'CASE$(',TK_UCASES		* UCASE$(
01:00207860 D4
                            	  9268: KEY_UNTIL
01:00207861 4E54494C        	  9269: 	dc.b	'NTIL',TK_UNTIL			* UNTIL
01:00207865 B0
                            	  9270: KEY_USINGS
01:00207866 53494E472428    	  9271: 	dc.b	'SING$(',TK_USINGS		* USING$(
01:0020786C E4
                            	  9272: KEY_USR
01:0020786D 535228          	  9273: 	dc.b	'SR(',TK_USR			* USR(
01:00207870 C2
01:00207871 00              	  9274: 	dc.b	$00
                            	  9275: TAB_ASCV
                            	  9276: KEY_VAL
01:00207872 414C28          	  9277: 	dc.b	'AL(',TK_VAL			* VAL(
01:00207875 D2
                            	  9278: KEY_VPTR
01:00207876 415250545228    	  9279: 	dc.b	'ARPTR(',TK_VPTR			* VARPTR(
01:0020787C DF
01:0020787D 00              	  9280: 	dc.b	$00
                            	  9281: TAB_ASCW
                            	  9282: KEY_WAIT
01:0020787E 414954          	  9283: 	dc.b	'AIT',TK_WAIT			* WAIT
01:00207881 94
                            	  9284: KEY_WHILE
01:00207882 48494C45        	  9285: 	dc.b	'HILE',TK_WHILE			* WHILE
01:00207886 B1
                            	  9286: KEY_WIDTH
01:00207887 49445448        	  9287: 	dc.b	'IDTH',TK_WIDTH			* WIDTH
01:0020788B A3
01:0020788C 00              	  9288: 	dc.b	$00
                            	  9289: TAB_POWR
                            	  9290: KEY_POWER
01:0020788D B6              	  9291: 	dc.b	TK_POWER,$00			* ^
01:0020788E 00
                            	  9292: 
                            	  9293: 
                            	  9294: *************************************************************************************
                            	  9295: *
                            	  9296: * just messages
                            	  9297: 
                            	  9298: LAB_BMSG
01:0020788F 0D              	  9299: 	dc.b	$0D,$0A,'Break',$00
01:00207890 0A
01:00207891 427265616B
01:00207896 00
                            	  9300: LAB_EMSG
01:00207897 204572726F72    	  9301: 	dc.b	' Error',$00
01:0020789D 00
                            	  9302: LAB_LMSG
01:0020789E 20696E206C696E65	  9303: 	dc.b	' in line ',$00
01:002078A6 20
01:002078A7 00
                            	  9304: LAB_IMSG
01:002078A8 4578747261206967	  9305: 	dc.b	'Extra ignored',$0D,$0A,$00
01:002078B0 6E6F726564
01:002078B5 0D
01:002078B6 0A
01:002078B7 00
                            	  9306: LAB_REDO
01:002078B8 5265646F2066726F	  9307: 	dc.b	'Redo from start',$0D,$0A,$00
01:002078C0 6D207374617274
01:002078C7 0D
01:002078C8 0A
01:002078C9 00
                            	  9308: LAB_RMSG
01:002078CA 0D              	  9309: 	dc.b	$0D,$0A,'Ready',$0D,$0A,$00
01:002078CB 0A
01:002078CC 5265616479
01:002078D1 0D
01:002078D2 0A
01:002078D3 00
                            	  9310: LAB_SMSG
01:002078D4 2042797465732066	  9311: 	dc.b	' Bytes free',$0D,$0A,$0A
01:002078DC 726565
01:002078DF 0D
01:002078E0 0A
01:002078E1 0A
01:002078E2 456E68616E636564	  9312: 	dc.b	'Enhanced 68k BASIC Version 3.54',$0D,$0A,$00
01:002078EA 2036386B20424153
01:002078F2 4943205665727369
01:002078FA 6F6E20332E3534
01:00207901 0D
01:00207902 0A
01:00207903 00
                            	  9313: 
                            	  9314: 
                            	  9315: *************************************************************************************
                            	  9316: * EhBASIC keywords quick reference list								*
                            	  9317: *************************************************************************************
                            	  9318: 
                            	  9319: * glossary
                            	  9320: 
                            	  9321: *		<.>		  required
                            	  9322: *		{.|.}		  one of required
                            	  9323: *		[.]		  optional
                            	  9324: *		...		  may repeat as last
                            	  9325: 
                            	  9326: *		any		= anything
                            	  9327: *		num		= number
                            	  9328: *		state		= statement
                            	  9329: *		n		= positive integer
                            	  9330: *		str		= string
                            	  9331: *		var		= variable
                            	  9332: *		nvar		= numeric variable
                            	  9333: *		svar		= string variable
                            	  9334: *		expr		= expression
                            	  9335: *		nexpr		= numeric expression
                            	  9336: *		sexpr		= string expression
                            	  9337: 
                            	  9338: * statement separator
                            	  9339: 
                            	  9340: * :		. [<state>] : [<state>]						* done
                            	  9341: 
                            	  9342: * number bases
                            	  9343: 
                            	  9344: * %		. %<binary num>							* done
                            	  9345: * $		. $<hex num>							* done
                            	  9346: 
                            	  9347: * commands
                            	  9348: 
                            	  9349: * END		. END									* done
                            	  9350: * FOR		. FOR <nvar>=<nexpr> TO <nexpr> [STEP <nexpr>]		* done
                            	  9351: * NEXT	. NEXT [<nvar>[,<nvar>]...]					* done
                            	  9352: * DATA	. DATA [{num|["]str["]}[,{num|["]str["]}]...]		* done
                            	  9353: * INPUT	. INPUT [<">str<">;] <var>[,<var>[,<var>]...]		* done
                            	  9354: * DIM		. DIM <var>(<nexpr>[,<nexpr>[,<nexpr>]])			* done
                            	  9355: * READ	. READ <var>[,<var>[,<var>]...]				* done
                            	  9356: * LET		. [LET] <var>=<expr>						* done
                            	  9357: * DEC		. DEC <nvar>[,<nvar>[,<nvar>]...]				* done
                            	  9358: * GOTO	. GOTO <n>								* done
                            	  9359: * RUN		. RUN [<n>]								* done
                            	  9360: * IF		. IF <expr>{GOTO<n>|THEN<{n|comm}>}[ELSE <{n|comm}>]	* done
                            	  9361: * RESTORE	. RESTORE [<n>]							* done
                            	  9362: * GOSUB	. GOSUB <n>								* done
                            	  9363: * RETURN	. RETURN								* done
                            	  9364: * REM		. REM [<any>]							* done
                            	  9365: * STOP	. STOP								* done
                            	  9366: * ON		. ON <nexpr>{GOTO|GOSUB}<n>[,<n>[,<n>]...]		* done
                            	  9367: * NULL	. NULL <nexpr>							* done
                            	  9368: * INC		. INC <nvar>[,<nvar>[,<nvar>]...]				* done
                            	  9369: * WAIT	. WAIT <nexpr>,<nexpr>[,<nexpr>]				* done
                            	  9370: * LOAD	. LOAD [<sexpr>]							* done for sim
                            	  9371: * SAVE	. SAVE [<sexpr>][,[<n>][-<n>]]				* done for sim
                            	  9372: * DEF		. DEF FN<var>(<var>)=<expr>					* done
                            	  9373: * POKE	. POKE <nexpr>,<nexpr>						* done
                            	  9374: * DOKE	. DOKE <nexpr>,<nexpr>						* done
                            	  9375: * LOKE	. LOKE <nexpr>,<nexpr>						* done
                            	  9376: * CALL	. CALL <nexpr>							* done
                            	  9377: * DO		. DO									* done
                            	  9378: * LOOP	. LOOP [{WHILE|UNTIL}<nexpr>]					* done
                            	  9379: * PRINT	. PRINT [{;|,}][<expr>][{;|,}[<expr>]...]			* done
                            	  9380: * CONT	. CONT								* done
                            	  9381: * LIST	. LIST [<n>][-<n>]						* done
                            	  9382: * CLEAR	. CLEAR								* done
                            	  9383: * NEW		. NEW									* done
                            	  9384: * WIDTH	. WIDTH [<n>][,<n>]						* done
                            	  9385: * GET		. GET <var>								* done
                            	  9386: * SWAP	. SWAP <var>,<var>						* done
                            	  9387: * BITSET	. BITSET <nexpr>,<nexpr>					* done
                            	  9388: * BITCLR	. BITCLR <nexpr>,<nexpr>					* done
                            	  9389: 
                            	  9390: * sub commands (may not start a statement)
                            	  9391: 
                            	  9392: * TAB		. TAB(<nexpr>)							* done
                            	  9393: * ELSE	. IF <expr>{GOTO<n>|THEN<{n|comm}>}[ELSE <{n|comm}>]	* done
                            	  9394: * TO		. FOR <nvar>=<nexpr> TO <nexpr> [STEP <nexpr>]		* done
                            	  9395: * FN		. FN <var>(<expr>)						* done
                            	  9396: * SPC		. SPC(<nexpr>)							* done
                            	  9397: * THEN	. IF <nexpr> {THEN <{n|comm}>|GOTO <n>}			* done
                            	  9398: * NOT		. NOT <nexpr>							* done
                            	  9399: * STEP	. FOR <nvar>=<nexpr> TO <nexpr> [STEP <nexpr>]		* done
                            	  9400: * UNTIL	. LOOP [{WHILE|UNTIL}<nexpr>]					* done
                            	  9401: * WHILE	. LOOP [{WHILE|UNTIL}<nexpr>]					* done
                            	  9402: 
                            	  9403: * operators
                            	  9404: 
                            	  9405: * +		. [expr] + <expr>							* done
                            	  9406: * -		. [nexpr] - <nexpr>						* done
                            	  9407: * *		. <nexpr> * <nexpr>						* done fast hardware
                            	  9408: * /		. <nexpr> / <nexpr>						* done fast hardware
                            	  9409: * ^		. <nexpr> ^ <nexpr>						* done
                            	  9410: * AND		. <nexpr> AND <nexpr>						* done
                            	  9411: * EOR		. <nexpr> EOR <nexpr>						* done
                            	  9412: * OR		. <nexpr> OR <nexpr>						* done
                            	  9413: * >>		. <nexpr> >> <nexpr>						* done
                            	  9414: * <<		. <nexpr> << <nexpr>						* done
                            	  9415: 
                            	  9416: * compare functions
                            	  9417: 
                            	  9418: * <		. <expr> < <expr>							* done
                            	  9419: * =		. <expr> = <expr>							* done
                            	  9420: * >		. <expr> > <expr>							* done
                            	  9421: 
                            	  9422: * functions
                            	  9423: 
                            	  9424: * SGN		. SGN(<nexpr>)							* done
                            	  9425: * INT		. INT(<nexpr>)							* done
                            	  9426: * ABS		. ABS(<nexpr>)							* done
                            	  9427: * USR		. USR(<expr>)							* done
                            	  9428: * FRE		. FRE(<expr>)							* done
                            	  9429: * POS		. POS(<expr>)							* done
                            	  9430: * SQR		. SQR(<nexpr>)							* done fast shift/sub
                            	  9431: * RND		. RND(<nexpr>)							* done 32 bit PRNG
                            	  9432: * LOG		. LOG(<nexpr>)							* done fast cordic
                            	  9433: * EXP		. EXP(<nexpr>)							* done fast cordic
                            	  9434: * COS		. COS(<nexpr>)							* done fast cordic
                            	  9435: * SIN		. SIN(<nexpr>)							* done fast cordic
                            	  9436: * TAN		. TAN(<nexpr>)							* done fast cordic
                            	  9437: * ATN		. ATN(<nexpr>)							* done fast cordic
                            	  9438: * PEEK	. PEEK(<nexpr>)							* done
                            	  9439: * DEEK	. DEEK(<nexpr>)							* done
                            	  9440: * LEEK	. LEEK(<nexpr>)							* done
                            	  9441: * LEN		. LEN(<sexpr>)							* done
                            	  9442: * STR$	. STR$(<nexpr>)							* done
                            	  9443: * VAL		. VAL(<sexpr>)							* done
                            	  9444: * ASC		. ASC(<sexpr>)							* done
                            	  9445: * UCASE$	. UCASE$(<sexpr>)							* done
                            	  9446: * LCASE$	. LCASE$(<sexpr>)							* done
                            	  9447: * CHR$	. CHR$(<nexpr>)							* done
                            	  9448: * HEX$	. HEX$(<nexpr>)							* done
                            	  9449: * BIN$	. BIN$(<nexpr>)							* done
                            	  9450: * BTST	. BTST(<nexpr>,<nexpr>)						* done
                            	  9451: * MAX		. MAX(<nexpr>[,<nexpr>[,<nexpr>]...])			* done
                            	  9452: * MIN		. MIN(<nexpr>[,<nexpr>[,<nexpr>]...])			* done
                            	  9453: * PI		. PI									* done
                            	  9454: * TWOPI	. TWOPI								* done
                            	  9455: * VARPTR	. VARPTR(<var>)							* done
                            	  9456: * SADD	. SADD(<svar>)							* done
                            	  9457: * LEFT$	. LEFT$(<sexpr>,<nexpr>)					* done
                            	  9458: * RIGHT$	. RIGHT$(<sexpr>,<nexpr>)					* done
                            	  9459: * MID$	. MID$(<sexpr>,<nexpr>[,<nexpr>])				* done
                            	  9460: * USING$	. USING$(<sexpr>,<nexpr>[,<nexpr>]...])			* done
                            	  9461: 

Source: "src/combo_68k.asm"
                            	  8727: 
                            	  8728:          END     START
                            	  8729: 


Symbols by name:
A3OUT                            A:00200EFA
A5300                            A:002030CE
A5305                            A:002030DA
A5TODEST                         A:002030CC
ABORT335                         A:00201D40
ABORTB                           A:00201D18
ABORTE                           A:00201D5C
AC1gtAC2                         A:00205EE8
ACIA_1                           E:003C0008
ACIA_2                           E:003C0008
ADDRESS                          E:FFFFFFC0
ADDRMSG                          A:00200432
ALTSER1                          A:00000624
ALTSER2                          A:00000628
AV11                             A:0000002C
AV12                             A:00000030
AV2                              A:00000008
AV24                             A:00000060
AV3                              A:0000000C
AV31                             A:0000007C
AV4                              A:00000010
AV46                             A:000000B8
AV47                             A:000000BC
AV48                             A:000000C0
AV8                              A:00000020
AV9                              A:00000024
Asptl                            E:000005A8
Asrch                            E:000005DA
Astrtl                           E:000005AC
BACMD                            A:0020127E
BCMD0                            A:00200A52
BCMD00                           A:00200A60
BCMD01                           A:00200A36
BCMD3                            A:00200A6E
BCMD33                           A:00200A74
BCMD5                            A:00200A8C
BCMD55                           A:00200A94
BCMD6                            A:00200A86
BCMD7                            A:00200A9E
BCMD77                           A:00200AA6
BCMD8                            A:00200AAC
BCMD81                           A:00200ACC
BCMD9                            A:00200AD0
BEGHRAM                          A:0000044C
BELL                             E:00000007
BERRD                            A:000004CA
BERRMSG                          A:00200428
BFCMD                            A:002008E0
BFCMD11                          A:00200920
BHsend                           E:000005D6
BKPOINT                          E:00004AFB
BKSPACE                          A:002020FA
BLANK                            E:00000020
BLANKIT                          A:0020210C
BM112                            A:0020096E
BM122                            A:00200976
BM132                            A:0020097A
BM142                            A:00200980
BMCMD                            A:00200932
BPADD                            A:00000470
BPCNT                            A:00000494
BPDATA                           A:000004B8
BPSTATUS                         A:000004E0
BPTILL                           A:00000490
BRCMD                            A:00200A4E
BREAK                            A:00202278
BREAK1                           A:00202262
BREAK2                           A:0020225E
BREAK79                          A:0020227E
BRTBL                            A:00203B08
BS101                            A:00200B7E
BS200                            A:00200B8A
BS213                            A:00200BBC
BS215                            A:00200BC0
BS219                            A:00200BC4
BS225                            A:00200BD6
BS311                            A:00200BE8
BS313                            A:00200BEC
BS323                            A:00200C0C
BS325                            A:00200C12
BS355                            A:00200C3A
BS365                            A:00200C44
BS4CTLH                          A:00202108
BS91                             A:00200B44
BS97                             A:00200B6E
BSCMD                            A:00200B14
BTCMD                            A:00200C4E
BUFFER                           A:00000540
BUFFSIZE                         E:00000080
BUFSIZE                          E:00000050
Bin2dec                          A:00206E98
BinPr                            A:00206A80
Binss                            E:000005B6
Blinel                           E:00000456
Breakf                           E:000005DC
CC                               E:FFFFFFBC
CHARSAVE                         A:0020213A
CHKBP                            A:002011E0
CHKBP1                           A:0020120E
CHKBP11                          A:0020121A
CHKBP2                           A:00201224
CHKBP3                           A:00201230
CHKBP4                           A:00201234
CHKBRK                           A:0020224C
CHKCHKS                          A:002013C8
CHKCR                            A:0020214A
CHKCTLD                          A:0020211E
CHKCTLH                          A:002020EE
CHRPRINT                         A:00202174
CKADDR                           A:00201E92
CKADR39                          A:00201E9A
CKADR99                          A:00201EAE
CKWADR                           A:00201E8C
CMMD2                            A:00202DFE
CMMD2S10                         A:00202E76
CMMD2S11                         A:00202EE4
CMMD35                           A:00202E20
CODE68K                          A:00202C86
COMMA                            A:00202DDC
COMMAS20                         A:00202EE6
COMMON                           A:00203EFA
COMMON35                         A:00203F08
COMMON4                          A:00203EF8
CR                               E:0000000D
CRPADS                           A:0000061A
CRTPNT                           A:00000652
CS11                             A:00203930
CS12                             A:0020389A
CS13                             A:00203818
CS14                             A:002037A8
CS15                             A:00203768
CS16                             A:002036FA
CS17                             A:00203AD4
CS18                             A:00203A6E
CS19                             A:00203B80
CS20                             A:002039D0
CT                               A:002042FC
CTLD                             E:00000004
CTLH                             E:00000008
CTLINK                           A:00000656
CTLW                             E:00000017
CTLW9                            A:0020224A
CTLWH                            A:00202240
CTLX                             E:00000018
Cflag                            E:000005E1
Clinel                           E:00000452
Cpntrl                           E:0000045A
DCCMD                            A:00200CA0
DCODE68K                         A:00203E60
DDATA                            E:FFFFFFF0
DEC311                           A:00203E74
DEC404                           A:00203E90
DEC411                           A:00203EA0
DEC425                           A:00203EB0
DEC510                           A:00203EBE
DEC515                           A:00203EC2
DEC530                           A:00203ECA
DEC535                           A:00203ED0
DEC537                           A:00203EDC
DECODE1                          A:00200680
DECODE10                         A:00200696
DECODE2                          A:002006A0
DECODE21                         A:002006AA
DECODE3                          A:002006D0
DECODE4                          A:002006AE
DECODE41                         A:002006BC
DECODE6                          A:00200670
DEL                              E:0000007F
DELAYC1                          E:00001000
DFCMD                            A:00200CFE
DUCMD                            A:00200E1C
DUMPTEMP                         A:000005C0
Decss                            E:000005C6
Defdim                           E:000005B4
Dimcnt                           E:000005DB
Dlinel                           E:0000045E
DoCmp                            A:00204AFE
DoRest                           A:00204AEA
Dptrl                            E:00000462
Dtypef                           E:000005B5
EA                               A:0020269A
EA000                            A:00203BB0
EA001                            A:00203BBC
EA010                            A:00203BC8
EA011                            A:00203BDC
EA011RTS                         A:00203BF2
EA0633                           A:002026C8
EA0634                           A:002026CC
EA0635                           A:002026D8
EA0637                           A:002026E0
EA10                             A:002026EC
EA100                            A:00203BF4
EA101                            A:00203C96
EA11                             A:00202718
EA1105                           A:00203C72
EA1107                           A:00203C76
EA1109                           A:00203C8C
EA111                            A:00203CAC
EA1112                           A:00203CCA
EA1113                           A:00203CE6
EA1113A                          A:00203CF6
EA1114                           A:00203D18
EA1115                           A:00203D82
EA11153                          A:00203DBA
EA11155                          A:00203DC4
EA16BIT                          A:00202902
EA16BITC                         A:00202910
EA16BITS                         A:0020290C
EA21                             A:00202730
EA31                             A:00202744
EA34                             A:0020277A
EA35                             A:0020277C
EA41                             A:0020278A
EA4102                           A:0020279E
EA4105                           A:002027A4
EA4120                           A:002027E0
EA4127                           A:002027BA
EA4135                           A:002027CA
EA5115                           A:00202826
EA5116                           A:0020282A
EA5118                           A:0020286A
EA5119                           A:00202870
EA5119E                          A:0020287A
EA61                             A:0020287C
EA71                             A:002028AE
EA7113                           A:002028F0
EA7115                           A:002028F6
EA8BIT                           A:00202918
EA8BITC                          A:00202924
EA8BITS                          A:00202920
EAA                              A:00202690
EAALL                            A:00202696
EAC                              A:00202678
EADA                             A:00202672
EADADDR                          A:0020268A
EAF25                            A:00203D60
EAF27                            A:00203D64
EAF35                            A:00203D78
EAM                              A:0020267E
EAS                              A:00202926
EASEX                            A:00202934
EAZ                              A:00202684
ECHOPT1                          A:000004E2
EEA                              A:00203C0E
EEA10                            A:00203822
ENDHRAM                          A:0000065A
ENDS0                            A:00200E8E
EOHLOOP                          A:002012CE
EOT                              E:00000004
ER                               A:00202DF6
ER1                              A:0020266E
ER10                             A:0020347E
ER2                              A:0020319C
ER3                              A:00202786
ER4                              A:002028AA
ERDONE                           A:00202DFA
ERF                              A:00202DF4
ERROR                            A:002004A8
ESKB                             E:00000000
ESKE                             E:00000022
EV                               A:002025C2
EV15                             A:002025CA
EV21                             A:002025C6
EV39                             A:002025E0
EVECT                            A:002008DC
EVECT2                           A:00201D78
EVECT4                           A:00201D3C
EVECT5                           A:002007F6
EVECT6                           A:0020083C
EVECT7                           A:0020088C
EVECTL                           A:00201D64
EVER                             A:002031FC
EVSR                             A:00203220
Earryl                           E:00000442
Ememl                            E:0000044A
EndBHS                           A:00206A5A
F100                             A:00204370
F110                             A:00204378
F120                             A:00204380
FAC1_e                           E:00000594
FAC1_m                           E:00000590
FAC1_s                           E:00000595
FAC2_e                           E:0000059C
FAC2_m                           E:00000598
FAC2_s                           E:0000059D
FAC_sc                           E:0000059E
FAULTAC2                         A:0020235A
FAULTAC3                         A:0020236E
FAULTAC4                         A:00202342
FAULTSER                         A:00202338
FDATA                            E:0000000A
FE10                             A:00203C0A
FE11                             A:00203CF2
FE12                             A:00203EAE
FERROR                           A:00203F22
FERROR35                         A:00203F2C
FERROR39                         A:00203F38
FIRST                            A:00200000
FIXBP                            A:00200A3E
FIXBUF                           A:00202090
FIXD2                            A:002004F8
FIXDADD                          A:002004EE
FIXDATA                          A:002004EA
FIXDCRLF                         A:002004FE
FLAG                             S:00000000
FLASH_SUPPORT                    E:00000000
FNEXTF                           A:00201E6E
FNEXTF1                          A:00201E6C
FNEXTF7                          A:00201E88
FOC                              E:0000001F
FOL                              E:0000001F
FOP                              E:00000027
FORM1                            A:002037A0
FORM10                           A:00203868
FORM103                          A:0020386E
FORM104                          A:00203872
FORM105                          A:00203884
FORM10E3                         A:0020384A
FORM10E4                         A:00203852
FORM10E6                         A:0020385E
FORM10EX                         A:00203828
FORM11                           A:002038A0
FORM112                          A:002038C0
FORM114                          A:002038CE
FORM11SL                         A:002038AC
FORM12                           A:002038D0
FORM125                          A:002038EA
FORM12A                          A:0020390C
FORM1A                           A:002037A4
FORM3                            A:002037AC
FORM4                            A:002037B0
FORM5                            A:002037C4
FORM6A                           A:002037C8
FORM6D                           A:002037D8
FORM7                            A:00203800
FORM8                            A:0020380C
FORM815                          A:00203810
FORM9                            A:0020381C
FORM91                           A:00203B98
FORM93                           A:00203BAC
FORM95                           A:00203BAE
FORMREG5                         A:002037EC
FORMREGA                         A:002037E8
FORMREGD                         A:002037F8
FORMSIZE                         A:00203B84
FPR315                           A:00202E14
FREL10                           A:00201DDA
FREL15                           A:00201DEC
FREL20                           A:00201E04
FREL25                           A:00201E16
FREL30                           A:00201E20
FRELADDR                         A:00201DCE
FSIZE                            A:0020262C
GAE                              A:00201006
GAP111                           A:00200F52
GAP111S                          A:00200FBC
GAP113                           A:00200F5A
GAP118                           A:00200FB4
GAP119                           A:00200FB6
GAP121                           A:00200FBE
GAP131                           A:00200FCA
GAP135                           A:00200FD6
GAP141                           A:00200FDE
GAP161                           A:0020100A
GAP163                           A:00201020
GAP165                           A:0020102A
GAP171                           A:00201030
GAP181                           A:0020104C
GAP191                           A:00201052
GAP197                           A:00201064
GAP199                           A:00201066
GASRGN                           A:0020106C
GCMD                             A:00200A20
GDCMD                            A:00200A2E
GET41                            A:0020263A
GETA                             A:00200F36
GETCHAR                          A:00202DE4
GETCHARF                         A:00202DEC
GETCHR                           A:002014FE
GETDECNU                         A:00201EF4
GETEXP                           A:00201EC2
GETEXP15                         A:00201ECA
GETEXP21                         A:00201EC6
GETEXP39                         A:00201EE0
GETF305                          A:002025F4
GETF308                          A:00202608
GETF311                          A:00202608
GETF312                          A:00202618
GETF313                          A:0020261C
GETF314                          A:0020261E
GETF325                          A:00202624
GETF333                          A:0020262A
GETFIELD                         A:002025E8
GETHEX                           A:00201FA0
GETHEXC                          A:00201506
GETHEXNU                         A:00201EFC
GETIMM                           A:00203640
GETN20                           A:00201F02
GETN30                           A:00201F0C
GETN40                           A:00201F18
GETN50                           A:00201F22
GETN55                           A:00201F2A
GETN57                           A:00201F2E
GETN60                           A:00201F32
GETN65                           A:00201F3C
GETN70                           A:00201F46
GETN75                           A:00201F50
GETN77                           A:00201F6A
GETN80                           A:00201F84
GETN85                           A:00201F88
GETN90                           A:00201F8A
GETN95                           A:00201F8E
GETNDATA                         A:00201F94
GETNUMA                          A:00201EF0
GETNUMD                          A:00201EE8
GETNUMD9                         A:00201EEA
GETREGA                          A:0020264C
GETREGAD                         A:0020265A
GETREGD                          A:00202632
GETSER1                          A:0020206C
GETSER2                          A:0020207E
GOCMD                            A:00200A20
GOCMD1                           A:00200A22
GOCMD1A                          A:00200A16
GOSET1                           A:00200A02
GT21                             A:002009F0
GTCMD                            A:002009D4
GTHX2                            A:00201FBA
Gclctd                           E:000005DE
GetFirst                         A:002052CC
GetPair                          A:00205388
GoPr                             A:00206A8A
HECMD                            A:00201282
HELP4                            A:0020129A
HELP6                            A:002012E2
HELP81                           A:002012D0
HELP85                           A:002012E0
HEX2DEC                          A:0020135C
HISPC                            E:FFFFFFFC
HX2DC                            A:0020136C
HX2DC0                           A:00201370
HX2DC1                           A:00201378
HX2DC2                           A:00201392
HX2DC22                          A:00201394
HX2DC3                           A:0020139E
HX2DC4                           A:002013A6
HX2DC5                           A:002013AE
HX2DC57                          A:002013B6
HX2DC6                           A:002013BA
Hexss                            E:000005CE
IBSR                             A:00203A28
ICC                              A:00203A24
ICC35                            A:00203A3A
ICC55                            A:00203A50
ICCCC                            A:00203AF0
ICCCC9                           A:00203B06
IDBCC                            A:00203A10
ILINK                            A:00203788
IM7788                           A:002036C4
IM7799                           A:002036C8
IMMED                            A:00203710
IMMED45                          A:00203736
IMMED55                          A:0020376A
IMMED65                          A:00203770
IMMED75                          A:00203780
IMOVE                            A:00203784
IMOVE19                          A:00203B4E
IMOVEA1                          A:00203B28
IMOVEMFR                         A:002036B0
IMOVEMTR                         A:002036E0
IMOVEP                           A:002039A8
IMOVEP11                         A:002039B8
IMOVEP35                         A:002039D4
IMOVEP66                         A:002039E2
IMOVEQ                           A:00203938
IMVFSR                           A:00203958
IMVFUSP                          A:00203968
IMVT44                           A:00203986
IMVTCCR                          A:00203998
IMVTSR                           A:00203978
IMVTUSP                          A:0020398C
INCHNE                           A:002023A0
INFROM                           A:00000620
INGET                            A:00206ADE
INIT                             A:00200410
INIT0                            A:00200510
INITAC3                          A:0020237E
INITHRAM                         A:00200404
INITSER                          A:00202374
INITVECT                         A:00200508
INITVMSG                         A:0020077A
INPORT1                          A:0000062C
INPORT2                          A:00000634
INPORT3                          A:0000063C
INPORT4                          A:00000644
IQUICK                           A:00203934
IQUICK21                         A:00203B66
IQUICK31                         A:00203B7C
IQUICKA                          A:00203B54
ISCC                             A:00203A04
ISETD                            A:00203A60
ISETD12                          A:00203A66
ISETS                            A:00203A70
ISHIFT                           A:00203A8C
ISHIFT13                         A:00203A98
ISHIFT23                         A:00203ABC
ISHIFT33                         A:00203AC8
ISHIFT44                         A:00203ACC
ISHIFTM1                         A:00203AD6
ISTOP                            A:002036FC
Ibuffe                           E:00000590
Ibuffs                           E:00000490
Iclim                            E:000005E7
Imode                            E:000005E0
Itemp                            E:0000042A
KEY_ABS                          A:002076F8
KEY_AND                          A:002076FC
KEY_ASC                          A:002076FF
KEY_ATN                          A:00207703
KEY_BINS                         A:00207708
KEY_BITCLR                       A:0020770D
KEY_BITSET                       A:00207713
KEY_BITTST                       A:00207719
KEY_CALL                         A:00207721
KEY_CHRS                         A:00207725
KEY_CLEAR                        A:0020772A
KEY_CONT                         A:0020772F
KEY_COS                          A:00207733
KEY_DATA                         A:00207738
KEY_DEC                          A:0020773C
KEY_DEEK                         A:0020773F
KEY_DEF                          A:00207744
KEY_DIM                          A:00207747
KEY_DIV                          A:002076EA
KEY_DO                           A:0020774E
KEY_DOKE                         A:0020774A
KEY_ELSE                         A:00207751
KEY_END                          A:00207755
KEY_EOR                          A:00207758
KEY_EQUAL                        A:002076F0
KEY_EXP                          A:0020775B
KEY_FN                           A:00207763
KEY_FOR                          A:00207760
KEY_FRE                          A:00207765
KEY_GET                          A:0020776A
KEY_GOSUB                        A:00207771
KEY_GOTO                         A:0020776D
KEY_GT                           A:002076F4
KEY_HEXS                         A:00207777
KEY_IF                           A:0020777D
KEY_INC                          A:0020777F
KEY_INPUT                        A:00207782
KEY_INT                          A:00207787
KEY_LCASES                       A:0020778C
KEY_LEEK                         A:00207793
KEY_LEFTS                        A:00207798
KEY_LEN                          A:0020779E
KEY_LET                          A:002077A2
KEY_LIST                         A:002077A5
KEY_LOAD                         A:002077A9
KEY_LOG                          A:002077AD
KEY_LOKE                         A:002077B1
KEY_LOOP                         A:002077B5
KEY_LSHIFT                       A:002076EC
KEY_LT                           A:002076EE
KEY_MAX                          A:002077BA
KEY_MIDS                         A:002077BE
KEY_MIN                          A:002077C3
KEY_MINUS                        A:002076E8
KEY_MULT                         A:002076E4
KEY_NEW                          A:002077C8
KEY_NEXT                         A:002077CB
KEY_NOT                          A:002077CF
KEY_NULL                         A:002077D2
KEY_ON                           A:002077D7
KEY_OR                           A:002077D9
KEY_PEEK                         A:002077DC
KEY_PI                           A:002077E1
KEY_PLUS                         A:002076E6
KEY_POKE                         A:002077E3
KEY_POS                          A:002077E7
KEY_POWER                        A:0020788D
KEY_PRINT                        A:002077EB
KEY_RAM                          A:002077F1
KEY_READ                         A:002077F8
KEY_REM                          A:002077FC
KEY_RESTORE                      A:002077FF
KEY_RETURN                       A:00207806
KEY_RIGHTS                       A:0020780C
KEY_RND                          A:00207813
KEY_RSHIFT                       A:002076F2
KEY_RUN                          A:00207817
KEY_SADD                         A:0020781B
KEY_SAVE                         A:00207820
KEY_SGN                          A:00207824
KEY_SIN                          A:00207828
KEY_SPC                          A:0020782C
KEY_SQR                          A:00207830
KEY_STEP                         A:00207834
KEY_STOP                         A:00207838
KEY_STRS                         A:0020783C
KEY_SWAP                         A:00207841
KEY_TAB                          A:00207846
KEY_TAN                          A:0020784A
KEY_THEN                         A:0020784E
KEY_TO                           A:00207852
KEY_TWOPI                        A:00207854
KEY_UCASES                       A:0020785A
KEY_UNTIL                        A:00207861
KEY_USINGS                       A:00207866
KEY_USR                          A:0020786D
KEY_VAL                          A:00207872
KEY_VPTR                         A:00207876
KEY_WAIT                         A:0020787E
KEY_WHILE                        A:00207882
KEY_WIDTH                        A:00207887
KFCTSEED                         E:26A3D110
KI                               A:00203F4C
KIEND                            A:00203F4E
LAB_11A5                         A:00204F9E
LAB_11A6                         A:00204FA0
LAB_11BD                         A:00204FAC
LAB_1269                         A:00204592
LAB_1274                         A:002045A0
LAB_127D                         A:002045A8
LAB_127E                         A:002045B6
LAB_1295                         A:002045CA
LAB_12AE                         A:002045EC
LAB_12B0                         A:002045EE
LAB_12E6                         A:0020460E
LAB_12FF                         A:00204640
LAB_1301                         A:00204642
LAB_1303                         A:00204660
LAB_1325                         A:00204678
LAB_132E                         A:00204668
LAB_1330                         A:0020466A
LAB_134B                         A:00204686
LAB_1357                         A:002046A4
LAB_1359                         A:002046AA
LAB_1374                         A:002046CA
LAB_1378                         A:002046D0
LAB_137F                         A:002046DC
LAB_138E                         A:002046E2
LAB_1392                         A:002046E6
LAB_13A6                         A:0020471A
LAB_13AC                         A:00204722
LAB_13C6                         A:0020474C
LAB_13CC                         A:00204752
LAB_13D6                         A:00204774
LAB_13D8                         A:0020477A
LAB_13EA                         A:00204786
LAB_13EC                         A:00204788
LAB_13FF                         A:002047A0
LAB_1401                         A:002047A4
LAB_1408                         A:002047B0
LAB_1410                         A:002047BC
LAB_1417                         A:002047C6
LAB_141B                         A:002047C8
LAB_141F                         A:002047D8
LAB_142A                         A:002047DE
LAB_142C                         A:002047EA
LAB_145E                         A:00204804
LAB_145F                         A:002047F6
LAB_1463                         A:0020480C
LAB_1477                         A:00204818
LAB_147A                         A:0020481E
LAB_1480                         A:00204838
LAB_1491                         A:00204842
LAB_14BD                         A:00204872
LAB_14C0                         A:00204876
LAB_14D4                         A:00204896
LAB_14E2                         A:002048B2
LAB_150C                         A:002048C0
LAB_1519                         A:002048CE
LAB_152E                         A:002048DA
LAB_1540                         A:00204906
LAB_15B3                         A:00204966
LAB_15C2                         A:00204990
LAB_15D1                         A:0020499C
LAB_15DC                         A:00204978
LAB_15F6                         A:0020498A
LAB_15FF                         A:002049AA
LAB_1602                         A:002049AE
LAB_1624                         A:00204A32
LAB_1629                         A:002049D2
LAB_1636                         A:002049D6
LAB_1639                         A:002049DC
LAB_163B                         A:002049E8
LAB_1647                         A:002049F4
LAB_164F                         A:002049FA
LAB_16B0                         A:00204A92
LAB_16D0                         A:00204AB6
LAB_1723                         A:00204B50
LAB_1725                         A:00204B54
LAB_172C                         A:00204B40
LAB_172D                         A:00204B48
LAB_174B                         A:00204B7C
LAB_174E                         A:00204BA0
LAB_1750                         A:00204BA8
LAB_1752                         A:00204BB4
LAB_1754                         A:00204BCC
LAB_1756                         A:00204BB8
LAB_176C                         A:00204BEA
LAB_1773                         A:00204BF4
LAB_1785                         A:00204C10
LAB_1786                         A:00204C3C
LAB_17B7                         A:00204C52
LAB_17B8                         A:00204C4E
LAB_17D5                         A:00204CCC
LAB_17D6                         A:00204CD0
LAB_1810                         A:00204CE2
LAB_1811                         A:00204CF2
LAB_1813                         A:00204CF8
LAB_1829                         A:00204D30
LAB_182C                         A:00204D34
LAB_1831                         A:00204D3A
LAB_185E                         A:00204D7A
LAB_1866                         A:00204D7E
LAB_1880                         A:00204E40
LAB_1886                         A:00204E4A
LAB_188A                         A:00204E4E
LAB_188B                         A:00204D8C
LAB_1898                         A:00204D9A
LAB_18A2                         A:00204DA4
LAB_18B7                         A:00204DC6
LAB_18B8                         A:00204DD2
LAB_18BD                         A:00204DD8
LAB_18C3                         A:00204DE2
LAB_18C6                         A:00204DE6
LAB_18CD                         A:00204DF0
LAB_18E3                         A:00204DFA
LAB_18F0                         A:00204E1A
LAB_18F7                         A:00204E28
LAB_18F9                         A:00204E2C
LAB_1904                         A:00204E52
LAB_1913                         A:00204E64
LAB_1934                         A:00204E8A
LAB_1953                         A:00204E9E
LAB_195B                         A:00204EA6
LAB_1961                         A:00204EB0
LAB_1984                         A:00204ED0
LAB_1985                         A:00204ED4
LAB_1986                         A:00204ED8
LAB_1999                         A:00204EEC
LAB_19B0                         A:00204EFE
LAB_19B6                         A:00204F0E
LAB_19C2                         A:00204F1E
LAB_19DD                         A:00204F32
LAB_19F6                         A:00204F52
LAB_1A03                         A:00204F60
LAB_1A0E                         A:00204F70
LAB_1A1B                         A:00204F76
LAB_1A46                         A:00204F90
LAB_1A90                         A:0020500E
LAB_1A9B                         A:0020501C
LAB_1ABA                         A:00205046
LAB_1ACD                         A:00205072
LAB_1ADB                         A:0020507E
LAB_1ADE                         A:00205082
LAB_1AE0                         A:00205098
LAB_1AFA                         A:002050B2
LAB_1B0B                         A:002050C8
LAB_1B13                         A:002050D0
LAB_1B1C                         A:002050E0
LAB_1B1D                         A:002050E2
LAB_1B2A                         A:002050F4
LAB_1B3C                         A:00205110
LAB_1B43                         A:00205056
LAB_1B78                         A:0020511C
LAB_1B7B                         A:00205120
LAB_1B7D                         A:00205122
LAB_1B84                         A:0020512C
LAB_1B86                         A:00205130
LAB_1B9D                         A:00205154
LAB_1BC1                         A:00205184
LAB_1BD0                         A:002051F0
LAB_1BE7                         A:0020520A
LAB_1BF3                         A:00205190
LAB_1BF7                         A:00205196
LAB_1BFB                         A:0020519A
LAB_1C01                         A:002051A2
LAB_1C11                         A:002051CA
LAB_1C13                         A:002051D0
LAB_1C18                         A:002051D6
LAB_1C19                         A:002051DA
LAB_1C1A                         A:002051EA
LAB_1C2A                         A:00205248
LAB_1CAE                         A:002052F0
LAB_1CB5                         A:0020530E
LAB_1CD4                         A:00205318
LAB_1CD5                         A:0020531E
LAB_1CD6                         A:00205320
LAB_1CDB                         A:00205330
LAB_1CE6                         A:00205322
LAB_1CF2                         A:00205332
LAB_1CFE                         A:00205348
LAB_1D10                         A:002053C0
LAB_1D12                         A:002053C4
LAB_1D2D                         A:002053D6
LAB_1D2E                         A:002053E2
LAB_1D44                         A:002053FE
LAB_1D45                         A:0020540E
LAB_1D48                         A:00205422
LAB_1D49                         A:0020542A
LAB_1D4A                         A:0020542E
LAB_1D4B                         A:0020543E
LAB_1D5D                         A:00205446
LAB_1D5E                         A:0020544C
LAB_1D83                         A:002053B0
LAB_1D8A                         A:002053AA
LAB_1D94                         A:00205460
LAB_1D96                         A:0020718E
LAB_1D98                         A:0020546A
LAB_1DAC                         A:00205484
LAB_1DAE                         A:00205486
LAB_1DAF                         A:00205492
LAB_1DB0                         A:002054A0
LAB_1DB1                         A:002054A4
LAB_1DB2                         A:002054A8
LAB_1DD7                         A:002054C0
LAB_1DE6                         A:002054DA
LAB_1E17                         A:0020551C
LAB_1E1F                         A:00205522
LAB_1E5C                         A:0020555C
LAB_1E8D                         A:00205578
LAB_1EA1                         A:00205594
LAB_1EC0                         A:002055BC
LAB_1ED6                         A:002055E8
LAB_1ED8                         A:002055F6
LAB_1EDF                         A:002055B0
LAB_1F07                         A:00205608
LAB_1F28                         A:00205622
LAB_1F2C                         A:00205628
LAB_1F5A                         A:00205636
LAB_1F6A                         A:0020565E
LAB_1F6B                         A:0020566A
LAB_1F7C                         A:00205670
LAB_1FB4                         A:0020569E
LAB_1FD0                         A:002056CA
LAB_201E                         A:00205724
LAB_2043                         A:00205772
LAB_2044                         A:002057A4
LAB_2045                         A:002057AE
LAB_204S                         A:00205774
LAB_204T                         A:002057A2
LAB_20AE                         A:002057C0
LAB_20B4                         A:002057C4
LAB_20BE                         A:002057CA
LAB_20C9                         A:002057EE
LAB_20CB                         A:002057DA
LAB_20D0                         A:002057E2
LAB_20D8                         A:002057F8
LAB_20E0                         A:00205800
LAB_2115                         A:00205820
LAB_2117                         A:00205838
LAB_2128                         A:00205852
LAB_2137                         A:00205856
LAB_214B                         A:00205876
LAB_2161                         A:0020588A
LAB_2176                         A:00205890
LAB_217E                         A:0020589C
LAB_2183                         A:002058B6
LAB_218B                         A:002058BE
LAB_218F                         A:002058C0
LAB_21C2                         A:002058CC
LAB_21C4                         A:002058D0
LAB_21D1                         A:00205904
LAB_2206                         A:0020590A
LAB_2212                         A:00205932
LAB_2216                         A:002058F4
LAB_2240                         A:002058FC
LAB_224D                         A:00205938
LAB_224E                         A:0020594E
LAB_229E                         A:00205992
LAB_22A0                         A:0020599E
LAB_22B6                         A:002059AC
LAB_22BA                         A:002059B0
LAB_22BD                         A:002059BA
LAB_22E6                         A:002059D4
LAB_2316                         A:00205A14
LAB_2317                         A:00205A16
LAB_231C                         A:00205A1A
LAB_2358                         A:00205A4E
LAB_2368                         A:00205A6E
LAB_2441                         A:00205C60
LAB_2445                         A:00205C64
LAB_2467                         A:00205CB4
LAB_2468                         A:00205CB8
LAB_249C                         A:00205CA6
LAB_24A8                         A:00205CBC
LAB_24B4                         A:00205CE6
LAB_24D0                         A:00205CF2
LAB_24D5                         A:00205CFC
LAB_24D6                         A:00205D16
LAB_24D7                         A:00205D24
LAB_24D8                         A:00205D2A
LAB_24D9                         A:00205D0A
LAB_24DA                         A:00205D30
LAB_24F7                         A:00205CD6
LAB_24F8                         A:00205CDC
LAB_2778                         A:00205F98
LAB_277C                         A:00205F9A
LAB_279B                         A:00205FBE
LAB_27BA                         A:00205FCC
LAB_27C3                         A:00205FE8
LAB_27C4                         A:00205FF2
LAB_27CA                         A:00205FF8
LAB_27CE                         A:00206000
LAB_27D0                         A:00206004
LAB_27DB                         A:00206012
LAB_27F0                         A:002062CE
LAB_27F1                         A:002062E4
LAB_27F2                         A:002062EA
LAB_27F3                         A:002062EC
LAB_27FA                         A:0020602A
LAB_2828                         A:0020604A
LAB_282E                         A:00206050
LAB_282F                         A:00206052
LAB_2831                         A:00206056
LAB_284G                         A:00206078
LAB_284H                         A:0020608A
LAB_284J                         A:0020608C
LAB_284L                         A:00206080
LAB_2887                         A:00206C86
LAB_289A                         A:00206CB0
LAB_289C                         A:00206CB6
LAB_289D                         A:00206CBC
LAB_28FD                         A:00206CD8
LAB_28FE                         A:00206CDE
LAB_28FF                         A:00206CE4
LAB_2900                         A:00206CF2
LAB_2901                         A:00206CF8
LAB_2902                         A:00206D4A
LAB_2903                         A:00206D52
LAB_2904                         A:00206D54
LAB_2953                         A:002060AC
LAB_295E                         A:002060B8
LAB_2967                         A:002060C4
LAB_2968                         A:002060CC
LAB_2969                         A:002060DE
LAB_296A                         A:002060E8
LAB_2970                         A:002060FE
LAB_2978                         A:0020610E
LAB_2989                         A:0020611E
LAB_299C                         A:00206172
LAB_29A7                         A:0020619A
LAB_29B7                         A:002061B2
LAB_29B9                         A:0020614A
LAB_29C0                         A:002061C0
LAB_29C3                         A:002061D8
LAB_29D9                         A:002061F2
LAB_29E4                         A:00206204
LAB_29F7                         A:00206218
LAB_29FB                         A:0020621C
LAB_29FD                         A:00206224
LAB_2A18                         A:00206234
LAB_2A1A                         A:00206236
LAB_2A21                         A:0020623E
LAB_2A3B                         A:0020625E
LAB_2A4B                         A:0020626C
LAB_2A58                         A:00206280
LAB_2A68                         A:00206298
LAB_2A74                         A:002062A4
LAB_2A89                         A:002062C0
LAB_2A8C                         A:002062C4
LAB_2A91                         A:002062CA
LAB_2A9A                         A:00207332
LAB_2A9B                         A:0020734E
LAB_2X01                         A:00206D10
LAB_2X02                         A:00206D18
LAB_2X03                         A:00206D26
LAB_2X04                         A:00206D2C
LAB_2X05                         A:00206D42
LAB_2Y01                         A:00206D62
LAB_2Y02                         A:00206D6A
LAB_2Y03                         A:00206D76
LAB_2Y04                         A:00206D7C
LAB_3216                         A:00205F32
LAB_32_16                        A:00205F30
LAB_ABER                         A:00204554
LAB_ABS                          A:00206022
LAB_AD                           A:002076C5
LAB_ADD                          A:00205C82
LAB_ADER                         A:00204520
LAB_AND                          A:002052C4
LAB_ASC                          A:00205AF8
LAB_ATCD                         A:00206666
LAB_ATGO                         A:00206624
LAB_ATLE                         A:00206642
LAB_ATN                          A:00206606
LAB_ATNP                         A:00206660
LAB_AYFC                         A:002056AA
LAB_BAER                         A:0020754C
LAB_BHCB                         A:002052AA
LAB_BHSS                         A:00205284
LAB_BINS                         A:00206A3C
LAB_BITCLR                       A:002066C8
LAB_BITSET                       A:002066B8
LAB_BMSG                         A:0020788F
LAB_BS                           A:002075EE
LAB_BTST                         A:002066D8
LAB_CALL                         A:00205C40
LAB_CASC                         A:0020539A
LAB_CATN                         A:0020666C
LAB_CAUC                         A:002053A0
LAB_CBIN                         A:00206E36
LAB_CBX1                         A:00206E50
LAB_CBXN                         A:00206E3E
LAB_CCER                         A:00204538
LAB_CHEX                         A:00206DD4
LAB_CHRS                         A:002059DE
LAB_CHX1                         A:00206DFA
LAB_CHX2                         A:00206E1E
LAB_CHX3                         A:00206E16
LAB_CHXX                         A:00206DDC
LAB_CKRN                         A:002056D2
LAB_CKTM                         A:00205038
LAB_CLEAR                        A:0020485A
LAB_CN                           A:0020765B
LAB_COLD                         A:0020445A
LAB_CONT                         A:00204A44
LAB_CORD                         A:0020659E
LAB_COS                          A:0020652E
LAB_CRLF                         A:00204D84
LAB_CTBL                         A:00207216
LAB_CTNM                         A:00205036
LAB_D0                           A:0020760C
LAB_D002                         A:002069A0
LAB_D00A                         A:002069B0
LAB_D00E                         A:002069C0
LAB_DATA                         A:00204B32
LAB_DD                           A:002075FB
LAB_DDER                         A:00204550
LAB_DEC                          A:00204C42
LAB_DECI                         A:00204CA0
LAB_DEEK                         A:00205BBE
LAB_DEF                          A:002056DC
LAB_DIM                          A:0020534C
LAB_DIV0                         A:00205F2A
LAB_DIVIDE                       A:00205EB0
LAB_DIVX                         A:00205F00
LAB_DO                           A:00204A76
LAB_DOKE                         A:00205BE8
LAB_DZER                         A:0020454C
LAB_DupFmt                       A:00206988
LAB_EMSG                         A:00207897
LAB_END                          A:002049DE
LAB_EOR                          A:002052B4
LAB_EQUAL                        A:002052DA
LAB_ESML                         A:00206444
LAB_EVBY                         A:00205B10
LAB_EVEX                         A:0020504C
LAB_EVEZ                         A:0020504E
LAB_EVIN                         A:002054E6
LAB_EVIR                         A:002054F6
LAB_EVNM                         A:00205034
LAB_EVPI                         A:002054EE
LAB_EX1                          A:0020637C
LAB_EXAD                         A:002064CE
LAB_EXCC                         A:002064B4
LAB_EXCM                         A:002063E6
LAB_EXNN                         A:002064A0
LAB_EXOF                         A:002063A0
LAB_EXOL                         A:002063B6
LAB_EXOU                         A:0020638C
LAB_EXP                          A:002063C0
LAB_EXPL                         A:0020649A
LAB_EXPS                         A:002063F8
LAB_EXRN                         A:002064A6
LAB_FB95                         A:00206AEE
LAB_FBA0                         A:00206AD2
LAB_FC                           A:002075B5
LAB_FCER                         A:00204564
LAB_FO                           A:002076CD
LAB_FOER                         A:0020451C
LAB_FOR                          A:00204912
LAB_FRE                          A:00205694
LAB_FTBL                         A:002072B2
LAB_FTPP                         A:00207266
LAB_FVAR                         A:002053B8
LAB_GADB                         A:00205B62
LAB_GADW                         A:00205B76
LAB_GARB                         A:0020586C
LAB_GBYT                         A:002051AE
LAB_GEAD                         A:00205B96
LAB_GET                          A:00204CFE
LAB_GETS                         A:00204D18
LAB_GFPN                         A:00204C04
LAB_GOSUB                        A:00204A88
LAB_GOTO                         A:00204A9A
LAB_GOTs                         A:00204AAA
LAB_GSCH                         A:00204A2A
LAB_GTBY                         A:00205B0C
LAB_GTHAN                        A:0020636E
LAB_GTWO                         A:00205B20
LAB_GVAL                         A:0020515A
LAB_GVAR                         A:002053BA
LAB_HEXS                         A:00206A8E
LAB_ID                           A:0020761B
LAB_IDER                         A:00204548
LAB_IF                           A:00204B5A
LAB_IGBY                         A:002051AC
LAB_IMSG                         A:002078A8
LAB_INC                          A:00204C48
LAB_INCI                         A:00204C96
LAB_INCT                         A:00204C88
LAB_INLN                         A:0020469A
LAB_INPUT                        A:00204E72
LAB_INT                          A:00206092
LAB_IRTS                         A:002060AA
LAB_ISHN                         A:00206DF6
LAB_KEYT                         A:002073B8
LAB_LAAD                         A:00205DAA
LAB_LCASE                        A:00205A76
LAB_LD                           A:0020767D
LAB_LDER                         A:00204530
LAB_LEEK                         A:00205BD4
LAB_LEFT                         A:002059EE
LAB_LENS                         A:00205AF0
LAB_LET                          A:00204CA4
LAB_LIST                         A:0020485E
LAB_LMSG                         A:0020789E
LAB_LOAD                         A:00205C38
LAB_LOCC                         A:00205DB0
LAB_LOCX                         A:00205DCC
LAB_LOG                          A:00205D32
LAB_LOKE                         A:00205BEE
LAB_LOLP                         A:00205DBA
LAB_LONE                         A:00205DE8
LAB_LONN                         A:00205DD0
LAB_LOOP                         A:00204AC8
LAB_LOWZ                         A:00205E22
LAB_LOXO                         A:00205DEE
LAB_LOXP                         A:00205DDE
LAB_LRMS                         A:00205262
LAB_LS                           A:00207638
LAB_LSHIFT                       A:00205358
LAB_LTHAN                        A:002052E4
LAB_LTPF                         A:002065AC
LAB_LTPT                         A:002065B8
LAB_LT_1                         A:00205F3E
LAB_MADD                         A:00205E50
LAB_MAN1                         A:00205F24
LAB_MAX                          A:00206AFA
LAB_MAXN                         A:00206B06
LAB_MIDS                         A:00205A32
LAB_MIN                          A:00206B10
LAB_MINN                         A:00206B1C
LAB_MKCHR                        A:002059E2
LAB_MMEC                         A:00206B26
LAB_MNOC                         A:00205E4A
LAB_MUEX                         A:00205E9E
LAB_MUF1                         A:00205E7A
LAB_MUF2                         A:00205E84
LAB_MUF3                         A:00205E9A
LAB_MULTIPLY                     A:00205E24
LAB_MUUF                         A:00205EA4
LAB_NB1T                         A:00205F76
LAB_NEW                          A:0020480A
LAB_NEXT                         A:00204F7E
LAB_NF                           A:0020757C
LAB_NFER                         A:00204574
LAB_NI                           A:002076D4
LAB_NSTT                         A:00206B8A
LAB_NULL                         A:00204A3A
LAB_NoSt                         A:00204D2A
LAB_OD                           A:002075A9
LAB_ODER                         A:00204568
LAB_OFER                         A:00204560
LAB_OM                           A:002075CC
LAB_OMER                         A:0020455C
LAB_ON                           A:00204BD0
LAB_OPPT                         A:002072FE
LAB_OR                           A:002052BC
LAB_OV                           A:002075C3
LAB_P004                         A:002069DE
LAB_P008                         A:002069F4
LAB_P00C                         A:002069FC
LAB_P00E                         A:00206A08
LAB_P010                         A:00206A0C
LAB_P018                         A:00206A26
LAB_P01A                         A:00206A2A
LAB_P01E                         A:00206A32
LAB_PEEK                         A:00205BAC
LAB_PFAC                         A:00205F80
LAB_PHFA                         A:00206B34
LAB_PI                           A:00206C66
LAB_POKE                         A:00205BB8
LAB_POON                         A:002062EE
LAB_POS                          A:002056C6
LAB_POWER                        A:0020630A
LAB_POWP                         A:0020633C
LAB_POZE                         A:002062FE
LAB_PPBI                         A:00205258
LAB_PPFN                         A:0020524A
LAB_PPFS                         A:0020523C
LAB_PRINT                        A:00204D38
LAB_PRNA                         A:00204DFC
LAB_P_10                         A:00206FA8
LAB_ProcFo                       A:002069C6
LAB_RAM                          A:00206C5C
LAB_READ                         A:00204E98
LAB_REDO                         A:002078B8
LAB_REM                          A:00204BC8
LAB_REMM                         A:00205F56
LAB_RESTORE                      A:00204A0C
LAB_RESs                         A:00204A1E
LAB_RETURN                       A:00204B1E
LAB_RG                           A:00207594
LAB_RGER                         A:0020456C
LAB_RIGHT                        A:00205A02
LAB_RMSG                         A:002078CA
LAB_RND                          A:002064DA
LAB_RSED                         A:00206EC0
LAB_RSHIFT                       A:00205368
LAB_RTST                         A:00205806
LAB_RUN                          A:00204A62
LAB_RUNn                         A:00204A70
LAB_SADD                         A:00205AD8
LAB_SAVE                         A:00205C3C
LAB_SCCA                         A:002051A4
LAB_SCER                         A:0020453C
LAB_SCGB                         A:0020519E
LAB_SCL0                         A:00206594
LAB_SCLN                         A:002047F8
LAB_SCZE                         A:00206586
LAB_SET1                         A:00205F08
LAB_SGBY                         A:00205B08
LAB_SGN                          A:00206010
LAB_SIN                          A:00206546
LAB_SLER                         A:00204540
LAB_SMSG                         A:002078D4
LAB_SN                           A:0020758D
LAB_SNBS                         A:00204B38
LAB_SNER                         A:00204570
LAB_SQE1                         A:00206C0E
LAB_SQE2                         A:00206C14
LAB_SQNA                         A:00206C3C
LAB_SQNS                         A:00206C26
LAB_SQR                          A:00206BEA
LAB_SSLN                         A:002047F0
LAB_ST                           A:00207648
LAB_STOP                         A:002049E6
LAB_STRS                         A:002057BC
LAB_SUBTRACT                     A:00205C6E
LAB_SVAR                         A:002053B6
LAB_SVTB                         A:00206BBC
LAB_SWAP                         A:00205C02
LAB_TAN                          A:0020650C
LAB_TBSZ                         A:00206B9C
LAB_TM                           A:0020762A
LAB_TMER                         A:00204544
LAB_TWOPI                        A:00206C76
LAB_U002                         A:00206730
LAB_U004                         A:00206786
LAB_U005                         A:00206796
LAB_U006                         A:00206798
LAB_U008                         A:002067AC
LAB_U009                         A:002067CE
LAB_U00A                         A:002067D6
LAB_U00B                         A:002067E0
LAB_U00C                         A:002067F4
LAB_U00D                         A:002067F8
LAB_U00E                         A:0020680A
LAB_U00F                         A:00206816
LAB_U010                         A:0020681A
LAB_U014                         A:00206820
LAB_U018                         A:00206828
LAB_U01C                         A:0020683E
LAB_U020                         A:0020684A
LAB_U022                         A:00206850
LAB_U026                         A:00206860
LAB_U02A                         A:0020686A
LAB_U02B                         A:00206882
LAB_U02C                         A:00206888
LAB_U02E                         A:0020689A
LAB_U030                         A:0020689E
LAB_U034                         A:002068B4
LAB_U036                         A:002068BA
LAB_U038                         A:002068C2
LAB_U03C                         A:002068CA
LAB_U03E                         A:002068D0
LAB_U040                         A:002068E8
LAB_U044                         A:002068F8
LAB_U046                         A:00206920
LAB_U048                         A:00206922
LAB_U04A                         A:0020692C
LAB_U04C                         A:0020695E
LAB_UA                           A:002076A0
LAB_UCASE                        A:00205AA6
LAB_UDER                         A:00204528
LAB_UF                           A:0020766A
LAB_UFAC                         A:00205F64
LAB_UFER                         A:00204534
LAB_US                           A:002075DA
LAB_USER                         A:00204558
LAB_USINGS                       A:00206706
LAB_USR                          A:00205C30
LAB_UV                           A:0020768D
LAB_UVER                         A:0020452C
LAB_VAL                          A:00205B34
LAB_VALZ                         A:00205B5C
LAB_VARCALL                      A:00206C4E
LAB_VARPTR                       A:00206C4C
LAB_WAIT                         A:00205C4A
LAB_WARM                         E:00000400
LAB_WD                           A:002076B4
LAB_WDER                         A:00204524
LAB_WDLP                         A:00206BD0
LAB_WDTH                         A:00206B6A
LAB_XDIV                         A:00205F18
LAB_XERR                         A:00204576
LAB_XGADW                        A:00205B90
LAB_exxf                         A:00206E24
LAB_ret0                         A:00206DC2
LAB_rtn0                         A:00206DC4
LAB_sizok                        A:0020446A
LAST                             A:002043E8
LC_loop                          A:00205A8C
LDATA                            E:FFFFFFC4
LERR1                            A:002021DC
LF                               E:0000000A
LINK                             E:0000001E
LIST                             A:00202164
LIST1                            A:0020216E
LIST2                            A:00202178
LIST24                           A:002021A0
LIST25                           A:002021A4
LIST3                            A:002021B8
LIST5                            A:002021F0
LOCMD                            A:002013C6
LOCVARSZ                         E:00000010
LTIME                            S:000320C8
L_DDIV                           A:00205F5E
L_DIVRND                         A:00205F0C
LoopAlways                       A:00204B04
LoopDone                         A:00204B18
Lvarpl                           E:00000472
M300                             A:00202C98
M340                             A:00202CE2
M350                             A:00202CEE
M352                             A:00202D22
M410                             A:00202D2C
M415                             A:00202D32
M420                             A:00202D44
M424                             A:00202D48
M426                             A:00202D4C
M428                             A:00202D56
M430                             A:00202D5C
M432                             A:00202D6A
M4324                            A:00202D98
M4326                            A:00202D9E
M435                             A:00202DBA
M437                             A:00202DC2
M440                             A:00202DD0
MABCD                            A:00202E34
MABCD55                          A:00202E6E
MABCD9                           A:00202E40
MACSBUG                          A:0020062E
MACSBUG1                         A:0020065C
MADD                             A:00202EEA
MADD46                           A:00202F1C
MADD56                           A:00202F28
MADD58                           A:00202F38
MADDA                            A:00202F92
MADDA21                          A:00202F9C
MADDI                            A:00202F44
MADDQ                            A:00202FBA
MADDQ25                          A:00202FF8
MADDX                            A:00202FFC
MADDX5                           A:00203032
MAND                             A:0020303E
MAND77                           A:00203072
MAND90                           A:00203088
MAND91                           A:00203096
MAND97                           A:0020309A
MANDI                            A:00202F5A
MANDI23                          A:00202F74
MASL                             A:002030EC
MB100                            A:00203166
MB105                            A:0020317E
MB145                            A:002031A0
MB185                            A:002031A6
MB200                            A:002031AA
MBCHG                            A:0020315C
MBCLR                            A:002031C0
MBRA                             A:002031E6
MBRA23                           A:00203200
MBRA27                           A:0020320E
MBSET                            A:002031B4
MBTST                            A:002031CC
MCHK                             A:0020323E
MCLR                             A:00203258
MCMD                             A:00201712
MCMMD2                           A:00202E04
MCMP                             A:00202E78
MCMP39                           A:00202ECE
MCMP56                           A:00202ED6
MCMPM                            A:00203266
MD1CON                           A:0000064C
MDBCC                            A:002031D8
MDC                              A:002036A0
MDCMD                            A:00201564
MEMSIZE                          A:0000046C
MEOR                             A:002030A0
MEOR90                           A:002030C0
MEXG                             A:00203290
MEXG25                           A:002032B2
MEXG35                           A:002032BC
MEXT                             A:002032CA
MJMP                             A:002035D8
MJMP22                           A:002035F4
MJMP32                           A:002035FA
MJMP42                           A:002035FE
MLEA                             A:00203604
MLINK                            A:0020364E
MM045                            A:00201742
MM05                             A:00201724
MM054                            A:00201756
MM056                            A:00201762
MM058                            A:00201770
MM060                            A:0020177E
MM064                            A:00201784
MM065                            A:0020178A
MM10                             A:0020178E
MM11                             A:0020179E
MM12                             A:002017C2
MM14                             A:002017CC
MM16                             A:002017D6
MM18                             A:002017DE
MM22                             A:0020182C
MM24                             A:0020183A
MM26                             A:00201848
MM315                            A:002034AA
MM40                             A:00201854
MM50                             A:00201878
MM508                            A:002034F0
MM60                             A:0020187E
MM70                             A:00203516
MM80                             A:00203544
MM804                            A:0020355C
MM806                            A:0020357A
MM825                            A:00203592
MM90                             A:00201884
MM905                            A:00201890
MM95                             A:00201888
MMA225                           A:002035C4
MMCMD                            A:00201712
MMDI                             A:0020167A
MMDI22                           A:00201684
MMDI23                           A:00201686
MMDI26                           A:002016C4
MMDI27                           A:002016CE
MMDI29                           A:002016E4
MMDI30                           A:002016F6
MMDI31                           A:0020169A
MMDI34                           A:002016AC
MMDI44                           A:002016FA
MMM40                            A:002034B2
MMM44                            A:0020331E
MMM46                            A:0020331E
MMM48                            A:00203344
MMM50                            A:002034D4
MMM60                            A:00203502
MMOVE                            A:00203490
MMOVEA                           A:002035AC
MMOVEA1                          A:002035A4
MMOVEM                           A:002032E4
MMOVEP                           A:002033E4
MMOVEQ                           A:00203444
MMP344                           A:00203414
MMP348                           A:00203424
MMP368                           A:00203440
MMQ20                            A:0020345E
MORES0                           A:00200E7E
MORESP                           A:00200E94
MOVEMR                           A:00203DE4
MOVEMR11                         A:00203DF4
MOVEMR33                         A:00203DFC
MOVEMR44                         A:00203E0E
MOVEMR77                         A:00203E28
MOVEMR79                         A:00203E3A
MOVEMR88                         A:00203E3C
MOVEMR94                         A:00203E54
MOVEMS                           A:00203DD0
MOVEMS2                          A:00203DE0
MPEA                             A:0020361E
MSCC                             A:0020314E
MSCMD                            A:00201896
MSG                              A:002004A0
MSG001                           A:002006F6
MSG002                           A:002012EA
MSG003                           A:00201BEA
MSG004                           A:00201BF5
MSG005                           A:00201C00
MSG006                           A:00201D02
MSG007                           A:002021FE
MSG008                           A:00200482
MSG008E                          A:00200489
MSG009                           A:00201244
MSG010                           A:00201D8E
MSG011                           A:00201FD4
MSG012                           A:00201D48
MSG013                           A:0020228A
MSG014                           A:00201258
MSG017                           A:0020193C
MSG018                           A:00201EB0
MSG019                           A:002004D8
MSG020                           A:00201266
MSG021                           A:00200490
MSG030                           A:00202426
MSG031                           A:00201C0B
MSG111                           A:00203F42
MSGBR                            A:00200ADA
MSGEOT                           A:0020048F
MSGLOAD1                         A:0020152A
MSGLOAD2                         A:00201533
MSGT14                           A:002042D0
MSL150                           A:0020310A
MSL200                           A:00203120
MSL300                           A:00203132
MSTOP                            A:0020366C
MSWAP                            A:0020362C
MTBL                             A:002033D4
MTCLR                            A:00201C42
MTRAP                            A:00203684
MTSETUP                          A:00201952
MTSTOR0                          A:00201C5A
MTSTOR1                          A:00201C4A
MUNLK                            A:00203696
NOAUTOLF                         A:0020215A
NOBR0                            A:00200AE6
NOBR1                            A:00200AEA
NOBR3                            A:00200B00
NOBR4                            A:00200B0C
NOBRCMD                          A:00200A34
NOC                              E:00000080
NOCMD                            A:002006EA
NOPACMD                          A:002025B8
NOTCHR                           A:00201636
NULLPADS                         A:00000618
NUMCON0                          A:00200CA0
NUMCON1                          A:00200CC4
NUMCON2                          A:00200CD0
NUMCON3                          A:00200CE8
NW                               E:00000040
NXTBP                            A:00201604
NXTBP3                           A:00201618
NXTCHR                           A:00201624
NextB1                           A:00206A4C
NextB2                           A:00206A72
NextH1                           A:00206A9E
NextPRN                          A:002064E8
Ninc0                            A:002064F0
Ninc1                            A:002064F6
NoLcase                          A:00205ACE
NoShift                          A:00205364
NoString                         A:00205AD4
NoUcase                          A:00205A9E
Not2Big                          A:0020537C
Nullct                           E:000005E4
OFCMD                            A:00201AB8
OFFSET                           A:0000044C
OPCTBL                           A:00204158
OPTIONS                          A:000004E6
OUT1CR                           A:00201FEA
OUT1CR0                          A:00202004
OUT1CRX                          A:00201FFE
OUTBSIZE                         E:00000050
OUTCH                            A:00202214
OUTCH1                           A:0020203C
OUTCH2                           A:0020205C
OUTCH21                          A:0020222E
OUTCH3                           A:00202062
OUTCHRTS                         A:0020206A
OUTP2                            A:0020202C
OUTP3                            A:00202036
OUTPORT1                         A:00000630
OUTPORT2                         A:00000638
OUTPORT3                         A:00000640
OUTPORT4                         A:00000648
OUTPUT                           A:00202004
OUTPUT2                          A:0020200E
OUTPUT20                         A:00202024
OUTPUT21                         A:00202024
OUTPUT2X                         A:0020201E
OUTTO                            A:0000061C
Oquote                           E:000005DD
P2CMD0                           A:00201C7E
P2CMD01                          A:00201CAA
P2CMD2                           A:00201CC8
P2CMD4                           A:00201CF2
P2CMD6                           A:00201CFE
P2PHY                            A:002004BC
P2PHY2                           A:002004CE
P2READY                          A:0020242E
PACMD                            A:002025B4
PBDATA                           S:00000003
PCOUNTER                         E:0000000E
PDATA                            S:00000001
PDI1                             S:000F0000
PDIPORT                          A:0000064E
PENDOP                           E:00000016
PER3                             A:002019B6
PER4                             A:00201994
PERCMD                           A:0020198A
PFCH                             A:00201BC0
PFCH2                            A:00201BCC
PFCH4                            A:00201BE8
PFCMD                            A:00201B34
PFCMD1                           A:00201B96
PFPT                             A:00201B7E
PITCDDR                          S:000F0009
PITPCDR                          S:000F0019
PITTCR                           S:000F0021
PNCA3                            A:00200EDA
PNMSG011                         A:00201FC2
PNT2HX                           A:00201DB2
PNT4HX                           A:00201DAA
PNT6HX                           A:00201DA4
PNT8HX                           A:00201D9C
PNTCLS                           A:00201ADA
PNTCLS1                          A:00201AE0
PNTCLS2                          A:00201AF2
PNTCLSA                          A:00201ACC
PNTCLSB                          A:00201AD4
PNTCLSD                          A:00201AC2
PNTREG                           A:00201AFE
PNTREG1                          A:00201B26
PNTSREC                          A:00200F14
PNTSRECX                         A:00200F0E
PNTSRTS                          A:00200F34
PNTZ0                            A:00201E38
PNTZ1                            A:00201E3A
PNTZ2                            A:00201E42
PNTZ3                            A:00201E58
PNTZ4                            A:00201E4E
PNTZ8                            A:00201E5E
PNTZ81                           A:00201E66
PNTZ9                            A:00201E6A
PNTZHX                           A:00201E28
PORT2100                         A:002023E2
PORT2120                         A:002023EA
PORT2130                         A:002023EC
PORT2140                         A:002023F8
PORT2150                         A:0020240A
PORT2250                         A:00202412
PORT2260                         A:00202418
PORT2300                         A:0020241E
PORTIN1                          A:00202098
PORTIN10                         A:002020B8
PORTIN1N                         A:002020AA
PORTIN1V                         A:002020BC
PORTIN1W                         A:002020BE
PORTIN1X                         A:002020A4
PORTIN2                          A:002023BC
PORTIN20                         A:002023CE
PORTIN2X                         A:002023C8
PPHY                             A:002004B4
PRCRLF                           A:00202160
PRINT3                           A:002015EA
PRINT5                           A:002015A8
PRINT7                           A:002015C4
PRINT8                           A:0020157A
PRINT9                           A:00201650
PRINTDI                          A:00201598
PRINTDI5                         A:002015C8
PRINTMB                          A:0020158C
PRINTR                           A:00201A9A
PRINTR2                          A:00201AB2
PRNlword                         E:000005A0
PSTATUS                          S:0000000B
PTRBUFE                          E:0000001A
PTROP                            E:00000012
PUM11                            A:00200E4E
PUM13                            A:00200E56
PUNCH5                           A:00200E48
PUTADR                           A:002015F2
PUTCHR                           A:0020163A
PUTHEX                           A:00201DBA
RAMERR                           A:00201C66
RAMTEST                          A:00201C16
RAM_START                        E:00000000
READ0                            A:00201418
READ00                           A:0020142C
READ005                          A:00201432
READ01                           A:002013CE
READ021                          A:002013E6
READ03                           A:002013D4
READ08                           A:0020140A
READ09                           A:0020140E
READ100                          A:0020147C
READ120                          A:00201492
READ130                          A:002014A2
READ135                          A:002014AE
READ400                          A:002014B2
READ410                          A:002014BA
READ420                          A:002014C6
READ430                          A:002014D0
READ440                          A:002014D6
READBUF                          A:002020C2
READCKSM                         A:002014DE
READHEX                          A:002014F0
READHEX4                         A:00201542
READHEX6                         A:0020153C
READS1                           A:002013FE
READS2                           A:00201468
READS202                         A:00201470
READS8                           A:0020154E
READS800                         A:00201550
READS9                           A:0020155E
REGA7                            A:00000444
REGNAMES                         A:00200CF4
REGPC                            A:00000400
REGS                             A:00000408
REGSR                            A:00000404
REGTBL                           E:002019C2
REGUS                            A:00000448
RES                              A:00202444
RES140                           A:00202456
RES150                           A:00202476
RES190                           A:00202478
RES194                           A:00202484
RES195                           A:00202490
RESET                            E:00000003
RETURN                           A:0020207C
RETURN5                          A:00201A98
RHEX2                            A:0020151C
RHEX3                            A:0020151E
RL111                            A:00203348
RL114                            A:00203358
RL115                            A:0020335A
RL30                             A:002033CC
RL333                            A:00203368
RL444                            A:00203374
RL555                            A:0020339E
RL666                            A:002033AA
RTS_001                          A:002051C8
RTS_005                          A:00204858
RTS_006                          A:00204A38
RTS_007                          A:00204B36
RTS_007a                         A:00204B4C
RTS_008                          A:00204CFC
RTS_009                          A:00204DF8
RTS_011                          A:0020566E
RTS_012                          A:00205936
RTS_013                          A:002059AA
RTS_015                          A:00205C00
RTS_016                          A:00205CDA
RTS_017                          A:00205FF6
RTS_020                          A:0020637A
RTS_021                          A:002066B6
RTS_022                          A:00206ADC
RTS_023                          A:00206BE8
RTS_024                          A:00206E34
RTS_025                          A:00206E96
RXNOTREADY                       A:00204424
Rdptrl                           E:00000466
S2REC                            A:00200EC2
SAVE                             A:00201088
SAVEAV4                          A:000004D2
SAVHEX                           A:00201DCA
SCAN                             A:00201A8A
SCAN2                            A:00201A8C
SCANP4                           A:00202574
SCANP5                           A:00202588
SCANP6                           A:002025B0
SCANP7                           A:002025AE
SCANP8                           A:0020259C
SCANPORT                         A:00202550
SCHR                             A:00203950
SCOMMON                          A:00203A00
SCREEN1                          A:00000610
SCREEN2                          A:00000614
SEMACS                           A:00201A4C
SER1                             S:003C0008
SER2                             S:003C0008
SETA                             A:002019F2
SETA7                            A:00201A04
SETBIT                           A:002033B8
SETCRTPR                         A:002025BA
SETD                             A:002019EC
SETM1                            A:002018A8
SETM3                            A:002018D0
SETM5                            A:002018EA
SETM6                            A:002018EC
SETM7                            A:0020190E
SETME                            A:00201902
SETO                             A:00201AB8
SETPC                            A:002019F8
SETR                             A:00201A26
SETR0                            A:00201A2E
SETR4                            A:00201A50
SETR5                            A:00201A56
SETRN                            A:00201A1A
SETSR                            A:002019FE
SETSR1                           A:00201A5A
SETSR15                          A:00201A88
SETSS                            A:00201A0E
SETUS                            A:00201A14
SI201                            A:00203474
SI222                            A:0020348E
SIZEBYTE                         A:00203482
SIZELONG                         A:00203466
SIZEWORD                         A:00203476
SOLIST                           A:00200704
SSA7                             A:0000053C
START                            A:0020053A
START11                          A:00200560
START1S                          A:0020051A
STARTIMR                         A:0020250C
STIME                            S:0000A028
SV_000003                        A:00200452
SV_000044                        A:002010C8
SV_000046                        A:002011F4
SV_000047                        A:00201D2C
SV_000048                        A:00201D74
SV_000393                        A:002042BC
SWAP                             A:002011A8
SWAP1                            A:002011B6
SWAP99                           A:002011D6
SWAPEND                          A:002011DE
SWAPIN                           A:00201182
SWAPIN1                          A:002011BE
SWAPOUT                          A:00201198
SWAPOUT1                         A:002011CE
SYNTAX                           A:002004AE
SYSTACK                          A:00000786
Sarryl                           E:0000043E
Sfncl                            E:00000432
Smeml                            E:0000042E
Sstorl                           E:00000446
Sstrl                            E:0000043A
Sufnxf                           E:000005DF
Sutill                           E:0000044E
Svarl                            E:00000436
T100                             A:00204260
T400                             A:00204276
T44                              A:00200D9C
T448                             A:00200DA8
T449                             A:00200DB0
T450                             A:00204294
T500                             A:002042A8
T600                             A:002042E2
T700                             A:002042E8
TAB_ASCA                         A:002076F8
TAB_ASCB                         A:00207708
TAB_ASCC                         A:00207721
TAB_ASCD                         A:00207738
TAB_ASCE                         A:00207751
TAB_ASCF                         A:00207760
TAB_ASCG                         A:0020776A
TAB_ASCH                         A:00207777
TAB_ASCI                         A:0020777D
TAB_ASCL                         A:0020778C
TAB_ASCM                         A:002077BA
TAB_ASCN                         A:002077C8
TAB_ASCO                         A:002077D7
TAB_ASCP                         A:002077DC
TAB_ASCR                         A:002077F1
TAB_ASCS                         A:0020781B
TAB_ASCT                         A:00207846
TAB_ASCU                         A:0020785A
TAB_ASCV                         A:00207872
TAB_ASCW                         A:0020787E
TAB_ATNC                         A:00207116
TAB_CHRT                         A:0020734E
TAB_EQUL                         A:002076F0
TAB_HTHET                        A:00207196
TAB_LESS                         A:002076EC
TAB_MNUS                         A:002076E8
TAB_MORE                         A:002076F2
TAB_PLUS                         A:002076E6
TAB_POWR                         A:0020788D
TAB_QEST                         A:002076F6
TAB_SLAS                         A:002076EA
TAB_SNCO                         A:00207096
TAB_STAR                         A:002076E4
TAPEIN                           A:00202496
TAPEIN10                         A:002024AE
TAPEIN11                         A:002024B2
TAPEIN12                         A:002024B8
TAPEIN20                         A:002024C4
TAPEIN21                         A:002024C6
TAPEIN30                         A:002024CC
TAPEIN31                         A:002024D0
TAPEIN32                         A:002024EA
TAPEIN40                         A:002024EC
TAPEIN41                         A:00202502
TAPEIN50                         A:00202534
TAPEIN51                         A:00202536
TAPEIN52                         A:00202544
TAPEIN53                         A:00202520
TAPENULS                         A:00000654
TAPEO                            A:002022DA
TAPEO1                           A:002022E0
TAPEO2                           A:002022F8
TAPEOUT                          A:00202296
TAPEOUT1                         A:002022B6
TAPEOUT2                         A:002022BE
TAPEOUT4                         A:002022D4
TAPEOUT5                         A:002022C6
TBL                              A:00203F4E
TBLE                             A:00204158
TBLKEYS                          A:00202936
TBLOPC                           A:00202982
TBLOPCE                          A:00202C86
TCMD                             A:00200984
TCMD15                           A:0020099A
TCMDHOT                          A:00200998
TD07                             A:00200D0A
TD09                             A:00200D1C
TD1                              A:00200D28
TD25                             A:00200D5C
TD27                             A:00200D54
TD39                             A:00200D80
TD4                              A:00200D82
TD9                              A:00200DB4
TDATA                            E:00000000
TDCC                             A:00200DBC
TDCC9                            A:00200E0C
TDCC91                           A:00200E18
TDISPLY                          A:00200D00
TEMP                             A:000004D6
TIMERTS1                         A:00202336
TIMERTST                         A:00202322
TISOK                            A:0020110E
TK_ABS                           E:000000C1
TK_AND                           E:000000B7
TK_ASC                           E:000000D3
TK_ATN                           E:000000CC
TK_BINS                          E:000000D8
TK_BITCLR                        E:000000A7
TK_BITSET                        E:000000A6
TK_BITTST                        E:000000D9
TK_CALL                          E:0000009B
TK_CHRS                          E:000000D6
TK_CLEAR                         E:000000A1
TK_CONT                          E:0000009F
TK_COS                           E:000000C9
TK_DATA                          E:00000083
TK_DEC                           E:00000088
TK_DEEK                          E:000000CE
TK_DEF                           E:00000097
TK_DIM                           E:00000085
TK_DIV                           E:000000B5
TK_DO                            E:0000009C
TK_DOKE                          E:00000099
TK_ELSE                          E:000000A9
TK_END                           E:00000080
TK_EOR                           E:000000B8
TK_EQUAL                         E:000000BD
TK_EXP                           E:000000C8
TK_FN                            E:000000AB
TK_FOR                           E:00000081
TK_FRE                           E:000000C3
TK_GET                           E:000000A4
TK_GOSUB                         E:0000008D
TK_GOTO                          E:00000089
TK_GT                            E:000000BC
TK_HEXS                          E:000000D7
TK_IF                            E:0000008B
TK_INC                           E:00000093
TK_INPUT                         E:00000084
TK_INT                           E:000000C0
TK_LCASES                        E:000000D5
TK_LEEK                          E:000000CF
TK_LEFTS                         E:000000E1
TK_LEN                           E:000000D0
TK_LET                           E:00000087
TK_LIST                          E:000000A0
TK_LOAD                          E:00000095
TK_LOG                           E:000000C7
TK_LOKE                          E:0000009A
TK_LOOP                          E:0000009D
TK_LSHIFT                        E:000000BB
TK_LT                            E:000000BE
TK_MAX                           E:000000DA
TK_MIDS                          E:000000E3
TK_MIN                           E:000000DB
TK_MINUS                         E:000000B3
TK_MULT                          E:000000B4
TK_NEW                           E:000000A2
TK_NEXT                          E:00000082
TK_NOT                           E:000000AE
TK_NULL                          E:00000092
TK_ON                            E:00000091
TK_OR                            E:000000B9
TK_PEEK                          E:000000CD
TK_PI                            E:000000DD
TK_PLUS                          E:000000B2
TK_POKE                          E:00000098
TK_POS                           E:000000C4
TK_POWER                         E:000000B6
TK_PRINT                         E:0000009E
TK_RAM                           E:000000DC
TK_READ                          E:00000086
TK_REM                           E:0000008F
TK_RESTORE                       E:0000008C
TK_RETURN                        E:0000008E
TK_RIGHTS                        E:000000E2
TK_RND                           E:000000C6
TK_RSHIFT                        E:000000BA
TK_RUN                           E:0000008A
TK_SADD                          E:000000E0
TK_SAVE                          E:00000096
TK_SGN                           E:000000BF
TK_SIN                           E:000000CA
TK_SPC                           E:000000AC
TK_SQR                           E:000000C5
TK_STEP                          E:000000AF
TK_STOP                          E:00000090
TK_STRS                          E:000000D1
TK_SWAP                          E:000000A5
TK_TAB                           E:000000A8
TK_TAN                           E:000000CB
TK_THEN                          E:000000AD
TK_TO                            E:000000AA
TK_TWOPI                         E:000000DE
TK_UCASES                        E:000000D4
TK_UNTIL                         E:000000B0
TK_USINGS                        E:000000E4
TK_USR                           E:000000C2
TK_VAL                           E:000000D2
TK_VPTR                          E:000000DF
TK_WAIT                          E:00000094
TK_WHILE                         E:000000B1
TK_WIDTH                         E:000000A3
TLENGTH                          E:0000000C
TLSPEC                           E:0000000B
TMCHARS                          E:000004EA
TMCMD                            A:00201C6A
TNB                              E:0000000A
TPos                             E:000005E5
TRACE                            A:002010B6
TRACE01                          A:00201118
TRACE03                          A:00201134
TRACE08                          A:0020112C
TRACE16                          A:002010E2
TRACE2                           A:002009C2
TRACE39                          A:00201142
TRACECNT                         A:000004DA
TRACEON                          A:000004DE
TRAP14                           A:00204258
TRCMD                            A:00200984
TTCMD                            A:002009A0
TWidth                           E:000005E6
TXNOTREADY                       A:002043F2
TabSiz                           E:000005E2
TooBig                           A:00205382
UC_loop                          A:00205ABC
UNSTACK                          A:00201158
UNTRACE                          A:0020114A
Usdss                            E:000005CC
Usrjmp                           E:00000406
V2                               A:00200400
VECMD                            A:002013C0
VECT                             A:0020079E
VECT10                           A:002007DA
VECT11                           A:002007E4
VECT24                           A:002007EE
VECT25                           A:002007F8
VECT26                           A:00200802
VECT27                           A:0020080C
VECT28                           A:00200816
VECT29                           A:00200820
VECT30                           A:0020082A
VECT31                           A:00200834
VECT32                           A:0020083E
VECT33                           A:00200848
VECT34                           A:00200852
VECT35                           A:0020085C
VECT36                           A:00200866
VECT37                           A:00200870
VECT38                           A:0020087A
VECT39                           A:00200884
VECT40                           A:0020088E
VECT41                           A:00200898
VECT42                           A:002008A2
VECT43                           A:002008AC
VECT44                           A:002008B6
VECT45                           A:002008C0
VECT46                           A:002008CA
VECT47                           A:002008D4
VECT5                            A:002007A8
VECT6                            A:002007B2
VECT7                            A:002007BC
VECT8                            A:002007C6
VECT9                            A:002007D0
VECTBE                           A:0020043A
VECTI                            A:00200784
VECTI2                           A:00200792
VEC_CC                           A:00206AB8
VEC_IN                           A:00204404
VEC_LD                           A:0020442E
VEC_OUT                          A:002043E8
VEC_SV                           A:00204434
VERSION                          E:00000004
V_CTLC                           E:00000424
V_INPT                           E:0000040C
V_LOAD                           E:00000418
V_OUTP                           E:00000412
V_SAVE                           E:0000041E
Varname                          E:0000046A
WALK0                            A:00201C1C
WALK1                            A:00201C2A
WALK3                            A:00201C1A
WExit                            A:00206BC0
WHAT                             A:00200496
WHAT93                           A:0020049A
Wrmjpv                           E:00000402
X                                A:002036B0
XBASE                            A:0020262C
XONOFF                           E:000004E6
ccbyte                           E:000005E9
ccflag                           E:000005E8
ccnull                           E:000005EA
code_start                       A:0020443A
comp_f                           E:000005E3
cosout                           E:000005B4
d1x02                            A:00206E72
d1x10                            A:00206E88
d1x16                            A:00206E64
des_sk                           E:0000048E
des_sk_e                         E:00000476
expcnt                           E:000005AD
expneg                           E:000005AF
fend                             E:00000008
flag                             E:0000059F
fsd                              E:00000000
fsdc                             E:0000000A
fsdpi                            E:00000008
fsli                             E:00000006
fsti                             E:00000004
func_l                           E:000005B0
mainloop                         A:002065D0
nexta                            A:002065E2
nobrk                            E:00000000
novar                            E:00000000
numexp                           E:000005AC
ofchr                            E:00000023
outloop                          A:002065F0
prg_strt                         E:000005EC
prstk                            E:000005D8
ram_addr                         E:00008800
ram_base                         E:00000400
ram_size                         E:00017800
subexit                          A:002065FA
subloop                          A:002065C8
tpower                           E:000005D9

Symbols by value:
FFFFFFBC CC
FFFFFFC0 ADDRESS
FFFFFFC4 LDATA
FFFFFFF0 DDATA
FFFFFFFC HISPC
00000000 ESKB
00000000 FLASH_SUPPORT
00000000 FLAG
00000000 novar
00000000 TDATA
00000000 fsd
00000000 RAM_START
00000000 nobrk
00000001 PDATA
00000003 PBDATA
00000003 RESET
00000004 VERSION
00000004 fsti
00000004 EOT
00000004 CTLD
00000006 fsli
00000007 BELL
00000008 fend
00000008 AV2
00000008 CTLH
00000008 fsdpi
0000000A TNB
0000000A fsdc
0000000A FDATA
0000000A LF
0000000B TLSPEC
0000000B PSTATUS
0000000C TLENGTH
0000000C AV3
0000000D CR
0000000E PCOUNTER
00000010 LOCVARSZ
00000010 AV4
00000012 PTROP
00000016 PENDOP
00000017 CTLW
00000018 CTLX
0000001A PTRBUFE
0000001E LINK
0000001F FOC
0000001F FOL
00000020 AV8
00000020 BLANK
00000022 ESKE
00000023 ofchr
00000024 AV9
00000027 FOP
0000002C AV11
00000030 AV12
00000040 NW
00000050 OUTBSIZE
00000050 BUFSIZE
00000060 AV24
0000007C AV31
0000007F DEL
00000080 TK_END
00000080 NOC
00000080 BUFFSIZE
00000081 TK_FOR
00000082 TK_NEXT
00000083 TK_DATA
00000084 TK_INPUT
00000085 TK_DIM
00000086 TK_READ
00000087 TK_LET
00000088 TK_DEC
00000089 TK_GOTO
0000008A TK_RUN
0000008B TK_IF
0000008C TK_RESTORE
0000008D TK_GOSUB
0000008E TK_RETURN
0000008F TK_REM
00000090 TK_STOP
00000091 TK_ON
00000092 TK_NULL
00000093 TK_INC
00000094 TK_WAIT
00000095 TK_LOAD
00000096 TK_SAVE
00000097 TK_DEF
00000098 TK_POKE
00000099 TK_DOKE
0000009A TK_LOKE
0000009B TK_CALL
0000009C TK_DO
0000009D TK_LOOP
0000009E TK_PRINT
0000009F TK_CONT
000000A0 TK_LIST
000000A1 TK_CLEAR
000000A2 TK_NEW
000000A3 TK_WIDTH
000000A4 TK_GET
000000A5 TK_SWAP
000000A6 TK_BITSET
000000A7 TK_BITCLR
000000A8 TK_TAB
000000A9 TK_ELSE
000000AA TK_TO
000000AB TK_FN
000000AC TK_SPC
000000AD TK_THEN
000000AE TK_NOT
000000AF TK_STEP
000000B0 TK_UNTIL
000000B1 TK_WHILE
000000B2 TK_PLUS
000000B3 TK_MINUS
000000B4 TK_MULT
000000B5 TK_DIV
000000B6 TK_POWER
000000B7 TK_AND
000000B8 TK_EOR
000000B8 AV46
000000B9 TK_OR
000000BA TK_RSHIFT
000000BB TK_LSHIFT
000000BC AV47
000000BC TK_GT
000000BD TK_EQUAL
000000BE TK_LT
000000BF TK_SGN
000000C0 AV48
000000C0 TK_INT
000000C1 TK_ABS
000000C2 TK_USR
000000C3 TK_FRE
000000C4 TK_POS
000000C5 TK_SQR
000000C6 TK_RND
000000C7 TK_LOG
000000C8 TK_EXP
000000C9 TK_COS
000000CA TK_SIN
000000CB TK_TAN
000000CC TK_ATN
000000CD TK_PEEK
000000CE TK_DEEK
000000CF TK_LEEK
000000D0 TK_LEN
000000D1 TK_STRS
000000D2 TK_VAL
000000D3 TK_ASC
000000D4 TK_UCASES
000000D5 TK_LCASES
000000D6 TK_CHRS
000000D7 TK_HEXS
000000D8 TK_BINS
000000D9 TK_BITTST
000000DA TK_MAX
000000DB TK_MIN
000000DC TK_RAM
000000DD TK_PI
000000DE TK_TWOPI
000000DF TK_VPTR
000000E0 TK_SADD
000000E1 TK_LEFTS
000000E2 TK_RIGHTS
000000E3 TK_MIDS
000000E4 TK_USINGS
00000400 REGPC
00000400 ram_base
00000400 LAB_WARM
00000402 Wrmjpv
00000404 REGSR
00000406 Usrjmp
00000408 REGS
0000040C V_INPT
00000412 V_OUTP
00000418 V_LOAD
0000041E V_SAVE
00000424 V_CTLC
0000042A Itemp
0000042E Smeml
00000432 Sfncl
00000436 Svarl
0000043A Sstrl
0000043E Sarryl
00000442 Earryl
00000444 REGA7
00000446 Sstorl
00000448 REGUS
0000044A Ememl
0000044C BEGHRAM
0000044C OFFSET
0000044E Sutill
00000452 Clinel
00000456 Blinel
0000045A Cpntrl
0000045E Dlinel
00000462 Dptrl
00000466 Rdptrl
0000046A Varname
0000046C MEMSIZE
00000470 BPADD
00000472 Lvarpl
00000476 des_sk_e
0000048E des_sk
00000490 BPTILL
00000490 Ibuffs
00000494 BPCNT
000004B8 BPDATA
000004CA BERRD
000004D2 SAVEAV4
000004D6 TEMP
000004DA TRACECNT
000004DE TRACEON
000004E0 BPSTATUS
000004E2 ECHOPT1
000004E6 XONOFF
000004E6 OPTIONS
000004EA TMCHARS
0000053C SSA7
00000540 BUFFER
00000590 FAC1_m
00000590 Ibuffe
00000594 FAC1_e
00000595 FAC1_s
00000598 FAC2_m
0000059C FAC2_e
0000059D FAC2_s
0000059E FAC_sc
0000059F flag
000005A0 PRNlword
000005A8 Asptl
000005AC numexp
000005AC Astrtl
000005AD expcnt
000005AF expneg
000005B0 func_l
000005B4 Defdim
000005B4 cosout
000005B5 Dtypef
000005B6 Binss
000005C0 DUMPTEMP
000005C6 Decss
000005CC Usdss
000005CE Hexss
000005D6 BHsend
000005D8 prstk
000005D9 tpower
000005DA Asrch
000005DB Dimcnt
000005DC Breakf
000005DD Oquote
000005DE Gclctd
000005DF Sufnxf
000005E0 Imode
000005E1 Cflag
000005E2 TabSiz
000005E3 comp_f
000005E4 Nullct
000005E5 TPos
000005E6 TWidth
000005E7 Iclim
000005E8 ccflag
000005E9 ccbyte
000005EA ccnull
000005EC prg_strt
00000610 SCREEN1
00000614 SCREEN2
00000618 NULLPADS
0000061A CRPADS
0000061C OUTTO
00000620 INFROM
00000624 ALTSER1
00000628 ALTSER2
0000062C INPORT1
00000630 OUTPORT1
00000634 INPORT2
00000638 OUTPORT2
0000063C INPORT3
00000640 OUTPORT3
00000644 INPORT4
00000648 OUTPORT4
0000064C MD1CON
0000064E PDIPORT
00000652 CRTPNT
00000654 TAPENULS
00000656 CTLINK
0000065A ENDHRAM
00000786 SYSTACK
00001000 DELAYC1
00004AFB BKPOINT
00008800 ram_addr
0000A028 STIME
00017800 ram_size
000320C8 LTIME
000F0000 PDI1
000F0009 PITCDDR
000F0019 PITPCDR
000F0021 PITTCR
00200000 FIRST
00200400 V2
00200404 INITHRAM
00200410 INIT
00200428 BERRMSG
00200432 ADDRMSG
0020043A VECTBE
00200452 SV_000003
00200482 MSG008
00200489 MSG008E
0020048F MSGEOT
00200490 MSG021
00200496 WHAT
0020049A WHAT93
002004A0 MSG
002004A8 ERROR
002004AE SYNTAX
002004B4 PPHY
002004BC P2PHY
002004CE P2PHY2
002004D8 MSG019
002004EA FIXDATA
002004EE FIXDADD
002004F8 FIXD2
002004FE FIXDCRLF
00200508 INITVECT
00200510 INIT0
0020051A START1S
0020053A START
00200560 START11
0020062E MACSBUG
0020065C MACSBUG1
00200670 DECODE6
00200680 DECODE1
00200696 DECODE10
002006A0 DECODE2
002006AA DECODE21
002006AE DECODE4
002006BC DECODE41
002006D0 DECODE3
002006EA NOCMD
002006F6 MSG001
00200704 SOLIST
0020077A INITVMSG
00200784 VECTI
00200792 VECTI2
0020079E VECT
002007A8 VECT5
002007B2 VECT6
002007BC VECT7
002007C6 VECT8
002007D0 VECT9
002007DA VECT10
002007E4 VECT11
002007EE VECT24
002007F6 EVECT5
002007F8 VECT25
00200802 VECT26
0020080C VECT27
00200816 VECT28
00200820 VECT29
0020082A VECT30
00200834 VECT31
0020083C EVECT6
0020083E VECT32
00200848 VECT33
00200852 VECT34
0020085C VECT35
00200866 VECT36
00200870 VECT37
0020087A VECT38
00200884 VECT39
0020088C EVECT7
0020088E VECT40
00200898 VECT41
002008A2 VECT42
002008AC VECT43
002008B6 VECT44
002008C0 VECT45
002008CA VECT46
002008D4 VECT47
002008DC EVECT
002008E0 BFCMD
00200920 BFCMD11
00200932 BMCMD
0020096E BM112
00200976 BM122
0020097A BM132
00200980 BM142
00200984 TCMD
00200984 TRCMD
00200998 TCMDHOT
0020099A TCMD15
002009A0 TTCMD
002009C2 TRACE2
002009D4 GTCMD
002009F0 GT21
00200A02 GOSET1
00200A16 GOCMD1A
00200A20 GOCMD
00200A20 GCMD
00200A22 GOCMD1
00200A2E GDCMD
00200A34 NOBRCMD
00200A36 BCMD01
00200A3E FIXBP
00200A4E BRCMD
00200A52 BCMD0
00200A60 BCMD00
00200A6E BCMD3
00200A74 BCMD33
00200A86 BCMD6
00200A8C BCMD5
00200A94 BCMD55
00200A9E BCMD7
00200AA6 BCMD77
00200AAC BCMD8
00200ACC BCMD81
00200AD0 BCMD9
00200ADA MSGBR
00200AE6 NOBR0
00200AEA NOBR1
00200B00 NOBR3
00200B0C NOBR4
00200B14 BSCMD
00200B44 BS91
00200B6E BS97
00200B7E BS101
00200B8A BS200
00200BBC BS213
00200BC0 BS215
00200BC4 BS219
00200BD6 BS225
00200BE8 BS311
00200BEC BS313
00200C0C BS323
00200C12 BS325
00200C3A BS355
00200C44 BS365
00200C4E BTCMD
00200CA0 NUMCON0
00200CA0 DCCMD
00200CC4 NUMCON1
00200CD0 NUMCON2
00200CE8 NUMCON3
00200CF4 REGNAMES
00200CFE DFCMD
00200D00 TDISPLY
00200D0A TD07
00200D1C TD09
00200D28 TD1
00200D54 TD27
00200D5C TD25
00200D80 TD39
00200D82 TD4
00200D9C T44
00200DA8 T448
00200DB0 T449
00200DB4 TD9
00200DBC TDCC
00200E0C TDCC9
00200E18 TDCC91
00200E1C DUCMD
00200E48 PUNCH5
00200E4E PUM11
00200E56 PUM13
00200E7E MORES0
00200E8E ENDS0
00200E94 MORESP
00200EC2 S2REC
00200EDA PNCA3
00200EFA A3OUT
00200F0E PNTSRECX
00200F14 PNTSREC
00200F34 PNTSRTS
00200F36 GETA
00200F52 GAP111
00200F5A GAP113
00200FB4 GAP118
00200FB6 GAP119
00200FBC GAP111S
00200FBE GAP121
00200FCA GAP131
00200FD6 GAP135
00200FDE GAP141
00201006 GAE
0020100A GAP161
00201020 GAP163
0020102A GAP165
00201030 GAP171
0020104C GAP181
00201052 GAP191
00201064 GAP197
00201066 GAP199
0020106C GASRGN
00201088 SAVE
002010B6 TRACE
002010C8 SV_000044
002010E2 TRACE16
0020110E TISOK
00201118 TRACE01
0020112C TRACE08
00201134 TRACE03
00201142 TRACE39
0020114A UNTRACE
00201158 UNSTACK
00201182 SWAPIN
00201198 SWAPOUT
002011A8 SWAP
002011B6 SWAP1
002011BE SWAPIN1
002011CE SWAPOUT1
002011D6 SWAP99
002011DE SWAPEND
002011E0 CHKBP
002011F4 SV_000046
0020120E CHKBP1
0020121A CHKBP11
00201224 CHKBP2
00201230 CHKBP3
00201234 CHKBP4
00201244 MSG009
00201258 MSG014
00201266 MSG020
0020127E BACMD
00201282 HECMD
0020129A HELP4
002012CE EOHLOOP
002012D0 HELP81
002012E0 HELP85
002012E2 HELP6
002012EA MSG002
0020135C HEX2DEC
0020136C HX2DC
00201370 HX2DC0
00201378 HX2DC1
00201392 HX2DC2
00201394 HX2DC22
0020139E HX2DC3
002013A6 HX2DC4
002013AE HX2DC5
002013B6 HX2DC57
002013BA HX2DC6
002013C0 VECMD
002013C6 LOCMD
002013C8 CHKCHKS
002013CE READ01
002013D4 READ03
002013E6 READ021
002013FE READS1
0020140A READ08
0020140E READ09
00201418 READ0
0020142C READ00
00201432 READ005
00201468 READS2
00201470 READS202
0020147C READ100
00201492 READ120
002014A2 READ130
002014AE READ135
002014B2 READ400
002014BA READ410
002014C6 READ420
002014D0 READ430
002014D6 READ440
002014DE READCKSM
002014F0 READHEX
002014FE GETCHR
00201506 GETHEXC
0020151C RHEX2
0020151E RHEX3
0020152A MSGLOAD1
00201533 MSGLOAD2
0020153C READHEX6
00201542 READHEX4
0020154E READS8
00201550 READS800
0020155E READS9
00201564 MDCMD
0020157A PRINT8
0020158C PRINTMB
00201598 PRINTDI
002015A8 PRINT5
002015C4 PRINT7
002015C8 PRINTDI5
002015EA PRINT3
002015F2 PUTADR
00201604 NXTBP
00201618 NXTBP3
00201624 NXTCHR
00201636 NOTCHR
0020163A PUTCHR
00201650 PRINT9
0020167A MMDI
00201684 MMDI22
00201686 MMDI23
0020169A MMDI31
002016AC MMDI34
002016C4 MMDI26
002016CE MMDI27
002016E4 MMDI29
002016F6 MMDI30
002016FA MMDI44
00201712 MMCMD
00201712 MCMD
00201724 MM05
00201742 MM045
00201756 MM054
00201762 MM056
00201770 MM058
0020177E MM060
00201784 MM064
0020178A MM065
0020178E MM10
0020179E MM11
002017C2 MM12
002017CC MM14
002017D6 MM16
002017DE MM18
0020182C MM22
0020183A MM24
00201848 MM26
00201854 MM40
00201878 MM50
0020187E MM60
00201884 MM90
00201888 MM95
00201890 MM905
00201896 MSCMD
002018A8 SETM1
002018D0 SETM3
002018EA SETM5
002018EC SETM6
00201902 SETME
0020190E SETM7
0020193C MSG017
00201952 MTSETUP
0020198A PERCMD
00201994 PER4
002019B6 PER3
002019C2 REGTBL
002019EC SETD
002019F2 SETA
002019F8 SETPC
002019FE SETSR
00201A04 SETA7
00201A0E SETSS
00201A14 SETUS
00201A1A SETRN
00201A26 SETR
00201A2E SETR0
00201A4C SEMACS
00201A50 SETR4
00201A56 SETR5
00201A5A SETSR1
00201A88 SETSR15
00201A8A SCAN
00201A8C SCAN2
00201A98 RETURN5
00201A9A PRINTR
00201AB2 PRINTR2
00201AB8 SETO
00201AB8 OFCMD
00201AC2 PNTCLSD
00201ACC PNTCLSA
00201AD4 PNTCLSB
00201ADA PNTCLS
00201AE0 PNTCLS1
00201AF2 PNTCLS2
00201AFE PNTREG
00201B26 PNTREG1
00201B34 PFCMD
00201B7E PFPT
00201B96 PFCMD1
00201BC0 PFCH
00201BCC PFCH2
00201BE8 PFCH4
00201BEA MSG003
00201BF5 MSG004
00201C00 MSG005
00201C0B MSG031
00201C16 RAMTEST
00201C1A WALK3
00201C1C WALK0
00201C2A WALK1
00201C42 MTCLR
00201C4A MTSTOR1
00201C5A MTSTOR0
00201C66 RAMERR
00201C6A TMCMD
00201C7E P2CMD0
00201CAA P2CMD01
00201CC8 P2CMD2
00201CF2 P2CMD4
00201CFE P2CMD6
00201D02 MSG006
00201D18 ABORTB
00201D2C SV_000047
00201D3C EVECT4
00201D40 ABORT335
00201D48 MSG012
00201D5C ABORTE
00201D64 EVECTL
00201D74 SV_000048
00201D78 EVECT2
00201D8E MSG010
00201D9C PNT8HX
00201DA4 PNT6HX
00201DAA PNT4HX
00201DB2 PNT2HX
00201DBA PUTHEX
00201DCA SAVHEX
00201DCE FRELADDR
00201DDA FREL10
00201DEC FREL15
00201E04 FREL20
00201E16 FREL25
00201E20 FREL30
00201E28 PNTZHX
00201E38 PNTZ0
00201E3A PNTZ1
00201E42 PNTZ2
00201E4E PNTZ4
00201E58 PNTZ3
00201E5E PNTZ8
00201E66 PNTZ81
00201E6A PNTZ9
00201E6C FNEXTF1
00201E6E FNEXTF
00201E88 FNEXTF7
00201E8C CKWADR
00201E92 CKADDR
00201E9A CKADR39
00201EAE CKADR99
00201EB0 MSG018
00201EC2 GETEXP
00201EC6 GETEXP21
00201ECA GETEXP15
00201EE0 GETEXP39
00201EE8 GETNUMD
00201EEA GETNUMD9
00201EF0 GETNUMA
00201EF4 GETDECNU
00201EFC GETHEXNU
00201F02 GETN20
00201F0C GETN30
00201F18 GETN40
00201F22 GETN50
00201F2A GETN55
00201F2E GETN57
00201F32 GETN60
00201F3C GETN65
00201F46 GETN70
00201F50 GETN75
00201F6A GETN77
00201F84 GETN80
00201F88 GETN85
00201F8A GETN90
00201F8E GETN95
00201F94 GETNDATA
00201FA0 GETHEX
00201FBA GTHX2
00201FC2 PNMSG011
00201FD4 MSG011
00201FEA OUT1CR
00201FFE OUT1CRX
00202004 OUTPUT
00202004 OUT1CR0
0020200E OUTPUT2
0020201E OUTPUT2X
00202024 OUTPUT20
00202024 OUTPUT21
0020202C OUTP2
00202036 OUTP3
0020203C OUTCH1
0020205C OUTCH2
00202062 OUTCH3
0020206A OUTCHRTS
0020206C GETSER1
0020207C RETURN
0020207E GETSER2
00202090 FIXBUF
00202098 PORTIN1
002020A4 PORTIN1X
002020AA PORTIN1N
002020B8 PORTIN10
002020BC PORTIN1V
002020BE PORTIN1W
002020C2 READBUF
002020EE CHKCTLH
002020FA BKSPACE
00202108 BS4CTLH
0020210C BLANKIT
0020211E CHKCTLD
0020213A CHARSAVE
0020214A CHKCR
0020215A NOAUTOLF
00202160 PRCRLF
00202164 LIST
0020216E LIST1
00202174 CHRPRINT
00202178 LIST2
002021A0 LIST24
002021A4 LIST25
002021B8 LIST3
002021DC LERR1
002021F0 LIST5
002021FE MSG007
00202214 OUTCH
0020222E OUTCH21
00202240 CTLWH
0020224A CTLW9
0020224C CHKBRK
0020225E BREAK2
00202262 BREAK1
00202278 BREAK
0020227E BREAK79
0020228A MSG013
00202296 TAPEOUT
002022B6 TAPEOUT1
002022BE TAPEOUT2
002022C6 TAPEOUT5
002022D4 TAPEOUT4
002022DA TAPEO
002022E0 TAPEO1
002022F8 TAPEO2
00202322 TIMERTST
00202336 TIMERTS1
00202338 FAULTSER
00202342 FAULTAC4
0020235A FAULTAC2
0020236E FAULTAC3
00202374 INITSER
0020237E INITAC3
002023A0 INCHNE
002023BC PORTIN2
002023C8 PORTIN2X
002023CE PORTIN20
002023E2 PORT2100
002023EA PORT2120
002023EC PORT2130
002023F8 PORT2140
0020240A PORT2150
00202412 PORT2250
00202418 PORT2260
0020241E PORT2300
00202426 MSG030
0020242E P2READY
00202444 RES
00202456 RES140
00202476 RES150
00202478 RES190
00202484 RES194
00202490 RES195
00202496 TAPEIN
002024AE TAPEIN10
002024B2 TAPEIN11
002024B8 TAPEIN12
002024C4 TAPEIN20
002024C6 TAPEIN21
002024CC TAPEIN30
002024D0 TAPEIN31
002024EA TAPEIN32
002024EC TAPEIN40
00202502 TAPEIN41
0020250C STARTIMR
00202520 TAPEIN53
00202534 TAPEIN50
00202536 TAPEIN51
00202544 TAPEIN52
00202550 SCANPORT
00202574 SCANP4
00202588 SCANP5
0020259C SCANP8
002025AE SCANP7
002025B0 SCANP6
002025B4 PACMD
002025B8 NOPACMD
002025BA SETCRTPR
002025C2 EV
002025C6 EV21
002025CA EV15
002025E0 EV39
002025E8 GETFIELD
002025F4 GETF305
00202608 GETF311
00202608 GETF308
00202618 GETF312
0020261C GETF313
0020261E GETF314
00202624 GETF325
0020262A GETF333
0020262C FSIZE
0020262C XBASE
00202632 GETREGD
0020263A GET41
0020264C GETREGA
0020265A GETREGAD
0020266E ER1
00202672 EADA
00202678 EAC
0020267E EAM
00202684 EAZ
0020268A EADADDR
00202690 EAA
00202696 EAALL
0020269A EA
002026C8 EA0633
002026CC EA0634
002026D8 EA0635
002026E0 EA0637
002026EC EA10
00202718 EA11
00202730 EA21
00202744 EA31
0020277A EA34
0020277C EA35
00202786 ER3
0020278A EA41
0020279E EA4102
002027A4 EA4105
002027BA EA4127
002027CA EA4135
002027E0 EA4120
00202826 EA5115
0020282A EA5116
0020286A EA5118
00202870 EA5119
0020287A EA5119E
0020287C EA61
002028AA ER4
002028AE EA71
002028F0 EA7113
002028F6 EA7115
00202902 EA16BIT
0020290C EA16BITS
00202910 EA16BITC
00202918 EA8BIT
00202920 EA8BITS
00202924 EA8BITC
00202926 EAS
00202934 EASEX
00202936 TBLKEYS
00202982 TBLOPC
00202C86 CODE68K
00202C86 TBLOPCE
00202C98 M300
00202CE2 M340
00202CEE M350
00202D22 M352
00202D2C M410
00202D32 M415
00202D44 M420
00202D48 M424
00202D4C M426
00202D56 M428
00202D5C M430
00202D6A M432
00202D98 M4324
00202D9E M4326
00202DBA M435
00202DC2 M437
00202DD0 M440
00202DDC COMMA
00202DE4 GETCHAR
00202DEC GETCHARF
00202DF4 ERF
00202DF6 ER
00202DFA ERDONE
00202DFE CMMD2
00202E04 MCMMD2
00202E14 FPR315
00202E20 CMMD35
00202E34 MABCD
00202E40 MABCD9
00202E6E MABCD55
00202E76 CMMD2S10
00202E78 MCMP
00202ECE MCMP39
00202ED6 MCMP56
00202EE4 CMMD2S11
00202EE6 COMMAS20
00202EEA MADD
00202F1C MADD46
00202F28 MADD56
00202F38 MADD58
00202F44 MADDI
00202F5A MANDI
00202F74 MANDI23
00202F92 MADDA
00202F9C MADDA21
00202FBA MADDQ
00202FF8 MADDQ25
00202FFC MADDX
00203032 MADDX5
0020303E MAND
00203072 MAND77
00203088 MAND90
00203096 MAND91
0020309A MAND97
002030A0 MEOR
002030C0 MEOR90
002030CC A5TODEST
002030CE A5300
002030DA A5305
002030EC MASL
0020310A MSL150
00203120 MSL200
00203132 MSL300
0020314E MSCC
0020315C MBCHG
00203166 MB100
0020317E MB105
0020319C ER2
002031A0 MB145
002031A6 MB185
002031AA MB200
002031B4 MBSET
002031C0 MBCLR
002031CC MBTST
002031D8 MDBCC
002031E6 MBRA
002031FC EVER
00203200 MBRA23
0020320E MBRA27
00203220 EVSR
0020323E MCHK
00203258 MCLR
00203266 MCMPM
00203290 MEXG
002032B2 MEXG25
002032BC MEXG35
002032CA MEXT
002032E4 MMOVEM
0020331E MMM46
0020331E MMM44
00203344 MMM48
00203348 RL111
00203358 RL114
0020335A RL115
00203368 RL333
00203374 RL444
0020339E RL555
002033AA RL666
002033B8 SETBIT
002033CC RL30
002033D4 MTBL
002033E4 MMOVEP
00203414 MMP344
00203424 MMP348
00203440 MMP368
00203444 MMOVEQ
0020345E MMQ20
00203466 SIZELONG
00203474 SI201
00203476 SIZEWORD
0020347E ER10
00203482 SIZEBYTE
0020348E SI222
00203490 MMOVE
002034AA MM315
002034B2 MMM40
002034D4 MMM50
002034F0 MM508
00203502 MMM60
00203516 MM70
00203544 MM80
0020355C MM804
0020357A MM806
00203592 MM825
002035A4 MMOVEA1
002035AC MMOVEA
002035C4 MMA225
002035D8 MJMP
002035F4 MJMP22
002035FA MJMP32
002035FE MJMP42
00203604 MLEA
0020361E MPEA
0020362C MSWAP
00203640 GETIMM
0020364E MLINK
0020366C MSTOP
00203684 MTRAP
00203696 MUNLK
002036A0 MDC
002036B0 IMOVEMFR
002036B0 X
002036C4 IM7788
002036C8 IM7799
002036E0 IMOVEMTR
002036FA CS16
002036FC ISTOP
00203710 IMMED
00203736 IMMED45
00203768 CS15
0020376A IMMED55
00203770 IMMED65
00203780 IMMED75
00203784 IMOVE
00203788 ILINK
002037A0 FORM1
002037A4 FORM1A
002037A8 CS14
002037AC FORM3
002037B0 FORM4
002037C4 FORM5
002037C8 FORM6A
002037D8 FORM6D
002037E8 FORMREGA
002037EC FORMREG5
002037F8 FORMREGD
00203800 FORM7
0020380C FORM8
00203810 FORM815
00203818 CS13
0020381C FORM9
00203822 EEA10
00203828 FORM10EX
0020384A FORM10E3
00203852 FORM10E4
0020385E FORM10E6
00203868 FORM10
0020386E FORM103
00203872 FORM104
00203884 FORM105
0020389A CS12
002038A0 FORM11
002038AC FORM11SL
002038C0 FORM112
002038CE FORM114
002038D0 FORM12
002038EA FORM125
0020390C FORM12A
00203930 CS11
00203934 IQUICK
00203938 IMOVEQ
00203950 SCHR
00203958 IMVFSR
00203968 IMVFUSP
00203978 IMVTSR
00203986 IMVT44
0020398C IMVTUSP
00203998 IMVTCCR
002039A8 IMOVEP
002039B8 IMOVEP11
002039D0 CS20
002039D4 IMOVEP35
002039E2 IMOVEP66
00203A00 SCOMMON
00203A04 ISCC
00203A10 IDBCC
00203A24 ICC
00203A28 IBSR
00203A3A ICC35
00203A50 ICC55
00203A60 ISETD
00203A66 ISETD12
00203A6E CS18
00203A70 ISETS
00203A8C ISHIFT
00203A98 ISHIFT13
00203ABC ISHIFT23
00203AC8 ISHIFT33
00203ACC ISHIFT44
00203AD4 CS17
00203AD6 ISHIFTM1
00203AF0 ICCCC
00203B06 ICCCC9
00203B08 BRTBL
00203B28 IMOVEA1
00203B4E IMOVE19
00203B54 IQUICKA
00203B66 IQUICK21
00203B7C IQUICK31
00203B80 CS19
00203B84 FORMSIZE
00203B98 FORM91
00203BAC FORM93
00203BAE FORM95
00203BB0 EA000
00203BBC EA001
00203BC8 EA010
00203BDC EA011
00203BF2 EA011RTS
00203BF4 EA100
00203C0A FE10
00203C0E EEA
00203C72 EA1105
00203C76 EA1107
00203C8C EA1109
00203C96 EA101
00203CAC EA111
00203CCA EA1112
00203CE6 EA1113
00203CF2 FE11
00203CF6 EA1113A
00203D18 EA1114
00203D60 EAF25
00203D64 EAF27
00203D78 EAF35
00203D82 EA1115
00203DBA EA11153
00203DC4 EA11155
00203DD0 MOVEMS
00203DE0 MOVEMS2
00203DE4 MOVEMR
00203DF4 MOVEMR11
00203DFC MOVEMR33
00203E0E MOVEMR44
00203E28 MOVEMR77
00203E3A MOVEMR79
00203E3C MOVEMR88
00203E54 MOVEMR94
00203E60 DCODE68K
00203E74 DEC311
00203E90 DEC404
00203EA0 DEC411
00203EAE FE12
00203EB0 DEC425
00203EBE DEC510
00203EC2 DEC515
00203ECA DEC530
00203ED0 DEC535
00203EDC DEC537
00203EF8 COMMON4
00203EFA COMMON
00203F08 COMMON35
00203F22 FERROR
00203F2C FERROR35
00203F38 FERROR39
00203F42 MSG111
00203F4C KI
00203F4E TBL
00203F4E KIEND
00204158 TBLE
00204158 OPCTBL
00204258 TRAP14
00204260 T100
00204276 T400
00204294 T450
002042A8 T500
002042BC SV_000393
002042D0 MSGT14
002042E2 T600
002042E8 T700
002042FC CT
00204370 F100
00204378 F110
00204380 F120
002043E8 LAST
002043E8 VEC_OUT
002043F2 TXNOTREADY
00204404 VEC_IN
00204424 RXNOTREADY
0020442E VEC_LD
00204434 VEC_SV
0020443A code_start
0020445A LAB_COLD
0020446A LAB_sizok
0020451C LAB_FOER
00204520 LAB_ADER
00204524 LAB_WDER
00204528 LAB_UDER
0020452C LAB_UVER
00204530 LAB_LDER
00204534 LAB_UFER
00204538 LAB_CCER
0020453C LAB_SCER
00204540 LAB_SLER
00204544 LAB_TMER
00204548 LAB_IDER
0020454C LAB_DZER
00204550 LAB_DDER
00204554 LAB_ABER
00204558 LAB_USER
0020455C LAB_OMER
00204560 LAB_OFER
00204564 LAB_FCER
00204568 LAB_ODER
0020456C LAB_RGER
00204570 LAB_SNER
00204574 LAB_NFER
00204576 LAB_XERR
00204592 LAB_1269
002045A0 LAB_1274
002045A8 LAB_127D
002045B6 LAB_127E
002045CA LAB_1295
002045EC LAB_12AE
002045EE LAB_12B0
0020460E LAB_12E6
00204640 LAB_12FF
00204642 LAB_1301
00204660 LAB_1303
00204668 LAB_132E
0020466A LAB_1330
00204678 LAB_1325
00204686 LAB_134B
0020469A LAB_INLN
002046A4 LAB_1357
002046AA LAB_1359
002046CA LAB_1374
002046D0 LAB_1378
002046DC LAB_137F
002046E2 LAB_138E
002046E6 LAB_1392
0020471A LAB_13A6
00204722 LAB_13AC
0020474C LAB_13C6
00204752 LAB_13CC
00204774 LAB_13D6
0020477A LAB_13D8
00204786 LAB_13EA
00204788 LAB_13EC
002047A0 LAB_13FF
002047A4 LAB_1401
002047B0 LAB_1408
002047BC LAB_1410
002047C6 LAB_1417
002047C8 LAB_141B
002047D8 LAB_141F
002047DE LAB_142A
002047EA LAB_142C
002047F0 LAB_SSLN
002047F6 LAB_145F
002047F8 LAB_SCLN
00204804 LAB_145E
0020480A LAB_NEW
0020480C LAB_1463
00204818 LAB_1477
0020481E LAB_147A
00204838 LAB_1480
00204842 LAB_1491
00204858 RTS_005
0020485A LAB_CLEAR
0020485E LAB_LIST
00204872 LAB_14BD
00204876 LAB_14C0
00204896 LAB_14D4
002048B2 LAB_14E2
002048C0 LAB_150C
002048CE LAB_1519
002048DA LAB_152E
00204906 LAB_1540
00204912 LAB_FOR
00204966 LAB_15B3
00204978 LAB_15DC
0020498A LAB_15F6
00204990 LAB_15C2
0020499C LAB_15D1
002049AA LAB_15FF
002049AE LAB_1602
002049D2 LAB_1629
002049D6 LAB_1636
002049DC LAB_1639
002049DE LAB_END
002049E6 LAB_STOP
002049E8 LAB_163B
002049F4 LAB_1647
002049FA LAB_164F
00204A0C LAB_RESTORE
00204A1E LAB_RESs
00204A2A LAB_GSCH
00204A32 LAB_1624
00204A38 RTS_006
00204A3A LAB_NULL
00204A44 LAB_CONT
00204A62 LAB_RUN
00204A70 LAB_RUNn
00204A76 LAB_DO
00204A88 LAB_GOSUB
00204A92 LAB_16B0
00204A9A LAB_GOTO
00204AAA LAB_GOTs
00204AB6 LAB_16D0
00204AC8 LAB_LOOP
00204AEA DoRest
00204AFE DoCmp
00204B04 LoopAlways
00204B18 LoopDone
00204B1E LAB_RETURN
00204B32 LAB_DATA
00204B36 RTS_007
00204B38 LAB_SNBS
00204B40 LAB_172C
00204B48 LAB_172D
00204B4C RTS_007a
00204B50 LAB_1723
00204B54 LAB_1725
00204B5A LAB_IF
00204B7C LAB_174B
00204BA0 LAB_174E
00204BA8 LAB_1750
00204BB4 LAB_1752
00204BB8 LAB_1756
00204BC8 LAB_REM
00204BCC LAB_1754
00204BD0 LAB_ON
00204BEA LAB_176C
00204BF4 LAB_1773
00204C04 LAB_GFPN
00204C10 LAB_1785
00204C3C LAB_1786
00204C42 LAB_DEC
00204C48 LAB_INC
00204C4E LAB_17B8
00204C52 LAB_17B7
00204C88 LAB_INCT
00204C96 LAB_INCI
00204CA0 LAB_DECI
00204CA4 LAB_LET
00204CCC LAB_17D5
00204CD0 LAB_17D6
00204CE2 LAB_1810
00204CF2 LAB_1811
00204CF8 LAB_1813
00204CFC RTS_008
00204CFE LAB_GET
00204D18 LAB_GETS
00204D2A LAB_NoSt
00204D30 LAB_1829
00204D34 LAB_182C
00204D38 LAB_PRINT
00204D3A LAB_1831
00204D7A LAB_185E
00204D7E LAB_1866
00204D84 LAB_CRLF
00204D8C LAB_188B
00204D9A LAB_1898
00204DA4 LAB_18A2
00204DC6 LAB_18B7
00204DD2 LAB_18B8
00204DD8 LAB_18BD
00204DE2 LAB_18C3
00204DE6 LAB_18C6
00204DF0 LAB_18CD
00204DF8 RTS_009
00204DFA LAB_18E3
00204DFC LAB_PRNA
00204E1A LAB_18F0
00204E28 LAB_18F7
00204E2C LAB_18F9
00204E40 LAB_1880
00204E4A LAB_1886
00204E4E LAB_188A
00204E52 LAB_1904
00204E64 LAB_1913
00204E72 LAB_INPUT
00204E8A LAB_1934
00204E98 LAB_READ
00204E9E LAB_1953
00204EA6 LAB_195B
00204EB0 LAB_1961
00204ED0 LAB_1984
00204ED4 LAB_1985
00204ED8 LAB_1986
00204EEC LAB_1999
00204EFE LAB_19B0
00204F0E LAB_19B6
00204F1E LAB_19C2
00204F32 LAB_19DD
00204F52 LAB_19F6
00204F60 LAB_1A03
00204F70 LAB_1A0E
00204F76 LAB_1A1B
00204F7E LAB_NEXT
00204F90 LAB_1A46
00204F9E LAB_11A5
00204FA0 LAB_11A6
00204FAC LAB_11BD
0020500E LAB_1A90
0020501C LAB_1A9B
00205034 LAB_EVNM
00205036 LAB_CTNM
00205038 LAB_CKTM
00205046 LAB_1ABA
0020504C LAB_EVEX
0020504E LAB_EVEZ
00205056 LAB_1B43
00205072 LAB_1ACD
0020507E LAB_1ADB
00205082 LAB_1ADE
00205098 LAB_1AE0
002050B2 LAB_1AFA
002050C8 LAB_1B0B
002050D0 LAB_1B13
002050E0 LAB_1B1C
002050E2 LAB_1B1D
002050F4 LAB_1B2A
00205110 LAB_1B3C
0020511C LAB_1B78
00205120 LAB_1B7B
00205122 LAB_1B7D
0020512C LAB_1B84
00205130 LAB_1B86
00205154 LAB_1B9D
0020515A LAB_GVAL
00205184 LAB_1BC1
00205190 LAB_1BF3
00205196 LAB_1BF7
0020519A LAB_1BFB
0020519E LAB_SCGB
002051A2 LAB_1C01
002051A4 LAB_SCCA
002051AC LAB_IGBY
002051AE LAB_GBYT
002051C8 RTS_001
002051CA LAB_1C11
002051D0 LAB_1C13
002051D6 LAB_1C18
002051DA LAB_1C19
002051EA LAB_1C1A
002051F0 LAB_1BD0
0020520A LAB_1BE7
0020523C LAB_PPFS
00205248 LAB_1C2A
0020524A LAB_PPFN
00205258 LAB_PPBI
00205262 LAB_LRMS
00205284 LAB_BHSS
002052AA LAB_BHCB
002052B4 LAB_EOR
002052BC LAB_OR
002052C4 LAB_AND
002052CC GetFirst
002052DA LAB_EQUAL
002052E4 LAB_LTHAN
002052F0 LAB_1CAE
0020530E LAB_1CB5
00205318 LAB_1CD4
0020531E LAB_1CD5
00205320 LAB_1CD6
00205322 LAB_1CE6
00205330 LAB_1CDB
00205332 LAB_1CF2
00205348 LAB_1CFE
0020534C LAB_DIM
00205358 LAB_LSHIFT
00205364 NoShift
00205368 LAB_RSHIFT
0020537C Not2Big
00205382 TooBig
00205388 GetPair
0020539A LAB_CASC
002053A0 LAB_CAUC
002053AA LAB_1D8A
002053B0 LAB_1D83
002053B6 LAB_SVAR
002053B8 LAB_FVAR
002053BA LAB_GVAR
002053C0 LAB_1D10
002053C4 LAB_1D12
002053D6 LAB_1D2D
002053E2 LAB_1D2E
002053FE LAB_1D44
0020540E LAB_1D45
00205422 LAB_1D48
0020542A LAB_1D49
0020542E LAB_1D4A
0020543E LAB_1D4B
00205446 LAB_1D5D
0020544C LAB_1D5E
00205460 LAB_1D94
0020546A LAB_1D98
00205484 LAB_1DAC
00205486 LAB_1DAE
00205492 LAB_1DAF
002054A0 LAB_1DB0
002054A4 LAB_1DB1
002054A8 LAB_1DB2
002054C0 LAB_1DD7
002054DA LAB_1DE6
002054E6 LAB_EVIN
002054EE LAB_EVPI
002054F6 LAB_EVIR
0020551C LAB_1E17
00205522 LAB_1E1F
0020555C LAB_1E5C
00205578 LAB_1E8D
00205594 LAB_1EA1
002055B0 LAB_1EDF
002055BC LAB_1EC0
002055E8 LAB_1ED6
002055F6 LAB_1ED8
00205608 LAB_1F07
00205622 LAB_1F28
00205628 LAB_1F2C
00205636 LAB_1F5A
0020565E LAB_1F6A
0020566A LAB_1F6B
0020566E RTS_011
00205670 LAB_1F7C
00205694 LAB_FRE
0020569E LAB_1FB4
002056AA LAB_AYFC
002056C6 LAB_POS
002056CA LAB_1FD0
002056D2 LAB_CKRN
002056DC LAB_DEF
00205724 LAB_201E
00205772 LAB_2043
00205774 LAB_204S
002057A2 LAB_204T
002057A4 LAB_2044
002057AE LAB_2045
002057BC LAB_STRS
002057C0 LAB_20AE
002057C4 LAB_20B4
002057CA LAB_20BE
002057DA LAB_20CB
002057E2 LAB_20D0
002057EE LAB_20C9
002057F8 LAB_20D8
00205800 LAB_20E0
00205806 LAB_RTST
00205820 LAB_2115
00205838 LAB_2117
00205852 LAB_2128
00205856 LAB_2137
0020586C LAB_GARB
00205876 LAB_214B
0020588A LAB_2161
00205890 LAB_2176
0020589C LAB_217E
002058B6 LAB_2183
002058BE LAB_218B
002058C0 LAB_218F
002058CC LAB_21C2
002058D0 LAB_21C4
002058F4 LAB_2216
002058FC LAB_2240
00205904 LAB_21D1
0020590A LAB_2206
00205932 LAB_2212
00205936 RTS_012
00205938 LAB_224D
0020594E LAB_224E
00205992 LAB_229E
0020599E LAB_22A0
002059AA RTS_013
002059AC LAB_22B6
002059B0 LAB_22BA
002059BA LAB_22BD
002059D4 LAB_22E6
002059DE LAB_CHRS
002059E2 LAB_MKCHR
002059EE LAB_LEFT
00205A02 LAB_RIGHT
00205A14 LAB_2316
00205A16 LAB_2317
00205A1A LAB_231C
00205A32 LAB_MIDS
00205A4E LAB_2358
00205A6E LAB_2368
00205A76 LAB_LCASE
00205A8C LC_loop
00205A9E NoUcase
00205AA6 LAB_UCASE
00205ABC UC_loop
00205ACE NoLcase
00205AD4 NoString
00205AD8 LAB_SADD
00205AF0 LAB_LENS
00205AF8 LAB_ASC
00205B08 LAB_SGBY
00205B0C LAB_GTBY
00205B10 LAB_EVBY
00205B20 LAB_GTWO
00205B34 LAB_VAL
00205B5C LAB_VALZ
00205B62 LAB_GADB
00205B76 LAB_GADW
00205B90 LAB_XGADW
00205B96 LAB_GEAD
00205BAC LAB_PEEK
00205BB8 LAB_POKE
00205BBE LAB_DEEK
00205BD4 LAB_LEEK
00205BE8 LAB_DOKE
00205BEE LAB_LOKE
00205C00 RTS_015
00205C02 LAB_SWAP
00205C30 LAB_USR
00205C38 LAB_LOAD
00205C3C LAB_SAVE
00205C40 LAB_CALL
00205C4A LAB_WAIT
00205C60 LAB_2441
00205C64 LAB_2445
00205C6E LAB_SUBTRACT
00205C82 LAB_ADD
00205CA6 LAB_249C
00205CB4 LAB_2467
00205CB8 LAB_2468
00205CBC LAB_24A8
00205CD6 LAB_24F7
00205CDA RTS_016
00205CDC LAB_24F8
00205CE6 LAB_24B4
00205CF2 LAB_24D0
00205CFC LAB_24D5
00205D0A LAB_24D9
00205D16 LAB_24D6
00205D24 LAB_24D7
00205D2A LAB_24D8
00205D30 LAB_24DA
00205D32 LAB_LOG
00205DAA LAB_LAAD
00205DB0 LAB_LOCC
00205DBA LAB_LOLP
00205DCC LAB_LOCX
00205DD0 LAB_LONN
00205DDE LAB_LOXP
00205DE8 LAB_LONE
00205DEE LAB_LOXO
00205E22 LAB_LOWZ
00205E24 LAB_MULTIPLY
00205E4A LAB_MNOC
00205E50 LAB_MADD
00205E7A LAB_MUF1
00205E84 LAB_MUF2
00205E9A LAB_MUF3
00205E9E LAB_MUEX
00205EA4 LAB_MUUF
00205EB0 LAB_DIVIDE
00205EE8 AC1gtAC2
00205F00 LAB_DIVX
00205F08 LAB_SET1
00205F0C L_DIVRND
00205F18 LAB_XDIV
00205F24 LAB_MAN1
00205F2A LAB_DIV0
00205F30 LAB_32_16
00205F32 LAB_3216
00205F3E LAB_LT_1
00205F56 LAB_REMM
00205F5E L_DDIV
00205F64 LAB_UFAC
00205F76 LAB_NB1T
00205F80 LAB_PFAC
00205F98 LAB_2778
00205F9A LAB_277C
00205FBE LAB_279B
00205FCC LAB_27BA
00205FE8 LAB_27C3
00205FF2 LAB_27C4
00205FF6 RTS_017
00205FF8 LAB_27CA
00206000 LAB_27CE
00206004 LAB_27D0
00206010 LAB_SGN
00206012 LAB_27DB
00206022 LAB_ABS
0020602A LAB_27FA
0020604A LAB_2828
00206050 LAB_282E
00206052 LAB_282F
00206056 LAB_2831
00206078 LAB_284G
00206080 LAB_284L
0020608A LAB_284H
0020608C LAB_284J
00206092 LAB_INT
002060AA LAB_IRTS
002060AC LAB_2953
002060B8 LAB_295E
002060C4 LAB_2967
002060CC LAB_2968
002060DE LAB_2969
002060E8 LAB_296A
002060FE LAB_2970
0020610E LAB_2978
0020611E LAB_2989
0020614A LAB_29B9
00206172 LAB_299C
0020619A LAB_29A7
002061B2 LAB_29B7
002061C0 LAB_29C0
002061D8 LAB_29C3
002061F2 LAB_29D9
00206204 LAB_29E4
00206218 LAB_29F7
0020621C LAB_29FB
00206224 LAB_29FD
00206234 LAB_2A18
00206236 LAB_2A1A
0020623E LAB_2A21
0020625E LAB_2A3B
0020626C LAB_2A4B
00206280 LAB_2A58
00206298 LAB_2A68
002062A4 LAB_2A74
002062C0 LAB_2A89
002062C4 LAB_2A8C
002062CA LAB_2A91
002062CE LAB_27F0
002062E4 LAB_27F1
002062EA LAB_27F2
002062EC LAB_27F3
002062EE LAB_POON
002062FE LAB_POZE
0020630A LAB_POWER
0020633C LAB_POWP
0020636E LAB_GTHAN
0020637A RTS_020
0020637C LAB_EX1
0020638C LAB_EXOU
002063A0 LAB_EXOF
002063B6 LAB_EXOL
002063C0 LAB_EXP
002063E6 LAB_EXCM
002063F8 LAB_EXPS
00206444 LAB_ESML
0020649A LAB_EXPL
002064A0 LAB_EXNN
002064A6 LAB_EXRN
002064B4 LAB_EXCC
002064CE LAB_EXAD
002064DA LAB_RND
002064E8 NextPRN
002064F0 Ninc0
002064F6 Ninc1
0020650C LAB_TAN
0020652E LAB_COS
00206546 LAB_SIN
00206586 LAB_SCZE
00206594 LAB_SCL0
0020659E LAB_CORD
002065AC LAB_LTPF
002065B8 LAB_LTPT
002065C8 subloop
002065D0 mainloop
002065E2 nexta
002065F0 outloop
002065FA subexit
00206606 LAB_ATN
00206624 LAB_ATGO
00206642 LAB_ATLE
00206660 LAB_ATNP
00206666 LAB_ATCD
0020666C LAB_CATN
002066B6 RTS_021
002066B8 LAB_BITSET
002066C8 LAB_BITCLR
002066D8 LAB_BTST
00206706 LAB_USINGS
00206730 LAB_U002
00206786 LAB_U004
00206796 LAB_U005
00206798 LAB_U006
002067AC LAB_U008
002067CE LAB_U009
002067D6 LAB_U00A
002067E0 LAB_U00B
002067F4 LAB_U00C
002067F8 LAB_U00D
0020680A LAB_U00E
00206816 LAB_U00F
0020681A LAB_U010
00206820 LAB_U014
00206828 LAB_U018
0020683E LAB_U01C
0020684A LAB_U020
00206850 LAB_U022
00206860 LAB_U026
0020686A LAB_U02A
00206882 LAB_U02B
00206888 LAB_U02C
0020689A LAB_U02E
0020689E LAB_U030
002068B4 LAB_U034
002068BA LAB_U036
002068C2 LAB_U038
002068CA LAB_U03C
002068D0 LAB_U03E
002068E8 LAB_U040
002068F8 LAB_U044
00206920 LAB_U046
00206922 LAB_U048
0020692C LAB_U04A
0020695E LAB_U04C
00206988 LAB_DupFmt
002069A0 LAB_D002
002069B0 LAB_D00A
002069C0 LAB_D00E
002069C6 LAB_ProcFo
002069DE LAB_P004
002069F4 LAB_P008
002069FC LAB_P00C
00206A08 LAB_P00E
00206A0C LAB_P010
00206A26 LAB_P018
00206A2A LAB_P01A
00206A32 LAB_P01E
00206A3C LAB_BINS
00206A4C NextB1
00206A5A EndBHS
00206A72 NextB2
00206A80 BinPr
00206A8A GoPr
00206A8E LAB_HEXS
00206A9E NextH1
00206AB8 VEC_CC
00206AD2 LAB_FBA0
00206ADC RTS_022
00206ADE INGET
00206AEE LAB_FB95
00206AFA LAB_MAX
00206B06 LAB_MAXN
00206B10 LAB_MIN
00206B1C LAB_MINN
00206B26 LAB_MMEC
00206B34 LAB_PHFA
00206B6A LAB_WDTH
00206B8A LAB_NSTT
00206B9C LAB_TBSZ
00206BBC LAB_SVTB
00206BC0 WExit
00206BD0 LAB_WDLP
00206BE8 RTS_023
00206BEA LAB_SQR
00206C0E LAB_SQE1
00206C14 LAB_SQE2
00206C26 LAB_SQNS
00206C3C LAB_SQNA
00206C4C LAB_VARPTR
00206C4E LAB_VARCALL
00206C5C LAB_RAM
00206C66 LAB_PI
00206C76 LAB_TWOPI
00206C86 LAB_2887
00206CB0 LAB_289A
00206CB6 LAB_289C
00206CBC LAB_289D
00206CD8 LAB_28FD
00206CDE LAB_28FE
00206CE4 LAB_28FF
00206CF2 LAB_2900
00206CF8 LAB_2901
00206D10 LAB_2X01
00206D18 LAB_2X02
00206D26 LAB_2X03
00206D2C LAB_2X04
00206D42 LAB_2X05
00206D4A LAB_2902
00206D52 LAB_2903
00206D54 LAB_2904
00206D62 LAB_2Y01
00206D6A LAB_2Y02
00206D76 LAB_2Y03
00206D7C LAB_2Y04
00206DC2 LAB_ret0
00206DC4 LAB_rtn0
00206DD4 LAB_CHEX
00206DDC LAB_CHXX
00206DF6 LAB_ISHN
00206DFA LAB_CHX1
00206E16 LAB_CHX3
00206E1E LAB_CHX2
00206E24 LAB_exxf
00206E34 RTS_024
00206E36 LAB_CBIN
00206E3E LAB_CBXN
00206E50 LAB_CBX1
00206E64 d1x16
00206E72 d1x02
00206E88 d1x10
00206E96 RTS_025
00206E98 Bin2dec
00206EC0 LAB_RSED
00206FA8 LAB_P_10
00207096 TAB_SNCO
00207116 TAB_ATNC
0020718E LAB_1D96
00207196 TAB_HTHET
00207216 LAB_CTBL
00207266 LAB_FTPP
002072B2 LAB_FTBL
002072FE LAB_OPPT
00207332 LAB_2A9A
0020734E TAB_CHRT
0020734E LAB_2A9B
002073B8 LAB_KEYT
0020754C LAB_BAER
0020757C LAB_NF
0020758D LAB_SN
00207594 LAB_RG
002075A9 LAB_OD
002075B5 LAB_FC
002075C3 LAB_OV
002075CC LAB_OM
002075DA LAB_US
002075EE LAB_BS
002075FB LAB_DD
0020760C LAB_D0
0020761B LAB_ID
0020762A LAB_TM
00207638 LAB_LS
00207648 LAB_ST
0020765B LAB_CN
0020766A LAB_UF
0020767D LAB_LD
0020768D LAB_UV
002076A0 LAB_UA
002076B4 LAB_WD
002076C5 LAB_AD
002076CD LAB_FO
002076D4 LAB_NI
002076E4 TAB_STAR
002076E4 KEY_MULT
002076E6 KEY_PLUS
002076E6 TAB_PLUS
002076E8 KEY_MINUS
002076E8 TAB_MNUS
002076EA TAB_SLAS
002076EA KEY_DIV
002076EC KEY_LSHIFT
002076EC TAB_LESS
002076EE KEY_LT
002076F0 KEY_EQUAL
002076F0 TAB_EQUL
002076F2 KEY_RSHIFT
002076F2 TAB_MORE
002076F4 KEY_GT
002076F6 TAB_QEST
002076F8 TAB_ASCA
002076F8 KEY_ABS
002076FC KEY_AND
002076FF KEY_ASC
00207703 KEY_ATN
00207708 KEY_BINS
00207708 TAB_ASCB
0020770D KEY_BITCLR
00207713 KEY_BITSET
00207719 KEY_BITTST
00207721 TAB_ASCC
00207721 KEY_CALL
00207725 KEY_CHRS
0020772A KEY_CLEAR
0020772F KEY_CONT
00207733 KEY_COS
00207738 KEY_DATA
00207738 TAB_ASCD
0020773C KEY_DEC
0020773F KEY_DEEK
00207744 KEY_DEF
00207747 KEY_DIM
0020774A KEY_DOKE
0020774E KEY_DO
00207751 KEY_ELSE
00207751 TAB_ASCE
00207755 KEY_END
00207758 KEY_EOR
0020775B KEY_EXP
00207760 KEY_FOR
00207760 TAB_ASCF
00207763 KEY_FN
00207765 KEY_FRE
0020776A KEY_GET
0020776A TAB_ASCG
0020776D KEY_GOTO
00207771 KEY_GOSUB
00207777 KEY_HEXS
00207777 TAB_ASCH
0020777D TAB_ASCI
0020777D KEY_IF
0020777F KEY_INC
00207782 KEY_INPUT
00207787 KEY_INT
0020778C TAB_ASCL
0020778C KEY_LCASES
00207793 KEY_LEEK
00207798 KEY_LEFTS
0020779E KEY_LEN
002077A2 KEY_LET
002077A5 KEY_LIST
002077A9 KEY_LOAD
002077AD KEY_LOG
002077B1 KEY_LOKE
002077B5 KEY_LOOP
002077BA TAB_ASCM
002077BA KEY_MAX
002077BE KEY_MIDS
002077C3 KEY_MIN
002077C8 KEY_NEW
002077C8 TAB_ASCN
002077CB KEY_NEXT
002077CF KEY_NOT
002077D2 KEY_NULL
002077D7 KEY_ON
002077D7 TAB_ASCO
002077D9 KEY_OR
002077DC TAB_ASCP
002077DC KEY_PEEK
002077E1 KEY_PI
002077E3 KEY_POKE
002077E7 KEY_POS
002077EB KEY_PRINT
002077F1 KEY_RAM
002077F1 TAB_ASCR
002077F8 KEY_READ
002077FC KEY_REM
002077FF KEY_RESTORE
00207806 KEY_RETURN
0020780C KEY_RIGHTS
00207813 KEY_RND
00207817 KEY_RUN
0020781B KEY_SADD
0020781B TAB_ASCS
00207820 KEY_SAVE
00207824 KEY_SGN
00207828 KEY_SIN
0020782C KEY_SPC
00207830 KEY_SQR
00207834 KEY_STEP
00207838 KEY_STOP
0020783C KEY_STRS
00207841 KEY_SWAP
00207846 TAB_ASCT
00207846 KEY_TAB
0020784A KEY_TAN
0020784E KEY_THEN
00207852 KEY_TO
00207854 KEY_TWOPI
0020785A KEY_UCASES
0020785A TAB_ASCU
00207861 KEY_UNTIL
00207866 KEY_USINGS
0020786D KEY_USR
00207872 TAB_ASCV
00207872 KEY_VAL
00207876 KEY_VPTR
0020787E TAB_ASCW
0020787E KEY_WAIT
00207882 KEY_WHILE
00207887 KEY_WIDTH
0020788D TAB_POWR
0020788D KEY_POWER
0020788F LAB_BMSG
00207897 LAB_EMSG
0020789E LAB_LMSG
002078A8 LAB_IMSG
002078B8 LAB_REDO
002078CA LAB_RMSG
002078D4 LAB_SMSG
003C0008 ACIA_1
003C0008 ACIA_2
003C0008 SER2
003C0008 SER1
26A3D110 KFCTSEED
